
firmware.debug.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
}

#pragma GCC diagnostic pop

int nvic_execution_priority(void)
{
       0:	00 00 03 20 fd 48 00 00 c9 48 00 00 7d 48 00 00     ... .H...H..}H..
	uint32_t priority=256;
	uint32_t primask, faultmask, basepri, ipsr;

	// full algorithm in ARM DDI0403D, page B1-639
	// this isn't quite complete, but hopefully good enough
	__asm__ volatile("mrs %0, faultmask\n" : "=r" (faultmask)::);
      10:	7d 48 00 00 7d 48 00 00 7d 48 00 00 7d 48 00 00     }H..}H..}H..}H..
	if (faultmask) return -1;
	__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
      20:	7d 48 00 00 7d 48 00 00 7d 48 00 00 c9 48 00 00     }H..}H..}H...H..
	if (primask) return 0;
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
      30:	c9 48 00 00 7d 48 00 00 09 4c 00 00 81 4c 00 00     .H..}H...L...L..
	if (ipsr) {
		if (ipsr < 16) priority = 0; // could be non-zero
      40:	c9 40 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .@...H...H...H..
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
	}
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
      50:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
	if (basepri > 0 && basepri < priority) priority = basepri;
      60:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
	return priority;
}
      70:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
      80:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
      90:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
				timer->_prev = this;
				_prev->_next = this;
      a0:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
				timer->_ms -= _ms;
      b0:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
		while (timer->_next) {
      c0:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
				_state = TimerActive;
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
      d0:	c9 48 00 00 c9 48 00 00 c9 48 00 00 6d 41 00 00     .H...H...H..mA..
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
      e0:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
	}
	_state = TimerActive;
}
      f0:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
#endif
#if defined(FTM3_CH0_PIN)
	} else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN || pin == FTM3_CH2_PIN
	  || pin == FTM3_CH3_PIN || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
     100:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
     110:	c9 48 00 00 6d 5d 00 00 c9 48 00 00 c9 48 00 00     .H..m]...H...H..
		cval = ((uint32_t)val * (uint32_t)(FTM3_MOD + 1)) >> analog_write_res;
     120:	21 41 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     !A...H...H...H..
     130:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
#endif
#if defined(TPM1_CH0_PIN)
	} else if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(TPM1_MOD + 1)) >> analog_write_res;
     140:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
     150:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
#endif
	} else {
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
     160:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
	}
	//serial_print("cval = ");
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
     170:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
     180:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
     190:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
     1a0:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
     1b0:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
     1c0:	c9 48 00 00 c9 48 00 00 c9 48 00 00 c9 48 00 00     .H...H...H...H..
     1d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     1e0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     1f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     200:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
     210:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
     220:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
     230:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
     240:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
     250:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
     260:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
     270:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
     280:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
     290:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
     2a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
     2b0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     2c0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     2d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     2e0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     2f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     300:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     310:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
     320:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
     330:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
#ifdef FTM3_CH0_PIN
	  case FTM3_CH0_PIN:
		FTM3_C0V = cval;
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
     340:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
#ifdef FTM3_CH1_PIN
	  case FTM3_CH1_PIN:
		FTM3_C1V = cval;
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
     350:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
#ifdef FTM3_CH2_PIN
	  case FTM3_CH2_PIN:
		FTM3_C2V = cval;
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
     360:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
#ifdef FTM3_CH3_PIN
	  case FTM3_CH3_PIN:
		FTM3_C3V = cval;
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
     370:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
#ifdef FTM3_CH4_PIN
	  case FTM3_CH4_PIN:
		FTM3_C4V = cval;
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
     380:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
#ifdef FTM3_CH5_PIN
	  case FTM3_CH5_PIN:
		FTM3_C5V = cval;
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
     390:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
#ifdef FTM3_CH6_PIN
	  case FTM3_CH6_PIN:
		FTM3_C6V = cval;
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
     3a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
#ifdef FTM3_CH7_PIN
	  case FTM3_CH7_PIN:
		FTM3_C7V = cval;
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
     3b0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
#ifdef TPM1_CH0_PIN
	  case TPM1_CH0_PIN:
		TPM1_C0V = cval;
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
     3c0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
#ifdef TPM1_CH1_PIN
	  case TPM1_CH1_PIN:
		TPM1_C1V = cval;
		FTM_PINCFG(TPM1_CH1_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
     3d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		break;
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
     3e0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
		pinMode(pin, OUTPUT);
     3f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................

00000400 <flashconfigbytes>:
	}
}
     400:	ff ff ff ff ff ff ff ff ff ff ff ff de f9 ff ff     ................

00000410 <register_tm_clones>:
     410:	4805      	ldr	r0, [pc, #20]	; (428 <register_tm_clones+0x18>)
     412:	4b06      	ldr	r3, [pc, #24]	; (42c <register_tm_clones+0x1c>)
     414:	1a1b      	subs	r3, r3, r0
     416:	0fd9      	lsrs	r1, r3, #31
     418:	eb01 01a3 	add.w	r1, r1, r3, asr #2
     41c:	1049      	asrs	r1, r1, #1
     41e:	d002      	beq.n	426 <register_tm_clones+0x16>
     420:	4b03      	ldr	r3, [pc, #12]	; (430 <register_tm_clones+0x20>)
     422:	b103      	cbz	r3, 426 <register_tm_clones+0x16>
     424:	4718      	bx	r3
     426:	4770      	bx	lr
     428:	1fff08b4 	.word	0x1fff08b4
     42c:	1fff08b4 	.word	0x1fff08b4
     430:	00000000 	.word	0x00000000

00000434 <frame_dummy>:
     434:	b508      	push	{r3, lr}
     436:	4b05      	ldr	r3, [pc, #20]	; (44c <frame_dummy+0x18>)
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4905      	ldr	r1, [pc, #20]	; (450 <frame_dummy+0x1c>)
     43c:	4805      	ldr	r0, [pc, #20]	; (454 <frame_dummy+0x20>)
     43e:	f3af 8000 	nop.w
     442:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     446:	f7ff bfe3 	b.w	410 <register_tm_clones>
     44a:	bf00      	nop
     44c:	00000000 	.word	0x00000000
     450:	1fff08b4 	.word	0x1fff08b4
     454:	00010d10 	.word	0x00010d10

00000458 <_ZSt4atanf>:
  using ::atan;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  atan(float __x)
  { return __builtin_atanf(__x); }
     458:	b580      	push	{r7, lr}
     45a:	b082      	sub	sp, #8
     45c:	af00      	add	r7, sp, #0
     45e:	ed87 0a01 	vstr	s0, [r7, #4]
     462:	ed97 0a01 	vldr	s0, [r7, #4]
     466:	f00b f9b9 	bl	b7dc <atanf>
     46a:	eef0 7a40 	vmov.f32	s15, s0
     46e:	eeb0 0a67 	vmov.f32	s0, s15
     472:	3708      	adds	r7, #8
     474:	46bd      	mov	sp, r7
     476:	bd80      	pop	{r7, pc}

00000478 <_ZSt3cosf>:
  using ::cos;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  cos(float __x)
  { return __builtin_cosf(__x); }
     478:	b580      	push	{r7, lr}
     47a:	b082      	sub	sp, #8
     47c:	af00      	add	r7, sp, #0
     47e:	ed87 0a01 	vstr	s0, [r7, #4]
     482:	ed97 0a01 	vldr	s0, [r7, #4]
     486:	f00b fa83 	bl	b990 <cosf>
     48a:	eef0 7a40 	vmov.f32	s15, s0
     48e:	eeb0 0a67 	vmov.f32	s0, s15
     492:	3708      	adds	r7, #8
     494:	46bd      	mov	sp, r7
     496:	bd80      	pop	{r7, pc}

00000498 <_ZSt3sinf>:
  using ::sin;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sin(float __x)
  { return __builtin_sinf(__x); }
     498:	b580      	push	{r7, lr}
     49a:	b082      	sub	sp, #8
     49c:	af00      	add	r7, sp, #0
     49e:	ed87 0a01 	vstr	s0, [r7, #4]
     4a2:	ed97 0a01 	vldr	s0, [r7, #4]
     4a6:	f00b fab3 	bl	ba10 <sinf>
     4aa:	eef0 7a40 	vmov.f32	s15, s0
     4ae:	eeb0 0a67 	vmov.f32	s0, s15
     4b2:	3708      	adds	r7, #8
     4b4:	46bd      	mov	sp, r7
     4b6:	bd80      	pop	{r7, pc}

000004b8 <_ZSt4sqrtf>:
  using ::sqrt;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
     4b8:	b580      	push	{r7, lr}
     4ba:	b082      	sub	sp, #8
     4bc:	af00      	add	r7, sp, #0
     4be:	ed87 0a01 	vstr	s0, [r7, #4]
     4c2:	ed97 0a01 	vldr	s0, [r7, #4]
     4c6:	f00b fadd 	bl	ba84 <sqrtf>
     4ca:	eef0 7a40 	vmov.f32	s15, s0
     4ce:	eeb0 0a67 	vmov.f32	s0, s15
     4d2:	3708      	adds	r7, #8
     4d4:	46bd      	mov	sp, r7
     4d6:	bd80      	pop	{r7, pc}

000004d8 <_ZNK6String6lengthEv>:
	String(double num, unsigned char digits=2) : String((float)num, digits) {}
	~String(void);

	// memory management
	unsigned char reserve(unsigned int size);
	inline unsigned int length(void) const {return len;}
     4d8:	b480      	push	{r7}
     4da:	b083      	sub	sp, #12
     4dc:	af00      	add	r7, sp, #0
     4de:	6078      	str	r0, [r7, #4]
     4e0:	687b      	ldr	r3, [r7, #4]
     4e2:	689b      	ldr	r3, [r3, #8]
     4e4:	4618      	mov	r0, r3
     4e6:	370c      	adds	r7, #12
     4e8:	46bd      	mov	sp, r7
     4ea:	f85d 7b04 	ldr.w	r7, [sp], #4
     4ee:	4770      	bx	lr

000004f0 <_ZNK6StringeqEPKc>:
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
     4f0:	b580      	push	{r7, lr}
     4f2:	b082      	sub	sp, #8
     4f4:	af00      	add	r7, sp, #0
     4f6:	6078      	str	r0, [r7, #4]
     4f8:	6039      	str	r1, [r7, #0]
     4fa:	6839      	ldr	r1, [r7, #0]
     4fc:	6878      	ldr	r0, [r7, #4]
     4fe:	f006 fa67 	bl	69d0 <_ZNK6String6equalsEPKc>
     502:	4603      	mov	r3, r0
     504:	4618      	mov	r0, r3
     506:	3708      	adds	r7, #8
     508:	46bd      	mov	sp, r7
     50a:	bd80      	pop	{r7, pc}

0000050c <_ZNK6StringneERKS_>:
	unsigned char operator == (const __FlashStringHelper *s) const {return equals((const char *)s);}
	unsigned char operator != (const String &rhs) const {return !equals(rhs);}
     50c:	b580      	push	{r7, lr}
     50e:	b082      	sub	sp, #8
     510:	af00      	add	r7, sp, #0
     512:	6078      	str	r0, [r7, #4]
     514:	6039      	str	r1, [r7, #0]
     516:	6839      	ldr	r1, [r7, #0]
     518:	6878      	ldr	r0, [r7, #4]
     51a:	f006 fa40 	bl	699e <_ZNK6String6equalsERKS_>
     51e:	4603      	mov	r3, r0
     520:	2b00      	cmp	r3, #0
     522:	bf0c      	ite	eq
     524:	2301      	moveq	r3, #1
     526:	2300      	movne	r3, #0
     528:	b2db      	uxtb	r3, r3
     52a:	4618      	mov	r0, r3
     52c:	3708      	adds	r7, #8
     52e:	46bd      	mov	sp, r7
     530:	bd80      	pop	{r7, pc}

00000532 <_ZNK6StringneEPKc>:
	unsigned char operator != (const char *cstr) const {return !equals(cstr);}
     532:	b580      	push	{r7, lr}
     534:	b082      	sub	sp, #8
     536:	af00      	add	r7, sp, #0
     538:	6078      	str	r0, [r7, #4]
     53a:	6039      	str	r1, [r7, #0]
     53c:	6839      	ldr	r1, [r7, #0]
     53e:	6878      	ldr	r0, [r7, #4]
     540:	f006 fa46 	bl	69d0 <_ZNK6String6equalsEPKc>
     544:	4603      	mov	r3, r0
     546:	2b00      	cmp	r3, #0
     548:	bf0c      	ite	eq
     54a:	2301      	moveq	r3, #1
     54c:	2300      	movne	r3, #0
     54e:	b2db      	uxtb	r3, r3
     550:	4618      	mov	r0, r3
     552:	3708      	adds	r7, #8
     554:	46bd      	mov	sp, r7
     556:	bd80      	pop	{r7, pc}

00000558 <_ZNK6String5c_strEv>:
	char operator [] (unsigned int index) const;
	char& operator [] (unsigned int index);
	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
	void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
		{getBytes((unsigned char *)buf, bufsize, index);}
	const char * c_str() const { return buffer; }
     558:	b480      	push	{r7}
     55a:	b083      	sub	sp, #12
     55c:	af00      	add	r7, sp, #0
     55e:	6078      	str	r0, [r7, #4]
     560:	687b      	ldr	r3, [r7, #4]
     562:	681b      	ldr	r3, [r3, #0]
     564:	4618      	mov	r0, r3
     566:	370c      	adds	r7, #12
     568:	46bd      	mov	sp, r7
     56a:	f85d 7b04 	ldr.w	r7, [sp], #4
     56e:	4770      	bx	lr

00000570 <_ZN5Print5writeEPKc>:
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     570:	b590      	push	{r4, r7, lr}
     572:	b083      	sub	sp, #12
     574:	af00      	add	r7, sp, #0
     576:	6078      	str	r0, [r7, #4]
     578:	6039      	str	r1, [r7, #0]
     57a:	687b      	ldr	r3, [r7, #4]
     57c:	681b      	ldr	r3, [r3, #0]
     57e:	3304      	adds	r3, #4
     580:	681c      	ldr	r4, [r3, #0]
     582:	6838      	ldr	r0, [r7, #0]
     584:	f00e f83a 	bl	e5fc <strlen>
     588:	4603      	mov	r3, r0
     58a:	461a      	mov	r2, r3
     58c:	6839      	ldr	r1, [r7, #0]
     58e:	6878      	ldr	r0, [r7, #4]
     590:	47a0      	blx	r4
     592:	4603      	mov	r3, r0
     594:	4618      	mov	r0, r3
     596:	370c      	adds	r7, #12
     598:	46bd      	mov	sp, r7
     59a:	bd90      	pop	{r4, r7, pc}

0000059c <_ZN5Print5printEc>:
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
     59c:	b580      	push	{r7, lr}
     59e:	b082      	sub	sp, #8
     5a0:	af00      	add	r7, sp, #0
     5a2:	6078      	str	r0, [r7, #4]
     5a4:	460b      	mov	r3, r1
     5a6:	70fb      	strb	r3, [r7, #3]
     5a8:	687b      	ldr	r3, [r7, #4]
     5aa:	681b      	ldr	r3, [r3, #0]
     5ac:	681b      	ldr	r3, [r3, #0]
     5ae:	78fa      	ldrb	r2, [r7, #3]
     5b0:	4611      	mov	r1, r2
     5b2:	6878      	ldr	r0, [r7, #4]
     5b4:	4798      	blx	r3
     5b6:	4603      	mov	r3, r0
     5b8:	4618      	mov	r0, r3
     5ba:	3708      	adds	r7, #8
     5bc:	46bd      	mov	sp, r7
     5be:	bd80      	pop	{r7, pc}

000005c0 <_ZN5Print5printEPKc>:
	size_t print(const char s[])			{ return write(s); }
     5c0:	b580      	push	{r7, lr}
     5c2:	b082      	sub	sp, #8
     5c4:	af00      	add	r7, sp, #0
     5c6:	6078      	str	r0, [r7, #4]
     5c8:	6039      	str	r1, [r7, #0]
     5ca:	6839      	ldr	r1, [r7, #0]
     5cc:	6878      	ldr	r0, [r7, #4]
     5ce:	f7ff ffcf 	bl	570 <_ZN5Print5writeEPKc>
     5d2:	4603      	mov	r3, r0
     5d4:	4618      	mov	r0, r3
     5d6:	3708      	adds	r7, #8
     5d8:	46bd      	mov	sp, r7
     5da:	bd80      	pop	{r7, pc}

000005dc <_ZN5Print5printEi>:
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
     5dc:	b580      	push	{r7, lr}
     5de:	b082      	sub	sp, #8
     5e0:	af00      	add	r7, sp, #0
     5e2:	6078      	str	r0, [r7, #4]
     5e4:	6039      	str	r1, [r7, #0]
     5e6:	6839      	ldr	r1, [r7, #0]
     5e8:	6878      	ldr	r0, [r7, #4]
     5ea:	f004 fd50 	bl	508e <_ZN5Print5printEl>
     5ee:	4603      	mov	r3, r0
     5f0:	4618      	mov	r0, r3
     5f2:	3708      	adds	r7, #8
     5f4:	46bd      	mov	sp, r7
     5f6:	bd80      	pop	{r7, pc}

000005f8 <_ZN5Print5printEj>:
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
     5f8:	b580      	push	{r7, lr}
     5fa:	b082      	sub	sp, #8
     5fc:	af00      	add	r7, sp, #0
     5fe:	6078      	str	r0, [r7, #4]
     600:	6039      	str	r1, [r7, #0]
     602:	2300      	movs	r3, #0
     604:	220a      	movs	r2, #10
     606:	6839      	ldr	r1, [r7, #0]
     608:	6878      	ldr	r0, [r7, #4]
     60a:	f004 fd6f 	bl	50ec <_ZN5Print11printNumberEmhh>
     60e:	4603      	mov	r3, r0
     610:	4618      	mov	r0, r3
     612:	3708      	adds	r7, #8
     614:	46bd      	mov	sp, r7
     616:	bd80      	pop	{r7, pc}

00000618 <_ZN5Print5printEm>:
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
     618:	b580      	push	{r7, lr}
     61a:	b082      	sub	sp, #8
     61c:	af00      	add	r7, sp, #0
     61e:	6078      	str	r0, [r7, #4]
     620:	6039      	str	r1, [r7, #0]
     622:	2300      	movs	r3, #0
     624:	220a      	movs	r2, #10
     626:	6839      	ldr	r1, [r7, #0]
     628:	6878      	ldr	r0, [r7, #4]
     62a:	f004 fd5f 	bl	50ec <_ZN5Print11printNumberEmhh>
     62e:	4603      	mov	r3, r0
     630:	4618      	mov	r0, r3
     632:	3708      	adds	r7, #8
     634:	46bd      	mov	sp, r7
     636:	bd80      	pop	{r7, pc}

00000638 <_ZN5Print5printEdi>:
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
     638:	b580      	push	{r7, lr}
     63a:	b084      	sub	sp, #16
     63c:	af00      	add	r7, sp, #0
     63e:	60f8      	str	r0, [r7, #12]
     640:	ed87 0b00 	vstr	d0, [r7]
     644:	60b9      	str	r1, [r7, #8]
     646:	68bb      	ldr	r3, [r7, #8]
     648:	b2db      	uxtb	r3, r3
     64a:	4619      	mov	r1, r3
     64c:	ed97 0b00 	vldr	d0, [r7]
     650:	68f8      	ldr	r0, [r7, #12]
     652:	f004 fdc5 	bl	51e0 <_ZN5Print10printFloatEdh>
     656:	4603      	mov	r3, r0
     658:	4618      	mov	r0, r3
     65a:	3710      	adds	r7, #16
     65c:	46bd      	mov	sp, r7
     65e:	bd80      	pop	{r7, pc}

00000660 <_ZN5Print7printlnEPKc>:
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     660:	b590      	push	{r4, r7, lr}
     662:	b083      	sub	sp, #12
     664:	af00      	add	r7, sp, #0
     666:	6078      	str	r0, [r7, #4]
     668:	6039      	str	r1, [r7, #0]
     66a:	6839      	ldr	r1, [r7, #0]
     66c:	6878      	ldr	r0, [r7, #4]
     66e:	f7ff ffa7 	bl	5c0 <_ZN5Print5printEPKc>
     672:	4604      	mov	r4, r0
     674:	6878      	ldr	r0, [r7, #4]
     676:	f004 fd24 	bl	50c2 <_ZN5Print7printlnEv>
     67a:	4603      	mov	r3, r0
     67c:	4423      	add	r3, r4
     67e:	4618      	mov	r0, r3
     680:	370c      	adds	r7, #12
     682:	46bd      	mov	sp, r7
     684:	bd90      	pop	{r4, r7, pc}

00000686 <_ZN16usb_serial_class5beginEl>:
#include "Stream.h"
class usb_serial_class : public Stream
{
public:
	constexpr usb_serial_class() {}
        void begin(long) {
     686:	b480      	push	{r7}
     688:	b083      	sub	sp, #12
     68a:	af00      	add	r7, sp, #0
     68c:	6078      	str	r0, [r7, #4]
     68e:	6039      	str	r1, [r7, #0]
			// Arduino Uno to "just work" (without forcing a reboot when
			// the port is opened), and when no PC is connected the user's
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
     690:	bf00      	nop
     692:	370c      	adds	r7, #12
     694:	46bd      	mov	sp, r7
     696:	f85d 7b04 	ldr.w	r7, [sp], #4
     69a:	4770      	bx	lr

0000069c <_ZN16usb_serial_class4peekEv>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
     69c:	b580      	push	{r7, lr}
     69e:	b082      	sub	sp, #8
     6a0:	af00      	add	r7, sp, #0
     6a2:	6078      	str	r0, [r7, #4]
     6a4:	f005 fdda 	bl	625c <usb_serial_peekchar>
     6a8:	4603      	mov	r3, r0
     6aa:	4618      	mov	r0, r3
     6ac:	3708      	adds	r7, #8
     6ae:	46bd      	mov	sp, r7
     6b0:	bd80      	pop	{r7, pc}

000006b2 <_ZN16usb_serial_class5flushEv>:
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
     6b2:	b580      	push	{r7, lr}
     6b4:	b082      	sub	sp, #8
     6b6:	af00      	add	r7, sp, #0
     6b8:	6078      	str	r0, [r7, #4]
     6ba:	f005 ff45 	bl	6548 <usb_serial_flush_output>
     6be:	bf00      	nop
     6c0:	3708      	adds	r7, #8
     6c2:	46bd      	mov	sp, r7
     6c4:	bd80      	pop	{r7, pc}

000006c6 <_ZN16usb_serial_class5clearEv>:
        virtual void clear(void) { usb_serial_flush_input(); }
     6c6:	b580      	push	{r7, lr}
     6c8:	b082      	sub	sp, #8
     6ca:	af00      	add	r7, sp, #0
     6cc:	6078      	str	r0, [r7, #4]
     6ce:	f005 fe21 	bl	6314 <usb_serial_flush_input>
     6d2:	bf00      	nop
     6d4:	3708      	adds	r7, #8
     6d6:	46bd      	mov	sp, r7
     6d8:	bd80      	pop	{r7, pc}
     6da:	Address 0x000006da is out of bounds.


000006dc <_ZN16usb_serial_classcvbEv>:
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     6dc:	b480      	push	{r7}
     6de:	b083      	sub	sp, #12
     6e0:	af00      	add	r7, sp, #0
     6e2:	6078      	str	r0, [r7, #4]
     6e4:	4b0d      	ldr	r3, [pc, #52]	; (71c <_ZN16usb_serial_classcvbEv+0x40>)
     6e6:	781b      	ldrb	r3, [r3, #0]
     6e8:	b2db      	uxtb	r3, r3
     6ea:	2b00      	cmp	r3, #0
     6ec:	d00f      	beq.n	70e <_ZN16usb_serial_classcvbEv+0x32>
     6ee:	4b0c      	ldr	r3, [pc, #48]	; (720 <_ZN16usb_serial_classcvbEv+0x44>)
     6f0:	781b      	ldrb	r3, [r3, #0]
     6f2:	b2db      	uxtb	r3, r3
     6f4:	f003 0301 	and.w	r3, r3, #1
     6f8:	2b00      	cmp	r3, #0
     6fa:	d008      	beq.n	70e <_ZN16usb_serial_classcvbEv+0x32>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     6fc:	4b09      	ldr	r3, [pc, #36]	; (724 <_ZN16usb_serial_classcvbEv+0x48>)
     6fe:	681a      	ldr	r2, [r3, #0]
     700:	4b09      	ldr	r3, [pc, #36]	; (728 <_ZN16usb_serial_classcvbEv+0x4c>)
     702:	681b      	ldr	r3, [r3, #0]
     704:	1ad3      	subs	r3, r2, r3
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     706:	2b0e      	cmp	r3, #14
     708:	d901      	bls.n	70e <_ZN16usb_serial_classcvbEv+0x32>
     70a:	2301      	movs	r3, #1
     70c:	e000      	b.n	710 <_ZN16usb_serial_classcvbEv+0x34>
     70e:	2300      	movs	r3, #0
	}
     710:	4618      	mov	r0, r3
     712:	370c      	adds	r7, #12
     714:	46bd      	mov	sp, r7
     716:	f85d 7b04 	ldr.w	r7, [sp], #4
     71a:	4770      	bx	lr
     71c:	1fff13e9 	.word	0x1fff13e9
     720:	1fff1400 	.word	0x1fff1400
     724:	1fff1308 	.word	0x1fff1308
     728:	1fff13fc 	.word	0x1fff13fc

0000072c <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
     72c:	b480      	push	{r7}
     72e:	b083      	sub	sp, #12
     730:	af00      	add	r7, sp, #0
     732:	4603      	mov	r3, r0
     734:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
     736:	f997 3007 	ldrsb.w	r3, [r7, #7]
     73a:	2b00      	cmp	r3, #0
     73c:	db0b      	blt.n	756 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     73e:	79fb      	ldrb	r3, [r7, #7]
     740:	f003 021f 	and.w	r2, r3, #31
     744:	4907      	ldr	r1, [pc, #28]	; (764 <__NVIC_EnableIRQ+0x38>)
     746:	f997 3007 	ldrsb.w	r3, [r7, #7]
     74a:	095b      	lsrs	r3, r3, #5
     74c:	2001      	movs	r0, #1
     74e:	fa00 f202 	lsl.w	r2, r0, r2
     752:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
     756:	bf00      	nop
     758:	370c      	adds	r7, #12
     75a:	46bd      	mov	sp, r7
     75c:	f85d 7b04 	ldr.w	r7, [sp], #4
     760:	4770      	bx	lr
     762:	bf00      	nop
     764:	e000e100 	.word	0xe000e100

00000768 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
     768:	b480      	push	{r7}
     76a:	b083      	sub	sp, #12
     76c:	af00      	add	r7, sp, #0
     76e:	4603      	mov	r3, r0
     770:	6039      	str	r1, [r7, #0]
     772:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
     774:	f997 3007 	ldrsb.w	r3, [r7, #7]
     778:	2b00      	cmp	r3, #0
     77a:	db0a      	blt.n	792 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     77c:	683b      	ldr	r3, [r7, #0]
     77e:	b2da      	uxtb	r2, r3
     780:	490c      	ldr	r1, [pc, #48]	; (7b4 <__NVIC_SetPriority+0x4c>)
     782:	f997 3007 	ldrsb.w	r3, [r7, #7]
     786:	0112      	lsls	r2, r2, #4
     788:	b2d2      	uxtb	r2, r2
     78a:	440b      	add	r3, r1
     78c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
     790:	e00a      	b.n	7a8 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
     792:	683b      	ldr	r3, [r7, #0]
     794:	b2da      	uxtb	r2, r3
     796:	4908      	ldr	r1, [pc, #32]	; (7b8 <__NVIC_SetPriority+0x50>)
     798:	79fb      	ldrb	r3, [r7, #7]
     79a:	f003 030f 	and.w	r3, r3, #15
     79e:	3b04      	subs	r3, #4
     7a0:	0112      	lsls	r2, r2, #4
     7a2:	b2d2      	uxtb	r2, r2
     7a4:	440b      	add	r3, r1
     7a6:	761a      	strb	r2, [r3, #24]
}
     7a8:	bf00      	nop
     7aa:	370c      	adds	r7, #12
     7ac:	46bd      	mov	sp, r7
     7ae:	f85d 7b04 	ldr.w	r7, [sp], #4
     7b2:	4770      	bx	lr
     7b4:	e000e100 	.word	0xe000e100
     7b8:	e000ed00 	.word	0xe000ed00

000007bc <EnableIRQ>:
     * @param interrupt The IRQ number.
     * @retval kStatus_Success Interrupt enabled successfully
     * @retval kStatus_Fail Failed to enable the interrupt
     */
    static inline status_t EnableIRQ(IRQn_Type interrupt)
    {
     7bc:	b580      	push	{r7, lr}
     7be:	b084      	sub	sp, #16
     7c0:	af00      	add	r7, sp, #0
     7c2:	4603      	mov	r3, r0
     7c4:	71fb      	strb	r3, [r7, #7]
        status_t status = kStatus_Success;
     7c6:	2300      	movs	r3, #0
     7c8:	60fb      	str	r3, [r7, #12]

        if (NotAvail_IRQn == interrupt)
     7ca:	f997 3007 	ldrsb.w	r3, [r7, #7]
     7ce:	f113 0f80 	cmn.w	r3, #128	; 0x80
     7d2:	d102      	bne.n	7da <EnableIRQ+0x1e>
        {
            status = kStatus_Fail;
     7d4:	2301      	movs	r3, #1
     7d6:	60fb      	str	r3, [r7, #12]
     7d8:	e004      	b.n	7e4 <EnableIRQ+0x28>
        else
        {
#if defined(__GIC_PRIO_BITS)
            GIC_EnableIRQ(interrupt);
#else
            NVIC_EnableIRQ(interrupt);
     7da:	f997 3007 	ldrsb.w	r3, [r7, #7]
     7de:	4618      	mov	r0, r3
     7e0:	f7ff ffa4 	bl	72c <__NVIC_EnableIRQ>
#endif
        }

        return status;
     7e4:	68fb      	ldr	r3, [r7, #12]
    }
     7e6:	4618      	mov	r0, r3
     7e8:	3710      	adds	r7, #16
     7ea:	46bd      	mov	sp, r7
     7ec:	bd80      	pop	{r7, pc}

000007ee <CLOCK_EnableClock>:
 * @brief Enable the clock for specific IP.
 *
 * @param name  Which clock to enable, see \ref clock_ip_name_t.
 */
static inline void CLOCK_EnableClock(clock_ip_name_t name)
{
     7ee:	b480      	push	{r7}
     7f0:	b085      	sub	sp, #20
     7f2:	af00      	add	r7, sp, #0
     7f4:	6078      	str	r0, [r7, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
     7f6:	687b      	ldr	r3, [r7, #4]
     7f8:	0c1b      	lsrs	r3, r3, #16
     7fa:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
     7fe:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
     802:	60fb      	str	r3, [r7, #12]
    (*(volatile uint32_t *)regAddr) |= (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
     804:	68fb      	ldr	r3, [r7, #12]
     806:	6819      	ldr	r1, [r3, #0]
     808:	687b      	ldr	r3, [r7, #4]
     80a:	b29b      	uxth	r3, r3
     80c:	2201      	movs	r2, #1
     80e:	409a      	lsls	r2, r3
     810:	68fb      	ldr	r3, [r7, #12]
     812:	430a      	orrs	r2, r1
     814:	601a      	str	r2, [r3, #0]
}
     816:	bf00      	nop
     818:	3714      	adds	r7, #20
     81a:	46bd      	mov	sp, r7
     81c:	f85d 7b04 	ldr.w	r7, [sp], #4
     820:	4770      	bx	lr
     822:	Address 0x00000822 is out of bounds.


00000824 <CLOCK_SetSimSafeDivs>:
 * be used before MCG mode change, to make sure system level clocks are in allowed
 * range.
 *
 */
static inline void CLOCK_SetSimSafeDivs(void)
{
     824:	b480      	push	{r7}
     826:	af00      	add	r7, sp, #0
    SIM->CLKDIV1 = 0x02260000U;
     828:	4b05      	ldr	r3, [pc, #20]	; (840 <CLOCK_SetSimSafeDivs+0x1c>)
     82a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     82e:	461a      	mov	r2, r3
     830:	4b04      	ldr	r3, [pc, #16]	; (844 <CLOCK_SetSimSafeDivs+0x20>)
     832:	6453      	str	r3, [r2, #68]	; 0x44
}
     834:	bf00      	nop
     836:	46bd      	mov	sp, r7
     838:	f85d 7b04 	ldr.w	r7, [sp], #4
     83c:	4770      	bx	lr
     83e:	bf00      	nop
     840:	40047000 	.word	0x40047000
     844:	02260000 	.word	0x02260000

00000848 <CLOCK_SetXtal0Freq>:
 * @brief Sets the XTAL0 frequency based on board settings.
 *
 * @param freq The XTAL0/EXTAL0 input clock frequency in Hz.
 */
static inline void CLOCK_SetXtal0Freq(uint32_t freq)
{
     848:	b480      	push	{r7}
     84a:	b083      	sub	sp, #12
     84c:	af00      	add	r7, sp, #0
     84e:	6078      	str	r0, [r7, #4]
    g_xtal0Freq = freq;
     850:	4a04      	ldr	r2, [pc, #16]	; (864 <CLOCK_SetXtal0Freq+0x1c>)
     852:	687b      	ldr	r3, [r7, #4]
     854:	6013      	str	r3, [r2, #0]
}
     856:	bf00      	nop
     858:	370c      	adds	r7, #12
     85a:	46bd      	mov	sp, r7
     85c:	f85d 7b04 	ldr.w	r7, [sp], #4
     860:	4770      	bx	lr
     862:	bf00      	nop
     864:	1fff1434 	.word	0x1fff1434

00000868 <CLOCK_SetXtal32Freq>:
 * @brief Sets the XTAL32/RTC_CLKIN frequency based on board settings.
 *
 * @param freq The XTAL32/EXTAL32/RTC_CLKIN input clock frequency in Hz.
 */
static inline void CLOCK_SetXtal32Freq(uint32_t freq)
{
     868:	b480      	push	{r7}
     86a:	b083      	sub	sp, #12
     86c:	af00      	add	r7, sp, #0
     86e:	6078      	str	r0, [r7, #4]
    g_xtal32Freq = freq;
     870:	4a04      	ldr	r2, [pc, #16]	; (884 <CLOCK_SetXtal32Freq+0x1c>)
     872:	687b      	ldr	r3, [r7, #4]
     874:	6013      	str	r3, [r2, #0]
}
     876:	bf00      	nop
     878:	370c      	adds	r7, #12
     87a:	46bd      	mov	sp, r7
     87c:	f85d 7b04 	ldr.w	r7, [sp], #4
     880:	4770      	bx	lr
     882:	bf00      	nop
     884:	1fff1438 	.word	0x1fff1438

00000888 <GPIO_PinWrite>:
 * @param output  GPIO pin output logic level.
 *        - 0: corresponding pin output low-logic level.
 *        - 1: corresponding pin output high-logic level.
 */
static inline void GPIO_PinWrite(GPIO_Type *base, uint32_t pin, uint8_t output)
{
     888:	b480      	push	{r7}
     88a:	b087      	sub	sp, #28
     88c:	af00      	add	r7, sp, #0
     88e:	60f8      	str	r0, [r7, #12]
     890:	60b9      	str	r1, [r7, #8]
     892:	4613      	mov	r3, r2
     894:	71fb      	strb	r3, [r7, #7]
    uint32_t u32flag = 1;
     896:	2301      	movs	r3, #1
     898:	617b      	str	r3, [r7, #20]

    if (output == 0U)
     89a:	79fb      	ldrb	r3, [r7, #7]
     89c:	2b00      	cmp	r3, #0
     89e:	d105      	bne.n	8ac <GPIO_PinWrite+0x24>
    {
        base->PCOR = GPIO_FIT_REG(u32flag << pin);
     8a0:	697a      	ldr	r2, [r7, #20]
     8a2:	68bb      	ldr	r3, [r7, #8]
     8a4:	409a      	lsls	r2, r3
     8a6:	68fb      	ldr	r3, [r7, #12]
     8a8:	609a      	str	r2, [r3, #8]
    }
    else
    {
        base->PSOR = GPIO_FIT_REG(u32flag << pin);
    }
}
     8aa:	e004      	b.n	8b6 <GPIO_PinWrite+0x2e>
        base->PSOR = GPIO_FIT_REG(u32flag << pin);
     8ac:	697a      	ldr	r2, [r7, #20]
     8ae:	68bb      	ldr	r3, [r7, #8]
     8b0:	409a      	lsls	r2, r3
     8b2:	68fb      	ldr	r3, [r7, #12]
     8b4:	605a      	str	r2, [r3, #4]
}
     8b6:	bf00      	nop
     8b8:	371c      	adds	r7, #28
     8ba:	46bd      	mov	sp, r7
     8bc:	f85d 7b04 	ldr.w	r7, [sp], #4
     8c0:	4770      	bx	lr

000008c2 <GPIO_PortToggle>:
 *
 * @param base GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 * @param mask GPIO pin number macro
 */
static inline void GPIO_PortToggle(GPIO_Type *base, uint32_t mask)
{
     8c2:	b480      	push	{r7}
     8c4:	b083      	sub	sp, #12
     8c6:	af00      	add	r7, sp, #0
     8c8:	6078      	str	r0, [r7, #4]
     8ca:	6039      	str	r1, [r7, #0]
    base->PTOR = GPIO_FIT_REG(mask);
     8cc:	687b      	ldr	r3, [r7, #4]
     8ce:	683a      	ldr	r2, [r7, #0]
     8d0:	60da      	str	r2, [r3, #12]
}
     8d2:	bf00      	nop
     8d4:	370c      	adds	r7, #12
     8d6:	46bd      	mov	sp, r7
     8d8:	f85d 7b04 	ldr.w	r7, [sp], #4
     8dc:	4770      	bx	lr

000008de <PORT_SetPinMux>:
 *         reset to zero : kPORT_PinDisabledOrAnalog).
 *        This function is recommended to use to reset the pin mux
 *
 */
static inline void PORT_SetPinMux(PORT_Type *base, uint32_t pin, port_mux_t mux)
{
     8de:	b480      	push	{r7}
     8e0:	b085      	sub	sp, #20
     8e2:	af00      	add	r7, sp, #0
     8e4:	60f8      	str	r0, [r7, #12]
     8e6:	60b9      	str	r1, [r7, #8]
     8e8:	4613      	mov	r3, r2
     8ea:	71fb      	strb	r3, [r7, #7]
    base->PCR[pin] = (base->PCR[pin] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(mux);
     8ec:	68fb      	ldr	r3, [r7, #12]
     8ee:	68ba      	ldr	r2, [r7, #8]
     8f0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     8f4:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
     8f8:	79fb      	ldrb	r3, [r7, #7]
     8fa:	021b      	lsls	r3, r3, #8
     8fc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
     900:	ea42 0103 	orr.w	r1, r2, r3
     904:	68fb      	ldr	r3, [r7, #12]
     906:	68ba      	ldr	r2, [r7, #8]
     908:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
     90c:	bf00      	nop
     90e:	3714      	adds	r7, #20
     910:	46bd      	mov	sp, r7
     912:	f85d 7b04 	ldr.w	r7, [sp], #4
     916:	4770      	bx	lr

00000918 <SMC_SetPowerModeProtection>:
 *
 * @param base SMC peripheral base address.
 * @param allowedModes Bitmap of the allowed power modes.
 */
static inline void SMC_SetPowerModeProtection(SMC_Type *base, uint8_t allowedModes)
{
     918:	b480      	push	{r7}
     91a:	b083      	sub	sp, #12
     91c:	af00      	add	r7, sp, #0
     91e:	6078      	str	r0, [r7, #4]
     920:	460b      	mov	r3, r1
     922:	70fb      	strb	r3, [r7, #3]
    base->PMPROT = allowedModes;
     924:	687b      	ldr	r3, [r7, #4]
     926:	78fa      	ldrb	r2, [r7, #3]
     928:	701a      	strb	r2, [r3, #0]
}
     92a:	bf00      	nop
     92c:	370c      	adds	r7, #12
     92e:	46bd      	mov	sp, r7
     930:	f85d 7b04 	ldr.w	r7, [sp], #4
     934:	4770      	bx	lr

00000936 <ADC16_EnableDMA>:
 *
 * @param base   ADC16 peripheral base address.
 * @param enable Switcher of the DMA feature. "true" means enabled, "false" means not enabled.
 */
static inline void ADC16_EnableDMA(ADC_Type *base, bool enable)
{
     936:	b480      	push	{r7}
     938:	b083      	sub	sp, #12
     93a:	af00      	add	r7, sp, #0
     93c:	6078      	str	r0, [r7, #4]
     93e:	460b      	mov	r3, r1
     940:	70fb      	strb	r3, [r7, #3]
    if (enable)
     942:	78fb      	ldrb	r3, [r7, #3]
     944:	2b00      	cmp	r3, #0
     946:	d006      	beq.n	956 <ADC16_EnableDMA+0x20>
    {
        base->SC2 |= ADC_SC2_DMAEN_MASK;
     948:	687b      	ldr	r3, [r7, #4]
     94a:	6a1b      	ldr	r3, [r3, #32]
     94c:	f043 0204 	orr.w	r2, r3, #4
     950:	687b      	ldr	r3, [r7, #4]
     952:	621a      	str	r2, [r3, #32]
    }
    else
    {
        base->SC2 &= ~ADC_SC2_DMAEN_MASK;
    }
}
     954:	e005      	b.n	962 <ADC16_EnableDMA+0x2c>
        base->SC2 &= ~ADC_SC2_DMAEN_MASK;
     956:	687b      	ldr	r3, [r7, #4]
     958:	6a1b      	ldr	r3, [r3, #32]
     95a:	f023 0204 	bic.w	r2, r3, #4
     95e:	687b      	ldr	r3, [r7, #4]
     960:	621a      	str	r2, [r3, #32]
}
     962:	bf00      	nop
     964:	370c      	adds	r7, #12
     966:	46bd      	mov	sp, r7
     968:	f85d 7b04 	ldr.w	r7, [sp], #4
     96c:	4770      	bx	lr

0000096e <ADC16_EnableHardwareTrigger>:
 *
 * @param base   ADC16 peripheral base address.
 * @param enable Switcher of the hardware trigger feature. "true" means enabled, "false" means not enabled.
 */
static inline void ADC16_EnableHardwareTrigger(ADC_Type *base, bool enable)
{
     96e:	b480      	push	{r7}
     970:	b083      	sub	sp, #12
     972:	af00      	add	r7, sp, #0
     974:	6078      	str	r0, [r7, #4]
     976:	460b      	mov	r3, r1
     978:	70fb      	strb	r3, [r7, #3]
    if (enable)
     97a:	78fb      	ldrb	r3, [r7, #3]
     97c:	2b00      	cmp	r3, #0
     97e:	d006      	beq.n	98e <ADC16_EnableHardwareTrigger+0x20>
    {
        base->SC2 |= ADC_SC2_ADTRG_MASK;
     980:	687b      	ldr	r3, [r7, #4]
     982:	6a1b      	ldr	r3, [r3, #32]
     984:	f043 0240 	orr.w	r2, r3, #64	; 0x40
     988:	687b      	ldr	r3, [r7, #4]
     98a:	621a      	str	r2, [r3, #32]
    }
    else
    {
        base->SC2 &= ~ADC_SC2_ADTRG_MASK;
    }
}
     98c:	e005      	b.n	99a <ADC16_EnableHardwareTrigger+0x2c>
        base->SC2 &= ~ADC_SC2_ADTRG_MASK;
     98e:	687b      	ldr	r3, [r7, #4]
     990:	6a1b      	ldr	r3, [r3, #32]
     992:	f023 0240 	bic.w	r2, r3, #64	; 0x40
     996:	687b      	ldr	r3, [r7, #4]
     998:	621a      	str	r2, [r3, #32]
}
     99a:	bf00      	nop
     99c:	370c      	adds	r7, #12
     99e:	46bd      	mov	sp, r7
     9a0:	f85d 7b04 	ldr.w	r7, [sp], #4
     9a4:	4770      	bx	lr
     9a6:	Address 0x000009a6 is out of bounds.


000009a8 <DMAMUX_EnableChannel>:
 *
 * @param base DMAMUX peripheral base address.
 * @param channel DMAMUX channel number.
 */
static inline void DMAMUX_EnableChannel(DMAMUX_Type *base, uint32_t channel)
{
     9a8:	b580      	push	{r7, lr}
     9aa:	b082      	sub	sp, #8
     9ac:	af00      	add	r7, sp, #0
     9ae:	6078      	str	r0, [r7, #4]
     9b0:	6039      	str	r1, [r7, #0]
    assert(channel < (uint32_t)FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
     9b2:	683b      	ldr	r3, [r7, #0]
     9b4:	2b1f      	cmp	r3, #31
     9b6:	d905      	bls.n	9c4 <DMAMUX_EnableChannel+0x1c>
     9b8:	4b0b      	ldr	r3, [pc, #44]	; (9e8 <DMAMUX_EnableChannel+0x40>)
     9ba:	4a0c      	ldr	r2, [pc, #48]	; (9ec <DMAMUX_EnableChannel+0x44>)
     9bc:	214d      	movs	r1, #77	; 0x4d
     9be:	480c      	ldr	r0, [pc, #48]	; (9f0 <DMAMUX_EnableChannel+0x48>)
     9c0:	f006 fc0c 	bl	71dc <__assert_func>

    base->CHCFG[channel] |= DMAMUX_CHCFG_ENBL_MASK;
     9c4:	687a      	ldr	r2, [r7, #4]
     9c6:	683b      	ldr	r3, [r7, #0]
     9c8:	4413      	add	r3, r2
     9ca:	781b      	ldrb	r3, [r3, #0]
     9cc:	b2db      	uxtb	r3, r3
     9ce:	f063 037f 	orn	r3, r3, #127	; 0x7f
     9d2:	b2d9      	uxtb	r1, r3
     9d4:	687a      	ldr	r2, [r7, #4]
     9d6:	683b      	ldr	r3, [r7, #0]
     9d8:	4413      	add	r3, r2
     9da:	460a      	mov	r2, r1
     9dc:	701a      	strb	r2, [r3, #0]
}
     9de:	bf00      	nop
     9e0:	3708      	adds	r7, #8
     9e2:	46bd      	mov	sp, r7
     9e4:	bd80      	pop	{r7, pc}
     9e6:	bf00      	nop
     9e8:	0000ec24 	.word	0x0000ec24
     9ec:	0000ec5c 	.word	0x0000ec5c
     9f0:	0000ec90 	.word	0x0000ec90

000009f4 <DMAMUX_SetSource>:
 * @param base DMAMUX peripheral base address.
 * @param channel DMAMUX channel number.
 * @param source Channel source, which is used to trigger the DMA transfer.
 */
static inline void DMAMUX_SetSource(DMAMUX_Type *base, uint32_t channel, uint32_t source)
{
     9f4:	b580      	push	{r7, lr}
     9f6:	b084      	sub	sp, #16
     9f8:	af00      	add	r7, sp, #0
     9fa:	60f8      	str	r0, [r7, #12]
     9fc:	60b9      	str	r1, [r7, #8]
     9fe:	607a      	str	r2, [r7, #4]
    assert(channel < (uint32_t)FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
     a00:	68bb      	ldr	r3, [r7, #8]
     a02:	2b1f      	cmp	r3, #31
     a04:	d905      	bls.n	a12 <DMAMUX_SetSource+0x1e>
     a06:	4b0f      	ldr	r3, [pc, #60]	; (a44 <DMAMUX_SetSource+0x50>)
     a08:	4a0f      	ldr	r2, [pc, #60]	; (a48 <DMAMUX_SetSource+0x54>)
     a0a:	216f      	movs	r1, #111	; 0x6f
     a0c:	480f      	ldr	r0, [pc, #60]	; (a4c <DMAMUX_SetSource+0x58>)
     a0e:	f006 fbe5 	bl	71dc <__assert_func>

#if defined FSL_FEATURE_DMAMUX_CHCFG_REGISTER_WIDTH && (FSL_FEATURE_DMAMUX_CHCFG_REGISTER_WIDTH == 32U)
    base->CHCFG[channel] = ((base->CHCFG[channel] & ~DMAMUX_CHCFG_SOURCE_MASK) | DMAMUX_CHCFG_SOURCE(source));
#else
    base->CHCFG[channel] = (uint8_t)((base->CHCFG[channel] & ~DMAMUX_CHCFG_SOURCE_MASK) | DMAMUX_CHCFG_SOURCE(source));
     a12:	68fa      	ldr	r2, [r7, #12]
     a14:	68bb      	ldr	r3, [r7, #8]
     a16:	4413      	add	r3, r2
     a18:	781b      	ldrb	r3, [r3, #0]
     a1a:	b2db      	uxtb	r3, r3
     a1c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
     a20:	b2da      	uxtb	r2, r3
     a22:	687b      	ldr	r3, [r7, #4]
     a24:	b2db      	uxtb	r3, r3
     a26:	f003 033f 	and.w	r3, r3, #63	; 0x3f
     a2a:	b2db      	uxtb	r3, r3
     a2c:	4313      	orrs	r3, r2
     a2e:	b2d9      	uxtb	r1, r3
     a30:	68fa      	ldr	r2, [r7, #12]
     a32:	68bb      	ldr	r3, [r7, #8]
     a34:	4413      	add	r3, r2
     a36:	460a      	mov	r2, r1
     a38:	701a      	strb	r2, [r3, #0]
#endif
}
     a3a:	bf00      	nop
     a3c:	3710      	adds	r7, #16
     a3e:	46bd      	mov	sp, r7
     a40:	bd80      	pop	{r7, pc}
     a42:	bf00      	nop
     a44:	0000ec24 	.word	0x0000ec24
     a48:	0000ecec 	.word	0x0000ecec
     a4c:	0000ec90 	.word	0x0000ec90

00000a50 <EDMA_EnableAsyncRequest>:
 * @param base eDMA peripheral base address.
 * @param channel eDMA channel number.
 * @param enable The command to enable (true) or disable (false).
 */
static inline void EDMA_EnableAsyncRequest(DMA_Type *base, uint32_t channel, bool enable)
{
     a50:	b580      	push	{r7, lr}
     a52:	b084      	sub	sp, #16
     a54:	af00      	add	r7, sp, #0
     a56:	60f8      	str	r0, [r7, #12]
     a58:	60b9      	str	r1, [r7, #8]
     a5a:	4613      	mov	r3, r2
     a5c:	71fb      	strb	r3, [r7, #7]
    assert(channel < (uint32_t)FSL_FEATURE_DMAMUX_MODULE_CHANNEL);
     a5e:	68bb      	ldr	r3, [r7, #8]
     a60:	2b1f      	cmp	r3, #31
     a62:	d906      	bls.n	a72 <EDMA_EnableAsyncRequest+0x22>
     a64:	4b11      	ldr	r3, [pc, #68]	; (aac <EDMA_EnableAsyncRequest+0x5c>)
     a66:	4a12      	ldr	r2, [pc, #72]	; (ab0 <EDMA_EnableAsyncRequest+0x60>)
     a68:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
     a6c:	4811      	ldr	r0, [pc, #68]	; (ab4 <EDMA_EnableAsyncRequest+0x64>)
     a6e:	f006 fbb5 	bl	71dc <__assert_func>

    base->EARS &= ~((uint32_t)1U << channel);
     a72:	68fb      	ldr	r3, [r7, #12]
     a74:	6c5a      	ldr	r2, [r3, #68]	; 0x44
     a76:	2101      	movs	r1, #1
     a78:	68bb      	ldr	r3, [r7, #8]
     a7a:	fa01 f303 	lsl.w	r3, r1, r3
     a7e:	43db      	mvns	r3, r3
     a80:	401a      	ands	r2, r3
     a82:	68fb      	ldr	r3, [r7, #12]
     a84:	645a      	str	r2, [r3, #68]	; 0x44
    base->EARS |= ((uint32_t)(true == enable ? 1U : 0U) << channel);
     a86:	68fb      	ldr	r3, [r7, #12]
     a88:	6c5a      	ldr	r2, [r3, #68]	; 0x44
     a8a:	79fb      	ldrb	r3, [r7, #7]
     a8c:	2b01      	cmp	r3, #1
     a8e:	d101      	bne.n	a94 <EDMA_EnableAsyncRequest+0x44>
     a90:	2101      	movs	r1, #1
     a92:	e000      	b.n	a96 <EDMA_EnableAsyncRequest+0x46>
     a94:	2100      	movs	r1, #0
     a96:	68bb      	ldr	r3, [r7, #8]
     a98:	fa01 f303 	lsl.w	r3, r1, r3
     a9c:	431a      	orrs	r2, r3
     a9e:	68fb      	ldr	r3, [r7, #12]
     aa0:	645a      	str	r2, [r3, #68]	; 0x44
}
     aa2:	bf00      	nop
     aa4:	3710      	adds	r7, #16
     aa6:	46bd      	mov	sp, r7
     aa8:	bd80      	pop	{r7, pc}
     aaa:	bf00      	nop
     aac:	0000ec24 	.word	0x0000ec24
     ab0:	0000ed24 	.word	0x0000ed24
     ab4:	0000ed5c 	.word	0x0000ed5c

00000ab8 <PDB_DoSoftwareTrigger>:
 * @brief Triggers the PDB counter by software.
 *
 * @param base PDB peripheral base address.
 */
static inline void PDB_DoSoftwareTrigger(PDB_Type *base)
{
     ab8:	b480      	push	{r7}
     aba:	b083      	sub	sp, #12
     abc:	af00      	add	r7, sp, #0
     abe:	6078      	str	r0, [r7, #4]
    base->SC |= PDB_SC_SWTRIG_MASK;
     ac0:	687b      	ldr	r3, [r7, #4]
     ac2:	681b      	ldr	r3, [r3, #0]
     ac4:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
     ac8:	687b      	ldr	r3, [r7, #4]
     aca:	601a      	str	r2, [r3, #0]
}
     acc:	bf00      	nop
     ace:	370c      	adds	r7, #12
     ad0:	46bd      	mov	sp, r7
     ad2:	f85d 7b04 	ldr.w	r7, [sp], #4
     ad6:	4770      	bx	lr

00000ad8 <PDB_DoLoadValues>:
 * See "pdb_load_value_mode_t" about PDB's load mode.
 *
 * @param base PDB peripheral base address.
 */
static inline void PDB_DoLoadValues(PDB_Type *base)
{
     ad8:	b480      	push	{r7}
     ada:	b083      	sub	sp, #12
     adc:	af00      	add	r7, sp, #0
     ade:	6078      	str	r0, [r7, #4]
    base->SC |= PDB_SC_LDOK_MASK;
     ae0:	687b      	ldr	r3, [r7, #4]
     ae2:	681b      	ldr	r3, [r3, #0]
     ae4:	f043 0201 	orr.w	r2, r3, #1
     ae8:	687b      	ldr	r3, [r7, #4]
     aea:	601a      	str	r2, [r3, #0]
}
     aec:	bf00      	nop
     aee:	370c      	adds	r7, #12
     af0:	46bd      	mov	sp, r7
     af2:	f85d 7b04 	ldr.w	r7, [sp], #4
     af6:	4770      	bx	lr

00000af8 <PDB_SetModulusValue>:
 *
 * @param  base  PDB peripheral base address.
 * @param  value Setting value for the modulus. 16-bit is available.
 */
static inline void PDB_SetModulusValue(PDB_Type *base, uint32_t value)
{
     af8:	b480      	push	{r7}
     afa:	b083      	sub	sp, #12
     afc:	af00      	add	r7, sp, #0
     afe:	6078      	str	r0, [r7, #4]
     b00:	6039      	str	r1, [r7, #0]
    base->MOD = PDB_MOD_MOD(value);
     b02:	683b      	ldr	r3, [r7, #0]
     b04:	b29a      	uxth	r2, r3
     b06:	687b      	ldr	r3, [r7, #4]
     b08:	605a      	str	r2, [r3, #4]
}
     b0a:	bf00      	nop
     b0c:	370c      	adds	r7, #12
     b0e:	46bd      	mov	sp, r7
     b10:	f85d 7b04 	ldr.w	r7, [sp], #4
     b14:	4770      	bx	lr

00000b16 <PDB_SetCounterDelayValue>:
 *
 * @param base  PDB peripheral base address.
 * @param value Setting value for PDB counter delay event. 16-bit is available.
 */
static inline void PDB_SetCounterDelayValue(PDB_Type *base, uint32_t value)
{
     b16:	b480      	push	{r7}
     b18:	b083      	sub	sp, #12
     b1a:	af00      	add	r7, sp, #0
     b1c:	6078      	str	r0, [r7, #4]
     b1e:	6039      	str	r1, [r7, #0]
    base->IDLY = PDB_IDLY_IDLY(value);
     b20:	683b      	ldr	r3, [r7, #0]
     b22:	b29a      	uxth	r2, r3
     b24:	687b      	ldr	r3, [r7, #4]
     b26:	60da      	str	r2, [r3, #12]
}
     b28:	bf00      	nop
     b2a:	370c      	adds	r7, #12
     b2c:	46bd      	mov	sp, r7
     b2e:	f85d 7b04 	ldr.w	r7, [sp], #4
     b32:	4770      	bx	lr

00000b34 <PDB_SetDACTriggerIntervalValue>:
 * @param base    PDB peripheral base address.
 * @param channel Channel index for DAC instance.
 * @param value   Setting value for the DAC interval event.
 */
static inline void PDB_SetDACTriggerIntervalValue(PDB_Type *base, pdb_dac_trigger_channel_t channel, uint32_t value)
{
     b34:	b580      	push	{r7, lr}
     b36:	b084      	sub	sp, #16
     b38:	af00      	add	r7, sp, #0
     b3a:	60f8      	str	r0, [r7, #12]
     b3c:	460b      	mov	r3, r1
     b3e:	607a      	str	r2, [r7, #4]
     b40:	72fb      	strb	r3, [r7, #11]
    assert((uint8_t)channel < (uint8_t)FSL_FEATURE_PDB_DAC_INTERVAL_TRIGGER_COUNT);
     b42:	7afb      	ldrb	r3, [r7, #11]
     b44:	2b01      	cmp	r3, #1
     b46:	d906      	bls.n	b56 <PDB_SetDACTriggerIntervalValue+0x22>
     b48:	4b09      	ldr	r3, [pc, #36]	; (b70 <PDB_SetDACTriggerIntervalValue+0x3c>)
     b4a:	4a0a      	ldr	r2, [pc, #40]	; (b74 <PDB_SetDACTriggerIntervalValue+0x40>)
     b4c:	f240 2131 	movw	r1, #561	; 0x231
     b50:	4809      	ldr	r0, [pc, #36]	; (b78 <PDB_SetDACTriggerIntervalValue+0x44>)
     b52:	f006 fb43 	bl	71dc <__assert_func>

    base->DAC[channel].INT = PDB_INT_INT(value);
     b56:	7afb      	ldrb	r3, [r7, #11]
     b58:	687a      	ldr	r2, [r7, #4]
     b5a:	b292      	uxth	r2, r2
     b5c:	68f9      	ldr	r1, [r7, #12]
     b5e:	332a      	adds	r3, #42	; 0x2a
     b60:	00db      	lsls	r3, r3, #3
     b62:	440b      	add	r3, r1
     b64:	605a      	str	r2, [r3, #4]
}
     b66:	bf00      	nop
     b68:	3710      	adds	r7, #16
     b6a:	46bd      	mov	sp, r7
     b6c:	bd80      	pop	{r7, pc}
     b6e:	bf00      	nop
     b70:	0000edb4 	.word	0x0000edb4
     b74:	0000edfc 	.word	0x0000edfc
     b78:	0000ee50 	.word	0x0000ee50

00000b7c <DAC_Enable>:
 *
 * @param base DAC peripheral base address.
 * @param enable Enables or disables the feature.
 */
static inline void DAC_Enable(DAC_Type *base, bool enable)
{
     b7c:	b480      	push	{r7}
     b7e:	b083      	sub	sp, #12
     b80:	af00      	add	r7, sp, #0
     b82:	6078      	str	r0, [r7, #4]
     b84:	460b      	mov	r3, r1
     b86:	70fb      	strb	r3, [r7, #3]
    if (enable)
     b88:	78fb      	ldrb	r3, [r7, #3]
     b8a:	2b00      	cmp	r3, #0
     b8c:	d00a      	beq.n	ba4 <DAC_Enable+0x28>
    {
        base->C0 |= (uint8_t)DAC_C0_DACEN_MASK;
     b8e:	687b      	ldr	r3, [r7, #4]
     b90:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
     b94:	b2db      	uxtb	r3, r3
     b96:	f063 037f 	orn	r3, r3, #127	; 0x7f
     b9a:	b2da      	uxtb	r2, r3
     b9c:	687b      	ldr	r3, [r7, #4]
     b9e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    }
    else
    {
        base->C0 &= (uint8_t)(~DAC_C0_DACEN_MASK);
    }
}
     ba2:	e009      	b.n	bb8 <DAC_Enable+0x3c>
        base->C0 &= (uint8_t)(~DAC_C0_DACEN_MASK);
     ba4:	687b      	ldr	r3, [r7, #4]
     ba6:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
     baa:	b2db      	uxtb	r3, r3
     bac:	f003 037f 	and.w	r3, r3, #127	; 0x7f
     bb0:	b2da      	uxtb	r2, r3
     bb2:	687b      	ldr	r3, [r7, #4]
     bb4:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
}
     bb8:	bf00      	nop
     bba:	370c      	adds	r7, #12
     bbc:	46bd      	mov	sp, r7
     bbe:	f85d 7b04 	ldr.w	r7, [sp], #4
     bc2:	4770      	bx	lr

00000bc4 <DAC_EnableBuffer>:
 *
 * @param base DAC peripheral base address.
 * @param enable Enables or disables the feature.
 */
static inline void DAC_EnableBuffer(DAC_Type *base, bool enable)
{
     bc4:	b480      	push	{r7}
     bc6:	b083      	sub	sp, #12
     bc8:	af00      	add	r7, sp, #0
     bca:	6078      	str	r0, [r7, #4]
     bcc:	460b      	mov	r3, r1
     bce:	70fb      	strb	r3, [r7, #3]
    if (enable)
     bd0:	78fb      	ldrb	r3, [r7, #3]
     bd2:	2b00      	cmp	r3, #0
     bd4:	d00a      	beq.n	bec <DAC_EnableBuffer+0x28>
    {
        base->C1 |= (uint8_t)DAC_C1_DACBFEN_MASK;
     bd6:	687b      	ldr	r3, [r7, #4]
     bd8:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
     bdc:	b2db      	uxtb	r3, r3
     bde:	f043 0301 	orr.w	r3, r3, #1
     be2:	b2da      	uxtb	r2, r3
     be4:	687b      	ldr	r3, [r7, #4]
     be6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    }
    else
    {
        base->C1 &= (uint8_t)(~DAC_C1_DACBFEN_MASK);
    }
}
     bea:	e009      	b.n	c00 <DAC_EnableBuffer+0x3c>
        base->C1 &= (uint8_t)(~DAC_C1_DACBFEN_MASK);
     bec:	687b      	ldr	r3, [r7, #4]
     bee:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
     bf2:	b2db      	uxtb	r3, r3
     bf4:	f023 0301 	bic.w	r3, r3, #1
     bf8:	b2da      	uxtb	r2, r3
     bfa:	687b      	ldr	r3, [r7, #4]
     bfc:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
}
     c00:	bf00      	nop
     c02:	370c      	adds	r7, #12
     c04:	46bd      	mov	sp, r7
     c06:	f85d 7b04 	ldr.w	r7, [sp], #4
     c0a:	4770      	bx	lr

00000c0c <_Z10init_boardv>:
/*******************************************************************************
 * Initalise board
 ******************************************************************************/

void init_board()
{ 
     c0c:	b580      	push	{r7, lr}
     c0e:	af00      	add	r7, sp, #0
    CLOCK_EnableClock(kCLOCK_PortA);
     c10:	4817      	ldr	r0, [pc, #92]	; (c70 <_Z10init_boardv+0x64>)
     c12:	f7ff fdec 	bl	7ee <CLOCK_EnableClock>
    CLOCK_EnableClock(kCLOCK_PortB);
     c16:	4817      	ldr	r0, [pc, #92]	; (c74 <_Z10init_boardv+0x68>)
     c18:	f7ff fde9 	bl	7ee <CLOCK_EnableClock>
    CLOCK_EnableClock(kCLOCK_PortC);
     c1c:	4816      	ldr	r0, [pc, #88]	; (c78 <_Z10init_boardv+0x6c>)
     c1e:	f7ff fde6 	bl	7ee <CLOCK_EnableClock>
    CLOCK_EnableClock(kCLOCK_PortD);
     c22:	4816      	ldr	r0, [pc, #88]	; (c7c <_Z10init_boardv+0x70>)
     c24:	f7ff fde3 	bl	7ee <CLOCK_EnableClock>
    CLOCK_EnableClock(kCLOCK_PortE);
     c28:	4815      	ldr	r0, [pc, #84]	; (c80 <_Z10init_boardv+0x74>)
     c2a:	f7ff fde0 	bl	7ee <CLOCK_EnableClock>
    LED_INIT(1);
     c2e:	2201      	movs	r2, #1
     c30:	2105      	movs	r1, #5
     c32:	4814      	ldr	r0, [pc, #80]	; (c84 <_Z10init_boardv+0x78>)
     c34:	f7ff fe53 	bl	8de <PORT_SetPinMux>
     c38:	4a13      	ldr	r2, [pc, #76]	; (c88 <_Z10init_boardv+0x7c>)
     c3a:	2105      	movs	r1, #5
     c3c:	4813      	ldr	r0, [pc, #76]	; (c8c <_Z10init_boardv+0x80>)
     c3e:	f006 fa93 	bl	7168 <GPIO_PinInit>
    TP_INIT(1);
     c42:	2201      	movs	r2, #1
     c44:	2110      	movs	r1, #16
     c46:	4812      	ldr	r0, [pc, #72]	; (c90 <_Z10init_boardv+0x84>)
     c48:	f7ff fe49 	bl	8de <PORT_SetPinMux>
     c4c:	4a11      	ldr	r2, [pc, #68]	; (c94 <_Z10init_boardv+0x88>)
     c4e:	2110      	movs	r1, #16
     c50:	4811      	ldr	r0, [pc, #68]	; (c98 <_Z10init_boardv+0x8c>)
     c52:	f006 fa89 	bl	7168 <GPIO_PinInit>
    ADCFLG_INIT(1);
     c56:	2201      	movs	r2, #1
     c58:	2111      	movs	r1, #17
     c5a:	480d      	ldr	r0, [pc, #52]	; (c90 <_Z10init_boardv+0x84>)
     c5c:	f7ff fe3f 	bl	8de <PORT_SetPinMux>
     c60:	4a0e      	ldr	r2, [pc, #56]	; (c9c <_Z10init_boardv+0x90>)
     c62:	2111      	movs	r1, #17
     c64:	480c      	ldr	r0, [pc, #48]	; (c98 <_Z10init_boardv+0x8c>)
     c66:	f006 fa7f 	bl	7168 <GPIO_PinInit>
}
     c6a:	bf00      	nop
     c6c:	bd80      	pop	{r7, pc}
     c6e:	bf00      	nop
     c70:	10380009 	.word	0x10380009
     c74:	1038000a 	.word	0x1038000a
     c78:	1038000b 	.word	0x1038000b
     c7c:	1038000c 	.word	0x1038000c
     c80:	1038000d 	.word	0x1038000d
     c84:	4004b000 	.word	0x4004b000
     c88:	0000f4e4 	.word	0x0000f4e4
     c8c:	400ff080 	.word	0x400ff080
     c90:	4004a000 	.word	0x4004a000
     c94:	0000f4e8 	.word	0x0000f4e8
     c98:	400ff040 	.word	0x400ff040
     c9c:	0000f4ec 	.word	0x0000f4ec

00000ca0 <_Z18recalculateGlobalsv>:
uint16_t g_iPDB_mod              = g_iDAC_trigger_interval * g_iDAC_points;



void recalculateGlobals() 
{
     ca0:	b480      	push	{r7}
     ca2:	af00      	add	r7, sp, #0
    g_iTarget_frequency  = g_iADC_frequency / g_iSamples_per_cycle;
     ca4:	4b33      	ldr	r3, [pc, #204]	; (d74 <_Z18recalculateGlobalsv+0xd4>)
     ca6:	681a      	ldr	r2, [r3, #0]
     ca8:	4b33      	ldr	r3, [pc, #204]	; (d78 <_Z18recalculateGlobalsv+0xd8>)
     caa:	681b      	ldr	r3, [r3, #0]
     cac:	fbb2 f3f3 	udiv	r3, r2, r3
     cb0:	4a32      	ldr	r2, [pc, #200]	; (d7c <_Z18recalculateGlobalsv+0xdc>)
     cb2:	6013      	str	r3, [r2, #0]
    g_fTarget_frequency  = g_fADC_frequency / g_iSamples_per_cycle;
     cb4:	4b32      	ldr	r3, [pc, #200]	; (d80 <_Z18recalculateGlobalsv+0xe0>)
     cb6:	edd3 6a00 	vldr	s13, [r3]
     cba:	4b2f      	ldr	r3, [pc, #188]	; (d78 <_Z18recalculateGlobalsv+0xd8>)
     cbc:	681b      	ldr	r3, [r3, #0]
     cbe:	ee07 3a90 	vmov	s15, r3
     cc2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
     cc6:	eec6 7a87 	vdiv.f32	s15, s13, s14
     cca:	4b2e      	ldr	r3, [pc, #184]	; (d84 <_Z18recalculateGlobalsv+0xe4>)
     ccc:	edc3 7a00 	vstr	s15, [r3]
    g_iTarget_period_us  = ( 1.0 / g_fTarget_frequency ) / 1000000.0;
     cd0:	4b2c      	ldr	r3, [pc, #176]	; (d84 <_Z18recalculateGlobalsv+0xe4>)
     cd2:	edd3 7a00 	vldr	s15, [r3]
     cd6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
     cda:	ee86 7aa7 	vdiv.f32	s14, s13, s15
     cde:	eddf 6a2a 	vldr	s13, [pc, #168]	; d88 <_Z18recalculateGlobalsv+0xe8>
     ce2:	eec7 7a26 	vdiv.f32	s15, s14, s13
     ce6:	4b29      	ldr	r3, [pc, #164]	; (d8c <_Z18recalculateGlobalsv+0xec>)
     ce8:	edc3 7a00 	vstr	s15, [r3]
    g_iSamples_useful    = g_iSamples_per_cycle * g_iSample_cycles;
     cec:	4b22      	ldr	r3, [pc, #136]	; (d78 <_Z18recalculateGlobalsv+0xd8>)
     cee:	681b      	ldr	r3, [r3, #0]
     cf0:	4a27      	ldr	r2, [pc, #156]	; (d90 <_Z18recalculateGlobalsv+0xf0>)
     cf2:	6812      	ldr	r2, [r2, #0]
     cf4:	fb02 f303 	mul.w	r3, r2, r3
     cf8:	4a26      	ldr	r2, [pc, #152]	; (d94 <_Z18recalculateGlobalsv+0xf4>)
     cfa:	6013      	str	r3, [r2, #0]
    g_iSamples           = g_iSamples_useful + g_iSample_rubbish;
     cfc:	4b25      	ldr	r3, [pc, #148]	; (d94 <_Z18recalculateGlobalsv+0xf4>)
     cfe:	681a      	ldr	r2, [r3, #0]
     d00:	4b25      	ldr	r3, [pc, #148]	; (d98 <_Z18recalculateGlobalsv+0xf8>)
     d02:	681b      	ldr	r3, [r3, #0]
     d04:	4413      	add	r3, r2
     d06:	4a25      	ldr	r2, [pc, #148]	; (d9c <_Z18recalculateGlobalsv+0xfc>)
     d08:	6013      	str	r3, [r2, #0]

    g_iDAC_points = g_eDACMode == DACModes::HighRes ? lenof(g_dacValuesHighRes)*2 - 2 : lenof(g_dacValuesLowRes);
     d0a:	4b25      	ldr	r3, [pc, #148]	; (da0 <_Z18recalculateGlobalsv+0x100>)
     d0c:	781b      	ldrb	r3, [r3, #0]
     d0e:	2b01      	cmp	r3, #1
     d10:	d101      	bne.n	d16 <_Z18recalculateGlobalsv+0x76>
     d12:	221e      	movs	r2, #30
     d14:	e000      	b.n	d18 <_Z18recalculateGlobalsv+0x78>
     d16:	2210      	movs	r2, #16
     d18:	4b22      	ldr	r3, [pc, #136]	; (da4 <_Z18recalculateGlobalsv+0x104>)
     d1a:	801a      	strh	r2, [r3, #0]

    g_iPDB_cycleLength      = g_iPerip_frequency / g_iTarget_frequency;
     d1c:	4b22      	ldr	r3, [pc, #136]	; (da8 <_Z18recalculateGlobalsv+0x108>)
     d1e:	681a      	ldr	r2, [r3, #0]
     d20:	4b16      	ldr	r3, [pc, #88]	; (d7c <_Z18recalculateGlobalsv+0xdc>)
     d22:	681b      	ldr	r3, [r3, #0]
     d24:	fbb2 f3f3 	udiv	r3, r2, r3
     d28:	b29a      	uxth	r2, r3
     d2a:	4b20      	ldr	r3, [pc, #128]	; (dac <_Z18recalculateGlobalsv+0x10c>)
     d2c:	801a      	strh	r2, [r3, #0]
    g_iDAC_trigger_interval = g_iPDB_cycleLength / g_iDAC_points ;
     d2e:	4b1f      	ldr	r3, [pc, #124]	; (dac <_Z18recalculateGlobalsv+0x10c>)
     d30:	881a      	ldrh	r2, [r3, #0]
     d32:	4b1c      	ldr	r3, [pc, #112]	; (da4 <_Z18recalculateGlobalsv+0x104>)
     d34:	881b      	ldrh	r3, [r3, #0]
     d36:	fbb2 f3f3 	udiv	r3, r2, r3
     d3a:	b29a      	uxth	r2, r3
     d3c:	4b1c      	ldr	r3, [pc, #112]	; (db0 <_Z18recalculateGlobalsv+0x110>)
     d3e:	801a      	strh	r2, [r3, #0]
    g_iPDB_mod              = g_iDAC_trigger_interval * g_iDAC_points;
     d40:	4b1b      	ldr	r3, [pc, #108]	; (db0 <_Z18recalculateGlobalsv+0x110>)
     d42:	881a      	ldrh	r2, [r3, #0]
     d44:	4b17      	ldr	r3, [pc, #92]	; (da4 <_Z18recalculateGlobalsv+0x104>)
     d46:	881b      	ldrh	r3, [r3, #0]
     d48:	fb12 f303 	smulbb	r3, r2, r3
     d4c:	b29a      	uxth	r2, r3
     d4e:	4b19      	ldr	r3, [pc, #100]	; (db4 <_Z18recalculateGlobalsv+0x114>)
     d50:	801a      	strh	r2, [r3, #0]

    if( g_iDrivingDist > g_iElectrodes/2) g_iDrivingDist = g_iElectrodes/2;
     d52:	4b19      	ldr	r3, [pc, #100]	; (db8 <_Z18recalculateGlobalsv+0x118>)
     d54:	681b      	ldr	r3, [r3, #0]
     d56:	085a      	lsrs	r2, r3, #1
     d58:	4b18      	ldr	r3, [pc, #96]	; (dbc <_Z18recalculateGlobalsv+0x11c>)
     d5a:	681b      	ldr	r3, [r3, #0]
     d5c:	429a      	cmp	r2, r3
     d5e:	d204      	bcs.n	d6a <_Z18recalculateGlobalsv+0xca>
     d60:	4b15      	ldr	r3, [pc, #84]	; (db8 <_Z18recalculateGlobalsv+0x118>)
     d62:	681b      	ldr	r3, [r3, #0]
     d64:	085b      	lsrs	r3, r3, #1
     d66:	4a15      	ldr	r2, [pc, #84]	; (dbc <_Z18recalculateGlobalsv+0x11c>)
     d68:	6013      	str	r3, [r2, #0]
}
     d6a:	bf00      	nop
     d6c:	46bd      	mov	sp, r7
     d6e:	f85d 7b04 	ldr.w	r7, [sp], #4
     d72:	4770      	bx	lr
     d74:	1fff0760 	.word	0x1fff0760
     d78:	1fff0750 	.word	0x1fff0750
     d7c:	1fff0acc 	.word	0x1fff0acc
     d80:	1fff0764 	.word	0x1fff0764
     d84:	1fff0ad0 	.word	0x1fff0ad0
     d88:	49742400 	.word	0x49742400
     d8c:	1fff0ad4 	.word	0x1fff0ad4
     d90:	1fff074c 	.word	0x1fff074c
     d94:	1fff0ad8 	.word	0x1fff0ad8
     d98:	1fff0754 	.word	0x1fff0754
     d9c:	1fff0adc 	.word	0x1fff0adc
     da0:	1fff0731 	.word	0x1fff0731
     da4:	1fff0ae0 	.word	0x1fff0ae0
     da8:	1fff075c 	.word	0x1fff075c
     dac:	1fff0ae2 	.word	0x1fff0ae2
     db0:	1fff0ae4 	.word	0x1fff0ae4
     db4:	1fff0ae6 	.word	0x1fff0ae6
     db8:	1fff0738 	.word	0x1fff0738
     dbc:	1fff073c 	.word	0x1fff073c

00000dc0 <_Z13getModeLabelsN5Modes4TypeE>:
edma_transfer_config_t g_sTransferConfig;



char const * getModeLabels(Mode mode)
{
     dc0:	b480      	push	{r7}
     dc2:	b083      	sub	sp, #12
     dc4:	af00      	add	r7, sp, #0
     dc6:	4603      	mov	r3, r0
     dc8:	71fb      	strb	r3, [r7, #7]
    switch(mode)
     dca:	79fb      	ldrb	r3, [r7, #7]
     dcc:	2b05      	cmp	r3, #5
     dce:	d80f      	bhi.n	df0 <_Z13getModeLabelsN5Modes4TypeE+0x30>
     dd0:	a201      	add	r2, pc, #4	; (adr r2, dd8 <_Z13getModeLabelsN5Modes4TypeE+0x18>)
     dd2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     dd6:	bf00      	nop
     dd8:	00000df5 	.word	0x00000df5
     ddc:	00000df9 	.word	0x00000df9
     de0:	00000dfd 	.word	0x00000dfd
     de4:	00000e01 	.word	0x00000e01
     de8:	00000e05 	.word	0x00000e05
     dec:	00000e09 	.word	0x00000e09
    {
        default :
            return "ERROR";
     df0:	4b09      	ldr	r3, [pc, #36]	; (e18 <_Z13getModeLabelsN5Modes4TypeE+0x58>)
     df2:	e00a      	b.n	e0a <_Z13getModeLabelsN5Modes4TypeE+0x4a>
        case Modes::EIT:
            return "EIT";
     df4:	4b09      	ldr	r3, [pc, #36]	; (e1c <_Z13getModeLabelsN5Modes4TypeE+0x5c>)
     df6:	e008      	b.n	e0a <_Z13getModeLabelsN5Modes4TypeE+0x4a>
        case Modes::TestFixedOutput:
            return "Test output with fixed pins";
     df8:	4b09      	ldr	r3, [pc, #36]	; (e20 <_Z13getModeLabelsN5Modes4TypeE+0x60>)
     dfa:	e006      	b.n	e0a <_Z13getModeLabelsN5Modes4TypeE+0x4a>
        case Modes::TestInputs:
            return "Test inputs (EIT)";
     dfc:	4b09      	ldr	r3, [pc, #36]	; (e24 <_Z13getModeLabelsN5Modes4TypeE+0x64>)
     dfe:	e004      	b.n	e0a <_Z13getModeLabelsN5Modes4TypeE+0x4a>
        case Modes::TestElectrodeInputRawValues:
            return "Test electrode inputs (raw)";
     e00:	4b09      	ldr	r3, [pc, #36]	; (e28 <_Z13getModeLabelsN5Modes4TypeE+0x68>)
     e02:	e002      	b.n	e0a <_Z13getModeLabelsN5Modes4TypeE+0x4a>
        case Modes::TestOutputsToInputs:
            return "Test output to input matrix (EIT)";
     e04:	4b09      	ldr	r3, [pc, #36]	; (e2c <_Z13getModeLabelsN5Modes4TypeE+0x6c>)
     e06:	e000      	b.n	e0a <_Z13getModeLabelsN5Modes4TypeE+0x4a>
        case Modes::TestEITRaw:
            return "EIT (raw)";
     e08:	4b09      	ldr	r3, [pc, #36]	; (e30 <_Z13getModeLabelsN5Modes4TypeE+0x70>)
    }
}
     e0a:	4618      	mov	r0, r3
     e0c:	370c      	adds	r7, #12
     e0e:	46bd      	mov	sp, r7
     e10:	f85d 7b04 	ldr.w	r7, [sp], #4
     e14:	4770      	bx	lr
     e16:	bf00      	nop
     e18:	0000eea8 	.word	0x0000eea8
     e1c:	0000eeb0 	.word	0x0000eeb0
     e20:	0000eeb4 	.word	0x0000eeb4
     e24:	0000eed0 	.word	0x0000eed0
     e28:	0000eee4 	.word	0x0000eee4
     e2c:	0000ef00 	.word	0x0000ef00
     e30:	0000ef24 	.word	0x0000ef24

00000e34 <_Z15getDACModeLabelN8DACModes4TypeE>:
    TestEITRaw,                     // Modes::TestEITRaw
};


char const * getDACModeLabel(DACMode mode)
{
     e34:	b480      	push	{r7}
     e36:	b083      	sub	sp, #12
     e38:	af00      	add	r7, sp, #0
     e3a:	4603      	mov	r3, r0
     e3c:	71fb      	strb	r3, [r7, #7]
    switch(mode)
     e3e:	79fb      	ldrb	r3, [r7, #7]
     e40:	2b00      	cmp	r3, #0
     e42:	d003      	beq.n	e4c <_Z15getDACModeLabelN8DACModes4TypeE+0x18>
     e44:	2b01      	cmp	r3, #1
     e46:	d003      	beq.n	e50 <_Z15getDACModeLabelN8DACModes4TypeE+0x1c>
    {
        default :
            return "ERROR";
     e48:	4b05      	ldr	r3, [pc, #20]	; (e60 <_Z15getDACModeLabelN8DACModes4TypeE+0x2c>)
     e4a:	e002      	b.n	e52 <_Z15getDACModeLabelN8DACModes4TypeE+0x1e>
        case DACModes::LowRes:
            return "Low resolution (16 Point)";
     e4c:	4b05      	ldr	r3, [pc, #20]	; (e64 <_Z15getDACModeLabelN8DACModes4TypeE+0x30>)
     e4e:	e000      	b.n	e52 <_Z15getDACModeLabelN8DACModes4TypeE+0x1e>
        case DACModes::HighRes:
            return "High resolution (30 Point)";
     e50:	4b05      	ldr	r3, [pc, #20]	; (e68 <_Z15getDACModeLabelN8DACModes4TypeE+0x34>)
    }
     e52:	4618      	mov	r0, r3
     e54:	370c      	adds	r7, #12
     e56:	46bd      	mov	sp, r7
     e58:	f85d 7b04 	ldr.w	r7, [sp], #4
     e5c:	4770      	bx	lr
     e5e:	bf00      	nop
     e60:	0000eea8 	.word	0x0000eea8
     e64:	0000ef30 	.word	0x0000ef30
     e68:	0000ef4c 	.word	0x0000ef4c

00000e6c <_Z11init_clocksv>:

void init_clocks()
{
     e6c:	b580      	push	{r7, lr}
     e6e:	af00      	add	r7, sp, #0
    SMC_SetPowerModeProtection(SMC, kSMC_AllowPowerModeAll);
     e70:	21aa      	movs	r1, #170	; 0xaa
     e72:	4819      	ldr	r0, [pc, #100]	; (ed8 <_Z11init_clocksv+0x6c>)
     e74:	f7ff fd50 	bl	918 <SMC_SetPowerModeProtection>

    SMC_SetPowerModeHsrun(SMC);
     e78:	4817      	ldr	r0, [pc, #92]	; (ed8 <_Z11init_clocksv+0x6c>)
     e7a:	f007 fc9f 	bl	87bc <SMC_SetPowerModeHsrun>

    CLOCK_SetSimSafeDivs();
     e7e:	f7ff fcd1 	bl	824 <CLOCK_SetSimSafeDivs>

    CLOCK_InitOsc0(&oscConfig);
     e82:	4816      	ldr	r0, [pc, #88]	; (edc <_Z11init_clocksv+0x70>)
     e84:	f007 f810 	bl	7ea8 <CLOCK_InitOsc0>

    CLOCK_SetXtal0Freq(16000000U);
     e88:	4815      	ldr	r0, [pc, #84]	; (ee0 <_Z11init_clocksv+0x74>)
     e8a:	f7ff fcdd 	bl	848 <CLOCK_SetXtal0Freq>
    CLOCK_SetXtal32Freq(32768U);
     e8e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
     e92:	f7ff fce9 	bl	868 <CLOCK_SetXtal32Freq>

    CLOCK_SetMcgConfig(&mcgConfig);
     e96:	4813      	ldr	r0, [pc, #76]	; (ee4 <_Z11init_clocksv+0x78>)
     e98:	f007 fb7c 	bl	8594 <CLOCK_SetMcgConfig>
    
    CLOCK_SetSimConfig(&simConfig);
     e9c:	4812      	ldr	r0, [pc, #72]	; (ee8 <_Z11init_clocksv+0x7c>)
     e9e:	f006 fd3b 	bl	7918 <CLOCK_SetSimConfig>

    CLOCK_EnableUsbfs0Clock(kCLOCK_UsbSrcIrc48M, 48000000);
     ea2:	4912      	ldr	r1, [pc, #72]	; (eec <_Z11init_clocksv+0x80>)
     ea4:	f44f 20e0 	mov.w	r0, #458752	; 0x70000
     ea8:	f006 fd56 	bl	7958 <CLOCK_EnableUsbfs0Clock>

    SystemCoreClock     = CLOCK_GetCoreSysClkFreq();
     eac:	f006 fc7c 	bl	77a8 <CLOCK_GetCoreSysClkFreq>
     eb0:	4603      	mov	r3, r0
     eb2:	4a0f      	ldr	r2, [pc, #60]	; (ef0 <_Z11init_clocksv+0x84>)
     eb4:	6013      	str	r3, [r2, #0]
    SystemPlatformClock = CLOCK_GetPlatClkFreq();
     eb6:	f006 fc4f 	bl	7758 <CLOCK_GetPlatClkFreq>
     eba:	4603      	mov	r3, r0
     ebc:	4a0d      	ldr	r2, [pc, #52]	; (ef4 <_Z11init_clocksv+0x88>)
     ebe:	6013      	str	r3, [r2, #0]
    SystemBusClock      = CLOCK_GetBusClkFreq();
     ec0:	f006 fc5e 	bl	7780 <CLOCK_GetBusClkFreq>
     ec4:	4603      	mov	r3, r0
     ec6:	4a0c      	ldr	r2, [pc, #48]	; (ef8 <_Z11init_clocksv+0x8c>)
     ec8:	6013      	str	r3, [r2, #0]
    SystemUSBClock      = CLOCK_GetPllFllSelClkFreq();
     eca:	f006 fbfd 	bl	76c8 <CLOCK_GetPllFllSelClkFreq>
     ece:	4603      	mov	r3, r0
     ed0:	4a0a      	ldr	r2, [pc, #40]	; (efc <_Z11init_clocksv+0x90>)
     ed2:	6013      	str	r3, [r2, #0]
        printf( "Core Clock Frequency : %ul\n"    , SystemCoreClock     );
        printf( "Platform Clock Frequency : %ul\n", SystemPlatformClock );
        printf( "Bus Clock Frequency : %ul\n"     , SystemBusClock      );
        printf( "USB clock Frequency : %ul\n"     , SystemUSBClock);
    #endif 
}
     ed4:	bf00      	nop
     ed6:	bd80      	pop	{r7, pc}
     ed8:	4007e000 	.word	0x4007e000
     edc:	0000f4dc 	.word	0x0000f4dc
     ee0:	00f42400 	.word	0x00f42400
     ee4:	0000f4c8 	.word	0x0000f4c8
     ee8:	0000f4d4 	.word	0x0000f4d4
     eec:	02dc6c00 	.word	0x02dc6c00
     ef0:	1fff0768 	.word	0x1fff0768
     ef4:	1fff12b8 	.word	0x1fff12b8
     ef8:	1fff12bc 	.word	0x1fff12bc
     efc:	1fff12c0 	.word	0x1fff12c0

00000f00 <_Z9init_edmav>:


static void Edma_Callback(edma_handle_t *handle, void *userData, bool transferDone, uint32_t tcds);
void init_edma()
{
     f00:	b580      	push	{r7, lr}
     f02:	b082      	sub	sp, #8
     f04:	af00      	add	r7, sp, #0
    edma_config_t userConfig;
    EDMA_GetDefaultConfig(&userConfig);
     f06:	1d3b      	adds	r3, r7, #4
     f08:	4618      	mov	r0, r3
     f0a:	f007 ffeb 	bl	8ee4 <EDMA_GetDefaultConfig>
    EDMA_Init(DMA0, &userConfig);
     f0e:	1d3b      	adds	r3, r7, #4
     f10:	4619      	mov	r1, r3
     f12:	480f      	ldr	r0, [pc, #60]	; (f50 <_Z9init_edmav+0x50>)
     f14:	f007 ff94 	bl	8e40 <EDMA_Init>
    EDMA_CreateHandle(&g_hEDMA_Handle, DMA0, ADC_measure_DMA_channel);
     f18:	2200      	movs	r2, #0
     f1a:	490d      	ldr	r1, [pc, #52]	; (f50 <_Z9init_edmav+0x50>)
     f1c:	480d      	ldr	r0, [pc, #52]	; (f54 <_Z9init_edmav+0x54>)
     f1e:	f008 f9f7 	bl	9310 <EDMA_CreateHandle>
    EDMA_SetCallback(&g_hEDMA_Handle, Edma_Callback, NULL);
     f22:	2200      	movs	r2, #0
     f24:	490c      	ldr	r1, [pc, #48]	; (f58 <_Z9init_edmav+0x58>)
     f26:	480b      	ldr	r0, [pc, #44]	; (f54 <_Z9init_edmav+0x54>)
     f28:	f008 fa6e 	bl	9408 <EDMA_SetCallback>

    NVIC_SET_PRIORITY(IRQ_DMA_CH0 + ADC_measure_DMA_channel, 16);
     f2c:	4b0b      	ldr	r3, [pc, #44]	; (f5c <_Z9init_edmav+0x5c>)
     f2e:	2210      	movs	r2, #16
     f30:	701a      	strb	r2, [r3, #0]
    
    EDMA_EnableChannelInterrupts(DMA0, ADC_measure_DMA_channel, kEDMA_MajorInterruptEnable);
     f32:	2202      	movs	r2, #2
     f34:	2100      	movs	r1, #0
     f36:	4806      	ldr	r0, [pc, #24]	; (f50 <_Z9init_edmav+0x50>)
     f38:	f008 f838 	bl	8fac <EDMA_EnableChannelInterrupts>
    EDMA_EnableAsyncRequest(DMA0, ADC_measure_DMA_channel, true);
     f3c:	2201      	movs	r2, #1
     f3e:	2100      	movs	r1, #0
     f40:	4803      	ldr	r0, [pc, #12]	; (f50 <_Z9init_edmav+0x50>)
     f42:	f7ff fd85 	bl	a50 <EDMA_EnableAsyncRequest>
}
     f46:	bf00      	nop
     f48:	3708      	adds	r7, #8
     f4a:	46bd      	mov	sp, r7
     f4c:	bd80      	pop	{r7, pc}
     f4e:	bf00      	nop
     f50:	40008000 	.word	0x40008000
     f54:	1fff12c4 	.word	0x1fff12c4
     f58:	000040e5 	.word	0x000040e5
     f5c:	e000e400 	.word	0xe000e400

00000f60 <_Z11init_dmamuxv>:

void init_dmamux()
{
     f60:	b580      	push	{r7, lr}
     f62:	af00      	add	r7, sp, #0
    DMAMUX_Init(DMAMUX);
     f64:	4806      	ldr	r0, [pc, #24]	; (f80 <_Z11init_dmamuxv+0x20>)
     f66:	f007 febd 	bl	8ce4 <DMAMUX_Init>
    DMAMUX_SetSource(DMAMUX, ADC_measure_DMA_channel, ADC_measure_DMA_source); 
     f6a:	2228      	movs	r2, #40	; 0x28
     f6c:	2100      	movs	r1, #0
     f6e:	4804      	ldr	r0, [pc, #16]	; (f80 <_Z11init_dmamuxv+0x20>)
     f70:	f7ff fd40 	bl	9f4 <DMAMUX_SetSource>
    DMAMUX_EnableChannel(DMAMUX, ADC_measure_DMA_channel);
     f74:	2100      	movs	r1, #0
     f76:	4802      	ldr	r0, [pc, #8]	; (f80 <_Z11init_dmamuxv+0x20>)
     f78:	f7ff fd16 	bl	9a8 <DMAMUX_EnableChannel>
}
     f7c:	bf00      	nop
     f7e:	bd80      	pop	{r7, pc}
     f80:	40021000 	.word	0x40021000

00000f84 <_Z10init_adc16v>:

void init_adc16()
{
     f84:	b580      	push	{r7, lr}
     f86:	b084      	sub	sp, #16
     f88:	af00      	add	r7, sp, #0
    adc16_config_t adcUserConfig;

    adcUserConfig.referenceVoltageSource      = kADC16_ReferenceVoltageSourceVref;  /* VRref In */
     f8a:	2300      	movs	r3, #0
     f8c:	713b      	strb	r3, [r7, #4]
    adcUserConfig.clockSource                 = kADC16_ClockSourceAlt1;              /* Bus Clock / 2 */
     f8e:	2301      	movs	r3, #1
     f90:	717b      	strb	r3, [r7, #5]
    adcUserConfig.enableAsynchronousClock     = false;                               /* ASync clock is not used */
     f92:	2300      	movs	r3, #0
     f94:	71bb      	strb	r3, [r7, #6]
    adcUserConfig.clockDivider                = kADC16_ClockDivider4;                /* Bus Clock (90) / 2 / 4 = 11.25MHz  (Must be between 2 and 12) */
     f96:	2302      	movs	r3, #2
     f98:	71fb      	strb	r3, [r7, #7]
    adcUserConfig.resolution                  = kADC16_Resolution16Bit;              /* 16 bit ADC readings */
     f9a:	2303      	movs	r3, #3
     f9c:	723b      	strb	r3, [r7, #8]
    adcUserConfig.longSampleMode              = kADC16_LongSampleCycle24;           /*  */
     f9e:	2300      	movs	r3, #0
     fa0:	727b      	strb	r3, [r7, #9]
    adcUserConfig.enableHighSpeed             = false;                                /* Regular mode */
     fa2:	2300      	movs	r3, #0
     fa4:	72bb      	strb	r3, [r7, #10]
    adcUserConfig.enableLowPower              = false;                               /* Regular Power */
     fa6:	2300      	movs	r3, #0
     fa8:	72fb      	strb	r3, [r7, #11]
    adcUserConfig.enableContinuousConversion  = true;                                /* Single conversions */
     faa:	2301      	movs	r3, #1
     fac:	733b      	strb	r3, [r7, #12]
    adcUserConfig.hardwareAverageMode         = kADC16_HardwareAverageDisabled;      /* Disable averaging */
     fae:	2304      	movs	r3, #4
     fb0:	737b      	strb	r3, [r7, #13]

    //ADC16_GetDefaultConfig(&adcUserConfig);

    PORT_SetPinMux(PORTC, 2U, kPORT_PinDisabledOrAnalog); 
     fb2:	2200      	movs	r2, #0
     fb4:	2102      	movs	r1, #2
     fb6:	480f      	ldr	r0, [pc, #60]	; (ff4 <_Z10init_adc16v+0x70>)
     fb8:	f7ff fc91 	bl	8de <PORT_SetPinMux>
    
    ADC16_Init(ADC_measure_base, &adcUserConfig);
     fbc:	1d3b      	adds	r3, r7, #4
     fbe:	4619      	mov	r1, r3
     fc0:	480d      	ldr	r0, [pc, #52]	; (ff8 <_Z10init_adc16v+0x74>)
     fc2:	f007 fc5b 	bl	887c <ADC16_Init>
    //ADC16_SetHardwareAverage(ADC_measure_base, kADC16_HardwareAverageCount32);
    ADC16_DoAutoCalibration(ADC_measure_base);
     fc6:	480c      	ldr	r0, [pc, #48]	; (ff8 <_Z10init_adc16v+0x74>)
     fc8:	f007 fcec 	bl	89a4 <ADC16_DoAutoCalibration>
    //ADC16_SetHardwareAverage(ADC_measure_base, adcUserConfig.hardwareAverageMode);
    ADC16_SetChannelMuxMode(ADC_measure_base, ADC_measure_mux);
     fcc:	2101      	movs	r1, #1
     fce:	480a      	ldr	r0, [pc, #40]	; (ff8 <_Z10init_adc16v+0x74>)
     fd0:	f007 fd80 	bl	8ad4 <ADC16_SetChannelMuxMode>
    
    ADC16_EnableHardwareTrigger(ADC_measure_base, false);
     fd4:	2100      	movs	r1, #0
     fd6:	4808      	ldr	r0, [pc, #32]	; (ff8 <_Z10init_adc16v+0x74>)
     fd8:	f7ff fcc9 	bl	96e <ADC16_EnableHardwareTrigger>

    __NVIC_SetPriority(ADC0_IRQn, 16); // 0 is highest
     fdc:	2110      	movs	r1, #16
     fde:	2027      	movs	r0, #39	; 0x27
     fe0:	f7ff fbc2 	bl	768 <__NVIC_SetPriority>

    EnableIRQ(ADC0_IRQn);
     fe4:	2027      	movs	r0, #39	; 0x27
     fe6:	f7ff fbe9 	bl	7bc <EnableIRQ>
}
     fea:	bf00      	nop
     fec:	3710      	adds	r7, #16
     fee:	46bd      	mov	sp, r7
     ff0:	bd80      	pop	{r7, pc}
     ff2:	bf00      	nop
     ff4:	4004b000 	.word	0x4004b000
     ff8:	4003b000 	.word	0x4003b000

00000ffc <_Z8init_pdbv>:

void init_pdb()
{
     ffc:	b580      	push	{r7, lr}
     ffe:	b084      	sub	sp, #16
    1000:	af00      	add	r7, sp, #0
    pdb_config_t pdbConfigStruct;
    // PDB Clock is Peripheral Clock.
    pdbConfigStruct.loadValueMode = kPDB_LoadValueImmediately;
    1002:	2300      	movs	r3, #0
    1004:	723b      	strb	r3, [r7, #8]
    pdbConfigStruct.prescalerDivider = kPDB_PrescalerDivider1;
    1006:	2300      	movs	r3, #0
    1008:	727b      	strb	r3, [r7, #9]
    pdbConfigStruct.dividerMultiplicationFactor = kPDB_DividerMultiplicationFactor1;
    100a:	2300      	movs	r3, #0
    100c:	72bb      	strb	r3, [r7, #10]
    pdbConfigStruct.triggerInputSource = kPDB_TriggerSoftware;
    100e:	230f      	movs	r3, #15
    1010:	72fb      	strb	r3, [r7, #11]
    pdbConfigStruct.enableContinuousMode = true;
    1012:	2301      	movs	r3, #1
    1014:	733b      	strb	r3, [r7, #12]
    
    PDB_Init(PDB_base, &pdbConfigStruct);
    1016:	f107 0308 	add.w	r3, r7, #8
    101a:	4619      	mov	r1, r3
    101c:	4812      	ldr	r0, [pc, #72]	; (1068 <_Z8init_pdbv+0x6c>)
    101e:	f008 fd4f 	bl	9ac0 <PDB_Init>
    //PDB_EnableInterrupts(PDB_base, kPDB_DelayInterruptEnable);
    PDB_SetModulusValue(PDB_base, g_iPDB_mod);
    1022:	4b12      	ldr	r3, [pc, #72]	; (106c <_Z8init_pdbv+0x70>)
    1024:	881b      	ldrh	r3, [r3, #0]
    1026:	4619      	mov	r1, r3
    1028:	480f      	ldr	r0, [pc, #60]	; (1068 <_Z8init_pdbv+0x6c>)
    102a:	f7ff fd65 	bl	af8 <PDB_SetModulusValue>
    PDB_SetCounterDelayValue(PDB_base, 0);
    102e:	2100      	movs	r1, #0
    1030:	480d      	ldr	r0, [pc, #52]	; (1068 <_Z8init_pdbv+0x6c>)
    1032:	f7ff fd70 	bl	b16 <PDB_SetCounterDelayValue>

    /* Set DAC trigger. */
    pdb_dac_trigger_config_t pdbDacTriggerConfigStruct;
    pdbDacTriggerConfigStruct.enableExternalTriggerInput = false;
    1036:	2300      	movs	r3, #0
    1038:	713b      	strb	r3, [r7, #4]
    pdbDacTriggerConfigStruct.enableIntervalTrigger      = true;
    103a:	2301      	movs	r3, #1
    103c:	717b      	strb	r3, [r7, #5]
    PDB_SetDACTriggerConfig(PDB_base, kPDB_DACTriggerChannel0, &pdbDacTriggerConfigStruct);
    103e:	1d3b      	adds	r3, r7, #4
    1040:	461a      	mov	r2, r3
    1042:	2100      	movs	r1, #0
    1044:	4808      	ldr	r0, [pc, #32]	; (1068 <_Z8init_pdbv+0x6c>)
    1046:	f008 fd8d 	bl	9b64 <PDB_SetDACTriggerConfig>
    PDB_SetDACTriggerIntervalValue(PDB_base, kPDB_DACTriggerChannel0, g_iDAC_trigger_interval);
    104a:	4b09      	ldr	r3, [pc, #36]	; (1070 <_Z8init_pdbv+0x74>)
    104c:	881b      	ldrh	r3, [r3, #0]
    104e:	461a      	mov	r2, r3
    1050:	2100      	movs	r1, #0
    1052:	4805      	ldr	r0, [pc, #20]	; (1068 <_Z8init_pdbv+0x6c>)
    1054:	f7ff fd6e 	bl	b34 <PDB_SetDACTriggerIntervalValue>
    //pdbAdcPreTriggerConfigStruct.enableBackToBackOperationMask = 0U;
    //PDB_SetADCPreTriggerConfig(PDB_base, kPDB_ADCTriggerChannel0, &pdbAdcPreTriggerConfigStruct);
    //PDB_SetADCPreTriggerDelayValue(PDB_base, kPDB_ADCTriggerChannel0, kPDB_ADCPreTrigger0, g_iDAC_trigger_interval * 1.5 );

    /* Load PDB values. */
    PDB_DoLoadValues(PDB_base);
    1058:	4803      	ldr	r0, [pc, #12]	; (1068 <_Z8init_pdbv+0x6c>)
    105a:	f7ff fd3d 	bl	ad8 <PDB_DoLoadValues>

    //EnableIRQ(PDB0_IRQn);
}
    105e:	bf00      	nop
    1060:	3710      	adds	r7, #16
    1062:	46bd      	mov	sp, r7
    1064:	bd80      	pop	{r7, pc}
    1066:	bf00      	nop
    1068:	40036000 	.word	0x40036000
    106c:	1fff0ae6 	.word	0x1fff0ae6
    1070:	1fff0ae4 	.word	0x1fff0ae4

00001074 <_Z8init_dacv>:

void init_dac()
{
    1074:	b580      	push	{r7, lr}
    1076:	b086      	sub	sp, #24
    1078:	af00      	add	r7, sp, #0
    uint const length = DACModes::HighRes ? lenof(g_dacValuesHighRes) : lenof(g_dacValuesLowRes);
    107a:	2310      	movs	r3, #16
    107c:	613b      	str	r3, [r7, #16]
    uint16_t const * const dacValues = g_eDACMode == DACModes::HighRes ? g_dacValuesHighRes : g_dacValuesLowRes;
    107e:	4b2b      	ldr	r3, [pc, #172]	; (112c <_Z8init_dacv+0xb8>)
    1080:	781b      	ldrb	r3, [r3, #0]
    1082:	2b01      	cmp	r3, #1
    1084:	d101      	bne.n	108a <_Z8init_dacv+0x16>
    1086:	4b2a      	ldr	r3, [pc, #168]	; (1130 <_Z8init_dacv+0xbc>)
    1088:	e000      	b.n	108c <_Z8init_dacv+0x18>
    108a:	4b2a      	ldr	r3, [pc, #168]	; (1134 <_Z8init_dacv+0xc0>)
    108c:	60fb      	str	r3, [r7, #12]

    /* Configure the DAC. */
    
    dac_config_t dacConfigStruct;
    DAC_GetDefaultConfig(&dacConfigStruct);
    108e:	f107 0308 	add.w	r3, r7, #8
    1092:	4618      	mov	r0, r3
    1094:	f008 fe2a 	bl	9cec <DAC_GetDefaultConfig>
    dacConfigStruct.referenceVoltageSource = kDAC_ReferenceVoltageSourceVref2;
    1098:	2301      	movs	r3, #1
    109a:	723b      	strb	r3, [r7, #8]
    dacConfigStruct.enableLowPowerMode     = false;
    109c:	2300      	movs	r3, #0
    109e:	727b      	strb	r3, [r7, #9]

    dac_buffer_config_t dacBufferConfigStruct;
    DAC_GetDefaultBufferConfig(&dacBufferConfigStruct);
    10a0:	1d3b      	adds	r3, r7, #4
    10a2:	4618      	mov	r0, r3
    10a4:	f008 fea2 	bl	9dec <DAC_GetDefaultBufferConfig>
    dacBufferConfigStruct.triggerMode = kDAC_BufferTriggerByHardwareMode;
    10a8:	2300      	movs	r3, #0
    10aa:	713b      	strb	r3, [r7, #4]
    dacBufferConfigStruct.workMode    = g_eDACMode == DACModes::HighRes ? kDAC_BufferWorkAsSwingMode : kDAC_BufferWorkAsNormalMode;
    10ac:	4b1f      	ldr	r3, [pc, #124]	; (112c <_Z8init_dacv+0xb8>)
    10ae:	781b      	ldrb	r3, [r3, #0]
    10b0:	2b01      	cmp	r3, #1
    10b2:	d101      	bne.n	10b8 <_Z8init_dacv+0x44>
    10b4:	2301      	movs	r3, #1
    10b6:	e000      	b.n	10ba <_Z8init_dacv+0x46>
    10b8:	2300      	movs	r3, #0
    10ba:	71bb      	strb	r3, [r7, #6]
    // dacBufferConfigStruct.watermark   = g_eDACMode == kDAC_BufferWatermark1Word;
    dacBufferConfigStruct.upperLimit  = length -1;
    10bc:	230f      	movs	r3, #15
    10be:	71fb      	strb	r3, [r7, #7]

    //Serial.print("\r\nDAC values : ");Serial.print(length);Serial.print("\r\n");
    
    DAC_Init(DAC_base, &dacConfigStruct);
    10c0:	f107 0308 	add.w	r3, r7, #8
    10c4:	4619      	mov	r1, r3
    10c6:	481c      	ldr	r0, [pc, #112]	; (1138 <_Z8init_dacv+0xc4>)
    10c8:	f008 fdd0 	bl	9c6c <DAC_Init>
    DAC_SetBufferConfig(DAC_base, &dacBufferConfigStruct);
    10cc:	1d3b      	adds	r3, r7, #4
    10ce:	4619      	mov	r1, r3
    10d0:	4819      	ldr	r0, [pc, #100]	; (1138 <_Z8init_dacv+0xc4>)
    10d2:	f008 fe2d 	bl	9d30 <DAC_SetBufferConfig>
    DAC_SetBufferReadPointer(DAC_base, 0U); /* Make sure the read pointer to the start. */
    10d6:	2100      	movs	r1, #0
    10d8:	4817      	ldr	r0, [pc, #92]	; (1138 <_Z8init_dacv+0xc4>)
    10da:	f008 fedd 	bl	9e98 <DAC_SetBufferReadPointer>
    for (uint i = 0U; i < length; ++i)
    10de:	2300      	movs	r3, #0
    10e0:	617b      	str	r3, [r7, #20]
    10e2:	e00d      	b.n	1100 <_Z8init_dacv+0x8c>
    {
        //Serial.print("\t");Serial.print(i);Serial.print(": ");Serial.print(dacValues[i]);Serial.print("\r\n");
        DAC_SetBufferValue(DAC_base, i, dacValues[i]);
    10e4:	697b      	ldr	r3, [r7, #20]
    10e6:	b2d9      	uxtb	r1, r3
    10e8:	697b      	ldr	r3, [r7, #20]
    10ea:	005b      	lsls	r3, r3, #1
    10ec:	68fa      	ldr	r2, [r7, #12]
    10ee:	4413      	add	r3, r2
    10f0:	881b      	ldrh	r3, [r3, #0]
    10f2:	461a      	mov	r2, r3
    10f4:	4810      	ldr	r0, [pc, #64]	; (1138 <_Z8init_dacv+0xc4>)
    10f6:	f008 fea1 	bl	9e3c <DAC_SetBufferValue>
    for (uint i = 0U; i < length; ++i)
    10fa:	697b      	ldr	r3, [r7, #20]
    10fc:	3301      	adds	r3, #1
    10fe:	617b      	str	r3, [r7, #20]
    1100:	697b      	ldr	r3, [r7, #20]
    1102:	2b0f      	cmp	r3, #15
    1104:	d9ee      	bls.n	10e4 <_Z8init_dacv+0x70>
    }
    DAC_EnableBuffer(DAC_base, true);
    1106:	2101      	movs	r1, #1
    1108:	480b      	ldr	r0, [pc, #44]	; (1138 <_Z8init_dacv+0xc4>)
    110a:	f7ff fd5b 	bl	bc4 <DAC_EnableBuffer>
    //DAC_EnableBufferInterrupts(DAC_base, kDAC_BufferWatermarkInterruptEnable);
    
    DAC_Enable(DAC_base, true);             /* Enable output. */
    110e:	2101      	movs	r1, #1
    1110:	4809      	ldr	r0, [pc, #36]	; (1138 <_Z8init_dacv+0xc4>)
    1112:	f7ff fd33 	bl	b7c <DAC_Enable>
    
    __NVIC_SetPriority(DAC0_IRQn, 16); // 0 is highest
    1116:	2110      	movs	r1, #16
    1118:	2038      	movs	r0, #56	; 0x38
    111a:	f7ff fb25 	bl	768 <__NVIC_SetPriority>

    EnableIRQ(DAC0_IRQn);
    111e:	2038      	movs	r0, #56	; 0x38
    1120:	f7ff fb4c 	bl	7bc <EnableIRQ>
}
    1124:	bf00      	nop
    1126:	3718      	adds	r7, #24
    1128:	46bd      	mov	sp, r7
    112a:	bd80      	pop	{r7, pc}
    112c:	1fff0731 	.word	0x1fff0731
    1130:	0000f510 	.word	0x0000f510
    1134:	0000f4f0 	.word	0x0000f4f0
    1138:	400cc000 	.word	0x400cc000

0000113c <_Z19eit_iq_demodulationPKmhhb>:
void adc_collect_samples(uint32_t * sample_array, uint8_t samples);


// eit_iq_demodulation ( const_cast<&g_aiSamples[g_iSample_rubbish]>, g_iSamples_useful, g_iSamples_per_cycle);
float eit_iq_demodulation(uint32_t const * sample_array, uint8_t length, uint8_t samples_per_period, bool print_info = false)
{
    113c:	b5b0      	push	{r4, r5, r7, lr}
    113e:	b08e      	sub	sp, #56	; 0x38
    1140:	af00      	add	r7, sp, #0
    1142:	6078      	str	r0, [r7, #4]
    1144:	4608      	mov	r0, r1
    1146:	4611      	mov	r1, r2
    1148:	461a      	mov	r2, r3
    114a:	4603      	mov	r3, r0
    114c:	70fb      	strb	r3, [r7, #3]
    114e:	460b      	mov	r3, r1
    1150:	70bb      	strb	r3, [r7, #2]
    1152:	4613      	mov	r3, r2
    1154:	707b      	strb	r3, [r7, #1]
    float s_cum=0;
    1156:	f04f 0300 	mov.w	r3, #0
    115a:	637b      	str	r3, [r7, #52]	; 0x34
    float i_cum=0;
    115c:	f04f 0300 	mov.w	r3, #0
    1160:	633b      	str	r3, [r7, #48]	; 0x30
    float q_cum=0;
    1162:	f04f 0300 	mov.w	r3, #0
    1166:	62fb      	str	r3, [r7, #44]	; 0x2c

    for ( unsigned int i = 0; 
    1168:	2300      	movs	r3, #0
    116a:	62bb      	str	r3, [r7, #40]	; 0x28
    116c:	e04b      	b.n	1206 <_Z19eit_iq_demodulationPKmhhb+0xca>
          i < length;
          ++i)
    {
        float sample = sample_array[i] * ( 3.33f / 65536 ) ; // Covert ADC to Volts
    116e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1170:	009b      	lsls	r3, r3, #2
    1172:	687a      	ldr	r2, [r7, #4]
    1174:	4413      	add	r3, r2
    1176:	681b      	ldr	r3, [r3, #0]
    1178:	ee07 3a90 	vmov	s15, r3
    117c:	eef8 7a67 	vcvt.f32.u32	s15, s15
    1180:	ed9f 7a7b 	vldr	s14, [pc, #492]	; 1370 <_Z19eit_iq_demodulationPKmhhb+0x234>
    1184:	ee67 7a87 	vmul.f32	s15, s15, s14
    1188:	edc7 7a04 	vstr	s15, [r7, #16]
        float omegat = PI * 2.0f * ( i / ( (float) samples_per_period) );
    118c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    118e:	ee07 3a90 	vmov	s15, r3
    1192:	eef8 6a67 	vcvt.f32.u32	s13, s15
    1196:	78bb      	ldrb	r3, [r7, #2]
    1198:	ee07 3a90 	vmov	s15, r3
    119c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
    11a0:	eec6 7a87 	vdiv.f32	s15, s13, s14
    11a4:	ed9f 7a73 	vldr	s14, [pc, #460]	; 1374 <_Z19eit_iq_demodulationPKmhhb+0x238>
    11a8:	ee67 7a87 	vmul.f32	s15, s15, s14
    11ac:	edc7 7a03 	vstr	s15, [r7, #12]
        s_cum += sample;
    11b0:	ed97 7a0d 	vldr	s14, [r7, #52]	; 0x34
    11b4:	edd7 7a04 	vldr	s15, [r7, #16]
    11b8:	ee77 7a27 	vadd.f32	s15, s14, s15
    11bc:	edc7 7a0d 	vstr	s15, [r7, #52]	; 0x34
        i_cum += sample * cos( omegat ); // Could put known systematic phase offset in here
    11c0:	ed97 0a03 	vldr	s0, [r7, #12]
    11c4:	f7ff f958 	bl	478 <_ZSt3cosf>
    11c8:	eeb0 7a40 	vmov.f32	s14, s0
    11cc:	edd7 7a04 	vldr	s15, [r7, #16]
    11d0:	ee67 7a27 	vmul.f32	s15, s14, s15
    11d4:	ed97 7a0c 	vldr	s14, [r7, #48]	; 0x30
    11d8:	ee77 7a27 	vadd.f32	s15, s14, s15
    11dc:	edc7 7a0c 	vstr	s15, [r7, #48]	; 0x30
        q_cum += sample * sin( omegat ); // Could put known systematic phase offset in here
    11e0:	ed97 0a03 	vldr	s0, [r7, #12]
    11e4:	f7ff f958 	bl	498 <_ZSt3sinf>
    11e8:	eeb0 7a40 	vmov.f32	s14, s0
    11ec:	edd7 7a04 	vldr	s15, [r7, #16]
    11f0:	ee67 7a27 	vmul.f32	s15, s14, s15
    11f4:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
    11f8:	ee77 7a27 	vadd.f32	s15, s14, s15
    11fc:	edc7 7a0b 	vstr	s15, [r7, #44]	; 0x2c
    for ( unsigned int i = 0; 
    1200:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1202:	3301      	adds	r3, #1
    1204:	62bb      	str	r3, [r7, #40]	; 0x28
          i < length;
    1206:	78fb      	ldrb	r3, [r7, #3]
    1208:	6aba      	ldr	r2, [r7, #40]	; 0x28
    120a:	429a      	cmp	r2, r3
    120c:	d3af      	bcc.n	116e <_Z19eit_iq_demodulationPKmhhb+0x32>
    }

    // Cheap ass FIR filter, (Where Ftarget is a factor of Fsampling)
    float s_mean = ( s_cum / length ) ;
    120e:	78fb      	ldrb	r3, [r7, #3]
    1210:	ee07 3a90 	vmov	s15, r3
    1214:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    1218:	edd7 6a0d 	vldr	s13, [r7, #52]	; 0x34
    121c:	eec6 7a87 	vdiv.f32	s15, s13, s14
    1220:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
    float i_mean = ( i_cum / length ) ;
    1224:	78fb      	ldrb	r3, [r7, #3]
    1226:	ee07 3a90 	vmov	s15, r3
    122a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    122e:	edd7 6a0c 	vldr	s13, [r7, #48]	; 0x30
    1232:	eec6 7a87 	vdiv.f32	s15, s13, s14
    1236:	edc7 7a08 	vstr	s15, [r7, #32]
    float q_mean = ( q_cum / length ) ;
    123a:	78fb      	ldrb	r3, [r7, #3]
    123c:	ee07 3a90 	vmov	s15, r3
    1240:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    1244:	edd7 6a0b 	vldr	s13, [r7, #44]	; 0x2c
    1248:	eec6 7a87 	vdiv.f32	s15, s13, s14
    124c:	edc7 7a07 	vstr	s15, [r7, #28]
 
    float magnitude = 2 * sqrt(pow(i_mean,2) + pow(q_mean,2));
    1250:	2002      	movs	r0, #2
    1252:	ed97 0a08 	vldr	s0, [r7, #32]
    1256:	f003 f82b 	bl	42b0 <_ZSt3powIfiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_XsrSt12__is_integerIS2_E7__valueEE6__typeENS4_IS3_XsrS5_IS3_E7__valueEE6__typeEE6__typeES2_S3_>
    125a:	ec55 4b10 	vmov	r4, r5, d0
    125e:	2002      	movs	r0, #2
    1260:	ed97 0a07 	vldr	s0, [r7, #28]
    1264:	f003 f824 	bl	42b0 <_ZSt3powIfiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_XsrSt12__is_integerIS2_E7__valueEE6__typeENS4_IS3_XsrS5_IS3_E7__valueEE6__typeEE6__typeES2_S3_>
    1268:	ec53 2b10 	vmov	r2, r3, d0
    126c:	4620      	mov	r0, r4
    126e:	4629      	mov	r1, r5
    1270:	f00c fa12 	bl	d698 <__adddf3>
    1274:	4602      	mov	r2, r0
    1276:	460b      	mov	r3, r1
    1278:	ec43 2b17 	vmov	d7, r2, r3
    127c:	eeb0 0a47 	vmov.f32	s0, s14
    1280:	eef0 0a67 	vmov.f32	s1, s15
    1284:	f00a fc98 	bl	bbb8 <sqrt>
    1288:	ec51 0b10 	vmov	r0, r1, d0
    128c:	4602      	mov	r2, r0
    128e:	460b      	mov	r3, r1
    1290:	f00c fa02 	bl	d698 <__adddf3>
    1294:	4602      	mov	r2, r0
    1296:	460b      	mov	r3, r1
    1298:	4610      	mov	r0, r2
    129a:	4619      	mov	r1, r3
    129c:	f00c fe82 	bl	dfa4 <__aeabi_d2f>
    12a0:	4603      	mov	r3, r0
    12a2:	61bb      	str	r3, [r7, #24]
    float phase = atan(q_mean/i_mean);
    12a4:	ed97 7a07 	vldr	s14, [r7, #28]
    12a8:	edd7 7a08 	vldr	s15, [r7, #32]
    12ac:	eec7 6a27 	vdiv.f32	s13, s14, s15
    12b0:	eeb0 0a66 	vmov.f32	s0, s13
    12b4:	f7ff f8d0 	bl	458 <_ZSt4atanf>
    12b8:	ed87 0a05 	vstr	s0, [r7, #20]

    if ( print_info )
    12bc:	787b      	ldrb	r3, [r7, #1]
    12be:	2b00      	cmp	r3, #0
    12c0:	d04e      	beq.n	1360 <_Z19eit_iq_demodulationPKmhhb+0x224>
    {
        Serial.print("\r\n s_mean : ");     Serial.print(s_mean,4);
    12c2:	492d      	ldr	r1, [pc, #180]	; (1378 <_Z19eit_iq_demodulationPKmhhb+0x23c>)
    12c4:	482d      	ldr	r0, [pc, #180]	; (137c <_Z19eit_iq_demodulationPKmhhb+0x240>)
    12c6:	f7ff f97b 	bl	5c0 <_ZN5Print5printEPKc>
    12ca:	6a78      	ldr	r0, [r7, #36]	; 0x24
    12cc:	f00c fb42 	bl	d954 <__aeabi_f2d>
    12d0:	4602      	mov	r2, r0
    12d2:	460b      	mov	r3, r1
    12d4:	2104      	movs	r1, #4
    12d6:	ec43 2b10 	vmov	d0, r2, r3
    12da:	4828      	ldr	r0, [pc, #160]	; (137c <_Z19eit_iq_demodulationPKmhhb+0x240>)
    12dc:	f7ff f9ac 	bl	638 <_ZN5Print5printEdi>
        Serial.print(", i_mean : ");    Serial.print(i_mean,4);
    12e0:	4927      	ldr	r1, [pc, #156]	; (1380 <_Z19eit_iq_demodulationPKmhhb+0x244>)
    12e2:	4826      	ldr	r0, [pc, #152]	; (137c <_Z19eit_iq_demodulationPKmhhb+0x240>)
    12e4:	f7ff f96c 	bl	5c0 <_ZN5Print5printEPKc>
    12e8:	6a38      	ldr	r0, [r7, #32]
    12ea:	f00c fb33 	bl	d954 <__aeabi_f2d>
    12ee:	4602      	mov	r2, r0
    12f0:	460b      	mov	r3, r1
    12f2:	2104      	movs	r1, #4
    12f4:	ec43 2b10 	vmov	d0, r2, r3
    12f8:	4820      	ldr	r0, [pc, #128]	; (137c <_Z19eit_iq_demodulationPKmhhb+0x240>)
    12fa:	f7ff f99d 	bl	638 <_ZN5Print5printEdi>
        Serial.print(", q_mean : ");    Serial.print(q_mean,4);
    12fe:	4921      	ldr	r1, [pc, #132]	; (1384 <_Z19eit_iq_demodulationPKmhhb+0x248>)
    1300:	481e      	ldr	r0, [pc, #120]	; (137c <_Z19eit_iq_demodulationPKmhhb+0x240>)
    1302:	f7ff f95d 	bl	5c0 <_ZN5Print5printEPKc>
    1306:	69f8      	ldr	r0, [r7, #28]
    1308:	f00c fb24 	bl	d954 <__aeabi_f2d>
    130c:	4602      	mov	r2, r0
    130e:	460b      	mov	r3, r1
    1310:	2104      	movs	r1, #4
    1312:	ec43 2b10 	vmov	d0, r2, r3
    1316:	4819      	ldr	r0, [pc, #100]	; (137c <_Z19eit_iq_demodulationPKmhhb+0x240>)
    1318:	f7ff f98e 	bl	638 <_ZN5Print5printEdi>
        Serial.print(", magnitude : "); Serial.print(magnitude,4);
    131c:	491a      	ldr	r1, [pc, #104]	; (1388 <_Z19eit_iq_demodulationPKmhhb+0x24c>)
    131e:	4817      	ldr	r0, [pc, #92]	; (137c <_Z19eit_iq_demodulationPKmhhb+0x240>)
    1320:	f7ff f94e 	bl	5c0 <_ZN5Print5printEPKc>
    1324:	69b8      	ldr	r0, [r7, #24]
    1326:	f00c fb15 	bl	d954 <__aeabi_f2d>
    132a:	4602      	mov	r2, r0
    132c:	460b      	mov	r3, r1
    132e:	2104      	movs	r1, #4
    1330:	ec43 2b10 	vmov	d0, r2, r3
    1334:	4811      	ldr	r0, [pc, #68]	; (137c <_Z19eit_iq_demodulationPKmhhb+0x240>)
    1336:	f7ff f97f 	bl	638 <_ZN5Print5printEdi>
        Serial.print(", phase : ");     Serial.print(phase,4);
    133a:	4914      	ldr	r1, [pc, #80]	; (138c <_Z19eit_iq_demodulationPKmhhb+0x250>)
    133c:	480f      	ldr	r0, [pc, #60]	; (137c <_Z19eit_iq_demodulationPKmhhb+0x240>)
    133e:	f7ff f93f 	bl	5c0 <_ZN5Print5printEPKc>
    1342:	6978      	ldr	r0, [r7, #20]
    1344:	f00c fb06 	bl	d954 <__aeabi_f2d>
    1348:	4602      	mov	r2, r0
    134a:	460b      	mov	r3, r1
    134c:	2104      	movs	r1, #4
    134e:	ec43 2b10 	vmov	d0, r2, r3
    1352:	480a      	ldr	r0, [pc, #40]	; (137c <_Z19eit_iq_demodulationPKmhhb+0x240>)
    1354:	f7ff f970 	bl	638 <_ZN5Print5printEdi>
        Serial.print("\r\n");
    1358:	490d      	ldr	r1, [pc, #52]	; (1390 <_Z19eit_iq_demodulationPKmhhb+0x254>)
    135a:	4808      	ldr	r0, [pc, #32]	; (137c <_Z19eit_iq_demodulationPKmhhb+0x240>)
    135c:	f7ff f930 	bl	5c0 <_ZN5Print5printEPKc>
    }

    return magnitude;
    1360:	69bb      	ldr	r3, [r7, #24]
    1362:	ee07 3a90 	vmov	s15, r3
}
    1366:	eeb0 0a67 	vmov.f32	s0, s15
    136a:	3738      	adds	r7, #56	; 0x38
    136c:	46bd      	mov	sp, r7
    136e:	bdb0      	pop	{r4, r5, r7, pc}
    1370:	38551eb8 	.word	0x38551eb8
    1374:	40c90fdb 	.word	0x40c90fdb
    1378:	0000ef68 	.word	0x0000ef68
    137c:	1fff078c 	.word	0x1fff078c
    1380:	0000ef78 	.word	0x0000ef78
    1384:	0000ef84 	.word	0x0000ef84
    1388:	0000ef90 	.word	0x0000ef90
    138c:	0000efa0 	.word	0x0000efa0
    1390:	0000efac 	.word	0x0000efac

00001394 <_Z18transformElectrodej>:
//  [1  2   3   ..... 16 ]
// When bMapElectrodesToLines is FALSE:
//  [2  4   6   ..... 32 ]
//  [1  3   5   ..... 31 ]
unsigned int transformElectrode(unsigned int electrode) 
{
    1394:	b480      	push	{r7}
    1396:	b085      	sub	sp, #20
    1398:	af00      	add	r7, sp, #0
    139a:	6078      	str	r0, [r7, #4]
    if (!g_bMapElectrodesToLines) return electrode;
    139c:	4b0e      	ldr	r3, [pc, #56]	; (13d8 <_Z18transformElectrodej+0x44>)
    139e:	781b      	ldrb	r3, [r3, #0]
    13a0:	f083 0301 	eor.w	r3, r3, #1
    13a4:	b2db      	uxtb	r3, r3
    13a6:	2b00      	cmp	r3, #0
    13a8:	d001      	beq.n	13ae <_Z18transformElectrodej+0x1a>
    13aa:	687b      	ldr	r3, [r7, #4]
    13ac:	e00d      	b.n	13ca <_Z18transformElectrodej+0x36>
    unsigned int transformed = (0xF & electrode) * 2;
    13ae:	687b      	ldr	r3, [r7, #4]
    13b0:	f003 030f 	and.w	r3, r3, #15
    13b4:	005b      	lsls	r3, r3, #1
    13b6:	60fb      	str	r3, [r7, #12]
    if ( electrode & 0x10 ) return transformed + 1;
    13b8:	687b      	ldr	r3, [r7, #4]
    13ba:	f003 0310 	and.w	r3, r3, #16
    13be:	2b00      	cmp	r3, #0
    13c0:	d002      	beq.n	13c8 <_Z18transformElectrodej+0x34>
    13c2:	68fb      	ldr	r3, [r7, #12]
    13c4:	3301      	adds	r3, #1
    13c6:	e000      	b.n	13ca <_Z18transformElectrodej+0x36>
    return transformed;
    13c8:	68fb      	ldr	r3, [r7, #12]
}
    13ca:	4618      	mov	r0, r3
    13cc:	3714      	adds	r7, #20
    13ce:	46bd      	mov	sp, r7
    13d0:	f85d 7b04 	ldr.w	r7, [sp], #4
    13d4:	4770      	bx	lr
    13d6:	bf00      	nop
    13d8:	1fff0758 	.word	0x1fff0758

000013dc <_Z17collect_eit_framev>:

void collect_eit_frame()
{
    13dc:	b580      	push	{r7, lr}
    13de:	b086      	sub	sp, #24
    13e0:	af00      	add	r7, sp, #0
    unsigned int result_counter = 0;
    13e2:	2300      	movs	r3, #0
    13e4:	617b      	str	r3, [r7, #20]
    Serial.print("\r\nmagnitudes: ");
    13e6:	497b      	ldr	r1, [pc, #492]	; (15d4 <_Z17collect_eit_framev+0x1f8>)
    13e8:	487b      	ldr	r0, [pc, #492]	; (15d8 <_Z17collect_eit_framev+0x1fc>)
    13ea:	f7ff f8e9 	bl	5c0 <_ZN5Print5printEPKc>
    Serial.flush();
    13ee:	487a      	ldr	r0, [pc, #488]	; (15d8 <_Z17collect_eit_framev+0x1fc>)
    13f0:	f7ff f95f 	bl	6b2 <_ZN16usb_serial_class5flushEv>

    // Disable Outputs
    driveSourceMux.enable(false);
    13f4:	2100      	movs	r1, #0
    13f6:	4879      	ldr	r0, [pc, #484]	; (15dc <_Z17collect_eit_framev+0x200>)
    13f8:	f008 ff81 	bl	a2fe <_ZN6ADG7326enableEb>
    driveGroundMux.enable(false);
    13fc:	2100      	movs	r1, #0
    13fe:	4878      	ldr	r0, [pc, #480]	; (15e0 <_Z17collect_eit_framev+0x204>)
    1400:	f008 ff7d 	bl	a2fe <_ZN6ADG7326enableEb>
    senseAMux.enable(false);
    1404:	2100      	movs	r1, #0
    1406:	4877      	ldr	r0, [pc, #476]	; (15e4 <_Z17collect_eit_framev+0x208>)
    1408:	f008 ff79 	bl	a2fe <_ZN6ADG7326enableEb>
    senseBMux.enable(false);
    140c:	2100      	movs	r1, #0
    140e:	4876      	ldr	r0, [pc, #472]	; (15e8 <_Z17collect_eit_framev+0x20c>)
    1410:	f008 ff75 	bl	a2fe <_ZN6ADG7326enableEb>

    // Loop over all driving pairs
    for(
            // Start from the 0th electrode
            unsigned int drivingElectrode = 0, 
    1414:	2300      	movs	r3, #0
    1416:	613b      	str	r3, [r7, #16]
                          groundElectrode = ( drivingElectrode + g_iDrivingDist ) % g_iElectrodes;
    1418:	4b74      	ldr	r3, [pc, #464]	; (15ec <_Z17collect_eit_framev+0x210>)
    141a:	681a      	ldr	r2, [r3, #0]
    141c:	693b      	ldr	r3, [r7, #16]
    141e:	4413      	add	r3, r2
    1420:	4a73      	ldr	r2, [pc, #460]	; (15f0 <_Z17collect_eit_framev+0x214>)
    1422:	6812      	ldr	r2, [r2, #0]
    1424:	fbb3 f1f2 	udiv	r1, r3, r2
    1428:	fb01 f202 	mul.w	r2, r1, r2
    142c:	1a9b      	subs	r3, r3, r2
    142e:	60fb      	str	r3, [r7, #12]
    for(
    1430:	e0c1      	b.n	15b6 <_Z17collect_eit_framev+0x1da>
            // Rotate by 1 each iteration
            groundElectrode  = ( ( ++drivingElectrode ) + g_iDrivingDist ) % g_iElectrodes // Update both the source and ground positions at the same time
        )
    {
        // Connect the selected driving pair
        driveSourceMux.select((ADG732::Channel) transformElectrode(drivingElectrode)); // Setup the drive current "+/source" multiplexer
    1432:	6938      	ldr	r0, [r7, #16]
    1434:	f7ff ffae 	bl	1394 <_Z18transformElectrodej>
    1438:	4603      	mov	r3, r0
    143a:	b2db      	uxtb	r3, r3
    143c:	4619      	mov	r1, r3
    143e:	4867      	ldr	r0, [pc, #412]	; (15dc <_Z17collect_eit_framev+0x200>)
    1440:	f008 ff00 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        driveGroundMux.select((ADG732::Channel) transformElectrode(groundElectrode )); // Setup the drive current "-/ground" multiplexer
    1444:	68f8      	ldr	r0, [r7, #12]
    1446:	f7ff ffa5 	bl	1394 <_Z18transformElectrodej>
    144a:	4603      	mov	r3, r0
    144c:	b2db      	uxtb	r3, r3
    144e:	4619      	mov	r1, r3
    1450:	4863      	ldr	r0, [pc, #396]	; (15e0 <_Z17collect_eit_framev+0x204>)
    1452:	f008 fef7 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        driveGroundMux.enable(true); driveSourceMux.enable(true); // Enable both drive current multiplexers
    1456:	2101      	movs	r1, #1
    1458:	4861      	ldr	r0, [pc, #388]	; (15e0 <_Z17collect_eit_framev+0x204>)
    145a:	f008 ff50 	bl	a2fe <_ZN6ADG7326enableEb>
    145e:	2101      	movs	r1, #1
    1460:	485e      	ldr	r0, [pc, #376]	; (15dc <_Z17collect_eit_framev+0x200>)
    1462:	f008 ff4c 	bl	a2fe <_ZN6ADG7326enableEb>

        // TODO: include drive settling delay

        // Loop over all sensing pairs for the current driving arrangement :
        for (   // Sensing pairs start immediately after the driving electrode
                unsigned int senseAElectrode = (drivingElectrode + g_iInitialDriveSenseDist) % g_iElectrodes,
    1466:	693b      	ldr	r3, [r7, #16]
    1468:	3301      	adds	r3, #1
    146a:	4a61      	ldr	r2, [pc, #388]	; (15f0 <_Z17collect_eit_framev+0x214>)
    146c:	6812      	ldr	r2, [r2, #0]
    146e:	fbb3 f1f2 	udiv	r1, r3, r2
    1472:	fb01 f202 	mul.w	r2, r1, r2
    1476:	1a9b      	subs	r3, r3, r2
    1478:	60bb      	str	r3, [r7, #8]
                             senseBElectrode = (senseAElectrode  + g_iSensingDist) % g_iElectrodes;
    147a:	68bb      	ldr	r3, [r7, #8]
    147c:	3301      	adds	r3, #1
    147e:	4a5c      	ldr	r2, [pc, #368]	; (15f0 <_Z17collect_eit_framev+0x214>)
    1480:	6812      	ldr	r2, [r2, #0]
    1482:	fbb3 f1f2 	udiv	r1, r3, r2
    1486:	fb01 f202 	mul.w	r2, r1, r2
    148a:	1a9b      	subs	r3, r3, r2
    148c:	607b      	str	r3, [r7, #4]
        for (   // Sensing pairs start immediately after the driving electrode
    148e:	e06b      	b.n	1568 <_Z17collect_eit_framev+0x18c>
                senseBElectrode = (   ( senseAElectrode = ( senseAElectrode + 1 ) % g_iElectrodes )  // Update both the senseA and senseB positions at the same time
                                      + g_iSensingDist ) % g_iElectrodes 
            )
        {
            // Skip measurements involving the driving electrodes
            if (    ( groundElectrode == senseAElectrode )
    1490:	68fa      	ldr	r2, [r7, #12]
    1492:	68bb      	ldr	r3, [r7, #8]
    1494:	429a      	cmp	r2, r3
    1496:	d052      	beq.n	153e <_Z17collect_eit_framev+0x162>
                 || ( groundElectrode == senseBElectrode ) )
    1498:	68fa      	ldr	r2, [r7, #12]
    149a:	687b      	ldr	r3, [r7, #4]
    149c:	429a      	cmp	r2, r3
    149e:	d04e      	beq.n	153e <_Z17collect_eit_framev+0x162>
            {
                continue;
            }

            // Connect the selected sensing pair
            senseAMux.select((ADG732::Channel) transformElectrode(senseAElectrode)); // Setup the sense "A" multiplexer
    14a0:	68b8      	ldr	r0, [r7, #8]
    14a2:	f7ff ff77 	bl	1394 <_Z18transformElectrodej>
    14a6:	4603      	mov	r3, r0
    14a8:	b2db      	uxtb	r3, r3
    14aa:	4619      	mov	r1, r3
    14ac:	484d      	ldr	r0, [pc, #308]	; (15e4 <_Z17collect_eit_framev+0x208>)
    14ae:	f008 fec9 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
            senseBMux.select((ADG732::Channel) transformElectrode(senseBElectrode)); // Setup the sense "B" multiplexer
    14b2:	6878      	ldr	r0, [r7, #4]
    14b4:	f7ff ff6e 	bl	1394 <_Z18transformElectrodej>
    14b8:	4603      	mov	r3, r0
    14ba:	b2db      	uxtb	r3, r3
    14bc:	4619      	mov	r1, r3
    14be:	484a      	ldr	r0, [pc, #296]	; (15e8 <_Z17collect_eit_framev+0x20c>)
    14c0:	f008 fec0 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
            senseAMux.enable(true); senseBMux.enable(true); // Enable both sense multiplexers
    14c4:	2101      	movs	r1, #1
    14c6:	4847      	ldr	r0, [pc, #284]	; (15e4 <_Z17collect_eit_framev+0x208>)
    14c8:	f008 ff19 	bl	a2fe <_ZN6ADG7326enableEb>
    14cc:	2101      	movs	r1, #1
    14ce:	4846      	ldr	r0, [pc, #280]	; (15e8 <_Z17collect_eit_framev+0x20c>)
    14d0:	f008 ff15 	bl	a2fe <_ZN6ADG7326enableEb>

            // Trigger and wait for ADC operation
            adc_collect_samples(const_cast<uint32_t * >(g_aiSamples), g_iSamples);
    14d4:	4b47      	ldr	r3, [pc, #284]	; (15f4 <_Z17collect_eit_framev+0x218>)
    14d6:	681b      	ldr	r3, [r3, #0]
    14d8:	b2db      	uxtb	r3, r3
    14da:	4619      	mov	r1, r3
    14dc:	4846      	ldr	r0, [pc, #280]	; (15f8 <_Z17collect_eit_framev+0x21c>)
    14de:	f002 fe59 	bl	4194 <_Z19adc_collect_samplesPmh>

            // Disable both sensing multiplexers
            senseAMux.enable(false); senseBMux.enable(false);
    14e2:	2100      	movs	r1, #0
    14e4:	483f      	ldr	r0, [pc, #252]	; (15e4 <_Z17collect_eit_framev+0x208>)
    14e6:	f008 ff0a 	bl	a2fe <_ZN6ADG7326enableEb>
    14ea:	2100      	movs	r1, #0
    14ec:	483e      	ldr	r0, [pc, #248]	; (15e8 <_Z17collect_eit_framev+0x20c>)
    14ee:	f008 ff06 	bl	a2fe <_ZN6ADG7326enableEb>

            // Calculate magnitude
            float magnitude = eit_iq_demodulation ( 
                const_cast<uint32_t const * >(&g_aiSamples[g_iSample_rubbish]), // Ignore "rubbish" samples. (impacted by mux settling time)
    14f2:	4b42      	ldr	r3, [pc, #264]	; (15fc <_Z17collect_eit_framev+0x220>)
    14f4:	681b      	ldr	r3, [r3, #0]
    14f6:	009b      	lsls	r3, r3, #2
    14f8:	4a3f      	ldr	r2, [pc, #252]	; (15f8 <_Z17collect_eit_framev+0x21c>)
    14fa:	1898      	adds	r0, r3, r2
            float magnitude = eit_iq_demodulation ( 
    14fc:	4b40      	ldr	r3, [pc, #256]	; (1600 <_Z17collect_eit_framev+0x224>)
    14fe:	681b      	ldr	r3, [r3, #0]
    1500:	b2d9      	uxtb	r1, r3
    1502:	4b40      	ldr	r3, [pc, #256]	; (1604 <_Z17collect_eit_framev+0x228>)
    1504:	681b      	ldr	r3, [r3, #0]
    1506:	b2da      	uxtb	r2, r3
    1508:	2300      	movs	r3, #0
    150a:	f7ff fe17 	bl	113c <_Z19eit_iq_demodulationPKmhhb>
    150e:	ed87 0a00 	vstr	s0, [r7]
                g_iSamples_per_cycle);

            // TODO: calculate Z using the phase offset
            // Z = complex division of Voltage and Current

            result_counter++;
    1512:	697b      	ldr	r3, [r7, #20]
    1514:	3301      	adds	r3, #1
    1516:	617b      	str	r3, [r7, #20]

            // Write output to usb and flush immediately so that USB interrupts do not impact ADC timings
            Serial.print(magnitude, 4); Serial.print(", ");Serial.flush();
    1518:	6838      	ldr	r0, [r7, #0]
    151a:	f00c fa1b 	bl	d954 <__aeabi_f2d>
    151e:	4602      	mov	r2, r0
    1520:	460b      	mov	r3, r1
    1522:	2104      	movs	r1, #4
    1524:	ec43 2b10 	vmov	d0, r2, r3
    1528:	482b      	ldr	r0, [pc, #172]	; (15d8 <_Z17collect_eit_framev+0x1fc>)
    152a:	f7ff f885 	bl	638 <_ZN5Print5printEdi>
    152e:	4936      	ldr	r1, [pc, #216]	; (1608 <_Z17collect_eit_framev+0x22c>)
    1530:	4829      	ldr	r0, [pc, #164]	; (15d8 <_Z17collect_eit_framev+0x1fc>)
    1532:	f7ff f845 	bl	5c0 <_ZN5Print5printEPKc>
    1536:	4828      	ldr	r0, [pc, #160]	; (15d8 <_Z17collect_eit_framev+0x1fc>)
    1538:	f7ff f8bb 	bl	6b2 <_ZN16usb_serial_class5flushEv>
    153c:	e000      	b.n	1540 <_Z17collect_eit_framev+0x164>
                continue;
    153e:	bf00      	nop
                senseBElectrode = (   ( senseAElectrode = ( senseAElectrode + 1 ) % g_iElectrodes )  // Update both the senseA and senseB positions at the same time
    1540:	68bb      	ldr	r3, [r7, #8]
    1542:	3301      	adds	r3, #1
    1544:	4a2a      	ldr	r2, [pc, #168]	; (15f0 <_Z17collect_eit_framev+0x214>)
    1546:	6812      	ldr	r2, [r2, #0]
    1548:	fbb3 f1f2 	udiv	r1, r3, r2
    154c:	fb01 f202 	mul.w	r2, r1, r2
    1550:	1a9b      	subs	r3, r3, r2
    1552:	60bb      	str	r3, [r7, #8]
                                      + g_iSensingDist ) % g_iElectrodes 
    1554:	68bb      	ldr	r3, [r7, #8]
    1556:	3301      	adds	r3, #1
    1558:	4a25      	ldr	r2, [pc, #148]	; (15f0 <_Z17collect_eit_framev+0x214>)
    155a:	6812      	ldr	r2, [r2, #0]
                senseBElectrode = (   ( senseAElectrode = ( senseAElectrode + 1 ) % g_iElectrodes )  // Update both the senseA and senseB positions at the same time
    155c:	fbb3 f1f2 	udiv	r1, r3, r2
    1560:	fb01 f202 	mul.w	r2, r1, r2
    1564:	1a9b      	subs	r3, r3, r2
    1566:	607b      	str	r3, [r7, #4]
                  && ( senseBElectrode != drivingElectrode ) );
    1568:	68ba      	ldr	r2, [r7, #8]
    156a:	693b      	ldr	r3, [r7, #16]
    156c:	429a      	cmp	r2, r3
    156e:	d003      	beq.n	1578 <_Z17collect_eit_framev+0x19c>
    1570:	687a      	ldr	r2, [r7, #4]
    1572:	693b      	ldr	r3, [r7, #16]
    1574:	429a      	cmp	r2, r3
    1576:	d18b      	bne.n	1490 <_Z17collect_eit_framev+0xb4>
        }

        // Disable both drive and sensing multiplexers
        driveSourceMux.enable(false);
    1578:	2100      	movs	r1, #0
    157a:	4818      	ldr	r0, [pc, #96]	; (15dc <_Z17collect_eit_framev+0x200>)
    157c:	f008 febf 	bl	a2fe <_ZN6ADG7326enableEb>
        driveGroundMux.enable(false);
    1580:	2100      	movs	r1, #0
    1582:	4817      	ldr	r0, [pc, #92]	; (15e0 <_Z17collect_eit_framev+0x204>)
    1584:	f008 febb 	bl	a2fe <_ZN6ADG7326enableEb>
        senseAMux.enable(false);
    1588:	2100      	movs	r1, #0
    158a:	4816      	ldr	r0, [pc, #88]	; (15e4 <_Z17collect_eit_framev+0x208>)
    158c:	f008 feb7 	bl	a2fe <_ZN6ADG7326enableEb>
        senseBMux.enable(false);
    1590:	2100      	movs	r1, #0
    1592:	4815      	ldr	r0, [pc, #84]	; (15e8 <_Z17collect_eit_framev+0x20c>)
    1594:	f008 feb3 	bl	a2fe <_ZN6ADG7326enableEb>
    for(
    1598:	693b      	ldr	r3, [r7, #16]
    159a:	3301      	adds	r3, #1
    159c:	613b      	str	r3, [r7, #16]
            groundElectrode  = ( ( ++drivingElectrode ) + g_iDrivingDist ) % g_iElectrodes // Update both the source and ground positions at the same time
    159e:	4b13      	ldr	r3, [pc, #76]	; (15ec <_Z17collect_eit_framev+0x210>)
    15a0:	681a      	ldr	r2, [r3, #0]
    15a2:	693b      	ldr	r3, [r7, #16]
    15a4:	4413      	add	r3, r2
    15a6:	4a12      	ldr	r2, [pc, #72]	; (15f0 <_Z17collect_eit_framev+0x214>)
    15a8:	6812      	ldr	r2, [r2, #0]
    15aa:	fbb3 f1f2 	udiv	r1, r3, r2
    15ae:	fb01 f202 	mul.w	r2, r1, r2
    15b2:	1a9b      	subs	r3, r3, r2
    15b4:	60fb      	str	r3, [r7, #12]
            drivingElectrode < g_iElectrodes;
    15b6:	4b0e      	ldr	r3, [pc, #56]	; (15f0 <_Z17collect_eit_framev+0x214>)
    15b8:	681b      	ldr	r3, [r3, #0]
    15ba:	693a      	ldr	r2, [r7, #16]
    15bc:	429a      	cmp	r2, r3
    15be:	f4ff af38 	bcc.w	1432 <_Z17collect_eit_framev+0x56>

    }
    Serial.print("\r\n");
    15c2:	4912      	ldr	r1, [pc, #72]	; (160c <_Z17collect_eit_framev+0x230>)
    15c4:	4804      	ldr	r0, [pc, #16]	; (15d8 <_Z17collect_eit_framev+0x1fc>)
    15c6:	f7fe fffb 	bl	5c0 <_ZN5Print5printEPKc>
}
    15ca:	bf00      	nop
    15cc:	3718      	adds	r7, #24
    15ce:	46bd      	mov	sp, r7
    15d0:	bd80      	pop	{r7, pc}
    15d2:	bf00      	nop
    15d4:	0000efb0 	.word	0x0000efb0
    15d8:	1fff078c 	.word	0x1fff078c
    15dc:	1fff098c 	.word	0x1fff098c
    15e0:	1fff09ec 	.word	0x1fff09ec
    15e4:	1fff08cc 	.word	0x1fff08cc
    15e8:	1fff092c 	.word	0x1fff092c
    15ec:	1fff073c 	.word	0x1fff073c
    15f0:	1fff0738 	.word	0x1fff0738
    15f4:	1fff0adc 	.word	0x1fff0adc
    15f8:	1fff0ae8 	.word	0x1fff0ae8
    15fc:	1fff0754 	.word	0x1fff0754
    1600:	1fff0ad8 	.word	0x1fff0ad8
    1604:	1fff0750 	.word	0x1fff0750
    1608:	0000efc0 	.word	0x0000efc0
    160c:	0000efac 	.word	0x0000efac

00001610 <_Z15TestFixedOutputv>:

void collect_and_print_samples_analyse(bool printSamples = false);

void TestFixedOutput()
{
    1610:	b580      	push	{r7, lr}
    1612:	af00      	add	r7, sp, #0
    Serial.println("\r\n\r\nFixed Output Drive 1,2, Sense 3,4 : \r\n");
    1614:	4928      	ldr	r1, [pc, #160]	; (16b8 <_Z15TestFixedOutputv+0xa8>)
    1616:	4829      	ldr	r0, [pc, #164]	; (16bc <_Z15TestFixedOutputv+0xac>)
    1618:	f7ff f822 	bl	660 <_ZN5Print7printlnEPKc>
    Serial.flush();
    161c:	4827      	ldr	r0, [pc, #156]	; (16bc <_Z15TestFixedOutputv+0xac>)
    161e:	f7ff f848 	bl	6b2 <_ZN16usb_serial_class5flushEv>

    driveSourceMux.select((ADG732::Channel) transformElectrode(0));
    1622:	2000      	movs	r0, #0
    1624:	f7ff feb6 	bl	1394 <_Z18transformElectrodej>
    1628:	4603      	mov	r3, r0
    162a:	b2db      	uxtb	r3, r3
    162c:	4619      	mov	r1, r3
    162e:	4824      	ldr	r0, [pc, #144]	; (16c0 <_Z15TestFixedOutputv+0xb0>)
    1630:	f008 fe08 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
    driveGroundMux.select((ADG732::Channel) transformElectrode(1));
    1634:	2001      	movs	r0, #1
    1636:	f7ff fead 	bl	1394 <_Z18transformElectrodej>
    163a:	4603      	mov	r3, r0
    163c:	b2db      	uxtb	r3, r3
    163e:	4619      	mov	r1, r3
    1640:	4820      	ldr	r0, [pc, #128]	; (16c4 <_Z15TestFixedOutputv+0xb4>)
    1642:	f008 fdff 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
    senseAMux.select((ADG732::Channel) transformElectrode(2));
    1646:	2002      	movs	r0, #2
    1648:	f7ff fea4 	bl	1394 <_Z18transformElectrodej>
    164c:	4603      	mov	r3, r0
    164e:	b2db      	uxtb	r3, r3
    1650:	4619      	mov	r1, r3
    1652:	481d      	ldr	r0, [pc, #116]	; (16c8 <_Z15TestFixedOutputv+0xb8>)
    1654:	f008 fdf6 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
    senseBMux.select((ADG732::Channel) transformElectrode(3));
    1658:	2003      	movs	r0, #3
    165a:	f7ff fe9b 	bl	1394 <_Z18transformElectrodej>
    165e:	4603      	mov	r3, r0
    1660:	b2db      	uxtb	r3, r3
    1662:	4619      	mov	r1, r3
    1664:	4819      	ldr	r0, [pc, #100]	; (16cc <_Z15TestFixedOutputv+0xbc>)
    1666:	f008 fded 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>

    driveSourceMux.enable(true);
    166a:	2101      	movs	r1, #1
    166c:	4814      	ldr	r0, [pc, #80]	; (16c0 <_Z15TestFixedOutputv+0xb0>)
    166e:	f008 fe46 	bl	a2fe <_ZN6ADG7326enableEb>
    driveGroundMux.enable(true);
    1672:	2101      	movs	r1, #1
    1674:	4813      	ldr	r0, [pc, #76]	; (16c4 <_Z15TestFixedOutputv+0xb4>)
    1676:	f008 fe42 	bl	a2fe <_ZN6ADG7326enableEb>
    senseAMux.enable(true);
    167a:	2101      	movs	r1, #1
    167c:	4812      	ldr	r0, [pc, #72]	; (16c8 <_Z15TestFixedOutputv+0xb8>)
    167e:	f008 fe3e 	bl	a2fe <_ZN6ADG7326enableEb>
    senseBMux.enable(true);
    1682:	2101      	movs	r1, #1
    1684:	4811      	ldr	r0, [pc, #68]	; (16cc <_Z15TestFixedOutputv+0xbc>)
    1686:	f008 fe3a 	bl	a2fe <_ZN6ADG7326enableEb>

    collect_and_print_samples_analyse(true);
    168a:	2001      	movs	r0, #1
    168c:	f000 fc2c 	bl	1ee8 <_Z33collect_and_print_samples_analyseb>

    eit_iq_demodulation ( const_cast<uint32_t const * >(&g_aiSamples[g_iSample_rubbish]), g_iSamples_useful, g_iSamples_per_cycle, true);
    1690:	4b0f      	ldr	r3, [pc, #60]	; (16d0 <_Z15TestFixedOutputv+0xc0>)
    1692:	681b      	ldr	r3, [r3, #0]
    1694:	009b      	lsls	r3, r3, #2
    1696:	4a0f      	ldr	r2, [pc, #60]	; (16d4 <_Z15TestFixedOutputv+0xc4>)
    1698:	1898      	adds	r0, r3, r2
    169a:	4b0f      	ldr	r3, [pc, #60]	; (16d8 <_Z15TestFixedOutputv+0xc8>)
    169c:	681b      	ldr	r3, [r3, #0]
    169e:	b2d9      	uxtb	r1, r3
    16a0:	4b0e      	ldr	r3, [pc, #56]	; (16dc <_Z15TestFixedOutputv+0xcc>)
    16a2:	681b      	ldr	r3, [r3, #0]
    16a4:	b2da      	uxtb	r2, r3
    16a6:	2301      	movs	r3, #1
    16a8:	f7ff fd48 	bl	113c <_Z19eit_iq_demodulationPKmhhb>
    Serial.flush();
    16ac:	4803      	ldr	r0, [pc, #12]	; (16bc <_Z15TestFixedOutputv+0xac>)
    16ae:	f7ff f800 	bl	6b2 <_ZN16usb_serial_class5flushEv>
       
}
    16b2:	bf00      	nop
    16b4:	bd80      	pop	{r7, pc}
    16b6:	bf00      	nop
    16b8:	0000efc4 	.word	0x0000efc4
    16bc:	1fff078c 	.word	0x1fff078c
    16c0:	1fff098c 	.word	0x1fff098c
    16c4:	1fff09ec 	.word	0x1fff09ec
    16c8:	1fff08cc 	.word	0x1fff08cc
    16cc:	1fff092c 	.word	0x1fff092c
    16d0:	1fff0754 	.word	0x1fff0754
    16d4:	1fff0ae8 	.word	0x1fff0ae8
    16d8:	1fff0ad8 	.word	0x1fff0ad8
    16dc:	1fff0750 	.word	0x1fff0750

000016e0 <_Z19TestOutputsToInputsv>:

void TestOutputsToInputs()
{
    16e0:	b580      	push	{r7, lr}
    16e2:	b086      	sub	sp, #24
    16e4:	af00      	add	r7, sp, #0
    Serial.print("\r\nOutput vs Input Matrix");
    16e6:	4986      	ldr	r1, [pc, #536]	; (1900 <_Z19TestOutputsToInputsv+0x220>)
    16e8:	4886      	ldr	r0, [pc, #536]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    16ea:	f7fe ff69 	bl	5c0 <_ZN5Print5printEPKc>
    Serial.print("\r\nDist: ");Serial.print(g_iDrivingDist);
    16ee:	4986      	ldr	r1, [pc, #536]	; (1908 <_Z19TestOutputsToInputsv+0x228>)
    16f0:	4884      	ldr	r0, [pc, #528]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    16f2:	f7fe ff65 	bl	5c0 <_ZN5Print5printEPKc>
    16f6:	4b85      	ldr	r3, [pc, #532]	; (190c <_Z19TestOutputsToInputsv+0x22c>)
    16f8:	681b      	ldr	r3, [r3, #0]
    16fa:	4619      	mov	r1, r3
    16fc:	4881      	ldr	r0, [pc, #516]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    16fe:	f7fe ff8b 	bl	618 <_ZN5Print5printEm>
    Serial.print("\r\nO+,O-,\t");
    1702:	4983      	ldr	r1, [pc, #524]	; (1910 <_Z19TestOutputsToInputsv+0x230>)
    1704:	487f      	ldr	r0, [pc, #508]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    1706:	f7fe ff5b 	bl	5c0 <_ZN5Print5printEPKc>
    for (int i = 0; i < g_iElectrodes; ++i) {
    170a:	2300      	movs	r3, #0
    170c:	617b      	str	r3, [r7, #20]
    170e:	e010      	b.n	1732 <_Z19TestOutputsToInputsv+0x52>
        Serial.print(transformElectrode(i)+1);
    1710:	697b      	ldr	r3, [r7, #20]
    1712:	4618      	mov	r0, r3
    1714:	f7ff fe3e 	bl	1394 <_Z18transformElectrodej>
    1718:	4603      	mov	r3, r0
    171a:	3301      	adds	r3, #1
    171c:	4619      	mov	r1, r3
    171e:	4879      	ldr	r0, [pc, #484]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    1720:	f7fe ff6a 	bl	5f8 <_ZN5Print5printEj>
        Serial.print(",\t");
    1724:	497b      	ldr	r1, [pc, #492]	; (1914 <_Z19TestOutputsToInputsv+0x234>)
    1726:	4877      	ldr	r0, [pc, #476]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    1728:	f7fe ff4a 	bl	5c0 <_ZN5Print5printEPKc>
    for (int i = 0; i < g_iElectrodes; ++i) {
    172c:	697b      	ldr	r3, [r7, #20]
    172e:	3301      	adds	r3, #1
    1730:	617b      	str	r3, [r7, #20]
    1732:	697a      	ldr	r2, [r7, #20]
    1734:	4b78      	ldr	r3, [pc, #480]	; (1918 <_Z19TestOutputsToInputsv+0x238>)
    1736:	681b      	ldr	r3, [r3, #0]
    1738:	429a      	cmp	r2, r3
    173a:	d3e9      	bcc.n	1710 <_Z19TestOutputsToInputsv+0x30>
    }

    Serial.flush();
    173c:	4871      	ldr	r0, [pc, #452]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    173e:	f7fe ffb8 	bl	6b2 <_ZN16usb_serial_class5flushEv>

    driveSourceMux.enable(false);
    1742:	2100      	movs	r1, #0
    1744:	4875      	ldr	r0, [pc, #468]	; (191c <_Z19TestOutputsToInputsv+0x23c>)
    1746:	f008 fdda 	bl	a2fe <_ZN6ADG7326enableEb>
    driveGroundMux.enable(false);
    174a:	2100      	movs	r1, #0
    174c:	4874      	ldr	r0, [pc, #464]	; (1920 <_Z19TestOutputsToInputsv+0x240>)
    174e:	f008 fdd6 	bl	a2fe <_ZN6ADG7326enableEb>
    senseAMux.enable(false);
    1752:	2100      	movs	r1, #0
    1754:	4873      	ldr	r0, [pc, #460]	; (1924 <_Z19TestOutputsToInputsv+0x244>)
    1756:	f008 fdd2 	bl	a2fe <_ZN6ADG7326enableEb>
    senseBMux.enable(false);
    175a:	2100      	movs	r1, #0
    175c:	4872      	ldr	r0, [pc, #456]	; (1928 <_Z19TestOutputsToInputsv+0x248>)
    175e:	f008 fdce 	bl	a2fe <_ZN6ADG7326enableEb>

    // Loop over all driving pairs
    for(
            // Start from the 0th electrode
            unsigned int drivingElectrode = 0, 
    1762:	2300      	movs	r3, #0
    1764:	613b      	str	r3, [r7, #16]
                          groundElectrode = g_iDrivingDist;
    1766:	4b69      	ldr	r3, [pc, #420]	; (190c <_Z19TestOutputsToInputsv+0x22c>)
    1768:	681b      	ldr	r3, [r3, #0]
    176a:	60fb      	str	r3, [r7, #12]
    for(
    176c:	e0b6      	b.n	18dc <_Z19TestOutputsToInputsv+0x1fc>

            // Rotate by g_iDrivingDist each iteration
            groundElectrode  = ( ++drivingElectrode + g_iDrivingDist  ) % g_iElectrodes
        )
    {
        Serial.print("\r\n");
    176e:	496f      	ldr	r1, [pc, #444]	; (192c <_Z19TestOutputsToInputsv+0x24c>)
    1770:	4864      	ldr	r0, [pc, #400]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    1772:	f7fe ff25 	bl	5c0 <_ZN5Print5printEPKc>
        Serial.print(transformElectrode(drivingElectrode)+1);Serial.print(", ");
    1776:	6938      	ldr	r0, [r7, #16]
    1778:	f7ff fe0c 	bl	1394 <_Z18transformElectrodej>
    177c:	4603      	mov	r3, r0
    177e:	3301      	adds	r3, #1
    1780:	4619      	mov	r1, r3
    1782:	4860      	ldr	r0, [pc, #384]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    1784:	f7fe ff38 	bl	5f8 <_ZN5Print5printEj>
    1788:	4969      	ldr	r1, [pc, #420]	; (1930 <_Z19TestOutputsToInputsv+0x250>)
    178a:	485e      	ldr	r0, [pc, #376]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    178c:	f7fe ff18 	bl	5c0 <_ZN5Print5printEPKc>
        Serial.print(transformElectrode(groundElectrode) +1);Serial.print(",\t");Serial.flush();
    1790:	68f8      	ldr	r0, [r7, #12]
    1792:	f7ff fdff 	bl	1394 <_Z18transformElectrodej>
    1796:	4603      	mov	r3, r0
    1798:	3301      	adds	r3, #1
    179a:	4619      	mov	r1, r3
    179c:	4859      	ldr	r0, [pc, #356]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    179e:	f7fe ff2b 	bl	5f8 <_ZN5Print5printEj>
    17a2:	495c      	ldr	r1, [pc, #368]	; (1914 <_Z19TestOutputsToInputsv+0x234>)
    17a4:	4857      	ldr	r0, [pc, #348]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    17a6:	f7fe ff0b 	bl	5c0 <_ZN5Print5printEPKc>
    17aa:	4856      	ldr	r0, [pc, #344]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    17ac:	f7fe ff81 	bl	6b2 <_ZN16usb_serial_class5flushEv>

        driveSourceMux.select((ADG732::Channel) transformElectrode(drivingElectrode));
    17b0:	6938      	ldr	r0, [r7, #16]
    17b2:	f7ff fdef 	bl	1394 <_Z18transformElectrodej>
    17b6:	4603      	mov	r3, r0
    17b8:	b2db      	uxtb	r3, r3
    17ba:	4619      	mov	r1, r3
    17bc:	4857      	ldr	r0, [pc, #348]	; (191c <_Z19TestOutputsToInputsv+0x23c>)
    17be:	f008 fd41 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        driveGroundMux.select((ADG732::Channel) transformElectrode(groundElectrode));
    17c2:	68f8      	ldr	r0, [r7, #12]
    17c4:	f7ff fde6 	bl	1394 <_Z18transformElectrodej>
    17c8:	4603      	mov	r3, r0
    17ca:	b2db      	uxtb	r3, r3
    17cc:	4619      	mov	r1, r3
    17ce:	4854      	ldr	r0, [pc, #336]	; (1920 <_Z19TestOutputsToInputsv+0x240>)
    17d0:	f008 fd38 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        driveSourceMux.enable(true); driveGroundMux.enable(true);
    17d4:	2101      	movs	r1, #1
    17d6:	4851      	ldr	r0, [pc, #324]	; (191c <_Z19TestOutputsToInputsv+0x23c>)
    17d8:	f008 fd91 	bl	a2fe <_ZN6ADG7326enableEb>
    17dc:	2101      	movs	r1, #1
    17de:	4850      	ldr	r0, [pc, #320]	; (1920 <_Z19TestOutputsToInputsv+0x240>)
    17e0:	f008 fd8d 	bl	a2fe <_ZN6ADG7326enableEb>
        
        // Loop over all sensing pairs
        for (   // Sensing pairs from 0
                unsigned int senseAElectrode = 0, senseBElectrode = 1;
    17e4:	2300      	movs	r3, #0
    17e6:	60bb      	str	r3, [r7, #8]
    17e8:	2301      	movs	r3, #1
    17ea:	607b      	str	r3, [r7, #4]
        for (   // Sensing pairs from 0
    17ec:	e057      	b.n	189e <_Z19TestOutputsToInputsv+0x1be>
                // Rotate by one each iteration
                senseBElectrode = ( ++senseAElectrode + 1 ) % g_iElectrodes 
            )
        {

            senseAMux.select((ADG732::Channel) transformElectrode(senseAElectrode));
    17ee:	68b8      	ldr	r0, [r7, #8]
    17f0:	f7ff fdd0 	bl	1394 <_Z18transformElectrodej>
    17f4:	4603      	mov	r3, r0
    17f6:	b2db      	uxtb	r3, r3
    17f8:	4619      	mov	r1, r3
    17fa:	484a      	ldr	r0, [pc, #296]	; (1924 <_Z19TestOutputsToInputsv+0x244>)
    17fc:	f008 fd22 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
            senseBMux.select((ADG732::Channel) transformElectrode(senseBElectrode));
    1800:	6878      	ldr	r0, [r7, #4]
    1802:	f7ff fdc7 	bl	1394 <_Z18transformElectrodej>
    1806:	4603      	mov	r3, r0
    1808:	b2db      	uxtb	r3, r3
    180a:	4619      	mov	r1, r3
    180c:	4846      	ldr	r0, [pc, #280]	; (1928 <_Z19TestOutputsToInputsv+0x248>)
    180e:	f008 fd19 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
            senseAMux.enable(true); senseBMux.enable(true);
    1812:	2101      	movs	r1, #1
    1814:	4843      	ldr	r0, [pc, #268]	; (1924 <_Z19TestOutputsToInputsv+0x244>)
    1816:	f008 fd72 	bl	a2fe <_ZN6ADG7326enableEb>
    181a:	2101      	movs	r1, #1
    181c:	4842      	ldr	r0, [pc, #264]	; (1928 <_Z19TestOutputsToInputsv+0x248>)
    181e:	f008 fd6e 	bl	a2fe <_ZN6ADG7326enableEb>

            adc_collect_samples(const_cast<uint32_t * >(g_aiSamples), g_iSamples);
    1822:	4b44      	ldr	r3, [pc, #272]	; (1934 <_Z19TestOutputsToInputsv+0x254>)
    1824:	681b      	ldr	r3, [r3, #0]
    1826:	b2db      	uxtb	r3, r3
    1828:	4619      	mov	r1, r3
    182a:	4843      	ldr	r0, [pc, #268]	; (1938 <_Z19TestOutputsToInputsv+0x258>)
    182c:	f002 fcb2 	bl	4194 <_Z19adc_collect_samplesPmh>

            senseAMux.enable(false); senseBMux.enable(false);
    1830:	2100      	movs	r1, #0
    1832:	483c      	ldr	r0, [pc, #240]	; (1924 <_Z19TestOutputsToInputsv+0x244>)
    1834:	f008 fd63 	bl	a2fe <_ZN6ADG7326enableEb>
    1838:	2100      	movs	r1, #0
    183a:	483b      	ldr	r0, [pc, #236]	; (1928 <_Z19TestOutputsToInputsv+0x248>)
    183c:	f008 fd5f 	bl	a2fe <_ZN6ADG7326enableEb>

            float magnitude = eit_iq_demodulation ( const_cast<uint32_t const * >(&g_aiSamples[g_iSample_rubbish]), g_iSamples_useful, g_iSamples_per_cycle);
    1840:	4b3e      	ldr	r3, [pc, #248]	; (193c <_Z19TestOutputsToInputsv+0x25c>)
    1842:	681b      	ldr	r3, [r3, #0]
    1844:	009b      	lsls	r3, r3, #2
    1846:	4a3c      	ldr	r2, [pc, #240]	; (1938 <_Z19TestOutputsToInputsv+0x258>)
    1848:	1898      	adds	r0, r3, r2
    184a:	4b3d      	ldr	r3, [pc, #244]	; (1940 <_Z19TestOutputsToInputsv+0x260>)
    184c:	681b      	ldr	r3, [r3, #0]
    184e:	b2d9      	uxtb	r1, r3
    1850:	4b3c      	ldr	r3, [pc, #240]	; (1944 <_Z19TestOutputsToInputsv+0x264>)
    1852:	681b      	ldr	r3, [r3, #0]
    1854:	b2da      	uxtb	r2, r3
    1856:	2300      	movs	r3, #0
    1858:	f7ff fc70 	bl	113c <_Z19eit_iq_demodulationPKmhhb>
    185c:	ed87 0a00 	vstr	s0, [r7]

            Serial.print(magnitude, 4); Serial.print(",\t");Serial.flush();
    1860:	6838      	ldr	r0, [r7, #0]
    1862:	f00c f877 	bl	d954 <__aeabi_f2d>
    1866:	4602      	mov	r2, r0
    1868:	460b      	mov	r3, r1
    186a:	2104      	movs	r1, #4
    186c:	ec43 2b10 	vmov	d0, r2, r3
    1870:	4824      	ldr	r0, [pc, #144]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    1872:	f7fe fee1 	bl	638 <_ZN5Print5printEdi>
    1876:	4927      	ldr	r1, [pc, #156]	; (1914 <_Z19TestOutputsToInputsv+0x234>)
    1878:	4822      	ldr	r0, [pc, #136]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    187a:	f7fe fea1 	bl	5c0 <_ZN5Print5printEPKc>
    187e:	4821      	ldr	r0, [pc, #132]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    1880:	f7fe ff17 	bl	6b2 <_ZN16usb_serial_class5flushEv>
        for (   // Sensing pairs from 0
    1884:	68bb      	ldr	r3, [r7, #8]
    1886:	3301      	adds	r3, #1
    1888:	60bb      	str	r3, [r7, #8]
                senseBElectrode = ( ++senseAElectrode + 1 ) % g_iElectrodes 
    188a:	68bb      	ldr	r3, [r7, #8]
    188c:	3301      	adds	r3, #1
    188e:	4a22      	ldr	r2, [pc, #136]	; (1918 <_Z19TestOutputsToInputsv+0x238>)
    1890:	6812      	ldr	r2, [r2, #0]
    1892:	fbb3 f1f2 	udiv	r1, r3, r2
    1896:	fb01 f202 	mul.w	r2, r1, r2
    189a:	1a9b      	subs	r3, r3, r2
    189c:	607b      	str	r3, [r7, #4]
                senseAElectrode < g_iElectrodes;
    189e:	4b1e      	ldr	r3, [pc, #120]	; (1918 <_Z19TestOutputsToInputsv+0x238>)
    18a0:	681b      	ldr	r3, [r3, #0]
    18a2:	68ba      	ldr	r2, [r7, #8]
    18a4:	429a      	cmp	r2, r3
    18a6:	d3a2      	bcc.n	17ee <_Z19TestOutputsToInputsv+0x10e>
        }
        Serial.flush();
    18a8:	4816      	ldr	r0, [pc, #88]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    18aa:	f7fe ff02 	bl	6b2 <_ZN16usb_serial_class5flushEv>
        driveSourceMux.enable(false); driveGroundMux.enable(false);
    18ae:	2100      	movs	r1, #0
    18b0:	481a      	ldr	r0, [pc, #104]	; (191c <_Z19TestOutputsToInputsv+0x23c>)
    18b2:	f008 fd24 	bl	a2fe <_ZN6ADG7326enableEb>
    18b6:	2100      	movs	r1, #0
    18b8:	4819      	ldr	r0, [pc, #100]	; (1920 <_Z19TestOutputsToInputsv+0x240>)
    18ba:	f008 fd20 	bl	a2fe <_ZN6ADG7326enableEb>
    for(
    18be:	693b      	ldr	r3, [r7, #16]
    18c0:	3301      	adds	r3, #1
    18c2:	613b      	str	r3, [r7, #16]
            groundElectrode  = ( ++drivingElectrode + g_iDrivingDist  ) % g_iElectrodes
    18c4:	4b11      	ldr	r3, [pc, #68]	; (190c <_Z19TestOutputsToInputsv+0x22c>)
    18c6:	681a      	ldr	r2, [r3, #0]
    18c8:	693b      	ldr	r3, [r7, #16]
    18ca:	4413      	add	r3, r2
    18cc:	4a12      	ldr	r2, [pc, #72]	; (1918 <_Z19TestOutputsToInputsv+0x238>)
    18ce:	6812      	ldr	r2, [r2, #0]
    18d0:	fbb3 f1f2 	udiv	r1, r3, r2
    18d4:	fb01 f202 	mul.w	r2, r1, r2
    18d8:	1a9b      	subs	r3, r3, r2
    18da:	60fb      	str	r3, [r7, #12]
            drivingElectrode < g_iElectrodes;
    18dc:	4b0e      	ldr	r3, [pc, #56]	; (1918 <_Z19TestOutputsToInputsv+0x238>)
    18de:	681b      	ldr	r3, [r3, #0]
    18e0:	693a      	ldr	r2, [r7, #16]
    18e2:	429a      	cmp	r2, r3
    18e4:	f4ff af43 	bcc.w	176e <_Z19TestOutputsToInputsv+0x8e>
    }
    Serial.print("\r\n");
    18e8:	4910      	ldr	r1, [pc, #64]	; (192c <_Z19TestOutputsToInputsv+0x24c>)
    18ea:	4806      	ldr	r0, [pc, #24]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    18ec:	f7fe fe68 	bl	5c0 <_ZN5Print5printEPKc>
    Serial.flush();
    18f0:	4804      	ldr	r0, [pc, #16]	; (1904 <_Z19TestOutputsToInputsv+0x224>)
    18f2:	f7fe fede 	bl	6b2 <_ZN16usb_serial_class5flushEv>
}
    18f6:	bf00      	nop
    18f8:	3718      	adds	r7, #24
    18fa:	46bd      	mov	sp, r7
    18fc:	bd80      	pop	{r7, pc}
    18fe:	bf00      	nop
    1900:	0000eff0 	.word	0x0000eff0
    1904:	1fff078c 	.word	0x1fff078c
    1908:	0000f00c 	.word	0x0000f00c
    190c:	1fff073c 	.word	0x1fff073c
    1910:	0000f018 	.word	0x0000f018
    1914:	0000f024 	.word	0x0000f024
    1918:	1fff0738 	.word	0x1fff0738
    191c:	1fff098c 	.word	0x1fff098c
    1920:	1fff09ec 	.word	0x1fff09ec
    1924:	1fff08cc 	.word	0x1fff08cc
    1928:	1fff092c 	.word	0x1fff092c
    192c:	0000efac 	.word	0x0000efac
    1930:	0000efc0 	.word	0x0000efc0
    1934:	1fff0adc 	.word	0x1fff0adc
    1938:	1fff0ae8 	.word	0x1fff0ae8
    193c:	1fff0754 	.word	0x1fff0754
    1940:	1fff0ad8 	.word	0x1fff0ad8
    1944:	1fff0750 	.word	0x1fff0750

00001948 <_Z27TestElectrodeInputRawValuesv>:

void TestElectrodeInputRawValues()
{
    1948:	b580      	push	{r7, lr}
    194a:	b084      	sub	sp, #16
    194c:	af00      	add	r7, sp, #0
    Serial.println("\r\nElectrode Inputs Raw Values");
    194e:	493a      	ldr	r1, [pc, #232]	; (1a38 <_Z27TestElectrodeInputRawValuesv+0xf0>)
    1950:	483a      	ldr	r0, [pc, #232]	; (1a3c <_Z27TestElectrodeInputRawValuesv+0xf4>)
    1952:	f7fe fe85 	bl	660 <_ZN5Print7printlnEPKc>
    Serial.flush();
    1956:	4839      	ldr	r0, [pc, #228]	; (1a3c <_Z27TestElectrodeInputRawValuesv+0xf4>)
    1958:	f7fe feab 	bl	6b2 <_ZN16usb_serial_class5flushEv>

    driveSourceMux.enable(false);
    195c:	2100      	movs	r1, #0
    195e:	4838      	ldr	r0, [pc, #224]	; (1a40 <_Z27TestElectrodeInputRawValuesv+0xf8>)
    1960:	f008 fccd 	bl	a2fe <_ZN6ADG7326enableEb>
    driveGroundMux.enable(false);
    1964:	2100      	movs	r1, #0
    1966:	4837      	ldr	r0, [pc, #220]	; (1a44 <_Z27TestElectrodeInputRawValuesv+0xfc>)
    1968:	f008 fcc9 	bl	a2fe <_ZN6ADG7326enableEb>
    senseAMux.enable(false);
    196c:	2100      	movs	r1, #0
    196e:	4836      	ldr	r0, [pc, #216]	; (1a48 <_Z27TestElectrodeInputRawValuesv+0x100>)
    1970:	f008 fcc5 	bl	a2fe <_ZN6ADG7326enableEb>
    senseBMux.enable(false);
    1974:	2100      	movs	r1, #0
    1976:	4835      	ldr	r0, [pc, #212]	; (1a4c <_Z27TestElectrodeInputRawValuesv+0x104>)
    1978:	f008 fcc1 	bl	a2fe <_ZN6ADG7326enableEb>

        
    // Loop over all sensing pairs
    for (   // Sensing pairs from 0
            unsigned int senseAElectrode = 0, senseBElectrode = 1;
    197c:	2300      	movs	r3, #0
    197e:	60bb      	str	r3, [r7, #8]
    1980:	2301      	movs	r3, #1
    1982:	60fb      	str	r3, [r7, #12]
    for (   // Sensing pairs from 0
    1984:	e047      	b.n	1a16 <_Z27TestElectrodeInputRawValuesv+0xce>

            // Rotate by one each iteration
            ++senseBElectrode
        )
    {
        senseAMux.select((ADG732::Channel) transformElectrode(senseAElectrode));
    1986:	68b8      	ldr	r0, [r7, #8]
    1988:	f7ff fd04 	bl	1394 <_Z18transformElectrodej>
    198c:	4603      	mov	r3, r0
    198e:	b2db      	uxtb	r3, r3
    1990:	4619      	mov	r1, r3
    1992:	482d      	ldr	r0, [pc, #180]	; (1a48 <_Z27TestElectrodeInputRawValuesv+0x100>)
    1994:	f008 fc56 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        senseBMux.select((ADG732::Channel) transformElectrode(senseBElectrode));
    1998:	68f8      	ldr	r0, [r7, #12]
    199a:	f7ff fcfb 	bl	1394 <_Z18transformElectrodej>
    199e:	4603      	mov	r3, r0
    19a0:	b2db      	uxtb	r3, r3
    19a2:	4619      	mov	r1, r3
    19a4:	4829      	ldr	r0, [pc, #164]	; (1a4c <_Z27TestElectrodeInputRawValuesv+0x104>)
    19a6:	f008 fc4d 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        senseAMux.enable(true); senseBMux.enable(true);
    19aa:	2101      	movs	r1, #1
    19ac:	4826      	ldr	r0, [pc, #152]	; (1a48 <_Z27TestElectrodeInputRawValuesv+0x100>)
    19ae:	f008 fca6 	bl	a2fe <_ZN6ADG7326enableEb>
    19b2:	2101      	movs	r1, #1
    19b4:	4825      	ldr	r0, [pc, #148]	; (1a4c <_Z27TestElectrodeInputRawValuesv+0x104>)
    19b6:	f008 fca2 	bl	a2fe <_ZN6ADG7326enableEb>

        volatile uint32_t sample = 0;
    19ba:	2300      	movs	r3, #0
    19bc:	607b      	str	r3, [r7, #4]
        adc_collect_samples(const_cast<uint32_t * >( &sample), 1);
    19be:	1d3b      	adds	r3, r7, #4
    19c0:	2101      	movs	r1, #1
    19c2:	4618      	mov	r0, r3
    19c4:	f002 fbe6 	bl	4194 <_Z19adc_collect_samplesPmh>

        senseAMux.enable(false); senseBMux.enable(false);
    19c8:	2100      	movs	r1, #0
    19ca:	481f      	ldr	r0, [pc, #124]	; (1a48 <_Z27TestElectrodeInputRawValuesv+0x100>)
    19cc:	f008 fc97 	bl	a2fe <_ZN6ADG7326enableEb>
    19d0:	2100      	movs	r1, #0
    19d2:	481e      	ldr	r0, [pc, #120]	; (1a4c <_Z27TestElectrodeInputRawValuesv+0x104>)
    19d4:	f008 fc93 	bl	a2fe <_ZN6ADG7326enableEb>

        Serial.print(sample * ( 3.33f / 65536 ) , 4); Serial.print(",\t");Serial.flush();
    19d8:	687b      	ldr	r3, [r7, #4]
    19da:	ee07 3a90 	vmov	s15, r3
    19de:	eef8 7a67 	vcvt.f32.u32	s15, s15
    19e2:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 1a50 <_Z27TestElectrodeInputRawValuesv+0x108>
    19e6:	ee67 7a87 	vmul.f32	s15, s15, s14
    19ea:	ee17 0a90 	vmov	r0, s15
    19ee:	f00b ffb1 	bl	d954 <__aeabi_f2d>
    19f2:	4602      	mov	r2, r0
    19f4:	460b      	mov	r3, r1
    19f6:	2104      	movs	r1, #4
    19f8:	ec43 2b10 	vmov	d0, r2, r3
    19fc:	480f      	ldr	r0, [pc, #60]	; (1a3c <_Z27TestElectrodeInputRawValuesv+0xf4>)
    19fe:	f7fe fe1b 	bl	638 <_ZN5Print5printEdi>
    1a02:	4914      	ldr	r1, [pc, #80]	; (1a54 <_Z27TestElectrodeInputRawValuesv+0x10c>)
    1a04:	480d      	ldr	r0, [pc, #52]	; (1a3c <_Z27TestElectrodeInputRawValuesv+0xf4>)
    1a06:	f7fe fddb 	bl	5c0 <_ZN5Print5printEPKc>
    1a0a:	480c      	ldr	r0, [pc, #48]	; (1a3c <_Z27TestElectrodeInputRawValuesv+0xf4>)
    1a0c:	f7fe fe51 	bl	6b2 <_ZN16usb_serial_class5flushEv>
    for (   // Sensing pairs from 0
    1a10:	68fb      	ldr	r3, [r7, #12]
    1a12:	3301      	adds	r3, #1
    1a14:	60fb      	str	r3, [r7, #12]
            senseBElectrode < g_iElectrodes;
    1a16:	4b10      	ldr	r3, [pc, #64]	; (1a58 <_Z27TestElectrodeInputRawValuesv+0x110>)
    1a18:	681b      	ldr	r3, [r3, #0]
    1a1a:	68fa      	ldr	r2, [r7, #12]
    1a1c:	429a      	cmp	r2, r3
    1a1e:	d3b2      	bcc.n	1986 <_Z27TestElectrodeInputRawValuesv+0x3e>
    }
    Serial.print("\r\n");Serial.flush();
    1a20:	490e      	ldr	r1, [pc, #56]	; (1a5c <_Z27TestElectrodeInputRawValuesv+0x114>)
    1a22:	4806      	ldr	r0, [pc, #24]	; (1a3c <_Z27TestElectrodeInputRawValuesv+0xf4>)
    1a24:	f7fe fdcc 	bl	5c0 <_ZN5Print5printEPKc>
    1a28:	4804      	ldr	r0, [pc, #16]	; (1a3c <_Z27TestElectrodeInputRawValuesv+0xf4>)
    1a2a:	f7fe fe42 	bl	6b2 <_ZN16usb_serial_class5flushEv>
}
    1a2e:	bf00      	nop
    1a30:	3710      	adds	r7, #16
    1a32:	46bd      	mov	sp, r7
    1a34:	bd80      	pop	{r7, pc}
    1a36:	bf00      	nop
    1a38:	0000f028 	.word	0x0000f028
    1a3c:	1fff078c 	.word	0x1fff078c
    1a40:	1fff098c 	.word	0x1fff098c
    1a44:	1fff09ec 	.word	0x1fff09ec
    1a48:	1fff08cc 	.word	0x1fff08cc
    1a4c:	1fff092c 	.word	0x1fff092c
    1a50:	38551eb8 	.word	0x38551eb8
    1a54:	0000f024 	.word	0x0000f024
    1a58:	1fff0738 	.word	0x1fff0738
    1a5c:	0000efac 	.word	0x0000efac

00001a60 <_Z10TestInputsv>:

void TestInputs()
{
    1a60:	b580      	push	{r7, lr}
    1a62:	b086      	sub	sp, #24
    1a64:	af00      	add	r7, sp, #0
    Serial.println("\r\nInputs");
    1a66:	496c      	ldr	r1, [pc, #432]	; (1c18 <_Z10TestInputsv+0x1b8>)
    1a68:	486c      	ldr	r0, [pc, #432]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1a6a:	f7fe fdf9 	bl	660 <_ZN5Print7printlnEPKc>
    Serial.flush();
    1a6e:	486b      	ldr	r0, [pc, #428]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1a70:	f7fe fe1f 	bl	6b2 <_ZN16usb_serial_class5flushEv>

    driveSourceMux.enable(false);
    1a74:	2100      	movs	r1, #0
    1a76:	486a      	ldr	r0, [pc, #424]	; (1c20 <_Z10TestInputsv+0x1c0>)
    1a78:	f008 fc41 	bl	a2fe <_ZN6ADG7326enableEb>
    driveGroundMux.enable(false);
    1a7c:	2100      	movs	r1, #0
    1a7e:	4869      	ldr	r0, [pc, #420]	; (1c24 <_Z10TestInputsv+0x1c4>)
    1a80:	f008 fc3d 	bl	a2fe <_ZN6ADG7326enableEb>
    senseAMux.enable(false);
    1a84:	2100      	movs	r1, #0
    1a86:	4868      	ldr	r0, [pc, #416]	; (1c28 <_Z10TestInputsv+0x1c8>)
    1a88:	f008 fc39 	bl	a2fe <_ZN6ADG7326enableEb>
    senseBMux.enable(false);
    1a8c:	2100      	movs	r1, #0
    1a8e:	4867      	ldr	r0, [pc, #412]	; (1c2c <_Z10TestInputsv+0x1cc>)
    1a90:	f008 fc35 	bl	a2fe <_ZN6ADG7326enableEb>

        
    // Loop over all sensing pairs
    for (   // Sensing pairs from 0
            unsigned int senseAElectrode = 0, senseBElectrode = 1;
    1a94:	2300      	movs	r3, #0
    1a96:	60fb      	str	r3, [r7, #12]
    1a98:	2301      	movs	r3, #1
    1a9a:	617b      	str	r3, [r7, #20]
    for (   // Sensing pairs from 0
    1a9c:	e04d      	b.n	1b3a <_Z10TestInputsv+0xda>

            // Rotate by one each iteration
            ++senseBElectrode
        )
    {
        senseAMux.select((ADG732::Channel) transformElectrode(senseAElectrode));
    1a9e:	68f8      	ldr	r0, [r7, #12]
    1aa0:	f7ff fc78 	bl	1394 <_Z18transformElectrodej>
    1aa4:	4603      	mov	r3, r0
    1aa6:	b2db      	uxtb	r3, r3
    1aa8:	4619      	mov	r1, r3
    1aaa:	485f      	ldr	r0, [pc, #380]	; (1c28 <_Z10TestInputsv+0x1c8>)
    1aac:	f008 fbca 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        senseBMux.select((ADG732::Channel) transformElectrode(senseBElectrode));
    1ab0:	6978      	ldr	r0, [r7, #20]
    1ab2:	f7ff fc6f 	bl	1394 <_Z18transformElectrodej>
    1ab6:	4603      	mov	r3, r0
    1ab8:	b2db      	uxtb	r3, r3
    1aba:	4619      	mov	r1, r3
    1abc:	485b      	ldr	r0, [pc, #364]	; (1c2c <_Z10TestInputsv+0x1cc>)
    1abe:	f008 fbc1 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        senseAMux.enable(true); senseBMux.enable(true);
    1ac2:	2101      	movs	r1, #1
    1ac4:	4858      	ldr	r0, [pc, #352]	; (1c28 <_Z10TestInputsv+0x1c8>)
    1ac6:	f008 fc1a 	bl	a2fe <_ZN6ADG7326enableEb>
    1aca:	2101      	movs	r1, #1
    1acc:	4857      	ldr	r0, [pc, #348]	; (1c2c <_Z10TestInputsv+0x1cc>)
    1ace:	f008 fc16 	bl	a2fe <_ZN6ADG7326enableEb>
        
        adc_collect_samples(const_cast<uint32_t * >(g_aiSamples), g_iSamples);
    1ad2:	4b57      	ldr	r3, [pc, #348]	; (1c30 <_Z10TestInputsv+0x1d0>)
    1ad4:	681b      	ldr	r3, [r3, #0]
    1ad6:	b2db      	uxtb	r3, r3
    1ad8:	4619      	mov	r1, r3
    1ada:	4856      	ldr	r0, [pc, #344]	; (1c34 <_Z10TestInputsv+0x1d4>)
    1adc:	f002 fb5a 	bl	4194 <_Z19adc_collect_samplesPmh>

        senseAMux.enable(false); senseBMux.enable(false);
    1ae0:	2100      	movs	r1, #0
    1ae2:	4851      	ldr	r0, [pc, #324]	; (1c28 <_Z10TestInputsv+0x1c8>)
    1ae4:	f008 fc0b 	bl	a2fe <_ZN6ADG7326enableEb>
    1ae8:	2100      	movs	r1, #0
    1aea:	4850      	ldr	r0, [pc, #320]	; (1c2c <_Z10TestInputsv+0x1cc>)
    1aec:	f008 fc07 	bl	a2fe <_ZN6ADG7326enableEb>

        float magnitude = eit_iq_demodulation ( const_cast<uint32_t const * >(&g_aiSamples[g_iSample_rubbish]), g_iSamples_useful, g_iSamples_per_cycle);
    1af0:	4b51      	ldr	r3, [pc, #324]	; (1c38 <_Z10TestInputsv+0x1d8>)
    1af2:	681b      	ldr	r3, [r3, #0]
    1af4:	009b      	lsls	r3, r3, #2
    1af6:	4a4f      	ldr	r2, [pc, #316]	; (1c34 <_Z10TestInputsv+0x1d4>)
    1af8:	1898      	adds	r0, r3, r2
    1afa:	4b50      	ldr	r3, [pc, #320]	; (1c3c <_Z10TestInputsv+0x1dc>)
    1afc:	681b      	ldr	r3, [r3, #0]
    1afe:	b2d9      	uxtb	r1, r3
    1b00:	4b4f      	ldr	r3, [pc, #316]	; (1c40 <_Z10TestInputsv+0x1e0>)
    1b02:	681b      	ldr	r3, [r3, #0]
    1b04:	b2da      	uxtb	r2, r3
    1b06:	2300      	movs	r3, #0
    1b08:	f7ff fb18 	bl	113c <_Z19eit_iq_demodulationPKmhhb>
    1b0c:	ed87 0a00 	vstr	s0, [r7]

        Serial.print(magnitude, 4); Serial.print(",\t");Serial.flush();
    1b10:	6838      	ldr	r0, [r7, #0]
    1b12:	f00b ff1f 	bl	d954 <__aeabi_f2d>
    1b16:	4602      	mov	r2, r0
    1b18:	460b      	mov	r3, r1
    1b1a:	2104      	movs	r1, #4
    1b1c:	ec43 2b10 	vmov	d0, r2, r3
    1b20:	483e      	ldr	r0, [pc, #248]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1b22:	f7fe fd89 	bl	638 <_ZN5Print5printEdi>
    1b26:	4947      	ldr	r1, [pc, #284]	; (1c44 <_Z10TestInputsv+0x1e4>)
    1b28:	483c      	ldr	r0, [pc, #240]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1b2a:	f7fe fd49 	bl	5c0 <_ZN5Print5printEPKc>
    1b2e:	483b      	ldr	r0, [pc, #236]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1b30:	f7fe fdbf 	bl	6b2 <_ZN16usb_serial_class5flushEv>
    for (   // Sensing pairs from 0
    1b34:	697b      	ldr	r3, [r7, #20]
    1b36:	3301      	adds	r3, #1
    1b38:	617b      	str	r3, [r7, #20]
            senseBElectrode < g_iElectrodes;
    1b3a:	4b43      	ldr	r3, [pc, #268]	; (1c48 <_Z10TestInputsv+0x1e8>)
    1b3c:	681b      	ldr	r3, [r3, #0]
    1b3e:	697a      	ldr	r2, [r7, #20]
    1b40:	429a      	cmp	r2, r3
    1b42:	d3ac      	bcc.n	1a9e <_Z10TestInputsv+0x3e>
    }

    Serial.print("\r\n");Serial.flush();
    1b44:	4941      	ldr	r1, [pc, #260]	; (1c4c <_Z10TestInputsv+0x1ec>)
    1b46:	4835      	ldr	r0, [pc, #212]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1b48:	f7fe fd3a 	bl	5c0 <_ZN5Print5printEPKc>
    1b4c:	4833      	ldr	r0, [pc, #204]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1b4e:	f7fe fdb0 	bl	6b2 <_ZN16usb_serial_class5flushEv>

        // Loop over all sensing pairs
    for (   // Sensing pairs from 0
            unsigned int senseAElectrode = 0, senseBElectrode = 1;
    1b52:	2300      	movs	r3, #0
    1b54:	60bb      	str	r3, [r7, #8]
    1b56:	2301      	movs	r3, #1
    1b58:	613b      	str	r3, [r7, #16]
    for (   // Sensing pairs from 0
    1b5a:	e04d      	b.n	1bf8 <_Z10TestInputsv+0x198>

            // Rotate by one each iteration
            ++senseBElectrode
        )
    {
        senseBMux.select((ADG732::Channel) transformElectrode(senseAElectrode));
    1b5c:	68b8      	ldr	r0, [r7, #8]
    1b5e:	f7ff fc19 	bl	1394 <_Z18transformElectrodej>
    1b62:	4603      	mov	r3, r0
    1b64:	b2db      	uxtb	r3, r3
    1b66:	4619      	mov	r1, r3
    1b68:	4830      	ldr	r0, [pc, #192]	; (1c2c <_Z10TestInputsv+0x1cc>)
    1b6a:	f008 fb6b 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        senseAMux.select((ADG732::Channel) transformElectrode(senseBElectrode));
    1b6e:	6938      	ldr	r0, [r7, #16]
    1b70:	f7ff fc10 	bl	1394 <_Z18transformElectrodej>
    1b74:	4603      	mov	r3, r0
    1b76:	b2db      	uxtb	r3, r3
    1b78:	4619      	mov	r1, r3
    1b7a:	482b      	ldr	r0, [pc, #172]	; (1c28 <_Z10TestInputsv+0x1c8>)
    1b7c:	f008 fb62 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        senseAMux.enable(true); senseBMux.enable(true);
    1b80:	2101      	movs	r1, #1
    1b82:	4829      	ldr	r0, [pc, #164]	; (1c28 <_Z10TestInputsv+0x1c8>)
    1b84:	f008 fbbb 	bl	a2fe <_ZN6ADG7326enableEb>
    1b88:	2101      	movs	r1, #1
    1b8a:	4828      	ldr	r0, [pc, #160]	; (1c2c <_Z10TestInputsv+0x1cc>)
    1b8c:	f008 fbb7 	bl	a2fe <_ZN6ADG7326enableEb>
        
        adc_collect_samples(const_cast<uint32_t * >(g_aiSamples), g_iSamples);
    1b90:	4b27      	ldr	r3, [pc, #156]	; (1c30 <_Z10TestInputsv+0x1d0>)
    1b92:	681b      	ldr	r3, [r3, #0]
    1b94:	b2db      	uxtb	r3, r3
    1b96:	4619      	mov	r1, r3
    1b98:	4826      	ldr	r0, [pc, #152]	; (1c34 <_Z10TestInputsv+0x1d4>)
    1b9a:	f002 fafb 	bl	4194 <_Z19adc_collect_samplesPmh>

        senseAMux.enable(false); senseBMux.enable(false);
    1b9e:	2100      	movs	r1, #0
    1ba0:	4821      	ldr	r0, [pc, #132]	; (1c28 <_Z10TestInputsv+0x1c8>)
    1ba2:	f008 fbac 	bl	a2fe <_ZN6ADG7326enableEb>
    1ba6:	2100      	movs	r1, #0
    1ba8:	4820      	ldr	r0, [pc, #128]	; (1c2c <_Z10TestInputsv+0x1cc>)
    1baa:	f008 fba8 	bl	a2fe <_ZN6ADG7326enableEb>

        float magnitude = eit_iq_demodulation ( const_cast<uint32_t const * >(&g_aiSamples[g_iSample_rubbish]), g_iSamples_useful, g_iSamples_per_cycle);
    1bae:	4b22      	ldr	r3, [pc, #136]	; (1c38 <_Z10TestInputsv+0x1d8>)
    1bb0:	681b      	ldr	r3, [r3, #0]
    1bb2:	009b      	lsls	r3, r3, #2
    1bb4:	4a1f      	ldr	r2, [pc, #124]	; (1c34 <_Z10TestInputsv+0x1d4>)
    1bb6:	1898      	adds	r0, r3, r2
    1bb8:	4b20      	ldr	r3, [pc, #128]	; (1c3c <_Z10TestInputsv+0x1dc>)
    1bba:	681b      	ldr	r3, [r3, #0]
    1bbc:	b2d9      	uxtb	r1, r3
    1bbe:	4b20      	ldr	r3, [pc, #128]	; (1c40 <_Z10TestInputsv+0x1e0>)
    1bc0:	681b      	ldr	r3, [r3, #0]
    1bc2:	b2da      	uxtb	r2, r3
    1bc4:	2300      	movs	r3, #0
    1bc6:	f7ff fab9 	bl	113c <_Z19eit_iq_demodulationPKmhhb>
    1bca:	ed87 0a01 	vstr	s0, [r7, #4]

        Serial.print(magnitude, 4); Serial.print(",\t");Serial.flush();
    1bce:	6878      	ldr	r0, [r7, #4]
    1bd0:	f00b fec0 	bl	d954 <__aeabi_f2d>
    1bd4:	4602      	mov	r2, r0
    1bd6:	460b      	mov	r3, r1
    1bd8:	2104      	movs	r1, #4
    1bda:	ec43 2b10 	vmov	d0, r2, r3
    1bde:	480f      	ldr	r0, [pc, #60]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1be0:	f7fe fd2a 	bl	638 <_ZN5Print5printEdi>
    1be4:	4917      	ldr	r1, [pc, #92]	; (1c44 <_Z10TestInputsv+0x1e4>)
    1be6:	480d      	ldr	r0, [pc, #52]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1be8:	f7fe fcea 	bl	5c0 <_ZN5Print5printEPKc>
    1bec:	480b      	ldr	r0, [pc, #44]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1bee:	f7fe fd60 	bl	6b2 <_ZN16usb_serial_class5flushEv>
    for (   // Sensing pairs from 0
    1bf2:	693b      	ldr	r3, [r7, #16]
    1bf4:	3301      	adds	r3, #1
    1bf6:	613b      	str	r3, [r7, #16]
            senseBElectrode < g_iElectrodes;
    1bf8:	4b13      	ldr	r3, [pc, #76]	; (1c48 <_Z10TestInputsv+0x1e8>)
    1bfa:	681b      	ldr	r3, [r3, #0]
    1bfc:	693a      	ldr	r2, [r7, #16]
    1bfe:	429a      	cmp	r2, r3
    1c00:	d3ac      	bcc.n	1b5c <_Z10TestInputsv+0xfc>
    }
    Serial.print("\r\n");Serial.flush();
    1c02:	4912      	ldr	r1, [pc, #72]	; (1c4c <_Z10TestInputsv+0x1ec>)
    1c04:	4805      	ldr	r0, [pc, #20]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1c06:	f7fe fcdb 	bl	5c0 <_ZN5Print5printEPKc>
    1c0a:	4804      	ldr	r0, [pc, #16]	; (1c1c <_Z10TestInputsv+0x1bc>)
    1c0c:	f7fe fd51 	bl	6b2 <_ZN16usb_serial_class5flushEv>
}
    1c10:	bf00      	nop
    1c12:	3718      	adds	r7, #24
    1c14:	46bd      	mov	sp, r7
    1c16:	bd80      	pop	{r7, pc}
    1c18:	0000f048 	.word	0x0000f048
    1c1c:	1fff078c 	.word	0x1fff078c
    1c20:	1fff098c 	.word	0x1fff098c
    1c24:	1fff09ec 	.word	0x1fff09ec
    1c28:	1fff08cc 	.word	0x1fff08cc
    1c2c:	1fff092c 	.word	0x1fff092c
    1c30:	1fff0adc 	.word	0x1fff0adc
    1c34:	1fff0ae8 	.word	0x1fff0ae8
    1c38:	1fff0754 	.word	0x1fff0754
    1c3c:	1fff0ad8 	.word	0x1fff0ad8
    1c40:	1fff0750 	.word	0x1fff0750
    1c44:	0000f024 	.word	0x0000f024
    1c48:	1fff0738 	.word	0x1fff0738
    1c4c:	0000efac 	.word	0x0000efac

00001c50 <_Z10TestEITRawv>:


void TestEITRaw()
{
    1c50:	b580      	push	{r7, lr}
    1c52:	b088      	sub	sp, #32
    1c54:	af00      	add	r7, sp, #0
    unsigned int result_counter = 0;
    1c56:	2300      	movs	r3, #0
    1c58:	61fb      	str	r3, [r7, #28]
    Serial.print("\r\nEIT Raw data ");
    1c5a:	4993      	ldr	r1, [pc, #588]	; (1ea8 <_Z10TestEITRawv+0x258>)
    1c5c:	4893      	ldr	r0, [pc, #588]	; (1eac <_Z10TestEITRawv+0x25c>)
    1c5e:	f7fe fcaf 	bl	5c0 <_ZN5Print5printEPKc>
    Serial.print("\r\nO+,O-,\tI+,I-,\tSamples");
    1c62:	4993      	ldr	r1, [pc, #588]	; (1eb0 <_Z10TestEITRawv+0x260>)
    1c64:	4891      	ldr	r0, [pc, #580]	; (1eac <_Z10TestEITRawv+0x25c>)
    1c66:	f7fe fcab 	bl	5c0 <_ZN5Print5printEPKc>
    Serial.flush();
    1c6a:	4890      	ldr	r0, [pc, #576]	; (1eac <_Z10TestEITRawv+0x25c>)
    1c6c:	f7fe fd21 	bl	6b2 <_ZN16usb_serial_class5flushEv>

    driveSourceMux.enable(false);
    1c70:	2100      	movs	r1, #0
    1c72:	4890      	ldr	r0, [pc, #576]	; (1eb4 <_Z10TestEITRawv+0x264>)
    1c74:	f008 fb43 	bl	a2fe <_ZN6ADG7326enableEb>
    driveGroundMux.enable(false);
    1c78:	2100      	movs	r1, #0
    1c7a:	488f      	ldr	r0, [pc, #572]	; (1eb8 <_Z10TestEITRawv+0x268>)
    1c7c:	f008 fb3f 	bl	a2fe <_ZN6ADG7326enableEb>
    senseAMux.enable(false);
    1c80:	2100      	movs	r1, #0
    1c82:	488e      	ldr	r0, [pc, #568]	; (1ebc <_Z10TestEITRawv+0x26c>)
    1c84:	f008 fb3b 	bl	a2fe <_ZN6ADG7326enableEb>
    senseBMux.enable(false);
    1c88:	2100      	movs	r1, #0
    1c8a:	488d      	ldr	r0, [pc, #564]	; (1ec0 <_Z10TestEITRawv+0x270>)
    1c8c:	f008 fb37 	bl	a2fe <_ZN6ADG7326enableEb>

    // Loop over all driving pairs
    for(
            // Start from the 0th electrode
            unsigned int drivingElectrode = 0, 
    1c90:	2300      	movs	r3, #0
    1c92:	61bb      	str	r3, [r7, #24]
                          groundElectrode = ( drivingElectrode + g_iDrivingDist ) % g_iElectrodes;
    1c94:	4b8b      	ldr	r3, [pc, #556]	; (1ec4 <_Z10TestEITRawv+0x274>)
    1c96:	681a      	ldr	r2, [r3, #0]
    1c98:	69bb      	ldr	r3, [r7, #24]
    1c9a:	4413      	add	r3, r2
    1c9c:	4a8a      	ldr	r2, [pc, #552]	; (1ec8 <_Z10TestEITRawv+0x278>)
    1c9e:	6812      	ldr	r2, [r2, #0]
    1ca0:	fbb3 f1f2 	udiv	r1, r3, r2
    1ca4:	fb01 f202 	mul.w	r2, r1, r2
    1ca8:	1a9b      	subs	r3, r3, r2
    1caa:	617b      	str	r3, [r7, #20]
    for(
    1cac:	e0ee      	b.n	1e8c <_Z10TestEITRawv+0x23c>
            // Rotate by 1 each iteration
            groundElectrode  = ( ( ++drivingElectrode ) + g_iDrivingDist ) % g_iElectrodes
        )
    {
        // Drive the selected pair
        driveSourceMux.select((ADG732::Channel) transformElectrode(drivingElectrode));
    1cae:	69b8      	ldr	r0, [r7, #24]
    1cb0:	f7ff fb70 	bl	1394 <_Z18transformElectrodej>
    1cb4:	4603      	mov	r3, r0
    1cb6:	b2db      	uxtb	r3, r3
    1cb8:	4619      	mov	r1, r3
    1cba:	487e      	ldr	r0, [pc, #504]	; (1eb4 <_Z10TestEITRawv+0x264>)
    1cbc:	f008 fac2 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        driveGroundMux.select((ADG732::Channel) transformElectrode(groundElectrode ));
    1cc0:	6978      	ldr	r0, [r7, #20]
    1cc2:	f7ff fb67 	bl	1394 <_Z18transformElectrodej>
    1cc6:	4603      	mov	r3, r0
    1cc8:	b2db      	uxtb	r3, r3
    1cca:	4619      	mov	r1, r3
    1ccc:	487a      	ldr	r0, [pc, #488]	; (1eb8 <_Z10TestEITRawv+0x268>)
    1cce:	f008 fab9 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
        driveGroundMux.enable(true); driveSourceMux.enable(true);
    1cd2:	2101      	movs	r1, #1
    1cd4:	4878      	ldr	r0, [pc, #480]	; (1eb8 <_Z10TestEITRawv+0x268>)
    1cd6:	f008 fb12 	bl	a2fe <_ZN6ADG7326enableEb>
    1cda:	2101      	movs	r1, #1
    1cdc:	4875      	ldr	r0, [pc, #468]	; (1eb4 <_Z10TestEITRawv+0x264>)
    1cde:	f008 fb0e 	bl	a2fe <_ZN6ADG7326enableEb>

        // Loop over all sensing pairs for the current driving arrangement :
        for (   // Sensing pairs start immediately after the driving electrode
                unsigned int senseAElectrode = (drivingElectrode + 1) % g_iElectrodes,
    1ce2:	69bb      	ldr	r3, [r7, #24]
    1ce4:	3301      	adds	r3, #1
    1ce6:	4a78      	ldr	r2, [pc, #480]	; (1ec8 <_Z10TestEITRawv+0x278>)
    1ce8:	6812      	ldr	r2, [r2, #0]
    1cea:	fbb3 f1f2 	udiv	r1, r3, r2
    1cee:	fb01 f202 	mul.w	r2, r1, r2
    1cf2:	1a9b      	subs	r3, r3, r2
    1cf4:	613b      	str	r3, [r7, #16]
                             senseBElectrode = (senseAElectrode  + 1) % g_iElectrodes;
    1cf6:	693b      	ldr	r3, [r7, #16]
    1cf8:	3301      	adds	r3, #1
    1cfa:	4a73      	ldr	r2, [pc, #460]	; (1ec8 <_Z10TestEITRawv+0x278>)
    1cfc:	6812      	ldr	r2, [r2, #0]
    1cfe:	fbb3 f1f2 	udiv	r1, r3, r2
    1d02:	fb01 f202 	mul.w	r2, r1, r2
    1d06:	1a9b      	subs	r3, r3, r2
    1d08:	60fb      	str	r3, [r7, #12]
        for (   // Sensing pairs start immediately after the driving electrode
    1d0a:	e097      	b.n	1e3c <_Z10TestEITRawv+0x1ec>
                senseBElectrode = (   ( senseAElectrode = ( senseAElectrode + 1 ) % g_iElectrodes ) 
                                      + 1 ) % g_iElectrodes 
            )
        {
            // Skip measurements involving the driving electrodes
            if (    ( groundElectrode == senseAElectrode )
    1d0c:	697a      	ldr	r2, [r7, #20]
    1d0e:	693b      	ldr	r3, [r7, #16]
    1d10:	429a      	cmp	r2, r3
    1d12:	d07e      	beq.n	1e12 <_Z10TestEITRawv+0x1c2>
                 || ( groundElectrode == senseBElectrode ) )
    1d14:	697a      	ldr	r2, [r7, #20]
    1d16:	68fb      	ldr	r3, [r7, #12]
    1d18:	429a      	cmp	r2, r3
    1d1a:	d07a      	beq.n	1e12 <_Z10TestEITRawv+0x1c2>
            {
                continue;
            }

            Serial.print("\r\n");
    1d1c:	496b      	ldr	r1, [pc, #428]	; (1ecc <_Z10TestEITRawv+0x27c>)
    1d1e:	4863      	ldr	r0, [pc, #396]	; (1eac <_Z10TestEITRawv+0x25c>)
    1d20:	f7fe fc4e 	bl	5c0 <_ZN5Print5printEPKc>
            Serial.print(drivingElectrode + 1);
    1d24:	69bb      	ldr	r3, [r7, #24]
    1d26:	3301      	adds	r3, #1
    1d28:	4619      	mov	r1, r3
    1d2a:	4860      	ldr	r0, [pc, #384]	; (1eac <_Z10TestEITRawv+0x25c>)
    1d2c:	f7fe fc64 	bl	5f8 <_ZN5Print5printEj>
            Serial.print(',');
    1d30:	212c      	movs	r1, #44	; 0x2c
    1d32:	485e      	ldr	r0, [pc, #376]	; (1eac <_Z10TestEITRawv+0x25c>)
    1d34:	f7fe fc32 	bl	59c <_ZN5Print5printEc>
            Serial.print(groundElectrode + 1);
    1d38:	697b      	ldr	r3, [r7, #20]
    1d3a:	3301      	adds	r3, #1
    1d3c:	4619      	mov	r1, r3
    1d3e:	485b      	ldr	r0, [pc, #364]	; (1eac <_Z10TestEITRawv+0x25c>)
    1d40:	f7fe fc5a 	bl	5f8 <_ZN5Print5printEj>
            Serial.print(",\t");
    1d44:	4962      	ldr	r1, [pc, #392]	; (1ed0 <_Z10TestEITRawv+0x280>)
    1d46:	4859      	ldr	r0, [pc, #356]	; (1eac <_Z10TestEITRawv+0x25c>)
    1d48:	f7fe fc3a 	bl	5c0 <_ZN5Print5printEPKc>
            Serial.print(senseAElectrode + 1);
    1d4c:	693b      	ldr	r3, [r7, #16]
    1d4e:	3301      	adds	r3, #1
    1d50:	4619      	mov	r1, r3
    1d52:	4856      	ldr	r0, [pc, #344]	; (1eac <_Z10TestEITRawv+0x25c>)
    1d54:	f7fe fc50 	bl	5f8 <_ZN5Print5printEj>
            Serial.print(',');
    1d58:	212c      	movs	r1, #44	; 0x2c
    1d5a:	4854      	ldr	r0, [pc, #336]	; (1eac <_Z10TestEITRawv+0x25c>)
    1d5c:	f7fe fc1e 	bl	59c <_ZN5Print5printEc>
            Serial.print(senseBElectrode + 1);
    1d60:	68fb      	ldr	r3, [r7, #12]
    1d62:	3301      	adds	r3, #1
    1d64:	4619      	mov	r1, r3
    1d66:	4851      	ldr	r0, [pc, #324]	; (1eac <_Z10TestEITRawv+0x25c>)
    1d68:	f7fe fc46 	bl	5f8 <_ZN5Print5printEj>
            Serial.print(",\t");
    1d6c:	4958      	ldr	r1, [pc, #352]	; (1ed0 <_Z10TestEITRawv+0x280>)
    1d6e:	484f      	ldr	r0, [pc, #316]	; (1eac <_Z10TestEITRawv+0x25c>)
    1d70:	f7fe fc26 	bl	5c0 <_ZN5Print5printEPKc>
            Serial.flush();
    1d74:	484d      	ldr	r0, [pc, #308]	; (1eac <_Z10TestEITRawv+0x25c>)
    1d76:	f7fe fc9c 	bl	6b2 <_ZN16usb_serial_class5flushEv>

            senseAMux.select((ADG732::Channel) transformElectrode(senseAElectrode));
    1d7a:	6938      	ldr	r0, [r7, #16]
    1d7c:	f7ff fb0a 	bl	1394 <_Z18transformElectrodej>
    1d80:	4603      	mov	r3, r0
    1d82:	b2db      	uxtb	r3, r3
    1d84:	4619      	mov	r1, r3
    1d86:	484d      	ldr	r0, [pc, #308]	; (1ebc <_Z10TestEITRawv+0x26c>)
    1d88:	f008 fa5c 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
            senseBMux.select((ADG732::Channel) transformElectrode(senseBElectrode));
    1d8c:	68f8      	ldr	r0, [r7, #12]
    1d8e:	f7ff fb01 	bl	1394 <_Z18transformElectrodej>
    1d92:	4603      	mov	r3, r0
    1d94:	b2db      	uxtb	r3, r3
    1d96:	4619      	mov	r1, r3
    1d98:	4849      	ldr	r0, [pc, #292]	; (1ec0 <_Z10TestEITRawv+0x270>)
    1d9a:	f008 fa53 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
            senseAMux.enable(true); senseBMux.enable(true);
    1d9e:	2101      	movs	r1, #1
    1da0:	4846      	ldr	r0, [pc, #280]	; (1ebc <_Z10TestEITRawv+0x26c>)
    1da2:	f008 faac 	bl	a2fe <_ZN6ADG7326enableEb>
    1da6:	2101      	movs	r1, #1
    1da8:	4845      	ldr	r0, [pc, #276]	; (1ec0 <_Z10TestEITRawv+0x270>)
    1daa:	f008 faa8 	bl	a2fe <_ZN6ADG7326enableEb>

            adc_collect_samples(const_cast<uint32_t * >(g_aiSamples), g_iSamples);
    1dae:	4b49      	ldr	r3, [pc, #292]	; (1ed4 <_Z10TestEITRawv+0x284>)
    1db0:	681b      	ldr	r3, [r3, #0]
    1db2:	b2db      	uxtb	r3, r3
    1db4:	4619      	mov	r1, r3
    1db6:	4848      	ldr	r0, [pc, #288]	; (1ed8 <_Z10TestEITRawv+0x288>)
    1db8:	f002 f9ec 	bl	4194 <_Z19adc_collect_samplesPmh>

            senseAMux.enable(false); senseBMux.enable(false);
    1dbc:	2100      	movs	r1, #0
    1dbe:	483f      	ldr	r0, [pc, #252]	; (1ebc <_Z10TestEITRawv+0x26c>)
    1dc0:	f008 fa9d 	bl	a2fe <_ZN6ADG7326enableEb>
    1dc4:	2100      	movs	r1, #0
    1dc6:	483e      	ldr	r0, [pc, #248]	; (1ec0 <_Z10TestEITRawv+0x270>)
    1dc8:	f008 fa99 	bl	a2fe <_ZN6ADG7326enableEb>

            for (int i = 0; 
    1dcc:	2300      	movs	r3, #0
    1dce:	60bb      	str	r3, [r7, #8]
    1dd0:	e013      	b.n	1dfa <_Z10TestEITRawv+0x1aa>
                i < g_iSamples_useful;
                ++i)
            {
                const uint16_t sample = g_aiSamples[g_iSample_rubbish + i];
    1dd2:	4b42      	ldr	r3, [pc, #264]	; (1edc <_Z10TestEITRawv+0x28c>)
    1dd4:	681a      	ldr	r2, [r3, #0]
    1dd6:	68bb      	ldr	r3, [r7, #8]
    1dd8:	4413      	add	r3, r2
    1dda:	4a3f      	ldr	r2, [pc, #252]	; (1ed8 <_Z10TestEITRawv+0x288>)
    1ddc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1de0:	80fb      	strh	r3, [r7, #6]
                Serial.print(sample); Serial.print(", ");
    1de2:	88fb      	ldrh	r3, [r7, #6]
    1de4:	4619      	mov	r1, r3
    1de6:	4831      	ldr	r0, [pc, #196]	; (1eac <_Z10TestEITRawv+0x25c>)
    1de8:	f7fe fbf8 	bl	5dc <_ZN5Print5printEi>
    1dec:	493c      	ldr	r1, [pc, #240]	; (1ee0 <_Z10TestEITRawv+0x290>)
    1dee:	482f      	ldr	r0, [pc, #188]	; (1eac <_Z10TestEITRawv+0x25c>)
    1df0:	f7fe fbe6 	bl	5c0 <_ZN5Print5printEPKc>
            for (int i = 0; 
    1df4:	68bb      	ldr	r3, [r7, #8]
    1df6:	3301      	adds	r3, #1
    1df8:	60bb      	str	r3, [r7, #8]
                i < g_iSamples_useful;
    1dfa:	68ba      	ldr	r2, [r7, #8]
    1dfc:	4b39      	ldr	r3, [pc, #228]	; (1ee4 <_Z10TestEITRawv+0x294>)
    1dfe:	681b      	ldr	r3, [r3, #0]
    1e00:	429a      	cmp	r2, r3
    1e02:	d3e6      	bcc.n	1dd2 <_Z10TestEITRawv+0x182>
            }

            result_counter++;
    1e04:	69fb      	ldr	r3, [r7, #28]
    1e06:	3301      	adds	r3, #1
    1e08:	61fb      	str	r3, [r7, #28]
            Serial.flush();
    1e0a:	4828      	ldr	r0, [pc, #160]	; (1eac <_Z10TestEITRawv+0x25c>)
    1e0c:	f7fe fc51 	bl	6b2 <_ZN16usb_serial_class5flushEv>
    1e10:	e000      	b.n	1e14 <_Z10TestEITRawv+0x1c4>
                continue;
    1e12:	bf00      	nop
                senseBElectrode = (   ( senseAElectrode = ( senseAElectrode + 1 ) % g_iElectrodes ) 
    1e14:	693b      	ldr	r3, [r7, #16]
    1e16:	3301      	adds	r3, #1
    1e18:	4a2b      	ldr	r2, [pc, #172]	; (1ec8 <_Z10TestEITRawv+0x278>)
    1e1a:	6812      	ldr	r2, [r2, #0]
    1e1c:	fbb3 f1f2 	udiv	r1, r3, r2
    1e20:	fb01 f202 	mul.w	r2, r1, r2
    1e24:	1a9b      	subs	r3, r3, r2
    1e26:	613b      	str	r3, [r7, #16]
                                      + 1 ) % g_iElectrodes 
    1e28:	693b      	ldr	r3, [r7, #16]
    1e2a:	3301      	adds	r3, #1
    1e2c:	4a26      	ldr	r2, [pc, #152]	; (1ec8 <_Z10TestEITRawv+0x278>)
    1e2e:	6812      	ldr	r2, [r2, #0]
                senseBElectrode = (   ( senseAElectrode = ( senseAElectrode + 1 ) % g_iElectrodes ) 
    1e30:	fbb3 f1f2 	udiv	r1, r3, r2
    1e34:	fb01 f202 	mul.w	r2, r1, r2
    1e38:	1a9b      	subs	r3, r3, r2
    1e3a:	60fb      	str	r3, [r7, #12]
                  && ( senseBElectrode != drivingElectrode ) );
    1e3c:	693a      	ldr	r2, [r7, #16]
    1e3e:	69bb      	ldr	r3, [r7, #24]
    1e40:	429a      	cmp	r2, r3
    1e42:	d004      	beq.n	1e4e <_Z10TestEITRawv+0x1fe>
    1e44:	68fa      	ldr	r2, [r7, #12]
    1e46:	69bb      	ldr	r3, [r7, #24]
    1e48:	429a      	cmp	r2, r3
    1e4a:	f47f af5f 	bne.w	1d0c <_Z10TestEITRawv+0xbc>
        }

        driveSourceMux.enable(false);
    1e4e:	2100      	movs	r1, #0
    1e50:	4818      	ldr	r0, [pc, #96]	; (1eb4 <_Z10TestEITRawv+0x264>)
    1e52:	f008 fa54 	bl	a2fe <_ZN6ADG7326enableEb>
        driveGroundMux.enable(false);
    1e56:	2100      	movs	r1, #0
    1e58:	4817      	ldr	r0, [pc, #92]	; (1eb8 <_Z10TestEITRawv+0x268>)
    1e5a:	f008 fa50 	bl	a2fe <_ZN6ADG7326enableEb>
        senseAMux.enable(false);
    1e5e:	2100      	movs	r1, #0
    1e60:	4816      	ldr	r0, [pc, #88]	; (1ebc <_Z10TestEITRawv+0x26c>)
    1e62:	f008 fa4c 	bl	a2fe <_ZN6ADG7326enableEb>
        senseBMux.enable(false);
    1e66:	2100      	movs	r1, #0
    1e68:	4815      	ldr	r0, [pc, #84]	; (1ec0 <_Z10TestEITRawv+0x270>)
    1e6a:	f008 fa48 	bl	a2fe <_ZN6ADG7326enableEb>
    for(
    1e6e:	69bb      	ldr	r3, [r7, #24]
    1e70:	3301      	adds	r3, #1
    1e72:	61bb      	str	r3, [r7, #24]
            groundElectrode  = ( ( ++drivingElectrode ) + g_iDrivingDist ) % g_iElectrodes
    1e74:	4b13      	ldr	r3, [pc, #76]	; (1ec4 <_Z10TestEITRawv+0x274>)
    1e76:	681a      	ldr	r2, [r3, #0]
    1e78:	69bb      	ldr	r3, [r7, #24]
    1e7a:	4413      	add	r3, r2
    1e7c:	4a12      	ldr	r2, [pc, #72]	; (1ec8 <_Z10TestEITRawv+0x278>)
    1e7e:	6812      	ldr	r2, [r2, #0]
    1e80:	fbb3 f1f2 	udiv	r1, r3, r2
    1e84:	fb01 f202 	mul.w	r2, r1, r2
    1e88:	1a9b      	subs	r3, r3, r2
    1e8a:	617b      	str	r3, [r7, #20]
            drivingElectrode < g_iElectrodes;
    1e8c:	4b0e      	ldr	r3, [pc, #56]	; (1ec8 <_Z10TestEITRawv+0x278>)
    1e8e:	681b      	ldr	r3, [r3, #0]
    1e90:	69ba      	ldr	r2, [r7, #24]
    1e92:	429a      	cmp	r2, r3
    1e94:	f4ff af0b 	bcc.w	1cae <_Z10TestEITRawv+0x5e>

    }
    Serial.print("\r\n");
    1e98:	490c      	ldr	r1, [pc, #48]	; (1ecc <_Z10TestEITRawv+0x27c>)
    1e9a:	4804      	ldr	r0, [pc, #16]	; (1eac <_Z10TestEITRawv+0x25c>)
    1e9c:	f7fe fb90 	bl	5c0 <_ZN5Print5printEPKc>
}
    1ea0:	bf00      	nop
    1ea2:	3720      	adds	r7, #32
    1ea4:	46bd      	mov	sp, r7
    1ea6:	bd80      	pop	{r7, pc}
    1ea8:	0000f054 	.word	0x0000f054
    1eac:	1fff078c 	.word	0x1fff078c
    1eb0:	0000f064 	.word	0x0000f064
    1eb4:	1fff098c 	.word	0x1fff098c
    1eb8:	1fff09ec 	.word	0x1fff09ec
    1ebc:	1fff08cc 	.word	0x1fff08cc
    1ec0:	1fff092c 	.word	0x1fff092c
    1ec4:	1fff073c 	.word	0x1fff073c
    1ec8:	1fff0738 	.word	0x1fff0738
    1ecc:	0000efac 	.word	0x0000efac
    1ed0:	0000f024 	.word	0x0000f024
    1ed4:	1fff0adc 	.word	0x1fff0adc
    1ed8:	1fff0ae8 	.word	0x1fff0ae8
    1edc:	1fff0754 	.word	0x1fff0754
    1ee0:	0000efc0 	.word	0x0000efc0
    1ee4:	1fff0ad8 	.word	0x1fff0ad8

00001ee8 <_Z33collect_and_print_samples_analyseb>:


void collect_and_print_samples_analyse(bool printSamples)
{
    1ee8:	b5b0      	push	{r4, r5, r7, lr}
    1eea:	b08e      	sub	sp, #56	; 0x38
    1eec:	af00      	add	r7, sp, #0
    1eee:	4603      	mov	r3, r0
    1ef0:	71fb      	strb	r3, [r7, #7]
    uint16_t smallest = 0xFFFF;
    1ef2:	f64f 73ff 	movw	r3, #65535	; 0xffff
    1ef6:	86fb      	strh	r3, [r7, #54]	; 0x36
    uint16_t largest = 0x0000;
    1ef8:	2300      	movs	r3, #0
    1efa:	86bb      	strh	r3, [r7, #52]	; 0x34
    uint32_t sum = 0x00000000;
    1efc:	2300      	movs	r3, #0
    1efe:	633b      	str	r3, [r7, #48]	; 0x30

    adc_collect_samples(const_cast<uint32_t * >(g_aiSamples), g_iSamples);
    1f00:	4b96      	ldr	r3, [pc, #600]	; (215c <_Z33collect_and_print_samples_analyseb+0x274>)
    1f02:	681b      	ldr	r3, [r3, #0]
    1f04:	b2db      	uxtb	r3, r3
    1f06:	4619      	mov	r1, r3
    1f08:	4895      	ldr	r0, [pc, #596]	; (2160 <_Z33collect_and_print_samples_analyseb+0x278>)
    1f0a:	f002 f943 	bl	4194 <_Z19adc_collect_samplesPmh>

    Serial.print("Sampling : \r\n");
    1f0e:	4995      	ldr	r1, [pc, #596]	; (2164 <_Z33collect_and_print_samples_analyseb+0x27c>)
    1f10:	4895      	ldr	r0, [pc, #596]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    1f12:	f7fe fb55 	bl	5c0 <_ZN5Print5printEPKc>
    Serial.print("\tsamples: "); Serial.print(g_iSamples_useful);Serial.print("\r\n");
    1f16:	4995      	ldr	r1, [pc, #596]	; (216c <_Z33collect_and_print_samples_analyseb+0x284>)
    1f18:	4893      	ldr	r0, [pc, #588]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    1f1a:	f7fe fb51 	bl	5c0 <_ZN5Print5printEPKc>
    1f1e:	4b94      	ldr	r3, [pc, #592]	; (2170 <_Z33collect_and_print_samples_analyseb+0x288>)
    1f20:	681b      	ldr	r3, [r3, #0]
    1f22:	4619      	mov	r1, r3
    1f24:	4890      	ldr	r0, [pc, #576]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    1f26:	f7fe fb77 	bl	618 <_ZN5Print5printEm>
    1f2a:	4992      	ldr	r1, [pc, #584]	; (2174 <_Z33collect_and_print_samples_analyseb+0x28c>)
    1f2c:	488e      	ldr	r0, [pc, #568]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    1f2e:	f7fe fb47 	bl	5c0 <_ZN5Print5printEPKc>

    for (int i = 0; 
    1f32:	2300      	movs	r3, #0
    1f34:	62fb      	str	r3, [r7, #44]	; 0x2c
    1f36:	e026      	b.n	1f86 <_Z33collect_and_print_samples_analyseb+0x9e>
         i < g_iSamples_useful;
         ++i)
    {
        const uint16_t sample = g_aiSamples[g_iSample_rubbish + i];
    1f38:	4b8f      	ldr	r3, [pc, #572]	; (2178 <_Z33collect_and_print_samples_analyseb+0x290>)
    1f3a:	681a      	ldr	r2, [r3, #0]
    1f3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f3e:	4413      	add	r3, r2
    1f40:	4a87      	ldr	r2, [pc, #540]	; (2160 <_Z33collect_and_print_samples_analyseb+0x278>)
    1f42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1f46:	81fb      	strh	r3, [r7, #14]
        sum += sample;
    1f48:	89fb      	ldrh	r3, [r7, #14]
    1f4a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    1f4c:	4413      	add	r3, r2
    1f4e:	633b      	str	r3, [r7, #48]	; 0x30
        if (smallest > sample ) smallest = sample;
    1f50:	8efa      	ldrh	r2, [r7, #54]	; 0x36
    1f52:	89fb      	ldrh	r3, [r7, #14]
    1f54:	429a      	cmp	r2, r3
    1f56:	d901      	bls.n	1f5c <_Z33collect_and_print_samples_analyseb+0x74>
    1f58:	89fb      	ldrh	r3, [r7, #14]
    1f5a:	86fb      	strh	r3, [r7, #54]	; 0x36
        if (largest < sample ) largest = sample;
    1f5c:	8eba      	ldrh	r2, [r7, #52]	; 0x34
    1f5e:	89fb      	ldrh	r3, [r7, #14]
    1f60:	429a      	cmp	r2, r3
    1f62:	d201      	bcs.n	1f68 <_Z33collect_and_print_samples_analyseb+0x80>
    1f64:	89fb      	ldrh	r3, [r7, #14]
    1f66:	86bb      	strh	r3, [r7, #52]	; 0x34
        if(printSamples) { Serial.print(sample); Serial.print(", "); }
    1f68:	79fb      	ldrb	r3, [r7, #7]
    1f6a:	2b00      	cmp	r3, #0
    1f6c:	d008      	beq.n	1f80 <_Z33collect_and_print_samples_analyseb+0x98>
    1f6e:	89fb      	ldrh	r3, [r7, #14]
    1f70:	4619      	mov	r1, r3
    1f72:	487d      	ldr	r0, [pc, #500]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    1f74:	f7fe fb32 	bl	5dc <_ZN5Print5printEi>
    1f78:	4980      	ldr	r1, [pc, #512]	; (217c <_Z33collect_and_print_samples_analyseb+0x294>)
    1f7a:	487b      	ldr	r0, [pc, #492]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    1f7c:	f7fe fb20 	bl	5c0 <_ZN5Print5printEPKc>
    for (int i = 0; 
    1f80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f82:	3301      	adds	r3, #1
    1f84:	62fb      	str	r3, [r7, #44]	; 0x2c
         i < g_iSamples_useful;
    1f86:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    1f88:	4b79      	ldr	r3, [pc, #484]	; (2170 <_Z33collect_and_print_samples_analyseb+0x288>)
    1f8a:	681b      	ldr	r3, [r3, #0]
    1f8c:	429a      	cmp	r2, r3
    1f8e:	d3d3      	bcc.n	1f38 <_Z33collect_and_print_samples_analyseb+0x50>
    }

    const float mean =  sum / (float) g_iSamples_useful;
    1f90:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    1f92:	ee07 3a90 	vmov	s15, r3
    1f96:	eef8 6a67 	vcvt.f32.u32	s13, s15
    1f9a:	4b75      	ldr	r3, [pc, #468]	; (2170 <_Z33collect_and_print_samples_analyseb+0x288>)
    1f9c:	681b      	ldr	r3, [r3, #0]
    1f9e:	ee07 3a90 	vmov	s15, r3
    1fa2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
    1fa6:	eec6 7a87 	vdiv.f32	s15, s13, s14
    1faa:	edc7 7a08 	vstr	s15, [r7, #32]
    if(printSamples) Serial.print("\r\n");
    1fae:	79fb      	ldrb	r3, [r7, #7]
    1fb0:	2b00      	cmp	r3, #0
    1fb2:	d003      	beq.n	1fbc <_Z33collect_and_print_samples_analyseb+0xd4>
    1fb4:	496f      	ldr	r1, [pc, #444]	; (2174 <_Z33collect_and_print_samples_analyseb+0x28c>)
    1fb6:	486c      	ldr	r0, [pc, #432]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    1fb8:	f7fe fb02 	bl	5c0 <_ZN5Print5printEPKc>
    Serial.print("\tmin: ");  Serial.print(smallest * ( 3.33f / 65536 ), 4); Serial.print("\r\n");
    1fbc:	4970      	ldr	r1, [pc, #448]	; (2180 <_Z33collect_and_print_samples_analyseb+0x298>)
    1fbe:	486a      	ldr	r0, [pc, #424]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    1fc0:	f7fe fafe 	bl	5c0 <_ZN5Print5printEPKc>
    1fc4:	8efb      	ldrh	r3, [r7, #54]	; 0x36
    1fc6:	ee07 3a90 	vmov	s15, r3
    1fca:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    1fce:	ed9f 7a6d 	vldr	s14, [pc, #436]	; 2184 <_Z33collect_and_print_samples_analyseb+0x29c>
    1fd2:	ee67 7a87 	vmul.f32	s15, s15, s14
    1fd6:	ee17 0a90 	vmov	r0, s15
    1fda:	f00b fcbb 	bl	d954 <__aeabi_f2d>
    1fde:	4602      	mov	r2, r0
    1fe0:	460b      	mov	r3, r1
    1fe2:	2104      	movs	r1, #4
    1fe4:	ec43 2b10 	vmov	d0, r2, r3
    1fe8:	485f      	ldr	r0, [pc, #380]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    1fea:	f7fe fb25 	bl	638 <_ZN5Print5printEdi>
    1fee:	4961      	ldr	r1, [pc, #388]	; (2174 <_Z33collect_and_print_samples_analyseb+0x28c>)
    1ff0:	485d      	ldr	r0, [pc, #372]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    1ff2:	f7fe fae5 	bl	5c0 <_ZN5Print5printEPKc>
    Serial.print("\tmax: ");  Serial.print(largest  * ( 3.33f / 65536 ), 4); Serial.print("\r\n");
    1ff6:	4964      	ldr	r1, [pc, #400]	; (2188 <_Z33collect_and_print_samples_analyseb+0x2a0>)
    1ff8:	485b      	ldr	r0, [pc, #364]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    1ffa:	f7fe fae1 	bl	5c0 <_ZN5Print5printEPKc>
    1ffe:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
    2000:	ee07 3a90 	vmov	s15, r3
    2004:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    2008:	ed9f 7a5e 	vldr	s14, [pc, #376]	; 2184 <_Z33collect_and_print_samples_analyseb+0x29c>
    200c:	ee67 7a87 	vmul.f32	s15, s15, s14
    2010:	ee17 0a90 	vmov	r0, s15
    2014:	f00b fc9e 	bl	d954 <__aeabi_f2d>
    2018:	4602      	mov	r2, r0
    201a:	460b      	mov	r3, r1
    201c:	2104      	movs	r1, #4
    201e:	ec43 2b10 	vmov	d0, r2, r3
    2022:	4851      	ldr	r0, [pc, #324]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    2024:	f7fe fb08 	bl	638 <_ZN5Print5printEdi>
    2028:	4952      	ldr	r1, [pc, #328]	; (2174 <_Z33collect_and_print_samples_analyseb+0x28c>)
    202a:	484f      	ldr	r0, [pc, #316]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    202c:	f7fe fac8 	bl	5c0 <_ZN5Print5printEPKc>
    Serial.print("\tmean: "); Serial.print(mean     * ( 3.33f / 65536 ), 4); Serial.print("\r\n");
    2030:	4956      	ldr	r1, [pc, #344]	; (218c <_Z33collect_and_print_samples_analyseb+0x2a4>)
    2032:	484d      	ldr	r0, [pc, #308]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    2034:	f7fe fac4 	bl	5c0 <_ZN5Print5printEPKc>
    2038:	edd7 7a08 	vldr	s15, [r7, #32]
    203c:	ed9f 7a51 	vldr	s14, [pc, #324]	; 2184 <_Z33collect_and_print_samples_analyseb+0x29c>
    2040:	ee67 7a87 	vmul.f32	s15, s15, s14
    2044:	ee17 0a90 	vmov	r0, s15
    2048:	f00b fc84 	bl	d954 <__aeabi_f2d>
    204c:	4602      	mov	r2, r0
    204e:	460b      	mov	r3, r1
    2050:	2104      	movs	r1, #4
    2052:	ec43 2b10 	vmov	d0, r2, r3
    2056:	4844      	ldr	r0, [pc, #272]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    2058:	f7fe faee 	bl	638 <_ZN5Print5printEdi>
    205c:	4945      	ldr	r1, [pc, #276]	; (2174 <_Z33collect_and_print_samples_analyseb+0x28c>)
    205e:	4842      	ldr	r0, [pc, #264]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    2060:	f7fe faae 	bl	5c0 <_ZN5Print5printEPKc>

    float mean_squares = 0;
    2064:	f04f 0300 	mov.w	r3, #0
    2068:	62bb      	str	r3, [r7, #40]	; 0x28

    for (int i = 0; 
    206a:	2300      	movs	r3, #0
    206c:	627b      	str	r3, [r7, #36]	; 0x24
    206e:	e02f      	b.n	20d0 <_Z33collect_and_print_samples_analyseb+0x1e8>
         i < g_iSamples_useful;
         ++i)
    {
        const float sample = g_aiSamples[g_iSample_rubbish + i];
    2070:	4b41      	ldr	r3, [pc, #260]	; (2178 <_Z33collect_and_print_samples_analyseb+0x290>)
    2072:	681a      	ldr	r2, [r3, #0]
    2074:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2076:	4413      	add	r3, r2
    2078:	4a39      	ldr	r2, [pc, #228]	; (2160 <_Z33collect_and_print_samples_analyseb+0x278>)
    207a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    207e:	ee07 3a90 	vmov	s15, r3
    2082:	eef8 7a67 	vcvt.f32.u32	s15, s15
    2086:	edc7 7a05 	vstr	s15, [r7, #20]
        const float mean_f = mean;
    208a:	6a3b      	ldr	r3, [r7, #32]
    208c:	613b      	str	r3, [r7, #16]
        mean_squares += pow(sample - mean_f, 2);
    208e:	ed97 7a05 	vldr	s14, [r7, #20]
    2092:	edd7 7a04 	vldr	s15, [r7, #16]
    2096:	ee77 7a67 	vsub.f32	s15, s14, s15
    209a:	2002      	movs	r0, #2
    209c:	eeb0 0a67 	vmov.f32	s0, s15
    20a0:	f002 f906 	bl	42b0 <_ZSt3powIfiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_XsrSt12__is_integerIS2_E7__valueEE6__typeENS4_IS3_XsrS5_IS3_E7__valueEE6__typeEE6__typeES2_S3_>
    20a4:	ec55 4b10 	vmov	r4, r5, d0
    20a8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    20aa:	f00b fc53 	bl	d954 <__aeabi_f2d>
    20ae:	4602      	mov	r2, r0
    20b0:	460b      	mov	r3, r1
    20b2:	4620      	mov	r0, r4
    20b4:	4629      	mov	r1, r5
    20b6:	f00b faef 	bl	d698 <__adddf3>
    20ba:	4602      	mov	r2, r0
    20bc:	460b      	mov	r3, r1
    20be:	4610      	mov	r0, r2
    20c0:	4619      	mov	r1, r3
    20c2:	f00b ff6f 	bl	dfa4 <__aeabi_d2f>
    20c6:	4603      	mov	r3, r0
    20c8:	62bb      	str	r3, [r7, #40]	; 0x28
    for (int i = 0; 
    20ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    20cc:	3301      	adds	r3, #1
    20ce:	627b      	str	r3, [r7, #36]	; 0x24
         i < g_iSamples_useful;
    20d0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    20d2:	4b27      	ldr	r3, [pc, #156]	; (2170 <_Z33collect_and_print_samples_analyseb+0x288>)
    20d4:	681b      	ldr	r3, [r3, #0]
    20d6:	429a      	cmp	r2, r3
    20d8:	d3ca      	bcc.n	2070 <_Z33collect_and_print_samples_analyseb+0x188>
    }
    float variance = (mean_squares / g_iSamples_useful) * pow( 3.33f / 65536, 2 );
    20da:	4b25      	ldr	r3, [pc, #148]	; (2170 <_Z33collect_and_print_samples_analyseb+0x288>)
    20dc:	681b      	ldr	r3, [r3, #0]
    20de:	ee07 3a90 	vmov	s15, r3
    20e2:	eef8 7a67 	vcvt.f32.u32	s15, s15
    20e6:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
    20ea:	eec7 6a27 	vdiv.f32	s13, s14, s15
    20ee:	ee16 0a90 	vmov	r0, s13
    20f2:	f00b fc2f 	bl	d954 <__aeabi_f2d>
    20f6:	4604      	mov	r4, r0
    20f8:	460d      	mov	r5, r1
    20fa:	2002      	movs	r0, #2
    20fc:	ed9f 0a21 	vldr	s0, [pc, #132]	; 2184 <_Z33collect_and_print_samples_analyseb+0x29c>
    2100:	f002 f8d6 	bl	42b0 <_ZSt3powIfiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_XsrSt12__is_integerIS2_E7__valueEE6__typeENS4_IS3_XsrS5_IS3_E7__valueEE6__typeEE6__typeES2_S3_>
    2104:	ec53 2b10 	vmov	r2, r3, d0
    2108:	4620      	mov	r0, r4
    210a:	4629      	mov	r1, r5
    210c:	f00b fc7a 	bl	da04 <__aeabi_dmul>
    2110:	4602      	mov	r2, r0
    2112:	460b      	mov	r3, r1
    2114:	4610      	mov	r0, r2
    2116:	4619      	mov	r1, r3
    2118:	f00b ff44 	bl	dfa4 <__aeabi_d2f>
    211c:	4603      	mov	r3, r0
    211e:	61fb      	str	r3, [r7, #28]
    float sigma = sqrt(variance);
    2120:	ed97 0a07 	vldr	s0, [r7, #28]
    2124:	f7fe f9c8 	bl	4b8 <_ZSt4sqrtf>
    2128:	ed87 0a06 	vstr	s0, [r7, #24]
    Serial.print("\tsigma: "); Serial.print(sigma, 4); Serial.print("\r\n");
    212c:	4918      	ldr	r1, [pc, #96]	; (2190 <_Z33collect_and_print_samples_analyseb+0x2a8>)
    212e:	480e      	ldr	r0, [pc, #56]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    2130:	f7fe fa46 	bl	5c0 <_ZN5Print5printEPKc>
    2134:	69b8      	ldr	r0, [r7, #24]
    2136:	f00b fc0d 	bl	d954 <__aeabi_f2d>
    213a:	4602      	mov	r2, r0
    213c:	460b      	mov	r3, r1
    213e:	2104      	movs	r1, #4
    2140:	ec43 2b10 	vmov	d0, r2, r3
    2144:	4808      	ldr	r0, [pc, #32]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    2146:	f7fe fa77 	bl	638 <_ZN5Print5printEdi>
    214a:	490a      	ldr	r1, [pc, #40]	; (2174 <_Z33collect_and_print_samples_analyseb+0x28c>)
    214c:	4806      	ldr	r0, [pc, #24]	; (2168 <_Z33collect_and_print_samples_analyseb+0x280>)
    214e:	f7fe fa37 	bl	5c0 <_ZN5Print5printEPKc>
}
    2152:	bf00      	nop
    2154:	3738      	adds	r7, #56	; 0x38
    2156:	46bd      	mov	sp, r7
    2158:	bdb0      	pop	{r4, r5, r7, pc}
    215a:	bf00      	nop
    215c:	1fff0adc 	.word	0x1fff0adc
    2160:	1fff0ae8 	.word	0x1fff0ae8
    2164:	0000f07c 	.word	0x0000f07c
    2168:	1fff078c 	.word	0x1fff078c
    216c:	0000f08c 	.word	0x0000f08c
    2170:	1fff0ad8 	.word	0x1fff0ad8
    2174:	0000efac 	.word	0x0000efac
    2178:	1fff0754 	.word	0x1fff0754
    217c:	0000efc0 	.word	0x0000efc0
    2180:	0000f098 	.word	0x0000f098
    2184:	38551eb8 	.word	0x38551eb8
    2188:	0000f0a0 	.word	0x0000f0a0
    218c:	0000f0a8 	.word	0x0000f0a8
    2190:	0000f0b0 	.word	0x0000f0b0

00002194 <_Z3LOGPKc>:
void LOG(char const str[])
{
    2194:	b580      	push	{r7, lr}
    2196:	b082      	sub	sp, #8
    2198:	af00      	add	r7, sp, #0
    219a:	6078      	str	r0, [r7, #4]
    Serial.print(str);
    219c:	6879      	ldr	r1, [r7, #4]
    219e:	4803      	ldr	r0, [pc, #12]	; (21ac <_Z3LOGPKc+0x18>)
    21a0:	f7fe fa0e 	bl	5c0 <_ZN5Print5printEPKc>
}
    21a4:	bf00      	nop
    21a6:	3708      	adds	r7, #8
    21a8:	46bd      	mov	sp, r7
    21aa:	bd80      	pop	{r7, pc}
    21ac:	1fff078c 	.word	0x1fff078c

000021b0 <_Z3LOGRK6String>:

void LOG(String const & str)
{
    21b0:	b580      	push	{r7, lr}
    21b2:	b082      	sub	sp, #8
    21b4:	af00      	add	r7, sp, #0
    21b6:	6078      	str	r0, [r7, #4]
    Serial.print(str);
    21b8:	6879      	ldr	r1, [r7, #4]
    21ba:	4803      	ldr	r0, [pc, #12]	; (21c8 <_Z3LOGRK6String+0x18>)
    21bc:	f002 ff2e 	bl	501c <_ZN5Print5printERK6String>
}
    21c0:	bf00      	nop
    21c2:	3708      	adds	r7, #8
    21c4:	46bd      	mov	sp, r7
    21c6:	bd80      	pop	{r7, pc}
    21c8:	1fff078c 	.word	0x1fff078c

000021cc <_Z3LOGt>:
void LOG(uint16_t v)
{
    21cc:	b580      	push	{r7, lr}
    21ce:	b082      	sub	sp, #8
    21d0:	af00      	add	r7, sp, #0
    21d2:	4603      	mov	r3, r0
    21d4:	80fb      	strh	r3, [r7, #6]
    Serial.print(v);
    21d6:	88fb      	ldrh	r3, [r7, #6]
    21d8:	4619      	mov	r1, r3
    21da:	4803      	ldr	r0, [pc, #12]	; (21e8 <_Z3LOGt+0x1c>)
    21dc:	f7fe f9fe 	bl	5dc <_ZN5Print5printEi>
}
    21e0:	bf00      	nop
    21e2:	3708      	adds	r7, #8
    21e4:	46bd      	mov	sp, r7
    21e6:	bd80      	pop	{r7, pc}
    21e8:	1fff078c 	.word	0x1fff078c

000021ec <_Z3LOGm>:
void LOG(uint32_t v)
{
    21ec:	b580      	push	{r7, lr}
    21ee:	b082      	sub	sp, #8
    21f0:	af00      	add	r7, sp, #0
    21f2:	6078      	str	r0, [r7, #4]
    Serial.print(v);
    21f4:	6879      	ldr	r1, [r7, #4]
    21f6:	4803      	ldr	r0, [pc, #12]	; (2204 <_Z3LOGm+0x18>)
    21f8:	f7fe fa0e 	bl	618 <_ZN5Print5printEm>
}
    21fc:	bf00      	nop
    21fe:	3708      	adds	r7, #8
    2200:	46bd      	mov	sp, r7
    2202:	bd80      	pop	{r7, pc}
    2204:	1fff078c 	.word	0x1fff078c

00002208 <_Z3LOGf>:
void LOG(float v)
{
    2208:	b580      	push	{r7, lr}
    220a:	b082      	sub	sp, #8
    220c:	af00      	add	r7, sp, #0
    220e:	ed87 0a01 	vstr	s0, [r7, #4]
    Serial.print(v);
    2212:	6878      	ldr	r0, [r7, #4]
    2214:	f00b fb9e 	bl	d954 <__aeabi_f2d>
    2218:	4602      	mov	r2, r0
    221a:	460b      	mov	r3, r1
    221c:	2102      	movs	r1, #2
    221e:	ec43 2b10 	vmov	d0, r2, r3
    2222:	4803      	ldr	r0, [pc, #12]	; (2230 <_Z3LOGf+0x28>)
    2224:	f7fe fa08 	bl	638 <_ZN5Print5printEdi>
}
    2228:	bf00      	nop
    222a:	3708      	adds	r7, #8
    222c:	46bd      	mov	sp, r7
    222e:	bd80      	pop	{r7, pc}
    2230:	1fff078c 	.word	0x1fff078c

00002234 <_Z3LOGN5Modes4TypeE>:

void LOG(Mode m)
{
    2234:	b580      	push	{r7, lr}
    2236:	b082      	sub	sp, #8
    2238:	af00      	add	r7, sp, #0
    223a:	4603      	mov	r3, r0
    223c:	71fb      	strb	r3, [r7, #7]
    Serial.print(getModeLabels(m));
    223e:	79fb      	ldrb	r3, [r7, #7]
    2240:	4618      	mov	r0, r3
    2242:	f7fe fdbd 	bl	dc0 <_Z13getModeLabelsN5Modes4TypeE>
    2246:	4603      	mov	r3, r0
    2248:	4619      	mov	r1, r3
    224a:	480a      	ldr	r0, [pc, #40]	; (2274 <_Z3LOGN5Modes4TypeE+0x40>)
    224c:	f7fe f9b8 	bl	5c0 <_ZN5Print5printEPKc>
    Serial.print(" ["); Serial.print(m); Serial.print(']');
    2250:	4909      	ldr	r1, [pc, #36]	; (2278 <_Z3LOGN5Modes4TypeE+0x44>)
    2252:	4808      	ldr	r0, [pc, #32]	; (2274 <_Z3LOGN5Modes4TypeE+0x40>)
    2254:	f7fe f9b4 	bl	5c0 <_ZN5Print5printEPKc>
    2258:	79fb      	ldrb	r3, [r7, #7]
    225a:	4619      	mov	r1, r3
    225c:	4805      	ldr	r0, [pc, #20]	; (2274 <_Z3LOGN5Modes4TypeE+0x40>)
    225e:	f7fe f9bd 	bl	5dc <_ZN5Print5printEi>
    2262:	215d      	movs	r1, #93	; 0x5d
    2264:	4803      	ldr	r0, [pc, #12]	; (2274 <_Z3LOGN5Modes4TypeE+0x40>)
    2266:	f7fe f999 	bl	59c <_ZN5Print5printEc>
}
    226a:	bf00      	nop
    226c:	3708      	adds	r7, #8
    226e:	46bd      	mov	sp, r7
    2270:	bd80      	pop	{r7, pc}
    2272:	bf00      	nop
    2274:	1fff078c 	.word	0x1fff078c
    2278:	0000f0bc 	.word	0x0000f0bc

0000227c <_Z3LOGN8DACModes4TypeE>:
void LOG(DACMode m)
{
    227c:	b580      	push	{r7, lr}
    227e:	b082      	sub	sp, #8
    2280:	af00      	add	r7, sp, #0
    2282:	4603      	mov	r3, r0
    2284:	71fb      	strb	r3, [r7, #7]
    Serial.print(getDACModeLabel(m));
    2286:	79fb      	ldrb	r3, [r7, #7]
    2288:	4618      	mov	r0, r3
    228a:	f7fe fdd3 	bl	e34 <_Z15getDACModeLabelN8DACModes4TypeE>
    228e:	4603      	mov	r3, r0
    2290:	4619      	mov	r1, r3
    2292:	480a      	ldr	r0, [pc, #40]	; (22bc <_Z3LOGN8DACModes4TypeE+0x40>)
    2294:	f7fe f994 	bl	5c0 <_ZN5Print5printEPKc>
    Serial.print(" ["); Serial.print(m); Serial.print(']');
    2298:	4909      	ldr	r1, [pc, #36]	; (22c0 <_Z3LOGN8DACModes4TypeE+0x44>)
    229a:	4808      	ldr	r0, [pc, #32]	; (22bc <_Z3LOGN8DACModes4TypeE+0x40>)
    229c:	f7fe f990 	bl	5c0 <_ZN5Print5printEPKc>
    22a0:	79fb      	ldrb	r3, [r7, #7]
    22a2:	4619      	mov	r1, r3
    22a4:	4805      	ldr	r0, [pc, #20]	; (22bc <_Z3LOGN8DACModes4TypeE+0x40>)
    22a6:	f7fe f999 	bl	5dc <_ZN5Print5printEi>
    22aa:	215d      	movs	r1, #93	; 0x5d
    22ac:	4803      	ldr	r0, [pc, #12]	; (22bc <_Z3LOGN8DACModes4TypeE+0x40>)
    22ae:	f7fe f975 	bl	59c <_ZN5Print5printEc>
}
    22b2:	bf00      	nop
    22b4:	3708      	adds	r7, #8
    22b6:	46bd      	mov	sp, r7
    22b8:	bd80      	pop	{r7, pc}
    22ba:	bf00      	nop
    22bc:	1fff078c 	.word	0x1fff078c
    22c0:	0000f0bc 	.word	0x0000f0bc

000022c4 <_Z2SLv>:

void SL()
{
    22c4:	b580      	push	{r7, lr}
    22c6:	af00      	add	r7, sp, #0
    LOG("\r\n# ");
    22c8:	4802      	ldr	r0, [pc, #8]	; (22d4 <_Z2SLv+0x10>)
    22ca:	f7ff ff63 	bl	2194 <_Z3LOGPKc>
}
    22ce:	bf00      	nop
    22d0:	bd80      	pop	{r7, pc}
    22d2:	bf00      	nop
    22d4:	0000f0c0 	.word	0x0000f0c0

000022d8 <_Z10deviceInfov>:
{
  return ( value < min ) ? min : ( ( value > max ) ? max : value ); 
}

void deviceInfo()
{
    22d8:	b580      	push	{r7, lr}
    22da:	af00      	add	r7, sp, #0
    SL();
    22dc:	f7ff fff2 	bl	22c4 <_Z2SLv>
    SL(); LOG(" " DEVICE_NAME " ( v" FIRMWARE_VERSION " )");
    22e0:	f7ff fff0 	bl	22c4 <_Z2SLv>
    22e4:	4805      	ldr	r0, [pc, #20]	; (22fc <_Z10deviceInfov+0x24>)
    22e6:	f7ff ff55 	bl	2194 <_Z3LOGPKc>
    SL(); LOG(" DEBUG BUILD ");
    22ea:	f7ff ffeb 	bl	22c4 <_Z2SLv>
    22ee:	4804      	ldr	r0, [pc, #16]	; (2300 <_Z10deviceInfov+0x28>)
    22f0:	f7ff ff50 	bl	2194 <_Z3LOGPKc>
    SL();
    22f4:	f7ff ffe6 	bl	22c4 <_Z2SLv>
}
    22f8:	bf00      	nop
    22fa:	bd80      	pop	{r7, pc}
    22fc:	0000f0c8 	.word	0x0000f0c8
    2300:	0000f0dc 	.word	0x0000f0dc

00002304 <_Z9getDirectRK6StringS1_S1_Rt>:
    SL(); LOG(name); LOG(": "); LOG(value); LOG("\r\n");
    return true;
}

bool getDirect(String const & name, String const & match, String const & match_to, uint16_t & value)
{
    2304:	b580      	push	{r7, lr}
    2306:	b084      	sub	sp, #16
    2308:	af00      	add	r7, sp, #0
    230a:	60f8      	str	r0, [r7, #12]
    230c:	60b9      	str	r1, [r7, #8]
    230e:	607a      	str	r2, [r7, #4]
    2310:	603b      	str	r3, [r7, #0]
    if (match != match_to) return false;
    2312:	6879      	ldr	r1, [r7, #4]
    2314:	68b8      	ldr	r0, [r7, #8]
    2316:	f7fe f8f9 	bl	50c <_ZNK6StringneERKS_>
    231a:	4603      	mov	r3, r0
    231c:	2b00      	cmp	r3, #0
    231e:	bf14      	ite	ne
    2320:	2301      	movne	r3, #1
    2322:	2300      	moveq	r3, #0
    2324:	b2db      	uxtb	r3, r3
    2326:	2b00      	cmp	r3, #0
    2328:	d001      	beq.n	232e <_Z9getDirectRK6StringS1_S1_Rt+0x2a>
    232a:	2300      	movs	r3, #0
    232c:	e010      	b.n	2350 <_Z9getDirectRK6StringS1_S1_Rt+0x4c>
    SL(); LOG(name); LOG(": "); LOG(value); LOG("\r\n");
    232e:	f7ff ffc9 	bl	22c4 <_Z2SLv>
    2332:	68f8      	ldr	r0, [r7, #12]
    2334:	f7ff ff3c 	bl	21b0 <_Z3LOGRK6String>
    2338:	4807      	ldr	r0, [pc, #28]	; (2358 <_Z9getDirectRK6StringS1_S1_Rt+0x54>)
    233a:	f7ff ff2b 	bl	2194 <_Z3LOGPKc>
    233e:	683b      	ldr	r3, [r7, #0]
    2340:	881b      	ldrh	r3, [r3, #0]
    2342:	4618      	mov	r0, r3
    2344:	f7ff ff42 	bl	21cc <_Z3LOGt>
    2348:	4804      	ldr	r0, [pc, #16]	; (235c <_Z9getDirectRK6StringS1_S1_Rt+0x58>)
    234a:	f7ff ff23 	bl	2194 <_Z3LOGPKc>
    return true;
    234e:	2301      	movs	r3, #1
}
    2350:	4618      	mov	r0, r3
    2352:	3710      	adds	r7, #16
    2354:	46bd      	mov	sp, r7
    2356:	bd80      	pop	{r7, pc}
    2358:	0000f0ec 	.word	0x0000f0ec
    235c:	0000efac 	.word	0x0000efac

00002360 <_Z9getDirectRK6StringS1_S1_Rm>:

bool getDirect(String const & name, String const & match, String const & match_to, uint32_t & value)
{
    2360:	b580      	push	{r7, lr}
    2362:	b084      	sub	sp, #16
    2364:	af00      	add	r7, sp, #0
    2366:	60f8      	str	r0, [r7, #12]
    2368:	60b9      	str	r1, [r7, #8]
    236a:	607a      	str	r2, [r7, #4]
    236c:	603b      	str	r3, [r7, #0]
    if (match != match_to) return false;
    236e:	6879      	ldr	r1, [r7, #4]
    2370:	68b8      	ldr	r0, [r7, #8]
    2372:	f7fe f8cb 	bl	50c <_ZNK6StringneERKS_>
    2376:	4603      	mov	r3, r0
    2378:	2b00      	cmp	r3, #0
    237a:	bf14      	ite	ne
    237c:	2301      	movne	r3, #1
    237e:	2300      	moveq	r3, #0
    2380:	b2db      	uxtb	r3, r3
    2382:	2b00      	cmp	r3, #0
    2384:	d001      	beq.n	238a <_Z9getDirectRK6StringS1_S1_Rm+0x2a>
    2386:	2300      	movs	r3, #0
    2388:	e010      	b.n	23ac <_Z9getDirectRK6StringS1_S1_Rm+0x4c>
    SL(); LOG(name); LOG(": "); LOG(value); LOG("\r\n");
    238a:	f7ff ff9b 	bl	22c4 <_Z2SLv>
    238e:	68f8      	ldr	r0, [r7, #12]
    2390:	f7ff ff0e 	bl	21b0 <_Z3LOGRK6String>
    2394:	4807      	ldr	r0, [pc, #28]	; (23b4 <_Z9getDirectRK6StringS1_S1_Rm+0x54>)
    2396:	f7ff fefd 	bl	2194 <_Z3LOGPKc>
    239a:	683b      	ldr	r3, [r7, #0]
    239c:	681b      	ldr	r3, [r3, #0]
    239e:	4618      	mov	r0, r3
    23a0:	f7ff ff24 	bl	21ec <_Z3LOGm>
    23a4:	4804      	ldr	r0, [pc, #16]	; (23b8 <_Z9getDirectRK6StringS1_S1_Rm+0x58>)
    23a6:	f7ff fef5 	bl	2194 <_Z3LOGPKc>
    return true;
    23aa:	2301      	movs	r3, #1
}
    23ac:	4618      	mov	r0, r3
    23ae:	3710      	adds	r7, #16
    23b0:	46bd      	mov	sp, r7
    23b2:	bd80      	pop	{r7, pc}
    23b4:	0000f0ec 	.word	0x0000f0ec
    23b8:	0000efac 	.word	0x0000efac

000023bc <_Z9getDirectRK6StringS1_S1_Rf>:

bool getDirect(String const & name, String const & match, String const & match_to, float & value)
{
    23bc:	b580      	push	{r7, lr}
    23be:	b084      	sub	sp, #16
    23c0:	af00      	add	r7, sp, #0
    23c2:	60f8      	str	r0, [r7, #12]
    23c4:	60b9      	str	r1, [r7, #8]
    23c6:	607a      	str	r2, [r7, #4]
    23c8:	603b      	str	r3, [r7, #0]
    if (match != match_to) return false;
    23ca:	6879      	ldr	r1, [r7, #4]
    23cc:	68b8      	ldr	r0, [r7, #8]
    23ce:	f7fe f89d 	bl	50c <_ZNK6StringneERKS_>
    23d2:	4603      	mov	r3, r0
    23d4:	2b00      	cmp	r3, #0
    23d6:	bf14      	ite	ne
    23d8:	2301      	movne	r3, #1
    23da:	2300      	moveq	r3, #0
    23dc:	b2db      	uxtb	r3, r3
    23de:	2b00      	cmp	r3, #0
    23e0:	d001      	beq.n	23e6 <_Z9getDirectRK6StringS1_S1_Rf+0x2a>
    23e2:	2300      	movs	r3, #0
    23e4:	e012      	b.n	240c <_Z9getDirectRK6StringS1_S1_Rf+0x50>
    SL(); LOG(name); LOG(": "); LOG(value); LOG("\r\n");
    23e6:	f7ff ff6d 	bl	22c4 <_Z2SLv>
    23ea:	68f8      	ldr	r0, [r7, #12]
    23ec:	f7ff fee0 	bl	21b0 <_Z3LOGRK6String>
    23f0:	4808      	ldr	r0, [pc, #32]	; (2414 <_Z9getDirectRK6StringS1_S1_Rf+0x58>)
    23f2:	f7ff fecf 	bl	2194 <_Z3LOGPKc>
    23f6:	683b      	ldr	r3, [r7, #0]
    23f8:	edd3 7a00 	vldr	s15, [r3]
    23fc:	eeb0 0a67 	vmov.f32	s0, s15
    2400:	f7ff ff02 	bl	2208 <_Z3LOGf>
    2404:	4804      	ldr	r0, [pc, #16]	; (2418 <_Z9getDirectRK6StringS1_S1_Rf+0x5c>)
    2406:	f7ff fec5 	bl	2194 <_Z3LOGPKc>
    return true;
    240a:	2301      	movs	r3, #1
}
    240c:	4618      	mov	r0, r3
    240e:	3710      	adds	r7, #16
    2410:	46bd      	mov	sp, r7
    2412:	bd80      	pop	{r7, pc}
    2414:	0000f0ec 	.word	0x0000f0ec
    2418:	0000efac 	.word	0x0000efac

0000241c <_Z9getDirectRK6StringS1_S1_Rb>:

bool getDirect(String const & name, String const & match, String const & match_to, bool & value)
{
    241c:	b580      	push	{r7, lr}
    241e:	b084      	sub	sp, #16
    2420:	af00      	add	r7, sp, #0
    2422:	60f8      	str	r0, [r7, #12]
    2424:	60b9      	str	r1, [r7, #8]
    2426:	607a      	str	r2, [r7, #4]
    2428:	603b      	str	r3, [r7, #0]
    if (match != match_to) return false;
    242a:	6879      	ldr	r1, [r7, #4]
    242c:	68b8      	ldr	r0, [r7, #8]
    242e:	f7fe f86d 	bl	50c <_ZNK6StringneERKS_>
    2432:	4603      	mov	r3, r0
    2434:	2b00      	cmp	r3, #0
    2436:	bf14      	ite	ne
    2438:	2301      	movne	r3, #1
    243a:	2300      	moveq	r3, #0
    243c:	b2db      	uxtb	r3, r3
    243e:	2b00      	cmp	r3, #0
    2440:	d001      	beq.n	2446 <_Z9getDirectRK6StringS1_S1_Rb+0x2a>
    2442:	2300      	movs	r3, #0
    2444:	e015      	b.n	2472 <_Z9getDirectRK6StringS1_S1_Rb+0x56>
    SL(); LOG(name); LOG(": "); LOG(value ? "true" : "false"); LOG("\r\n");
    2446:	f7ff ff3d 	bl	22c4 <_Z2SLv>
    244a:	68f8      	ldr	r0, [r7, #12]
    244c:	f7ff feb0 	bl	21b0 <_Z3LOGRK6String>
    2450:	480a      	ldr	r0, [pc, #40]	; (247c <_Z9getDirectRK6StringS1_S1_Rb+0x60>)
    2452:	f7ff fe9f 	bl	2194 <_Z3LOGPKc>
    2456:	683b      	ldr	r3, [r7, #0]
    2458:	781b      	ldrb	r3, [r3, #0]
    245a:	2b00      	cmp	r3, #0
    245c:	d001      	beq.n	2462 <_Z9getDirectRK6StringS1_S1_Rb+0x46>
    245e:	4b08      	ldr	r3, [pc, #32]	; (2480 <_Z9getDirectRK6StringS1_S1_Rb+0x64>)
    2460:	e000      	b.n	2464 <_Z9getDirectRK6StringS1_S1_Rb+0x48>
    2462:	4b08      	ldr	r3, [pc, #32]	; (2484 <_Z9getDirectRK6StringS1_S1_Rb+0x68>)
    2464:	4618      	mov	r0, r3
    2466:	f7ff fe95 	bl	2194 <_Z3LOGPKc>
    246a:	4807      	ldr	r0, [pc, #28]	; (2488 <_Z9getDirectRK6StringS1_S1_Rb+0x6c>)
    246c:	f7ff fe92 	bl	2194 <_Z3LOGPKc>
    return true;
    2470:	2301      	movs	r3, #1
}
    2472:	4618      	mov	r0, r3
    2474:	3710      	adds	r7, #16
    2476:	46bd      	mov	sp, r7
    2478:	bd80      	pop	{r7, pc}
    247a:	bf00      	nop
    247c:	0000f0ec 	.word	0x0000f0ec
    2480:	0000f0f0 	.word	0x0000f0f0
    2484:	0000f0f8 	.word	0x0000f0f8
    2488:	0000efac 	.word	0x0000efac

0000248c <_Z9setDirectRK6StringS1_S1_S1_Rmmm>:
    SL(); LOG(name); LOG(": "); LOG(value); LOG("\r\n");
    return true;
}

bool setDirect(String const & name, String const & match, String const & match_to, String const & new_value, uint32_t & value, uint32_t min, uint32_t max)
{
    248c:	b580      	push	{r7, lr}
    248e:	b084      	sub	sp, #16
    2490:	af00      	add	r7, sp, #0
    2492:	60f8      	str	r0, [r7, #12]
    2494:	60b9      	str	r1, [r7, #8]
    2496:	607a      	str	r2, [r7, #4]
    2498:	603b      	str	r3, [r7, #0]
    if (match != match_to) return false;
    249a:	6879      	ldr	r1, [r7, #4]
    249c:	68b8      	ldr	r0, [r7, #8]
    249e:	f7fe f835 	bl	50c <_ZNK6StringneERKS_>
    24a2:	4603      	mov	r3, r0
    24a4:	2b00      	cmp	r3, #0
    24a6:	bf14      	ite	ne
    24a8:	2301      	movne	r3, #1
    24aa:	2300      	moveq	r3, #0
    24ac:	b2db      	uxtb	r3, r3
    24ae:	2b00      	cmp	r3, #0
    24b0:	d001      	beq.n	24b6 <_Z9setDirectRK6StringS1_S1_S1_Rmmm+0x2a>
    24b2:	2300      	movs	r3, #0
    24b4:	e020      	b.n	24f8 <_Z9setDirectRK6StringS1_S1_S1_Rmmm+0x6c>
    value = bound<uint32_t>(atoi(new_value.c_str()), min, max);
    24b6:	6838      	ldr	r0, [r7, #0]
    24b8:	f7fe f84e 	bl	558 <_ZNK6String5c_strEv>
    24bc:	4603      	mov	r3, r0
    24be:	4618      	mov	r0, r3
    24c0:	f00b ff3e 	bl	e340 <atoi>
    24c4:	4603      	mov	r3, r0
    24c6:	6a3a      	ldr	r2, [r7, #32]
    24c8:	69f9      	ldr	r1, [r7, #28]
    24ca:	4618      	mov	r0, r3
    24cc:	f001 ff11 	bl	42f2 <_Z5boundImET_S0_S0_S0_>
    24d0:	4602      	mov	r2, r0
    24d2:	69bb      	ldr	r3, [r7, #24]
    24d4:	601a      	str	r2, [r3, #0]
    SL(); LOG(name); LOG(": "); LOG(value); LOG("\r\n");
    24d6:	f7ff fef5 	bl	22c4 <_Z2SLv>
    24da:	68f8      	ldr	r0, [r7, #12]
    24dc:	f7ff fe68 	bl	21b0 <_Z3LOGRK6String>
    24e0:	4807      	ldr	r0, [pc, #28]	; (2500 <_Z9setDirectRK6StringS1_S1_S1_Rmmm+0x74>)
    24e2:	f7ff fe57 	bl	2194 <_Z3LOGPKc>
    24e6:	69bb      	ldr	r3, [r7, #24]
    24e8:	681b      	ldr	r3, [r3, #0]
    24ea:	4618      	mov	r0, r3
    24ec:	f7ff fe7e 	bl	21ec <_Z3LOGm>
    24f0:	4804      	ldr	r0, [pc, #16]	; (2504 <_Z9setDirectRK6StringS1_S1_S1_Rmmm+0x78>)
    24f2:	f7ff fe4f 	bl	2194 <_Z3LOGPKc>
    return true;
    24f6:	2301      	movs	r3, #1
}
    24f8:	4618      	mov	r0, r3
    24fa:	3710      	adds	r7, #16
    24fc:	46bd      	mov	sp, r7
    24fe:	bd80      	pop	{r7, pc}
    2500:	0000f0ec 	.word	0x0000f0ec
    2504:	0000efac 	.word	0x0000efac

00002508 <_Z9setDirectRK6StringS1_S1_S1_Rb>:

bool setDirect(String const & name, String const & match, String const & match_to, String const & new_value, bool & value)
{
    2508:	b580      	push	{r7, lr}
    250a:	b084      	sub	sp, #16
    250c:	af00      	add	r7, sp, #0
    250e:	60f8      	str	r0, [r7, #12]
    2510:	60b9      	str	r1, [r7, #8]
    2512:	607a      	str	r2, [r7, #4]
    2514:	603b      	str	r3, [r7, #0]
    if (match != match_to) return false;
    2516:	6879      	ldr	r1, [r7, #4]
    2518:	68b8      	ldr	r0, [r7, #8]
    251a:	f7fd fff7 	bl	50c <_ZNK6StringneERKS_>
    251e:	4603      	mov	r3, r0
    2520:	2b00      	cmp	r3, #0
    2522:	bf14      	ite	ne
    2524:	2301      	movne	r3, #1
    2526:	2300      	moveq	r3, #0
    2528:	b2db      	uxtb	r3, r3
    252a:	2b00      	cmp	r3, #0
    252c:	d001      	beq.n	2532 <_Z9setDirectRK6StringS1_S1_S1_Rb+0x2a>
    252e:	2300      	movs	r3, #0
    2530:	e028      	b.n	2584 <_Z9setDirectRK6StringS1_S1_S1_Rb+0x7c>
    value = ((new_value == "true") || (new_value == "1")) ? true : false;
    2532:	4916      	ldr	r1, [pc, #88]	; (258c <_Z9setDirectRK6StringS1_S1_S1_Rb+0x84>)
    2534:	6838      	ldr	r0, [r7, #0]
    2536:	f7fd ffdb 	bl	4f0 <_ZNK6StringeqEPKc>
    253a:	4603      	mov	r3, r0
    253c:	2b00      	cmp	r3, #0
    253e:	d106      	bne.n	254e <_Z9setDirectRK6StringS1_S1_S1_Rb+0x46>
    2540:	4913      	ldr	r1, [pc, #76]	; (2590 <_Z9setDirectRK6StringS1_S1_S1_Rb+0x88>)
    2542:	6838      	ldr	r0, [r7, #0]
    2544:	f7fd ffd4 	bl	4f0 <_ZNK6StringeqEPKc>
    2548:	4603      	mov	r3, r0
    254a:	2b00      	cmp	r3, #0
    254c:	d001      	beq.n	2552 <_Z9setDirectRK6StringS1_S1_S1_Rb+0x4a>
    254e:	2201      	movs	r2, #1
    2550:	e000      	b.n	2554 <_Z9setDirectRK6StringS1_S1_S1_Rb+0x4c>
    2552:	2200      	movs	r2, #0
    2554:	69bb      	ldr	r3, [r7, #24]
    2556:	701a      	strb	r2, [r3, #0]
    SL(); LOG(name); LOG(": "); LOG(value ? "true" : "false"); LOG("\r\n");
    2558:	f7ff feb4 	bl	22c4 <_Z2SLv>
    255c:	68f8      	ldr	r0, [r7, #12]
    255e:	f7ff fe27 	bl	21b0 <_Z3LOGRK6String>
    2562:	480c      	ldr	r0, [pc, #48]	; (2594 <_Z9setDirectRK6StringS1_S1_S1_Rb+0x8c>)
    2564:	f7ff fe16 	bl	2194 <_Z3LOGPKc>
    2568:	69bb      	ldr	r3, [r7, #24]
    256a:	781b      	ldrb	r3, [r3, #0]
    256c:	2b00      	cmp	r3, #0
    256e:	d001      	beq.n	2574 <_Z9setDirectRK6StringS1_S1_S1_Rb+0x6c>
    2570:	4b06      	ldr	r3, [pc, #24]	; (258c <_Z9setDirectRK6StringS1_S1_S1_Rb+0x84>)
    2572:	e000      	b.n	2576 <_Z9setDirectRK6StringS1_S1_S1_Rb+0x6e>
    2574:	4b08      	ldr	r3, [pc, #32]	; (2598 <_Z9setDirectRK6StringS1_S1_S1_Rb+0x90>)
    2576:	4618      	mov	r0, r3
    2578:	f7ff fe0c 	bl	2194 <_Z3LOGPKc>
    257c:	4807      	ldr	r0, [pc, #28]	; (259c <_Z9setDirectRK6StringS1_S1_S1_Rb+0x94>)
    257e:	f7ff fe09 	bl	2194 <_Z3LOGPKc>
    return true;
    2582:	2301      	movs	r3, #1
}
    2584:	4618      	mov	r0, r3
    2586:	3710      	adds	r7, #16
    2588:	46bd      	mov	sp, r7
    258a:	bd80      	pop	{r7, pc}
    258c:	0000f0f0 	.word	0x0000f0f0
    2590:	0000f100 	.word	0x0000f100
    2594:	0000f0ec 	.word	0x0000f0ec
    2598:	0000f0f8 	.word	0x0000f0f8
    259c:	0000efac 	.word	0x0000efac

000025a0 <_Z14possibleValuesb>:


void possibleValues(bool get = true)
{
    25a0:	b580      	push	{r7, lr}
    25a2:	b082      	sub	sp, #8
    25a4:	af00      	add	r7, sp, #0
    25a6:	4603      	mov	r3, r0
    25a8:	71fb      	strb	r3, [r7, #7]
    LOG("Possible values : ");
    25aa:	481a      	ldr	r0, [pc, #104]	; (2614 <_Z14possibleValuesb+0x74>)
    25ac:	f7ff fdf2 	bl	2194 <_Z3LOGPKc>
    if (get) LOG("all, ");
    25b0:	79fb      	ldrb	r3, [r7, #7]
    25b2:	2b00      	cmp	r3, #0
    25b4:	d002      	beq.n	25bc <_Z14possibleValuesb+0x1c>
    25b6:	4818      	ldr	r0, [pc, #96]	; (2618 <_Z14possibleValuesb+0x78>)
    25b8:	f7ff fdec 	bl	2194 <_Z3LOGPKc>
    LOG("dacMode, ");
    25bc:	4817      	ldr	r0, [pc, #92]	; (261c <_Z14possibleValuesb+0x7c>)
    25be:	f7ff fde9 	bl	2194 <_Z3LOGPKc>
    LOG("delay, ");
    25c2:	4817      	ldr	r0, [pc, #92]	; (2620 <_Z14possibleValuesb+0x80>)
    25c4:	f7ff fde6 	bl	2194 <_Z3LOGPKc>
    LOG("dist, ");
    25c8:	4816      	ldr	r0, [pc, #88]	; (2624 <_Z14possibleValuesb+0x84>)
    25ca:	f7ff fde3 	bl	2194 <_Z3LOGPKc>
    LOG("electrodes, ");
    25ce:	4816      	ldr	r0, [pc, #88]	; (2628 <_Z14possibleValuesb+0x88>)
    25d0:	f7ff fde0 	bl	2194 <_Z3LOGPKc>
    LOG("inputGainResistor1, ");
    25d4:	4815      	ldr	r0, [pc, #84]	; (262c <_Z14possibleValuesb+0x8c>)
    25d6:	f7ff fddd 	bl	2194 <_Z3LOGPKc>
    LOG("inputGainResistor2, ");
    25da:	4815      	ldr	r0, [pc, #84]	; (2630 <_Z14possibleValuesb+0x90>)
    25dc:	f7ff fdda 	bl	2194 <_Z3LOGPKc>
    LOG("mode, ");
    25e0:	4814      	ldr	r0, [pc, #80]	; (2634 <_Z14possibleValuesb+0x94>)
    25e2:	f7ff fdd7 	bl	2194 <_Z3LOGPKc>
    LOG("outputGainResistor, ");
    25e6:	4814      	ldr	r0, [pc, #80]	; (2638 <_Z14possibleValuesb+0x98>)
    25e8:	f7ff fdd4 	bl	2194 <_Z3LOGPKc>
    LOG("sampleCycles, ");
    25ec:	4813      	ldr	r0, [pc, #76]	; (263c <_Z14possibleValuesb+0x9c>)
    25ee:	f7ff fdd1 	bl	2194 <_Z3LOGPKc>
    LOG("samplesPerCycle, ");
    25f2:	4813      	ldr	r0, [pc, #76]	; (2640 <_Z14possibleValuesb+0xa0>)
    25f4:	f7ff fdce 	bl	2194 <_Z3LOGPKc>
    LOG("sampleRubbish, ");
    25f8:	4812      	ldr	r0, [pc, #72]	; (2644 <_Z14possibleValuesb+0xa4>)
    25fa:	f7ff fdcb 	bl	2194 <_Z3LOGPKc>
    LOG("mapToLines, ");
    25fe:	4812      	ldr	r0, [pc, #72]	; (2648 <_Z14possibleValuesb+0xa8>)
    2600:	f7ff fdc8 	bl	2194 <_Z3LOGPKc>
    LOG("\r\n");
    2604:	4811      	ldr	r0, [pc, #68]	; (264c <_Z14possibleValuesb+0xac>)
    2606:	f7ff fdc5 	bl	2194 <_Z3LOGPKc>
}
    260a:	bf00      	nop
    260c:	3708      	adds	r7, #8
    260e:	46bd      	mov	sp, r7
    2610:	bd80      	pop	{r7, pc}
    2612:	bf00      	nop
    2614:	0000f104 	.word	0x0000f104
    2618:	0000f118 	.word	0x0000f118
    261c:	0000f120 	.word	0x0000f120
    2620:	0000f12c 	.word	0x0000f12c
    2624:	0000f134 	.word	0x0000f134
    2628:	0000f13c 	.word	0x0000f13c
    262c:	0000f14c 	.word	0x0000f14c
    2630:	0000f164 	.word	0x0000f164
    2634:	0000f17c 	.word	0x0000f17c
    2638:	0000f184 	.word	0x0000f184
    263c:	0000f19c 	.word	0x0000f19c
    2640:	0000f1ac 	.word	0x0000f1ac
    2644:	0000f1c0 	.word	0x0000f1c0
    2648:	0000f1d0 	.word	0x0000f1d0
    264c:	0000efac 	.word	0x0000efac

00002650 <_Z8getUsagev>:

bool getUsage() {
    2650:	b580      	push	{r7, lr}
    2652:	af00      	add	r7, sp, #0
    SL(); LOG("Usage : get valueName\r\n");
    2654:	f7ff fe36 	bl	22c4 <_Z2SLv>
    2658:	4804      	ldr	r0, [pc, #16]	; (266c <_Z8getUsagev+0x1c>)
    265a:	f7ff fd9b 	bl	2194 <_Z3LOGPKc>
    possibleValues();
    265e:	2001      	movs	r0, #1
    2660:	f7ff ff9e 	bl	25a0 <_Z14possibleValuesb>
    return true;
    2664:	2301      	movs	r3, #1
}
    2666:	4618      	mov	r0, r3
    2668:	bd80      	pop	{r7, pc}
    266a:	bf00      	nop
    266c:	0000f1e0 	.word	0x0000f1e0

00002670 <_Z8setUsagev>:

bool setUsage() {
    2670:	b580      	push	{r7, lr}
    2672:	af00      	add	r7, sp, #0
    SL(); LOG("Usage : set valueName value\r\n");
    2674:	f7ff fe26 	bl	22c4 <_Z2SLv>
    2678:	4804      	ldr	r0, [pc, #16]	; (268c <_Z8setUsagev+0x1c>)
    267a:	f7ff fd8b 	bl	2194 <_Z3LOGPKc>
    possibleValues(false);
    267e:	2000      	movs	r0, #0
    2680:	f7ff ff8e 	bl	25a0 <_Z14possibleValuesb>
    return true;
    2684:	2301      	movs	r3, #1
}
    2686:	4618      	mov	r0, r3
    2688:	bd80      	pop	{r7, pc}
    268a:	bf00      	nop
    268c:	0000f1f8 	.word	0x0000f1f8

00002690 <_Z12unknownValueRK6String>:

bool unknownValue(String const & val)
{
    2690:	b580      	push	{r7, lr}
    2692:	b082      	sub	sp, #8
    2694:	af00      	add	r7, sp, #0
    2696:	6078      	str	r0, [r7, #4]
    SL(); LOG(val); LOG(" not valid!\r\n");
    2698:	f7ff fe14 	bl	22c4 <_Z2SLv>
    269c:	6878      	ldr	r0, [r7, #4]
    269e:	f7ff fd87 	bl	21b0 <_Z3LOGRK6String>
    26a2:	4805      	ldr	r0, [pc, #20]	; (26b8 <_Z12unknownValueRK6String+0x28>)
    26a4:	f7ff fd76 	bl	2194 <_Z3LOGPKc>
    possibleValues();
    26a8:	2001      	movs	r0, #1
    26aa:	f7ff ff79 	bl	25a0 <_Z14possibleValuesb>
    return true;
    26ae:	2301      	movs	r3, #1
}
    26b0:	4618      	mov	r0, r3
    26b2:	3708      	adds	r7, #8
    26b4:	46bd      	mov	sp, r7
    26b6:	bd80      	pop	{r7, pc}
    26b8:	0000f218 	.word	0x0000f218

000026bc <_Z16possibleCommandsv>:


bool possibleCommands()
{
    26bc:	b580      	push	{r7, lr}
    26be:	af00      	add	r7, sp, #0
    SL(); LOG("Possible commands : ");
    26c0:	f7ff fe00 	bl	22c4 <_Z2SLv>
    26c4:	4805      	ldr	r0, [pc, #20]	; (26dc <_Z16possibleCommandsv+0x20>)
    26c6:	f7ff fd65 	bl	2194 <_Z3LOGPKc>
    LOG("stop, start, set, get, help");
    26ca:	4805      	ldr	r0, [pc, #20]	; (26e0 <_Z16possibleCommandsv+0x24>)
    26cc:	f7ff fd62 	bl	2194 <_Z3LOGPKc>
    LOG("\r\n");
    26d0:	4804      	ldr	r0, [pc, #16]	; (26e4 <_Z16possibleCommandsv+0x28>)
    26d2:	f7ff fd5f 	bl	2194 <_Z3LOGPKc>
    return true;
    26d6:	2301      	movs	r3, #1
}
    26d8:	4618      	mov	r0, r3
    26da:	bd80      	pop	{r7, pc}
    26dc:	0000f228 	.word	0x0000f228
    26e0:	0000f240 	.word	0x0000f240
    26e4:	0000efac 	.word	0x0000efac

000026e8 <_Z14unknownCommandRK6String>:


bool unknownCommand(String const & cmd)
{
    26e8:	b580      	push	{r7, lr}
    26ea:	b082      	sub	sp, #8
    26ec:	af00      	add	r7, sp, #0
    26ee:	6078      	str	r0, [r7, #4]
    SL(); LOG("Command '");LOG(cmd); LOG("' not valid!\r\n");
    26f0:	f7ff fde8 	bl	22c4 <_Z2SLv>
    26f4:	4807      	ldr	r0, [pc, #28]	; (2714 <_Z14unknownCommandRK6String+0x2c>)
    26f6:	f7ff fd4d 	bl	2194 <_Z3LOGPKc>
    26fa:	6878      	ldr	r0, [r7, #4]
    26fc:	f7ff fd58 	bl	21b0 <_Z3LOGRK6String>
    2700:	4805      	ldr	r0, [pc, #20]	; (2718 <_Z14unknownCommandRK6String+0x30>)
    2702:	f7ff fd47 	bl	2194 <_Z3LOGPKc>
    possibleCommands();
    2706:	f7ff ffd9 	bl	26bc <_Z16possibleCommandsv>
    return true;
    270a:	2301      	movs	r3, #1
}
    270c:	4618      	mov	r0, r3
    270e:	3708      	adds	r7, #8
    2710:	46bd      	mov	sp, r7
    2712:	bd80      	pop	{r7, pc}
    2714:	0000f25c 	.word	0x0000f25c
    2718:	0000f268 	.word	0x0000f268

0000271c <_Z6getAllRK6String>:


bool getAll(String const & match_to)
{
    271c:	b580      	push	{r7, lr}
    271e:	b082      	sub	sp, #8
    2720:	af00      	add	r7, sp, #0
    2722:	6078      	str	r0, [r7, #4]
    if (match_to != "all") return false;
    2724:	49ac      	ldr	r1, [pc, #688]	; (29d8 <_Z6getAllRK6String+0x2bc>)
    2726:	6878      	ldr	r0, [r7, #4]
    2728:	f7fd ff03 	bl	532 <_ZNK6StringneEPKc>
    272c:	4603      	mov	r3, r0
    272e:	2b00      	cmp	r3, #0
    2730:	bf14      	ite	ne
    2732:	2301      	movne	r3, #1
    2734:	2300      	moveq	r3, #0
    2736:	b2db      	uxtb	r3, r3
    2738:	2b00      	cmp	r3, #0
    273a:	d001      	beq.n	2740 <_Z6getAllRK6String+0x24>
    273c:	2300      	movs	r3, #0
    273e:	e147      	b.n	29d0 <_Z6getAllRK6String+0x2b4>
    SL();
    2740:	f7ff fdc0 	bl	22c4 <_Z2SLv>
    SL();LOG("mode"             ); LOG(": ");  LOG(g_eMode                   );
    2744:	f7ff fdbe 	bl	22c4 <_Z2SLv>
    2748:	48a4      	ldr	r0, [pc, #656]	; (29dc <_Z6getAllRK6String+0x2c0>)
    274a:	f7ff fd23 	bl	2194 <_Z3LOGPKc>
    274e:	48a4      	ldr	r0, [pc, #656]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    2750:	f7ff fd20 	bl	2194 <_Z3LOGPKc>
    2754:	4ba3      	ldr	r3, [pc, #652]	; (29e4 <_Z6getAllRK6String+0x2c8>)
    2756:	781b      	ldrb	r3, [r3, #0]
    2758:	4618      	mov	r0, r3
    275a:	f7ff fd6b 	bl	2234 <_Z3LOGN5Modes4TypeE>
    SL();LOG("dacMode"          ); LOG(": ");  LOG(g_eDACMode                );
    275e:	f7ff fdb1 	bl	22c4 <_Z2SLv>
    2762:	48a1      	ldr	r0, [pc, #644]	; (29e8 <_Z6getAllRK6String+0x2cc>)
    2764:	f7ff fd16 	bl	2194 <_Z3LOGPKc>
    2768:	489d      	ldr	r0, [pc, #628]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    276a:	f7ff fd13 	bl	2194 <_Z3LOGPKc>
    276e:	4b9f      	ldr	r3, [pc, #636]	; (29ec <_Z6getAllRK6String+0x2d0>)
    2770:	781b      	ldrb	r3, [r3, #0]
    2772:	4618      	mov	r0, r3
    2774:	f7ff fd82 	bl	227c <_Z3LOGN8DACModes4TypeE>
    SL();
    2778:	f7ff fda4 	bl	22c4 <_Z2SLv>
    SL();LOG("delay"             ); LOG(": "); LOG(g_iDelay_ms               ); LOG(" ms");
    277c:	f7ff fda2 	bl	22c4 <_Z2SLv>
    2780:	489b      	ldr	r0, [pc, #620]	; (29f0 <_Z6getAllRK6String+0x2d4>)
    2782:	f7ff fd07 	bl	2194 <_Z3LOGPKc>
    2786:	4896      	ldr	r0, [pc, #600]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    2788:	f7ff fd04 	bl	2194 <_Z3LOGPKc>
    278c:	4b99      	ldr	r3, [pc, #612]	; (29f4 <_Z6getAllRK6String+0x2d8>)
    278e:	681b      	ldr	r3, [r3, #0]
    2790:	4618      	mov	r0, r3
    2792:	f7ff fd2b 	bl	21ec <_Z3LOGm>
    2796:	4898      	ldr	r0, [pc, #608]	; (29f8 <_Z6getAllRK6String+0x2dc>)
    2798:	f7ff fcfc 	bl	2194 <_Z3LOGPKc>
    SL();LOG("dist"              ); LOG(": "); LOG(g_iDrivingDist                   );
    279c:	f7ff fd92 	bl	22c4 <_Z2SLv>
    27a0:	4896      	ldr	r0, [pc, #600]	; (29fc <_Z6getAllRK6String+0x2e0>)
    27a2:	f7ff fcf7 	bl	2194 <_Z3LOGPKc>
    27a6:	488e      	ldr	r0, [pc, #568]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    27a8:	f7ff fcf4 	bl	2194 <_Z3LOGPKc>
    27ac:	4b94      	ldr	r3, [pc, #592]	; (2a00 <_Z6getAllRK6String+0x2e4>)
    27ae:	681b      	ldr	r3, [r3, #0]
    27b0:	4618      	mov	r0, r3
    27b2:	f7ff fd1b 	bl	21ec <_Z3LOGm>
    SL();LOG("electrodes"        ); LOG(": "); LOG(g_iElectrodes             );
    27b6:	f7ff fd85 	bl	22c4 <_Z2SLv>
    27ba:	4892      	ldr	r0, [pc, #584]	; (2a04 <_Z6getAllRK6String+0x2e8>)
    27bc:	f7ff fcea 	bl	2194 <_Z3LOGPKc>
    27c0:	4887      	ldr	r0, [pc, #540]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    27c2:	f7ff fce7 	bl	2194 <_Z3LOGPKc>
    27c6:	4b90      	ldr	r3, [pc, #576]	; (2a08 <_Z6getAllRK6String+0x2ec>)
    27c8:	681b      	ldr	r3, [r3, #0]
    27ca:	4618      	mov	r0, r3
    27cc:	f7ff fd0e 	bl	21ec <_Z3LOGm>
    SL();LOG("inputGainResistor1"); LOG(": "); LOG(g_iInputGainResistor1_ohms); LOG(" ohms");
    27d0:	f7ff fd78 	bl	22c4 <_Z2SLv>
    27d4:	488d      	ldr	r0, [pc, #564]	; (2a0c <_Z6getAllRK6String+0x2f0>)
    27d6:	f7ff fcdd 	bl	2194 <_Z3LOGPKc>
    27da:	4881      	ldr	r0, [pc, #516]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    27dc:	f7ff fcda 	bl	2194 <_Z3LOGPKc>
    27e0:	4b8b      	ldr	r3, [pc, #556]	; (2a10 <_Z6getAllRK6String+0x2f4>)
    27e2:	681b      	ldr	r3, [r3, #0]
    27e4:	4618      	mov	r0, r3
    27e6:	f7ff fd01 	bl	21ec <_Z3LOGm>
    27ea:	488a      	ldr	r0, [pc, #552]	; (2a14 <_Z6getAllRK6String+0x2f8>)
    27ec:	f7ff fcd2 	bl	2194 <_Z3LOGPKc>
    SL();LOG("inputGainResistor2"); LOG(": "); LOG(g_iInputGainResistor2_ohms); LOG(" ohms");
    27f0:	f7ff fd68 	bl	22c4 <_Z2SLv>
    27f4:	4888      	ldr	r0, [pc, #544]	; (2a18 <_Z6getAllRK6String+0x2fc>)
    27f6:	f7ff fccd 	bl	2194 <_Z3LOGPKc>
    27fa:	4879      	ldr	r0, [pc, #484]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    27fc:	f7ff fcca 	bl	2194 <_Z3LOGPKc>
    2800:	4b86      	ldr	r3, [pc, #536]	; (2a1c <_Z6getAllRK6String+0x300>)
    2802:	681b      	ldr	r3, [r3, #0]
    2804:	4618      	mov	r0, r3
    2806:	f7ff fcf1 	bl	21ec <_Z3LOGm>
    280a:	4882      	ldr	r0, [pc, #520]	; (2a14 <_Z6getAllRK6String+0x2f8>)
    280c:	f7ff fcc2 	bl	2194 <_Z3LOGPKc>
    SL();LOG("outputGainResistor"); LOG(": "); LOG(g_iOutputGainResistor_ohms); LOG(" ohms");
    2810:	f7ff fd58 	bl	22c4 <_Z2SLv>
    2814:	4882      	ldr	r0, [pc, #520]	; (2a20 <_Z6getAllRK6String+0x304>)
    2816:	f7ff fcbd 	bl	2194 <_Z3LOGPKc>
    281a:	4871      	ldr	r0, [pc, #452]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    281c:	f7ff fcba 	bl	2194 <_Z3LOGPKc>
    2820:	4b80      	ldr	r3, [pc, #512]	; (2a24 <_Z6getAllRK6String+0x308>)
    2822:	681b      	ldr	r3, [r3, #0]
    2824:	4618      	mov	r0, r3
    2826:	f7ff fce1 	bl	21ec <_Z3LOGm>
    282a:	487a      	ldr	r0, [pc, #488]	; (2a14 <_Z6getAllRK6String+0x2f8>)
    282c:	f7ff fcb2 	bl	2194 <_Z3LOGPKc>
    SL();LOG("sampleCycles"      ); LOG(": "); LOG(g_iSample_cycles          );
    2830:	f7ff fd48 	bl	22c4 <_Z2SLv>
    2834:	487c      	ldr	r0, [pc, #496]	; (2a28 <_Z6getAllRK6String+0x30c>)
    2836:	f7ff fcad 	bl	2194 <_Z3LOGPKc>
    283a:	4869      	ldr	r0, [pc, #420]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    283c:	f7ff fcaa 	bl	2194 <_Z3LOGPKc>
    2840:	4b7a      	ldr	r3, [pc, #488]	; (2a2c <_Z6getAllRK6String+0x310>)
    2842:	681b      	ldr	r3, [r3, #0]
    2844:	4618      	mov	r0, r3
    2846:	f7ff fcd1 	bl	21ec <_Z3LOGm>
    SL();LOG("samplesPerCycle"   ); LOG(": "); LOG(g_iSamples_per_cycle      );
    284a:	f7ff fd3b 	bl	22c4 <_Z2SLv>
    284e:	4878      	ldr	r0, [pc, #480]	; (2a30 <_Z6getAllRK6String+0x314>)
    2850:	f7ff fca0 	bl	2194 <_Z3LOGPKc>
    2854:	4862      	ldr	r0, [pc, #392]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    2856:	f7ff fc9d 	bl	2194 <_Z3LOGPKc>
    285a:	4b76      	ldr	r3, [pc, #472]	; (2a34 <_Z6getAllRK6String+0x318>)
    285c:	681b      	ldr	r3, [r3, #0]
    285e:	4618      	mov	r0, r3
    2860:	f7ff fcc4 	bl	21ec <_Z3LOGm>
    SL();LOG("sampleRubbish"     ); LOG(": "); LOG(g_iSample_rubbish         );
    2864:	f7ff fd2e 	bl	22c4 <_Z2SLv>
    2868:	4873      	ldr	r0, [pc, #460]	; (2a38 <_Z6getAllRK6String+0x31c>)
    286a:	f7ff fc93 	bl	2194 <_Z3LOGPKc>
    286e:	485c      	ldr	r0, [pc, #368]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    2870:	f7ff fc90 	bl	2194 <_Z3LOGPKc>
    2874:	4b71      	ldr	r3, [pc, #452]	; (2a3c <_Z6getAllRK6String+0x320>)
    2876:	681b      	ldr	r3, [r3, #0]
    2878:	4618      	mov	r0, r3
    287a:	f7ff fcb7 	bl	21ec <_Z3LOGm>
    SL();LOG("mapToLines"        ); LOG(": "); LOG(g_bMapElectrodesToLines ? "true" : "false" );
    287e:	f7ff fd21 	bl	22c4 <_Z2SLv>
    2882:	486f      	ldr	r0, [pc, #444]	; (2a40 <_Z6getAllRK6String+0x324>)
    2884:	f7ff fc86 	bl	2194 <_Z3LOGPKc>
    2888:	4855      	ldr	r0, [pc, #340]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    288a:	f7ff fc83 	bl	2194 <_Z3LOGPKc>
    288e:	4b6d      	ldr	r3, [pc, #436]	; (2a44 <_Z6getAllRK6String+0x328>)
    2890:	781b      	ldrb	r3, [r3, #0]
    2892:	2b00      	cmp	r3, #0
    2894:	d001      	beq.n	289a <_Z6getAllRK6String+0x17e>
    2896:	4b6c      	ldr	r3, [pc, #432]	; (2a48 <_Z6getAllRK6String+0x32c>)
    2898:	e000      	b.n	289c <_Z6getAllRK6String+0x180>
    289a:	4b6c      	ldr	r3, [pc, #432]	; (2a4c <_Z6getAllRK6String+0x330>)
    289c:	4618      	mov	r0, r3
    289e:	f7ff fc79 	bl	2194 <_Z3LOGPKc>
    SL();
    28a2:	f7ff fd0f 	bl	22c4 <_Z2SLv>
    SL();LOG("adcFrequency"      ); LOG(": "); LOG(g_iADC_frequency          ); LOG(" Hz");
    28a6:	f7ff fd0d 	bl	22c4 <_Z2SLv>
    28aa:	4869      	ldr	r0, [pc, #420]	; (2a50 <_Z6getAllRK6String+0x334>)
    28ac:	f7ff fc72 	bl	2194 <_Z3LOGPKc>
    28b0:	484b      	ldr	r0, [pc, #300]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    28b2:	f7ff fc6f 	bl	2194 <_Z3LOGPKc>
    28b6:	4b67      	ldr	r3, [pc, #412]	; (2a54 <_Z6getAllRK6String+0x338>)
    28b8:	681b      	ldr	r3, [r3, #0]
    28ba:	4618      	mov	r0, r3
    28bc:	f7ff fc96 	bl	21ec <_Z3LOGm>
    28c0:	4865      	ldr	r0, [pc, #404]	; (2a58 <_Z6getAllRK6String+0x33c>)
    28c2:	f7ff fc67 	bl	2194 <_Z3LOGPKc>
    SL();LOG("run"               ); LOG(": "); LOG(g_bRun ? "true" : "false" );
    28c6:	f7ff fcfd 	bl	22c4 <_Z2SLv>
    28ca:	4864      	ldr	r0, [pc, #400]	; (2a5c <_Z6getAllRK6String+0x340>)
    28cc:	f7ff fc62 	bl	2194 <_Z3LOGPKc>
    28d0:	4843      	ldr	r0, [pc, #268]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    28d2:	f7ff fc5f 	bl	2194 <_Z3LOGPKc>
    28d6:	4b62      	ldr	r3, [pc, #392]	; (2a60 <_Z6getAllRK6String+0x344>)
    28d8:	781b      	ldrb	r3, [r3, #0]
    28da:	2b00      	cmp	r3, #0
    28dc:	d001      	beq.n	28e2 <_Z6getAllRK6String+0x1c6>
    28de:	4b5a      	ldr	r3, [pc, #360]	; (2a48 <_Z6getAllRK6String+0x32c>)
    28e0:	e000      	b.n	28e4 <_Z6getAllRK6String+0x1c8>
    28e2:	4b5a      	ldr	r3, [pc, #360]	; (2a4c <_Z6getAllRK6String+0x330>)
    28e4:	4618      	mov	r0, r3
    28e6:	f7ff fc55 	bl	2194 <_Z3LOGPKc>
    SL();LOG("samples"           ); LOG(": "); LOG(g_iSamples                );
    28ea:	f7ff fceb 	bl	22c4 <_Z2SLv>
    28ee:	485d      	ldr	r0, [pc, #372]	; (2a64 <_Z6getAllRK6String+0x348>)
    28f0:	f7ff fc50 	bl	2194 <_Z3LOGPKc>
    28f4:	483a      	ldr	r0, [pc, #232]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    28f6:	f7ff fc4d 	bl	2194 <_Z3LOGPKc>
    28fa:	4b5b      	ldr	r3, [pc, #364]	; (2a68 <_Z6getAllRK6String+0x34c>)
    28fc:	681b      	ldr	r3, [r3, #0]
    28fe:	4618      	mov	r0, r3
    2900:	f7ff fc74 	bl	21ec <_Z3LOGm>
    SL();LOG("samplesUseful"     ); LOG(": "); LOG(g_iSamples_useful         );
    2904:	f7ff fcde 	bl	22c4 <_Z2SLv>
    2908:	4858      	ldr	r0, [pc, #352]	; (2a6c <_Z6getAllRK6String+0x350>)
    290a:	f7ff fc43 	bl	2194 <_Z3LOGPKc>
    290e:	4834      	ldr	r0, [pc, #208]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    2910:	f7ff fc40 	bl	2194 <_Z3LOGPKc>
    2914:	4b56      	ldr	r3, [pc, #344]	; (2a70 <_Z6getAllRK6String+0x354>)
    2916:	681b      	ldr	r3, [r3, #0]
    2918:	4618      	mov	r0, r3
    291a:	f7ff fc67 	bl	21ec <_Z3LOGm>
    SL();LOG("targetFrequency"   ); LOG(": "); LOG(g_iTarget_frequency       ); LOG(" Hz");
    291e:	f7ff fcd1 	bl	22c4 <_Z2SLv>
    2922:	4854      	ldr	r0, [pc, #336]	; (2a74 <_Z6getAllRK6String+0x358>)
    2924:	f7ff fc36 	bl	2194 <_Z3LOGPKc>
    2928:	482d      	ldr	r0, [pc, #180]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    292a:	f7ff fc33 	bl	2194 <_Z3LOGPKc>
    292e:	4b52      	ldr	r3, [pc, #328]	; (2a78 <_Z6getAllRK6String+0x35c>)
    2930:	681b      	ldr	r3, [r3, #0]
    2932:	4618      	mov	r0, r3
    2934:	f7ff fc5a 	bl	21ec <_Z3LOGm>
    2938:	4847      	ldr	r0, [pc, #284]	; (2a58 <_Z6getAllRK6String+0x33c>)
    293a:	f7ff fc2b 	bl	2194 <_Z3LOGPKc>
    SL();LOG("targetPeriod"      ); LOG(": "); LOG(g_iTarget_period_us       ); LOG(" μs");
    293e:	f7ff fcc1 	bl	22c4 <_Z2SLv>
    2942:	484e      	ldr	r0, [pc, #312]	; (2a7c <_Z6getAllRK6String+0x360>)
    2944:	f7ff fc26 	bl	2194 <_Z3LOGPKc>
    2948:	4825      	ldr	r0, [pc, #148]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    294a:	f7ff fc23 	bl	2194 <_Z3LOGPKc>
    294e:	4b4c      	ldr	r3, [pc, #304]	; (2a80 <_Z6getAllRK6String+0x364>)
    2950:	edd3 7a00 	vldr	s15, [r3]
    2954:	eeb0 0a67 	vmov.f32	s0, s15
    2958:	f7ff fc56 	bl	2208 <_Z3LOGf>
    295c:	4849      	ldr	r0, [pc, #292]	; (2a84 <_Z6getAllRK6String+0x368>)
    295e:	f7ff fc19 	bl	2194 <_Z3LOGPKc>
    SL();
    2962:	f7ff fcaf 	bl	22c4 <_Z2SLv>
    SL();LOG("dacPoints"         ); LOG(": "); LOG(g_iDAC_points             );
    2966:	f7ff fcad 	bl	22c4 <_Z2SLv>
    296a:	4847      	ldr	r0, [pc, #284]	; (2a88 <_Z6getAllRK6String+0x36c>)
    296c:	f7ff fc12 	bl	2194 <_Z3LOGPKc>
    2970:	481b      	ldr	r0, [pc, #108]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    2972:	f7ff fc0f 	bl	2194 <_Z3LOGPKc>
    2976:	4b45      	ldr	r3, [pc, #276]	; (2a8c <_Z6getAllRK6String+0x370>)
    2978:	881b      	ldrh	r3, [r3, #0]
    297a:	4618      	mov	r0, r3
    297c:	f7ff fc26 	bl	21cc <_Z3LOGt>
    SL();LOG("pdbCycleLength"    ); LOG(": "); LOG(g_iPDB_cycleLength        );
    2980:	f7ff fca0 	bl	22c4 <_Z2SLv>
    2984:	4842      	ldr	r0, [pc, #264]	; (2a90 <_Z6getAllRK6String+0x374>)
    2986:	f7ff fc05 	bl	2194 <_Z3LOGPKc>
    298a:	4815      	ldr	r0, [pc, #84]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    298c:	f7ff fc02 	bl	2194 <_Z3LOGPKc>
    2990:	4b40      	ldr	r3, [pc, #256]	; (2a94 <_Z6getAllRK6String+0x378>)
    2992:	881b      	ldrh	r3, [r3, #0]
    2994:	4618      	mov	r0, r3
    2996:	f7ff fc19 	bl	21cc <_Z3LOGt>
    SL();LOG("dacTriggerInterval"); LOG(": "); LOG(g_iDAC_trigger_interval   );
    299a:	f7ff fc93 	bl	22c4 <_Z2SLv>
    299e:	483e      	ldr	r0, [pc, #248]	; (2a98 <_Z6getAllRK6String+0x37c>)
    29a0:	f7ff fbf8 	bl	2194 <_Z3LOGPKc>
    29a4:	480e      	ldr	r0, [pc, #56]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    29a6:	f7ff fbf5 	bl	2194 <_Z3LOGPKc>
    29aa:	4b3c      	ldr	r3, [pc, #240]	; (2a9c <_Z6getAllRK6String+0x380>)
    29ac:	881b      	ldrh	r3, [r3, #0]
    29ae:	4618      	mov	r0, r3
    29b0:	f7ff fc0c 	bl	21cc <_Z3LOGt>
    SL();LOG("pdbMod"            ); LOG(": "); LOG(g_iPDB_mod                );
    29b4:	f7ff fc86 	bl	22c4 <_Z2SLv>
    29b8:	4839      	ldr	r0, [pc, #228]	; (2aa0 <_Z6getAllRK6String+0x384>)
    29ba:	f7ff fbeb 	bl	2194 <_Z3LOGPKc>
    29be:	4808      	ldr	r0, [pc, #32]	; (29e0 <_Z6getAllRK6String+0x2c4>)
    29c0:	f7ff fbe8 	bl	2194 <_Z3LOGPKc>
    29c4:	4b37      	ldr	r3, [pc, #220]	; (2aa4 <_Z6getAllRK6String+0x388>)
    29c6:	881b      	ldrh	r3, [r3, #0]
    29c8:	4618      	mov	r0, r3
    29ca:	f7ff fbff 	bl	21cc <_Z3LOGt>

    return true;
    29ce:	2301      	movs	r3, #1
}
    29d0:	4618      	mov	r0, r3
    29d2:	3708      	adds	r7, #8
    29d4:	46bd      	mov	sp, r7
    29d6:	bd80      	pop	{r7, pc}
    29d8:	0000f278 	.word	0x0000f278
    29dc:	0000f27c 	.word	0x0000f27c
    29e0:	0000f0ec 	.word	0x0000f0ec
    29e4:	1fff0ac8 	.word	0x1fff0ac8
    29e8:	0000f284 	.word	0x0000f284
    29ec:	1fff0731 	.word	0x1fff0731
    29f0:	0000f28c 	.word	0x0000f28c
    29f4:	1fff0734 	.word	0x1fff0734
    29f8:	0000f294 	.word	0x0000f294
    29fc:	0000f298 	.word	0x0000f298
    2a00:	1fff073c 	.word	0x1fff073c
    2a04:	0000f2a0 	.word	0x0000f2a0
    2a08:	1fff0738 	.word	0x1fff0738
    2a0c:	0000f2ac 	.word	0x0000f2ac
    2a10:	1fff0740 	.word	0x1fff0740
    2a14:	0000f2c0 	.word	0x0000f2c0
    2a18:	0000f2c8 	.word	0x0000f2c8
    2a1c:	1fff0744 	.word	0x1fff0744
    2a20:	0000f2dc 	.word	0x0000f2dc
    2a24:	1fff0748 	.word	0x1fff0748
    2a28:	0000f2f0 	.word	0x0000f2f0
    2a2c:	1fff074c 	.word	0x1fff074c
    2a30:	0000f300 	.word	0x0000f300
    2a34:	1fff0750 	.word	0x1fff0750
    2a38:	0000f310 	.word	0x0000f310
    2a3c:	1fff0754 	.word	0x1fff0754
    2a40:	0000f320 	.word	0x0000f320
    2a44:	1fff0758 	.word	0x1fff0758
    2a48:	0000f0f0 	.word	0x0000f0f0
    2a4c:	0000f0f8 	.word	0x0000f0f8
    2a50:	0000f32c 	.word	0x0000f32c
    2a54:	1fff0760 	.word	0x1fff0760
    2a58:	0000f33c 	.word	0x0000f33c
    2a5c:	0000f340 	.word	0x0000f340
    2a60:	1fff0730 	.word	0x1fff0730
    2a64:	0000f344 	.word	0x0000f344
    2a68:	1fff0adc 	.word	0x1fff0adc
    2a6c:	0000f34c 	.word	0x0000f34c
    2a70:	1fff0ad8 	.word	0x1fff0ad8
    2a74:	0000f35c 	.word	0x0000f35c
    2a78:	1fff0acc 	.word	0x1fff0acc
    2a7c:	0000f36c 	.word	0x0000f36c
    2a80:	1fff0ad4 	.word	0x1fff0ad4
    2a84:	0000f37c 	.word	0x0000f37c
    2a88:	0000f384 	.word	0x0000f384
    2a8c:	1fff0ae0 	.word	0x1fff0ae0
    2a90:	0000f390 	.word	0x0000f390
    2a94:	1fff0ae2 	.word	0x1fff0ae2
    2a98:	0000f3a0 	.word	0x0000f3a0
    2a9c:	1fff0ae4 	.word	0x1fff0ae4
    2aa0:	0000f3b4 	.word	0x0000f3b4
    2aa4:	1fff0ae6 	.word	0x1fff0ae6

00002aa8 <_Z16getConfigCommandRK6StringS1_>:

       

bool getConfigCommand(String const & command, String const & arguments) 
{
    2aa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2aac:	f5ad 7d59 	sub.w	sp, sp, #868	; 0x364
    2ab0:	af00      	add	r7, sp, #0
    2ab2:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2ab6:	f5a3 7331 	sub.w	r3, r3, #708	; 0x2c4
    2aba:	6018      	str	r0, [r3, #0]
    2abc:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2ac0:	f5a3 7332 	sub.w	r3, r3, #712	; 0x2c8
    2ac4:	6019      	str	r1, [r3, #0]
    if ( command != "get" ) return false;
    2ac6:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2aca:	f5a3 7331 	sub.w	r3, r3, #708	; 0x2c4
    2ace:	4912      	ldr	r1, [pc, #72]	; (2b18 <_Z16getConfigCommandRK6StringS1_+0x70>)
    2ad0:	6818      	ldr	r0, [r3, #0]
    2ad2:	f7fd fd2e 	bl	532 <_ZNK6StringneEPKc>
    2ad6:	4603      	mov	r3, r0
    2ad8:	2b00      	cmp	r3, #0
    2ada:	bf14      	ite	ne
    2adc:	2301      	movne	r3, #1
    2ade:	2300      	moveq	r3, #0
    2ae0:	b2db      	uxtb	r3, r3
    2ae2:	2b00      	cmp	r3, #0
    2ae4:	d002      	beq.n	2aec <_Z16getConfigCommandRK6StringS1_+0x44>
    2ae6:	2400      	movs	r4, #0
    2ae8:	f000 bd25 	b.w	3536 <_Z16getConfigCommandRK6StringS1_+0xa8e>
    
    if(arguments.length() == 0 ) return getUsage();
    2aec:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2af0:	f5a3 7332 	sub.w	r3, r3, #712	; 0x2c8
    2af4:	6818      	ldr	r0, [r3, #0]
    2af6:	f7fd fcef 	bl	4d8 <_ZNK6String6lengthEv>
    2afa:	4603      	mov	r3, r0
    2afc:	2b00      	cmp	r3, #0
    2afe:	bf0c      	ite	eq
    2b00:	2301      	moveq	r3, #1
    2b02:	2300      	movne	r3, #0
    2b04:	b2db      	uxtb	r3, r3
    2b06:	2b00      	cmp	r3, #0
    2b08:	d008      	beq.n	2b1c <_Z16getConfigCommandRK6StringS1_+0x74>
    2b0a:	f7ff fda1 	bl	2650 <_Z8getUsagev>
    2b0e:	4603      	mov	r3, r0
    2b10:	461c      	mov	r4, r3
    2b12:	f000 bd10 	b.w	3536 <_Z16getConfigCommandRK6StringS1_+0xa8e>
    2b16:	bf00      	nop
    2b18:	0000f3bc 	.word	0x0000f3bc
    || getDirect("dacPoints"         , "dacPoints"         , arguments, g_iDAC_points             )
    || getDirect("pdbCycleLength"    , "pdbcyclelength"    , arguments, g_iPDB_cycleLength        )
    || getDirect("dacTriggerInterval", "dactriggerinterval", arguments, g_iDAC_trigger_interval   )
    || getDirect("pdbMod"            , "pdbmod"            , arguments, g_iPDB_mod                )

    || unknownValue(arguments);
    2b1c:	2300      	movs	r3, #0
    2b1e:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    2b22:	2300      	movs	r3, #0
    2b24:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    2b28:	2300      	movs	r3, #0
    2b2a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    2b2e:	2300      	movs	r3, #0
    2b30:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    2b34:	2300      	movs	r3, #0
    2b36:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    2b3a:	2300      	movs	r3, #0
    2b3c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    2b40:	2300      	movs	r3, #0
    2b42:	67fb      	str	r3, [r7, #124]	; 0x7c
    2b44:	2300      	movs	r3, #0
    2b46:	67bb      	str	r3, [r7, #120]	; 0x78
    2b48:	2300      	movs	r3, #0
    2b4a:	677b      	str	r3, [r7, #116]	; 0x74
    2b4c:	2300      	movs	r3, #0
    2b4e:	673b      	str	r3, [r7, #112]	; 0x70
    2b50:	2300      	movs	r3, #0
    2b52:	66fb      	str	r3, [r7, #108]	; 0x6c
    2b54:	2300      	movs	r3, #0
    2b56:	66bb      	str	r3, [r7, #104]	; 0x68
    2b58:	2300      	movs	r3, #0
    2b5a:	667b      	str	r3, [r7, #100]	; 0x64
    2b5c:	2300      	movs	r3, #0
    2b5e:	663b      	str	r3, [r7, #96]	; 0x60
    2b60:	2300      	movs	r3, #0
    2b62:	65fb      	str	r3, [r7, #92]	; 0x5c
    2b64:	2300      	movs	r3, #0
    2b66:	65bb      	str	r3, [r7, #88]	; 0x58
    2b68:	2300      	movs	r3, #0
    2b6a:	657b      	str	r3, [r7, #84]	; 0x54
    2b6c:	2300      	movs	r3, #0
    2b6e:	653b      	str	r3, [r7, #80]	; 0x50
    2b70:	2300      	movs	r3, #0
    2b72:	64fb      	str	r3, [r7, #76]	; 0x4c
    2b74:	2300      	movs	r3, #0
    2b76:	64bb      	str	r3, [r7, #72]	; 0x48
    2b78:	2300      	movs	r3, #0
    2b7a:	647b      	str	r3, [r7, #68]	; 0x44
    2b7c:	2300      	movs	r3, #0
    2b7e:	643b      	str	r3, [r7, #64]	; 0x40
    2b80:	2300      	movs	r3, #0
    2b82:	63fb      	str	r3, [r7, #60]	; 0x3c
    2b84:	2300      	movs	r3, #0
    2b86:	63bb      	str	r3, [r7, #56]	; 0x38
    2b88:	2300      	movs	r3, #0
    2b8a:	637b      	str	r3, [r7, #52]	; 0x34
    2b8c:	2300      	movs	r3, #0
    2b8e:	633b      	str	r3, [r7, #48]	; 0x30
    2b90:	2300      	movs	r3, #0
    2b92:	62fb      	str	r3, [r7, #44]	; 0x2c
    2b94:	2300      	movs	r3, #0
    2b96:	62bb      	str	r3, [r7, #40]	; 0x28
    2b98:	2300      	movs	r3, #0
    2b9a:	627b      	str	r3, [r7, #36]	; 0x24
    2b9c:	2300      	movs	r3, #0
    2b9e:	623b      	str	r3, [r7, #32]
    2ba0:	2300      	movs	r3, #0
    2ba2:	61fb      	str	r3, [r7, #28]
    2ba4:	2300      	movs	r3, #0
    2ba6:	61bb      	str	r3, [r7, #24]
    2ba8:	2300      	movs	r3, #0
    2baa:	617b      	str	r3, [r7, #20]
    2bac:	2300      	movs	r3, #0
    2bae:	613b      	str	r3, [r7, #16]
    2bb0:	2300      	movs	r3, #0
    2bb2:	60fb      	str	r3, [r7, #12]
    2bb4:	2300      	movs	r3, #0
    2bb6:	60bb      	str	r3, [r7, #8]
    2bb8:	2300      	movs	r3, #0
    2bba:	607b      	str	r3, [r7, #4]
    2bbc:	2300      	movs	r3, #0
    2bbe:	603b      	str	r3, [r7, #0]
    2bc0:	f04f 0b00 	mov.w	fp, #0
    2bc4:	f04f 0a00 	mov.w	sl, #0
    2bc8:	f04f 0900 	mov.w	r9, #0
    2bcc:	f04f 0800 	mov.w	r8, #0
    2bd0:	2600      	movs	r6, #0
    2bd2:	2500      	movs	r5, #0
    return getAll(arguments)
    2bd4:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2bd8:	f5a3 7332 	sub.w	r3, r3, #712	; 0x2c8
    2bdc:	6818      	ldr	r0, [r3, #0]
    2bde:	f7ff fd9d 	bl	271c <_Z6getAllRK6String>
    2be2:	4603      	mov	r3, r0
    || unknownValue(arguments);
    2be4:	2b00      	cmp	r3, #0
    2be6:	f040 830f 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirectE<Modes>("mode"      , "mode"              , arguments, g_eMode                   )
    2bea:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
    2bee:	49d2      	ldr	r1, [pc, #840]	; (2f38 <_Z16getConfigCommandRK6StringS1_+0x490>)
    2bf0:	4618      	mov	r0, r3
    2bf2:	f003 fd23 	bl	663c <_ZN6StringC1EPKc>
    2bf6:	2301      	movs	r3, #1
    2bf8:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    2bfc:	f107 03b0 	add.w	r3, r7, #176	; 0xb0
    2c00:	49cd      	ldr	r1, [pc, #820]	; (2f38 <_Z16getConfigCommandRK6StringS1_+0x490>)
    2c02:	4618      	mov	r0, r3
    2c04:	f003 fd1a 	bl	663c <_ZN6StringC1EPKc>
    2c08:	2301      	movs	r3, #1
    2c0a:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    2c0e:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2c12:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2c16:	f107 01b0 	add.w	r1, r7, #176	; 0xb0
    2c1a:	f107 00a0 	add.w	r0, r7, #160	; 0xa0
    2c1e:	4bc7      	ldr	r3, [pc, #796]	; (2f3c <_Z16getConfigCommandRK6StringS1_+0x494>)
    2c20:	6812      	ldr	r2, [r2, #0]
    2c22:	f001 fb7f 	bl	4324 <_Z10getDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_RT0_>
    2c26:	4603      	mov	r3, r0
    2c28:	2b00      	cmp	r3, #0
    2c2a:	f040 82ed 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirectE<DACModes>("dacMode", "dacmode"           , arguments, g_eDACMode                )
    2c2e:	f107 03c0 	add.w	r3, r7, #192	; 0xc0
    2c32:	49c3      	ldr	r1, [pc, #780]	; (2f40 <_Z16getConfigCommandRK6StringS1_+0x498>)
    2c34:	4618      	mov	r0, r3
    2c36:	f003 fd01 	bl	663c <_ZN6StringC1EPKc>
    2c3a:	2301      	movs	r3, #1
    2c3c:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    2c40:	f107 03d0 	add.w	r3, r7, #208	; 0xd0
    2c44:	49bf      	ldr	r1, [pc, #764]	; (2f44 <_Z16getConfigCommandRK6StringS1_+0x49c>)
    2c46:	4618      	mov	r0, r3
    2c48:	f003 fcf8 	bl	663c <_ZN6StringC1EPKc>
    2c4c:	2301      	movs	r3, #1
    2c4e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    2c52:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2c56:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2c5a:	f107 01d0 	add.w	r1, r7, #208	; 0xd0
    2c5e:	f107 00c0 	add.w	r0, r7, #192	; 0xc0
    2c62:	4bb9      	ldr	r3, [pc, #740]	; (2f48 <_Z16getConfigCommandRK6StringS1_+0x4a0>)
    2c64:	6812      	ldr	r2, [r2, #0]
    2c66:	f001 fb8b 	bl	4380 <_Z10getDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_RT0_>
    2c6a:	4603      	mov	r3, r0
    2c6c:	2b00      	cmp	r3, #0
    2c6e:	f040 82cb 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("delay"             , "delay"             , arguments, g_iDelay_ms               )
    2c72:	f107 03e0 	add.w	r3, r7, #224	; 0xe0
    2c76:	49b5      	ldr	r1, [pc, #724]	; (2f4c <_Z16getConfigCommandRK6StringS1_+0x4a4>)
    2c78:	4618      	mov	r0, r3
    2c7a:	f003 fcdf 	bl	663c <_ZN6StringC1EPKc>
    2c7e:	2301      	movs	r3, #1
    2c80:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    2c84:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
    2c88:	49b0      	ldr	r1, [pc, #704]	; (2f4c <_Z16getConfigCommandRK6StringS1_+0x4a4>)
    2c8a:	4618      	mov	r0, r3
    2c8c:	f003 fcd6 	bl	663c <_ZN6StringC1EPKc>
    2c90:	2301      	movs	r3, #1
    2c92:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    2c96:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2c9a:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2c9e:	f107 01f0 	add.w	r1, r7, #240	; 0xf0
    2ca2:	f107 00e0 	add.w	r0, r7, #224	; 0xe0
    2ca6:	4baa      	ldr	r3, [pc, #680]	; (2f50 <_Z16getConfigCommandRK6StringS1_+0x4a8>)
    2ca8:	6812      	ldr	r2, [r2, #0]
    2caa:	f7ff fb59 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    2cae:	4603      	mov	r3, r0
    2cb0:	2b00      	cmp	r3, #0
    2cb2:	f040 82a9 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("dist"              , "dist"              , arguments, g_iDrivingDist                   )
    2cb6:	f507 7380 	add.w	r3, r7, #256	; 0x100
    2cba:	49a6      	ldr	r1, [pc, #664]	; (2f54 <_Z16getConfigCommandRK6StringS1_+0x4ac>)
    2cbc:	4618      	mov	r0, r3
    2cbe:	f003 fcbd 	bl	663c <_ZN6StringC1EPKc>
    2cc2:	2301      	movs	r3, #1
    2cc4:	67fb      	str	r3, [r7, #124]	; 0x7c
    2cc6:	f507 7388 	add.w	r3, r7, #272	; 0x110
    2cca:	49a2      	ldr	r1, [pc, #648]	; (2f54 <_Z16getConfigCommandRK6StringS1_+0x4ac>)
    2ccc:	4618      	mov	r0, r3
    2cce:	f003 fcb5 	bl	663c <_ZN6StringC1EPKc>
    2cd2:	2301      	movs	r3, #1
    2cd4:	67bb      	str	r3, [r7, #120]	; 0x78
    2cd6:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2cda:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2cde:	f507 7188 	add.w	r1, r7, #272	; 0x110
    2ce2:	f507 7080 	add.w	r0, r7, #256	; 0x100
    2ce6:	4b9c      	ldr	r3, [pc, #624]	; (2f58 <_Z16getConfigCommandRK6StringS1_+0x4b0>)
    2ce8:	6812      	ldr	r2, [r2, #0]
    2cea:	f7ff fb39 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    2cee:	4603      	mov	r3, r0
    2cf0:	2b00      	cmp	r3, #0
    2cf2:	f040 8289 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("electrodes"        , "electrodes"        , arguments, g_iElectrodes             )
    2cf6:	f507 7390 	add.w	r3, r7, #288	; 0x120
    2cfa:	4998      	ldr	r1, [pc, #608]	; (2f5c <_Z16getConfigCommandRK6StringS1_+0x4b4>)
    2cfc:	4618      	mov	r0, r3
    2cfe:	f003 fc9d 	bl	663c <_ZN6StringC1EPKc>
    2d02:	2301      	movs	r3, #1
    2d04:	677b      	str	r3, [r7, #116]	; 0x74
    2d06:	f507 7398 	add.w	r3, r7, #304	; 0x130
    2d0a:	4994      	ldr	r1, [pc, #592]	; (2f5c <_Z16getConfigCommandRK6StringS1_+0x4b4>)
    2d0c:	4618      	mov	r0, r3
    2d0e:	f003 fc95 	bl	663c <_ZN6StringC1EPKc>
    2d12:	2301      	movs	r3, #1
    2d14:	673b      	str	r3, [r7, #112]	; 0x70
    2d16:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2d1a:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2d1e:	f507 7198 	add.w	r1, r7, #304	; 0x130
    2d22:	f507 7090 	add.w	r0, r7, #288	; 0x120
    2d26:	4b8e      	ldr	r3, [pc, #568]	; (2f60 <_Z16getConfigCommandRK6StringS1_+0x4b8>)
    2d28:	6812      	ldr	r2, [r2, #0]
    2d2a:	f7ff fb19 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    2d2e:	4603      	mov	r3, r0
    2d30:	2b00      	cmp	r3, #0
    2d32:	f040 8269 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("inputGainResistor1", "inputgainresistor1", arguments, g_iInputGainResistor1_ohms)
    2d36:	f507 73a0 	add.w	r3, r7, #320	; 0x140
    2d3a:	498a      	ldr	r1, [pc, #552]	; (2f64 <_Z16getConfigCommandRK6StringS1_+0x4bc>)
    2d3c:	4618      	mov	r0, r3
    2d3e:	f003 fc7d 	bl	663c <_ZN6StringC1EPKc>
    2d42:	2301      	movs	r3, #1
    2d44:	66fb      	str	r3, [r7, #108]	; 0x6c
    2d46:	f507 73a8 	add.w	r3, r7, #336	; 0x150
    2d4a:	4987      	ldr	r1, [pc, #540]	; (2f68 <_Z16getConfigCommandRK6StringS1_+0x4c0>)
    2d4c:	4618      	mov	r0, r3
    2d4e:	f003 fc75 	bl	663c <_ZN6StringC1EPKc>
    2d52:	2301      	movs	r3, #1
    2d54:	66bb      	str	r3, [r7, #104]	; 0x68
    2d56:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2d5a:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2d5e:	f507 71a8 	add.w	r1, r7, #336	; 0x150
    2d62:	f507 70a0 	add.w	r0, r7, #320	; 0x140
    2d66:	4b81      	ldr	r3, [pc, #516]	; (2f6c <_Z16getConfigCommandRK6StringS1_+0x4c4>)
    2d68:	6812      	ldr	r2, [r2, #0]
    2d6a:	f7ff faf9 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    2d6e:	4603      	mov	r3, r0
    2d70:	2b00      	cmp	r3, #0
    2d72:	f040 8249 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("inputGainResistor2", "inputgainresistor2", arguments, g_iInputGainResistor2_ohms)
    2d76:	f507 73b0 	add.w	r3, r7, #352	; 0x160
    2d7a:	497d      	ldr	r1, [pc, #500]	; (2f70 <_Z16getConfigCommandRK6StringS1_+0x4c8>)
    2d7c:	4618      	mov	r0, r3
    2d7e:	f003 fc5d 	bl	663c <_ZN6StringC1EPKc>
    2d82:	2301      	movs	r3, #1
    2d84:	667b      	str	r3, [r7, #100]	; 0x64
    2d86:	f507 73b8 	add.w	r3, r7, #368	; 0x170
    2d8a:	497a      	ldr	r1, [pc, #488]	; (2f74 <_Z16getConfigCommandRK6StringS1_+0x4cc>)
    2d8c:	4618      	mov	r0, r3
    2d8e:	f003 fc55 	bl	663c <_ZN6StringC1EPKc>
    2d92:	2301      	movs	r3, #1
    2d94:	663b      	str	r3, [r7, #96]	; 0x60
    2d96:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2d9a:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2d9e:	f507 71b8 	add.w	r1, r7, #368	; 0x170
    2da2:	f507 70b0 	add.w	r0, r7, #352	; 0x160
    2da6:	4b74      	ldr	r3, [pc, #464]	; (2f78 <_Z16getConfigCommandRK6StringS1_+0x4d0>)
    2da8:	6812      	ldr	r2, [r2, #0]
    2daa:	f7ff fad9 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    2dae:	4603      	mov	r3, r0
    2db0:	2b00      	cmp	r3, #0
    2db2:	f040 8229 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("outputGainResistor", "outputgainresistor", arguments, g_iOutputGainResistor_ohms)
    2db6:	f507 73c0 	add.w	r3, r7, #384	; 0x180
    2dba:	4970      	ldr	r1, [pc, #448]	; (2f7c <_Z16getConfigCommandRK6StringS1_+0x4d4>)
    2dbc:	4618      	mov	r0, r3
    2dbe:	f003 fc3d 	bl	663c <_ZN6StringC1EPKc>
    2dc2:	2301      	movs	r3, #1
    2dc4:	65fb      	str	r3, [r7, #92]	; 0x5c
    2dc6:	f507 73c8 	add.w	r3, r7, #400	; 0x190
    2dca:	496d      	ldr	r1, [pc, #436]	; (2f80 <_Z16getConfigCommandRK6StringS1_+0x4d8>)
    2dcc:	4618      	mov	r0, r3
    2dce:	f003 fc35 	bl	663c <_ZN6StringC1EPKc>
    2dd2:	2301      	movs	r3, #1
    2dd4:	65bb      	str	r3, [r7, #88]	; 0x58
    2dd6:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2dda:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2dde:	f507 71c8 	add.w	r1, r7, #400	; 0x190
    2de2:	f507 70c0 	add.w	r0, r7, #384	; 0x180
    2de6:	4b67      	ldr	r3, [pc, #412]	; (2f84 <_Z16getConfigCommandRK6StringS1_+0x4dc>)
    2de8:	6812      	ldr	r2, [r2, #0]
    2dea:	f7ff fab9 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    2dee:	4603      	mov	r3, r0
    2df0:	2b00      	cmp	r3, #0
    2df2:	f040 8209 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("sampleCycles"      , "samplecycles"      , arguments, g_iSample_cycles          )
    2df6:	f507 73d0 	add.w	r3, r7, #416	; 0x1a0
    2dfa:	4963      	ldr	r1, [pc, #396]	; (2f88 <_Z16getConfigCommandRK6StringS1_+0x4e0>)
    2dfc:	4618      	mov	r0, r3
    2dfe:	f003 fc1d 	bl	663c <_ZN6StringC1EPKc>
    2e02:	2301      	movs	r3, #1
    2e04:	657b      	str	r3, [r7, #84]	; 0x54
    2e06:	f507 73d8 	add.w	r3, r7, #432	; 0x1b0
    2e0a:	4960      	ldr	r1, [pc, #384]	; (2f8c <_Z16getConfigCommandRK6StringS1_+0x4e4>)
    2e0c:	4618      	mov	r0, r3
    2e0e:	f003 fc15 	bl	663c <_ZN6StringC1EPKc>
    2e12:	2301      	movs	r3, #1
    2e14:	653b      	str	r3, [r7, #80]	; 0x50
    2e16:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2e1a:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2e1e:	f507 71d8 	add.w	r1, r7, #432	; 0x1b0
    2e22:	f507 70d0 	add.w	r0, r7, #416	; 0x1a0
    2e26:	4b5a      	ldr	r3, [pc, #360]	; (2f90 <_Z16getConfigCommandRK6StringS1_+0x4e8>)
    2e28:	6812      	ldr	r2, [r2, #0]
    2e2a:	f7ff fa99 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    2e2e:	4603      	mov	r3, r0
    2e30:	2b00      	cmp	r3, #0
    2e32:	f040 81e9 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("samplesPerCycle"   , "samplespercycle"   , arguments, g_iSamples_per_cycle      )
    2e36:	f507 73e0 	add.w	r3, r7, #448	; 0x1c0
    2e3a:	4956      	ldr	r1, [pc, #344]	; (2f94 <_Z16getConfigCommandRK6StringS1_+0x4ec>)
    2e3c:	4618      	mov	r0, r3
    2e3e:	f003 fbfd 	bl	663c <_ZN6StringC1EPKc>
    2e42:	2301      	movs	r3, #1
    2e44:	64fb      	str	r3, [r7, #76]	; 0x4c
    2e46:	f507 73e8 	add.w	r3, r7, #464	; 0x1d0
    2e4a:	4953      	ldr	r1, [pc, #332]	; (2f98 <_Z16getConfigCommandRK6StringS1_+0x4f0>)
    2e4c:	4618      	mov	r0, r3
    2e4e:	f003 fbf5 	bl	663c <_ZN6StringC1EPKc>
    2e52:	2301      	movs	r3, #1
    2e54:	64bb      	str	r3, [r7, #72]	; 0x48
    2e56:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2e5a:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2e5e:	f507 71e8 	add.w	r1, r7, #464	; 0x1d0
    2e62:	f507 70e0 	add.w	r0, r7, #448	; 0x1c0
    2e66:	4b4d      	ldr	r3, [pc, #308]	; (2f9c <_Z16getConfigCommandRK6StringS1_+0x4f4>)
    2e68:	6812      	ldr	r2, [r2, #0]
    2e6a:	f7ff fa79 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    2e6e:	4603      	mov	r3, r0
    2e70:	2b00      	cmp	r3, #0
    2e72:	f040 81c9 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("sampleRubbish"     , "samplerubbish"     , arguments, g_iSample_rubbish         )
    2e76:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
    2e7a:	4949      	ldr	r1, [pc, #292]	; (2fa0 <_Z16getConfigCommandRK6StringS1_+0x4f8>)
    2e7c:	4618      	mov	r0, r3
    2e7e:	f003 fbdd 	bl	663c <_ZN6StringC1EPKc>
    2e82:	2301      	movs	r3, #1
    2e84:	647b      	str	r3, [r7, #68]	; 0x44
    2e86:	f507 73f8 	add.w	r3, r7, #496	; 0x1f0
    2e8a:	4946      	ldr	r1, [pc, #280]	; (2fa4 <_Z16getConfigCommandRK6StringS1_+0x4fc>)
    2e8c:	4618      	mov	r0, r3
    2e8e:	f003 fbd5 	bl	663c <_ZN6StringC1EPKc>
    2e92:	2301      	movs	r3, #1
    2e94:	643b      	str	r3, [r7, #64]	; 0x40
    2e96:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2e9a:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2e9e:	f507 71f8 	add.w	r1, r7, #496	; 0x1f0
    2ea2:	f507 70f0 	add.w	r0, r7, #480	; 0x1e0
    2ea6:	4b40      	ldr	r3, [pc, #256]	; (2fa8 <_Z16getConfigCommandRK6StringS1_+0x500>)
    2ea8:	6812      	ldr	r2, [r2, #0]
    2eaa:	f7ff fa59 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    2eae:	4603      	mov	r3, r0
    2eb0:	2b00      	cmp	r3, #0
    2eb2:	f040 81a9 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("mapToLines"        , "mapToLines"        , arguments, g_bMapElectrodesToLines            )
    2eb6:	f507 7300 	add.w	r3, r7, #512	; 0x200
    2eba:	493c      	ldr	r1, [pc, #240]	; (2fac <_Z16getConfigCommandRK6StringS1_+0x504>)
    2ebc:	4618      	mov	r0, r3
    2ebe:	f003 fbbd 	bl	663c <_ZN6StringC1EPKc>
    2ec2:	2301      	movs	r3, #1
    2ec4:	63fb      	str	r3, [r7, #60]	; 0x3c
    2ec6:	f507 7304 	add.w	r3, r7, #528	; 0x210
    2eca:	4938      	ldr	r1, [pc, #224]	; (2fac <_Z16getConfigCommandRK6StringS1_+0x504>)
    2ecc:	4618      	mov	r0, r3
    2ece:	f003 fbb5 	bl	663c <_ZN6StringC1EPKc>
    2ed2:	2301      	movs	r3, #1
    2ed4:	63bb      	str	r3, [r7, #56]	; 0x38
    2ed6:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2eda:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2ede:	f507 7104 	add.w	r1, r7, #528	; 0x210
    2ee2:	f507 7000 	add.w	r0, r7, #512	; 0x200
    2ee6:	4b32      	ldr	r3, [pc, #200]	; (2fb0 <_Z16getConfigCommandRK6StringS1_+0x508>)
    2ee8:	6812      	ldr	r2, [r2, #0]
    2eea:	f7ff fa97 	bl	241c <_Z9getDirectRK6StringS1_S1_Rb>
    2eee:	4603      	mov	r3, r0
    2ef0:	2b00      	cmp	r3, #0
    2ef2:	f040 8189 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("adcFrequency"      , "adcfrequency"      , arguments, g_iADC_frequency          )
    2ef6:	f507 7308 	add.w	r3, r7, #544	; 0x220
    2efa:	492e      	ldr	r1, [pc, #184]	; (2fb4 <_Z16getConfigCommandRK6StringS1_+0x50c>)
    2efc:	4618      	mov	r0, r3
    2efe:	f003 fb9d 	bl	663c <_ZN6StringC1EPKc>
    2f02:	2301      	movs	r3, #1
    2f04:	637b      	str	r3, [r7, #52]	; 0x34
    2f06:	f507 730c 	add.w	r3, r7, #560	; 0x230
    2f0a:	492b      	ldr	r1, [pc, #172]	; (2fb8 <_Z16getConfigCommandRK6StringS1_+0x510>)
    2f0c:	4618      	mov	r0, r3
    2f0e:	f003 fb95 	bl	663c <_ZN6StringC1EPKc>
    2f12:	2301      	movs	r3, #1
    2f14:	633b      	str	r3, [r7, #48]	; 0x30
    2f16:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2f1a:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2f1e:	f507 710c 	add.w	r1, r7, #560	; 0x230
    2f22:	f507 7008 	add.w	r0, r7, #544	; 0x220
    2f26:	4b25      	ldr	r3, [pc, #148]	; (2fbc <_Z16getConfigCommandRK6StringS1_+0x514>)
    2f28:	6812      	ldr	r2, [r2, #0]
    2f2a:	f7ff fa19 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    2f2e:	4603      	mov	r3, r0
    2f30:	2b00      	cmp	r3, #0
    2f32:	f040 8169 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    2f36:	e043      	b.n	2fc0 <_Z16getConfigCommandRK6StringS1_+0x518>
    2f38:	0000f27c 	.word	0x0000f27c
    2f3c:	1fff0ac8 	.word	0x1fff0ac8
    2f40:	0000f284 	.word	0x0000f284
    2f44:	0000f3c0 	.word	0x0000f3c0
    2f48:	1fff0731 	.word	0x1fff0731
    2f4c:	0000f28c 	.word	0x0000f28c
    2f50:	1fff0734 	.word	0x1fff0734
    2f54:	0000f298 	.word	0x0000f298
    2f58:	1fff073c 	.word	0x1fff073c
    2f5c:	0000f2a0 	.word	0x0000f2a0
    2f60:	1fff0738 	.word	0x1fff0738
    2f64:	0000f2ac 	.word	0x0000f2ac
    2f68:	0000f3c8 	.word	0x0000f3c8
    2f6c:	1fff0740 	.word	0x1fff0740
    2f70:	0000f2c8 	.word	0x0000f2c8
    2f74:	0000f3dc 	.word	0x0000f3dc
    2f78:	1fff0744 	.word	0x1fff0744
    2f7c:	0000f2dc 	.word	0x0000f2dc
    2f80:	0000f3f0 	.word	0x0000f3f0
    2f84:	1fff0748 	.word	0x1fff0748
    2f88:	0000f2f0 	.word	0x0000f2f0
    2f8c:	0000f404 	.word	0x0000f404
    2f90:	1fff074c 	.word	0x1fff074c
    2f94:	0000f300 	.word	0x0000f300
    2f98:	0000f414 	.word	0x0000f414
    2f9c:	1fff0750 	.word	0x1fff0750
    2fa0:	0000f310 	.word	0x0000f310
    2fa4:	0000f424 	.word	0x0000f424
    2fa8:	1fff0754 	.word	0x1fff0754
    2fac:	0000f320 	.word	0x0000f320
    2fb0:	1fff0758 	.word	0x1fff0758
    2fb4:	0000f32c 	.word	0x0000f32c
    2fb8:	0000f434 	.word	0x0000f434
    2fbc:	1fff0760 	.word	0x1fff0760
    || getDirect("run"               , "run"               , arguments, g_bRun                    )
    2fc0:	f507 7310 	add.w	r3, r7, #576	; 0x240
    2fc4:	4991      	ldr	r1, [pc, #580]	; (320c <_Z16getConfigCommandRK6StringS1_+0x764>)
    2fc6:	4618      	mov	r0, r3
    2fc8:	f003 fb38 	bl	663c <_ZN6StringC1EPKc>
    2fcc:	2301      	movs	r3, #1
    2fce:	62fb      	str	r3, [r7, #44]	; 0x2c
    2fd0:	f507 7314 	add.w	r3, r7, #592	; 0x250
    2fd4:	498d      	ldr	r1, [pc, #564]	; (320c <_Z16getConfigCommandRK6StringS1_+0x764>)
    2fd6:	4618      	mov	r0, r3
    2fd8:	f003 fb30 	bl	663c <_ZN6StringC1EPKc>
    2fdc:	2301      	movs	r3, #1
    2fde:	62bb      	str	r3, [r7, #40]	; 0x28
    2fe0:	f507 7358 	add.w	r3, r7, #864	; 0x360
    2fe4:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    2fe8:	f507 7114 	add.w	r1, r7, #592	; 0x250
    2fec:	f507 7010 	add.w	r0, r7, #576	; 0x240
    2ff0:	4b87      	ldr	r3, [pc, #540]	; (3210 <_Z16getConfigCommandRK6StringS1_+0x768>)
    2ff2:	6812      	ldr	r2, [r2, #0]
    2ff4:	f7ff fa12 	bl	241c <_Z9getDirectRK6StringS1_S1_Rb>
    2ff8:	4603      	mov	r3, r0
    2ffa:	2b00      	cmp	r3, #0
    2ffc:	f040 8104 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("samples"           , "samples"           , arguments, g_iSamples                )
    3000:	f507 7318 	add.w	r3, r7, #608	; 0x260
    3004:	4983      	ldr	r1, [pc, #524]	; (3214 <_Z16getConfigCommandRK6StringS1_+0x76c>)
    3006:	4618      	mov	r0, r3
    3008:	f003 fb18 	bl	663c <_ZN6StringC1EPKc>
    300c:	2301      	movs	r3, #1
    300e:	627b      	str	r3, [r7, #36]	; 0x24
    3010:	f507 731c 	add.w	r3, r7, #624	; 0x270
    3014:	497f      	ldr	r1, [pc, #508]	; (3214 <_Z16getConfigCommandRK6StringS1_+0x76c>)
    3016:	4618      	mov	r0, r3
    3018:	f003 fb10 	bl	663c <_ZN6StringC1EPKc>
    301c:	2301      	movs	r3, #1
    301e:	623b      	str	r3, [r7, #32]
    3020:	f507 7358 	add.w	r3, r7, #864	; 0x360
    3024:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    3028:	f507 711c 	add.w	r1, r7, #624	; 0x270
    302c:	f507 7018 	add.w	r0, r7, #608	; 0x260
    3030:	4b79      	ldr	r3, [pc, #484]	; (3218 <_Z16getConfigCommandRK6StringS1_+0x770>)
    3032:	6812      	ldr	r2, [r2, #0]
    3034:	f7ff f994 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    3038:	4603      	mov	r3, r0
    303a:	2b00      	cmp	r3, #0
    303c:	f040 80e4 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("samplesUseful"     , "samplesuseful"     , arguments, g_iSamples_useful         )
    3040:	f507 7320 	add.w	r3, r7, #640	; 0x280
    3044:	4975      	ldr	r1, [pc, #468]	; (321c <_Z16getConfigCommandRK6StringS1_+0x774>)
    3046:	4618      	mov	r0, r3
    3048:	f003 faf8 	bl	663c <_ZN6StringC1EPKc>
    304c:	2301      	movs	r3, #1
    304e:	61fb      	str	r3, [r7, #28]
    3050:	f507 7324 	add.w	r3, r7, #656	; 0x290
    3054:	4972      	ldr	r1, [pc, #456]	; (3220 <_Z16getConfigCommandRK6StringS1_+0x778>)
    3056:	4618      	mov	r0, r3
    3058:	f003 faf0 	bl	663c <_ZN6StringC1EPKc>
    305c:	2301      	movs	r3, #1
    305e:	61bb      	str	r3, [r7, #24]
    3060:	f507 7358 	add.w	r3, r7, #864	; 0x360
    3064:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    3068:	f507 7124 	add.w	r1, r7, #656	; 0x290
    306c:	f507 7020 	add.w	r0, r7, #640	; 0x280
    3070:	4b6c      	ldr	r3, [pc, #432]	; (3224 <_Z16getConfigCommandRK6StringS1_+0x77c>)
    3072:	6812      	ldr	r2, [r2, #0]
    3074:	f7ff f974 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    3078:	4603      	mov	r3, r0
    307a:	2b00      	cmp	r3, #0
    307c:	f040 80c4 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("targetFrequency"   , "targetfrequency"   , arguments, g_iTarget_frequency       )
    3080:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
    3084:	4968      	ldr	r1, [pc, #416]	; (3228 <_Z16getConfigCommandRK6StringS1_+0x780>)
    3086:	4618      	mov	r0, r3
    3088:	f003 fad8 	bl	663c <_ZN6StringC1EPKc>
    308c:	2301      	movs	r3, #1
    308e:	617b      	str	r3, [r7, #20]
    3090:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
    3094:	4965      	ldr	r1, [pc, #404]	; (322c <_Z16getConfigCommandRK6StringS1_+0x784>)
    3096:	4618      	mov	r0, r3
    3098:	f003 fad0 	bl	663c <_ZN6StringC1EPKc>
    309c:	2301      	movs	r3, #1
    309e:	613b      	str	r3, [r7, #16]
    30a0:	f507 7358 	add.w	r3, r7, #864	; 0x360
    30a4:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    30a8:	f507 712c 	add.w	r1, r7, #688	; 0x2b0
    30ac:	f507 7028 	add.w	r0, r7, #672	; 0x2a0
    30b0:	4b5f      	ldr	r3, [pc, #380]	; (3230 <_Z16getConfigCommandRK6StringS1_+0x788>)
    30b2:	6812      	ldr	r2, [r2, #0]
    30b4:	f7ff f954 	bl	2360 <_Z9getDirectRK6StringS1_S1_Rm>
    30b8:	4603      	mov	r3, r0
    30ba:	2b00      	cmp	r3, #0
    30bc:	f040 80a4 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("targetPeriod"      , "targetperiod"      , arguments, g_iTarget_period_us       )
    30c0:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
    30c4:	495b      	ldr	r1, [pc, #364]	; (3234 <_Z16getConfigCommandRK6StringS1_+0x78c>)
    30c6:	4618      	mov	r0, r3
    30c8:	f003 fab8 	bl	663c <_ZN6StringC1EPKc>
    30cc:	2301      	movs	r3, #1
    30ce:	60fb      	str	r3, [r7, #12]
    30d0:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
    30d4:	4958      	ldr	r1, [pc, #352]	; (3238 <_Z16getConfigCommandRK6StringS1_+0x790>)
    30d6:	4618      	mov	r0, r3
    30d8:	f003 fab0 	bl	663c <_ZN6StringC1EPKc>
    30dc:	2301      	movs	r3, #1
    30de:	60bb      	str	r3, [r7, #8]
    30e0:	f507 7358 	add.w	r3, r7, #864	; 0x360
    30e4:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    30e8:	f507 7134 	add.w	r1, r7, #720	; 0x2d0
    30ec:	f507 7030 	add.w	r0, r7, #704	; 0x2c0
    30f0:	4b52      	ldr	r3, [pc, #328]	; (323c <_Z16getConfigCommandRK6StringS1_+0x794>)
    30f2:	6812      	ldr	r2, [r2, #0]
    30f4:	f7ff f962 	bl	23bc <_Z9getDirectRK6StringS1_S1_Rf>
    30f8:	4603      	mov	r3, r0
    30fa:	2b00      	cmp	r3, #0
    30fc:	f040 8084 	bne.w	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("dacPoints"         , "dacPoints"         , arguments, g_iDAC_points             )
    3100:	f507 7338 	add.w	r3, r7, #736	; 0x2e0
    3104:	494e      	ldr	r1, [pc, #312]	; (3240 <_Z16getConfigCommandRK6StringS1_+0x798>)
    3106:	4618      	mov	r0, r3
    3108:	f003 fa98 	bl	663c <_ZN6StringC1EPKc>
    310c:	2301      	movs	r3, #1
    310e:	607b      	str	r3, [r7, #4]
    3110:	f507 733c 	add.w	r3, r7, #752	; 0x2f0
    3114:	494a      	ldr	r1, [pc, #296]	; (3240 <_Z16getConfigCommandRK6StringS1_+0x798>)
    3116:	4618      	mov	r0, r3
    3118:	f003 fa90 	bl	663c <_ZN6StringC1EPKc>
    311c:	2301      	movs	r3, #1
    311e:	603b      	str	r3, [r7, #0]
    3120:	f507 7358 	add.w	r3, r7, #864	; 0x360
    3124:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    3128:	f507 713c 	add.w	r1, r7, #752	; 0x2f0
    312c:	f507 7038 	add.w	r0, r7, #736	; 0x2e0
    3130:	4b44      	ldr	r3, [pc, #272]	; (3244 <_Z16getConfigCommandRK6StringS1_+0x79c>)
    3132:	6812      	ldr	r2, [r2, #0]
    3134:	f7ff f8e6 	bl	2304 <_Z9getDirectRK6StringS1_S1_Rt>
    3138:	4603      	mov	r3, r0
    313a:	2b00      	cmp	r3, #0
    313c:	d164      	bne.n	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("pdbCycleLength"    , "pdbcyclelength"    , arguments, g_iPDB_cycleLength        )
    313e:	f507 7340 	add.w	r3, r7, #768	; 0x300
    3142:	4941      	ldr	r1, [pc, #260]	; (3248 <_Z16getConfigCommandRK6StringS1_+0x7a0>)
    3144:	4618      	mov	r0, r3
    3146:	f003 fa79 	bl	663c <_ZN6StringC1EPKc>
    314a:	f04f 0b01 	mov.w	fp, #1
    314e:	f507 7344 	add.w	r3, r7, #784	; 0x310
    3152:	493e      	ldr	r1, [pc, #248]	; (324c <_Z16getConfigCommandRK6StringS1_+0x7a4>)
    3154:	4618      	mov	r0, r3
    3156:	f003 fa71 	bl	663c <_ZN6StringC1EPKc>
    315a:	f04f 0a01 	mov.w	sl, #1
    315e:	f507 7358 	add.w	r3, r7, #864	; 0x360
    3162:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    3166:	f507 7144 	add.w	r1, r7, #784	; 0x310
    316a:	f507 7040 	add.w	r0, r7, #768	; 0x300
    316e:	4b38      	ldr	r3, [pc, #224]	; (3250 <_Z16getConfigCommandRK6StringS1_+0x7a8>)
    3170:	6812      	ldr	r2, [r2, #0]
    3172:	f7ff f8c7 	bl	2304 <_Z9getDirectRK6StringS1_S1_Rt>
    3176:	4603      	mov	r3, r0
    3178:	2b00      	cmp	r3, #0
    317a:	d145      	bne.n	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("dacTriggerInterval", "dactriggerinterval", arguments, g_iDAC_trigger_interval   )
    317c:	f507 7348 	add.w	r3, r7, #800	; 0x320
    3180:	4934      	ldr	r1, [pc, #208]	; (3254 <_Z16getConfigCommandRK6StringS1_+0x7ac>)
    3182:	4618      	mov	r0, r3
    3184:	f003 fa5a 	bl	663c <_ZN6StringC1EPKc>
    3188:	f04f 0901 	mov.w	r9, #1
    318c:	f507 734c 	add.w	r3, r7, #816	; 0x330
    3190:	4931      	ldr	r1, [pc, #196]	; (3258 <_Z16getConfigCommandRK6StringS1_+0x7b0>)
    3192:	4618      	mov	r0, r3
    3194:	f003 fa52 	bl	663c <_ZN6StringC1EPKc>
    3198:	f04f 0801 	mov.w	r8, #1
    319c:	f507 7358 	add.w	r3, r7, #864	; 0x360
    31a0:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    31a4:	f507 714c 	add.w	r1, r7, #816	; 0x330
    31a8:	f507 7048 	add.w	r0, r7, #800	; 0x320
    31ac:	4b2b      	ldr	r3, [pc, #172]	; (325c <_Z16getConfigCommandRK6StringS1_+0x7b4>)
    31ae:	6812      	ldr	r2, [r2, #0]
    31b0:	f7ff f8a8 	bl	2304 <_Z9getDirectRK6StringS1_S1_Rt>
    31b4:	4603      	mov	r3, r0
    31b6:	2b00      	cmp	r3, #0
    31b8:	d126      	bne.n	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || getDirect("pdbMod"            , "pdbmod"            , arguments, g_iPDB_mod                )
    31ba:	f507 7350 	add.w	r3, r7, #832	; 0x340
    31be:	4928      	ldr	r1, [pc, #160]	; (3260 <_Z16getConfigCommandRK6StringS1_+0x7b8>)
    31c0:	4618      	mov	r0, r3
    31c2:	f003 fa3b 	bl	663c <_ZN6StringC1EPKc>
    31c6:	2601      	movs	r6, #1
    31c8:	f507 7354 	add.w	r3, r7, #848	; 0x350
    31cc:	4925      	ldr	r1, [pc, #148]	; (3264 <_Z16getConfigCommandRK6StringS1_+0x7bc>)
    31ce:	4618      	mov	r0, r3
    31d0:	f003 fa34 	bl	663c <_ZN6StringC1EPKc>
    31d4:	2501      	movs	r5, #1
    31d6:	f507 7358 	add.w	r3, r7, #864	; 0x360
    31da:	f5a3 7232 	sub.w	r2, r3, #712	; 0x2c8
    31de:	f507 7154 	add.w	r1, r7, #848	; 0x350
    31e2:	f507 7050 	add.w	r0, r7, #832	; 0x340
    31e6:	4b20      	ldr	r3, [pc, #128]	; (3268 <_Z16getConfigCommandRK6StringS1_+0x7c0>)
    31e8:	6812      	ldr	r2, [r2, #0]
    31ea:	f7ff f88b 	bl	2304 <_Z9getDirectRK6StringS1_S1_Rt>
    31ee:	4603      	mov	r3, r0
    31f0:	2b00      	cmp	r3, #0
    31f2:	d109      	bne.n	3208 <_Z16getConfigCommandRK6StringS1_+0x760>
    || unknownValue(arguments);
    31f4:	f507 7358 	add.w	r3, r7, #864	; 0x360
    31f8:	f5a3 7332 	sub.w	r3, r3, #712	; 0x2c8
    31fc:	6818      	ldr	r0, [r3, #0]
    31fe:	f7ff fa47 	bl	2690 <_Z12unknownValueRK6String>
    3202:	4603      	mov	r3, r0
    3204:	2b00      	cmp	r3, #0
    3206:	d031      	beq.n	326c <_Z16getConfigCommandRK6StringS1_+0x7c4>
    3208:	2401      	movs	r4, #1
    320a:	e030      	b.n	326e <_Z16getConfigCommandRK6StringS1_+0x7c6>
    320c:	0000f340 	.word	0x0000f340
    3210:	1fff0730 	.word	0x1fff0730
    3214:	0000f344 	.word	0x0000f344
    3218:	1fff0adc 	.word	0x1fff0adc
    321c:	0000f34c 	.word	0x0000f34c
    3220:	0000f444 	.word	0x0000f444
    3224:	1fff0ad8 	.word	0x1fff0ad8
    3228:	0000f35c 	.word	0x0000f35c
    322c:	0000f454 	.word	0x0000f454
    3230:	1fff0acc 	.word	0x1fff0acc
    3234:	0000f36c 	.word	0x0000f36c
    3238:	0000f464 	.word	0x0000f464
    323c:	1fff0ad4 	.word	0x1fff0ad4
    3240:	0000f384 	.word	0x0000f384
    3244:	1fff0ae0 	.word	0x1fff0ae0
    3248:	0000f390 	.word	0x0000f390
    324c:	0000f474 	.word	0x0000f474
    3250:	1fff0ae2 	.word	0x1fff0ae2
    3254:	0000f3a0 	.word	0x0000f3a0
    3258:	0000f484 	.word	0x0000f484
    325c:	1fff0ae4 	.word	0x1fff0ae4
    3260:	0000f3b4 	.word	0x0000f3b4
    3264:	0000f498 	.word	0x0000f498
    3268:	1fff0ae6 	.word	0x1fff0ae6
    326c:	2400      	movs	r4, #0
    || getDirect("pdbMod"            , "pdbmod"            , arguments, g_iPDB_mod                )
    326e:	2d00      	cmp	r5, #0
    3270:	d004      	beq.n	327c <_Z16getConfigCommandRK6StringS1_+0x7d4>
    3272:	f507 7354 	add.w	r3, r7, #848	; 0x350
    3276:	4618      	mov	r0, r3
    3278:	f003 fa0a 	bl	6690 <_ZN6StringD1Ev>
    327c:	2e00      	cmp	r6, #0
    327e:	d004      	beq.n	328a <_Z16getConfigCommandRK6StringS1_+0x7e2>
    3280:	f507 7350 	add.w	r3, r7, #832	; 0x340
    3284:	4618      	mov	r0, r3
    3286:	f003 fa03 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("dacTriggerInterval", "dactriggerinterval", arguments, g_iDAC_trigger_interval   )
    328a:	f1b8 0f00 	cmp.w	r8, #0
    328e:	d004      	beq.n	329a <_Z16getConfigCommandRK6StringS1_+0x7f2>
    3290:	f507 734c 	add.w	r3, r7, #816	; 0x330
    3294:	4618      	mov	r0, r3
    3296:	f003 f9fb 	bl	6690 <_ZN6StringD1Ev>
    329a:	f1b9 0f00 	cmp.w	r9, #0
    329e:	d004      	beq.n	32aa <_Z16getConfigCommandRK6StringS1_+0x802>
    32a0:	f507 7348 	add.w	r3, r7, #800	; 0x320
    32a4:	4618      	mov	r0, r3
    32a6:	f003 f9f3 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("pdbCycleLength"    , "pdbcyclelength"    , arguments, g_iPDB_cycleLength        )
    32aa:	f1ba 0f00 	cmp.w	sl, #0
    32ae:	d004      	beq.n	32ba <_Z16getConfigCommandRK6StringS1_+0x812>
    32b0:	f507 7344 	add.w	r3, r7, #784	; 0x310
    32b4:	4618      	mov	r0, r3
    32b6:	f003 f9eb 	bl	6690 <_ZN6StringD1Ev>
    32ba:	f1bb 0f00 	cmp.w	fp, #0
    32be:	d004      	beq.n	32ca <_Z16getConfigCommandRK6StringS1_+0x822>
    32c0:	f507 7340 	add.w	r3, r7, #768	; 0x300
    32c4:	4618      	mov	r0, r3
    32c6:	f003 f9e3 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("dacPoints"         , "dacPoints"         , arguments, g_iDAC_points             )
    32ca:	683b      	ldr	r3, [r7, #0]
    32cc:	2b00      	cmp	r3, #0
    32ce:	d004      	beq.n	32da <_Z16getConfigCommandRK6StringS1_+0x832>
    32d0:	f507 733c 	add.w	r3, r7, #752	; 0x2f0
    32d4:	4618      	mov	r0, r3
    32d6:	f003 f9db 	bl	6690 <_ZN6StringD1Ev>
    32da:	687b      	ldr	r3, [r7, #4]
    32dc:	2b00      	cmp	r3, #0
    32de:	d004      	beq.n	32ea <_Z16getConfigCommandRK6StringS1_+0x842>
    32e0:	f507 7338 	add.w	r3, r7, #736	; 0x2e0
    32e4:	4618      	mov	r0, r3
    32e6:	f003 f9d3 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("targetPeriod"      , "targetperiod"      , arguments, g_iTarget_period_us       )
    32ea:	68bb      	ldr	r3, [r7, #8]
    32ec:	2b00      	cmp	r3, #0
    32ee:	d004      	beq.n	32fa <_Z16getConfigCommandRK6StringS1_+0x852>
    32f0:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
    32f4:	4618      	mov	r0, r3
    32f6:	f003 f9cb 	bl	6690 <_ZN6StringD1Ev>
    32fa:	68fb      	ldr	r3, [r7, #12]
    32fc:	2b00      	cmp	r3, #0
    32fe:	d004      	beq.n	330a <_Z16getConfigCommandRK6StringS1_+0x862>
    3300:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
    3304:	4618      	mov	r0, r3
    3306:	f003 f9c3 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("targetFrequency"   , "targetfrequency"   , arguments, g_iTarget_frequency       )
    330a:	693b      	ldr	r3, [r7, #16]
    330c:	2b00      	cmp	r3, #0
    330e:	d004      	beq.n	331a <_Z16getConfigCommandRK6StringS1_+0x872>
    3310:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
    3314:	4618      	mov	r0, r3
    3316:	f003 f9bb 	bl	6690 <_ZN6StringD1Ev>
    331a:	697b      	ldr	r3, [r7, #20]
    331c:	2b00      	cmp	r3, #0
    331e:	d004      	beq.n	332a <_Z16getConfigCommandRK6StringS1_+0x882>
    3320:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
    3324:	4618      	mov	r0, r3
    3326:	f003 f9b3 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("samplesUseful"     , "samplesuseful"     , arguments, g_iSamples_useful         )
    332a:	69bb      	ldr	r3, [r7, #24]
    332c:	2b00      	cmp	r3, #0
    332e:	d004      	beq.n	333a <_Z16getConfigCommandRK6StringS1_+0x892>
    3330:	f507 7324 	add.w	r3, r7, #656	; 0x290
    3334:	4618      	mov	r0, r3
    3336:	f003 f9ab 	bl	6690 <_ZN6StringD1Ev>
    333a:	69fb      	ldr	r3, [r7, #28]
    333c:	2b00      	cmp	r3, #0
    333e:	d004      	beq.n	334a <_Z16getConfigCommandRK6StringS1_+0x8a2>
    3340:	f507 7320 	add.w	r3, r7, #640	; 0x280
    3344:	4618      	mov	r0, r3
    3346:	f003 f9a3 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("samples"           , "samples"           , arguments, g_iSamples                )
    334a:	6a3b      	ldr	r3, [r7, #32]
    334c:	2b00      	cmp	r3, #0
    334e:	d004      	beq.n	335a <_Z16getConfigCommandRK6StringS1_+0x8b2>
    3350:	f507 731c 	add.w	r3, r7, #624	; 0x270
    3354:	4618      	mov	r0, r3
    3356:	f003 f99b 	bl	6690 <_ZN6StringD1Ev>
    335a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    335c:	2b00      	cmp	r3, #0
    335e:	d004      	beq.n	336a <_Z16getConfigCommandRK6StringS1_+0x8c2>
    3360:	f507 7318 	add.w	r3, r7, #608	; 0x260
    3364:	4618      	mov	r0, r3
    3366:	f003 f993 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("run"               , "run"               , arguments, g_bRun                    )
    336a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    336c:	2b00      	cmp	r3, #0
    336e:	d004      	beq.n	337a <_Z16getConfigCommandRK6StringS1_+0x8d2>
    3370:	f507 7314 	add.w	r3, r7, #592	; 0x250
    3374:	4618      	mov	r0, r3
    3376:	f003 f98b 	bl	6690 <_ZN6StringD1Ev>
    337a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    337c:	2b00      	cmp	r3, #0
    337e:	d004      	beq.n	338a <_Z16getConfigCommandRK6StringS1_+0x8e2>
    3380:	f507 7310 	add.w	r3, r7, #576	; 0x240
    3384:	4618      	mov	r0, r3
    3386:	f003 f983 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("adcFrequency"      , "adcfrequency"      , arguments, g_iADC_frequency          )
    338a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    338c:	2b00      	cmp	r3, #0
    338e:	d004      	beq.n	339a <_Z16getConfigCommandRK6StringS1_+0x8f2>
    3390:	f507 730c 	add.w	r3, r7, #560	; 0x230
    3394:	4618      	mov	r0, r3
    3396:	f003 f97b 	bl	6690 <_ZN6StringD1Ev>
    339a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    339c:	2b00      	cmp	r3, #0
    339e:	d004      	beq.n	33aa <_Z16getConfigCommandRK6StringS1_+0x902>
    33a0:	f507 7308 	add.w	r3, r7, #544	; 0x220
    33a4:	4618      	mov	r0, r3
    33a6:	f003 f973 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("mapToLines"        , "mapToLines"        , arguments, g_bMapElectrodesToLines            )
    33aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    33ac:	2b00      	cmp	r3, #0
    33ae:	d004      	beq.n	33ba <_Z16getConfigCommandRK6StringS1_+0x912>
    33b0:	f507 7304 	add.w	r3, r7, #528	; 0x210
    33b4:	4618      	mov	r0, r3
    33b6:	f003 f96b 	bl	6690 <_ZN6StringD1Ev>
    33ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    33bc:	2b00      	cmp	r3, #0
    33be:	d004      	beq.n	33ca <_Z16getConfigCommandRK6StringS1_+0x922>
    33c0:	f507 7300 	add.w	r3, r7, #512	; 0x200
    33c4:	4618      	mov	r0, r3
    33c6:	f003 f963 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("sampleRubbish"     , "samplerubbish"     , arguments, g_iSample_rubbish         )
    33ca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    33cc:	2b00      	cmp	r3, #0
    33ce:	d004      	beq.n	33da <_Z16getConfigCommandRK6StringS1_+0x932>
    33d0:	f507 73f8 	add.w	r3, r7, #496	; 0x1f0
    33d4:	4618      	mov	r0, r3
    33d6:	f003 f95b 	bl	6690 <_ZN6StringD1Ev>
    33da:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    33dc:	2b00      	cmp	r3, #0
    33de:	d004      	beq.n	33ea <_Z16getConfigCommandRK6StringS1_+0x942>
    33e0:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
    33e4:	4618      	mov	r0, r3
    33e6:	f003 f953 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("samplesPerCycle"   , "samplespercycle"   , arguments, g_iSamples_per_cycle      )
    33ea:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    33ec:	2b00      	cmp	r3, #0
    33ee:	d004      	beq.n	33fa <_Z16getConfigCommandRK6StringS1_+0x952>
    33f0:	f507 73e8 	add.w	r3, r7, #464	; 0x1d0
    33f4:	4618      	mov	r0, r3
    33f6:	f003 f94b 	bl	6690 <_ZN6StringD1Ev>
    33fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    33fc:	2b00      	cmp	r3, #0
    33fe:	d004      	beq.n	340a <_Z16getConfigCommandRK6StringS1_+0x962>
    3400:	f507 73e0 	add.w	r3, r7, #448	; 0x1c0
    3404:	4618      	mov	r0, r3
    3406:	f003 f943 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("sampleCycles"      , "samplecycles"      , arguments, g_iSample_cycles          )
    340a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    340c:	2b00      	cmp	r3, #0
    340e:	d004      	beq.n	341a <_Z16getConfigCommandRK6StringS1_+0x972>
    3410:	f507 73d8 	add.w	r3, r7, #432	; 0x1b0
    3414:	4618      	mov	r0, r3
    3416:	f003 f93b 	bl	6690 <_ZN6StringD1Ev>
    341a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    341c:	2b00      	cmp	r3, #0
    341e:	d004      	beq.n	342a <_Z16getConfigCommandRK6StringS1_+0x982>
    3420:	f507 73d0 	add.w	r3, r7, #416	; 0x1a0
    3424:	4618      	mov	r0, r3
    3426:	f003 f933 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("outputGainResistor", "outputgainresistor", arguments, g_iOutputGainResistor_ohms)
    342a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    342c:	2b00      	cmp	r3, #0
    342e:	d004      	beq.n	343a <_Z16getConfigCommandRK6StringS1_+0x992>
    3430:	f507 73c8 	add.w	r3, r7, #400	; 0x190
    3434:	4618      	mov	r0, r3
    3436:	f003 f92b 	bl	6690 <_ZN6StringD1Ev>
    343a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    343c:	2b00      	cmp	r3, #0
    343e:	d004      	beq.n	344a <_Z16getConfigCommandRK6StringS1_+0x9a2>
    3440:	f507 73c0 	add.w	r3, r7, #384	; 0x180
    3444:	4618      	mov	r0, r3
    3446:	f003 f923 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("inputGainResistor2", "inputgainresistor2", arguments, g_iInputGainResistor2_ohms)
    344a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
    344c:	2b00      	cmp	r3, #0
    344e:	d004      	beq.n	345a <_Z16getConfigCommandRK6StringS1_+0x9b2>
    3450:	f507 73b8 	add.w	r3, r7, #368	; 0x170
    3454:	4618      	mov	r0, r3
    3456:	f003 f91b 	bl	6690 <_ZN6StringD1Ev>
    345a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
    345c:	2b00      	cmp	r3, #0
    345e:	d004      	beq.n	346a <_Z16getConfigCommandRK6StringS1_+0x9c2>
    3460:	f507 73b0 	add.w	r3, r7, #352	; 0x160
    3464:	4618      	mov	r0, r3
    3466:	f003 f913 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("inputGainResistor1", "inputgainresistor1", arguments, g_iInputGainResistor1_ohms)
    346a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    346c:	2b00      	cmp	r3, #0
    346e:	d004      	beq.n	347a <_Z16getConfigCommandRK6StringS1_+0x9d2>
    3470:	f507 73a8 	add.w	r3, r7, #336	; 0x150
    3474:	4618      	mov	r0, r3
    3476:	f003 f90b 	bl	6690 <_ZN6StringD1Ev>
    347a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
    347c:	2b00      	cmp	r3, #0
    347e:	d004      	beq.n	348a <_Z16getConfigCommandRK6StringS1_+0x9e2>
    3480:	f507 73a0 	add.w	r3, r7, #320	; 0x140
    3484:	4618      	mov	r0, r3
    3486:	f003 f903 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("electrodes"        , "electrodes"        , arguments, g_iElectrodes             )
    348a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
    348c:	2b00      	cmp	r3, #0
    348e:	d004      	beq.n	349a <_Z16getConfigCommandRK6StringS1_+0x9f2>
    3490:	f507 7398 	add.w	r3, r7, #304	; 0x130
    3494:	4618      	mov	r0, r3
    3496:	f003 f8fb 	bl	6690 <_ZN6StringD1Ev>
    349a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
    349c:	2b00      	cmp	r3, #0
    349e:	d004      	beq.n	34aa <_Z16getConfigCommandRK6StringS1_+0xa02>
    34a0:	f507 7390 	add.w	r3, r7, #288	; 0x120
    34a4:	4618      	mov	r0, r3
    34a6:	f003 f8f3 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("dist"              , "dist"              , arguments, g_iDrivingDist                   )
    34aa:	6fbb      	ldr	r3, [r7, #120]	; 0x78
    34ac:	2b00      	cmp	r3, #0
    34ae:	d004      	beq.n	34ba <_Z16getConfigCommandRK6StringS1_+0xa12>
    34b0:	f507 7388 	add.w	r3, r7, #272	; 0x110
    34b4:	4618      	mov	r0, r3
    34b6:	f003 f8eb 	bl	6690 <_ZN6StringD1Ev>
    34ba:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    34bc:	2b00      	cmp	r3, #0
    34be:	d004      	beq.n	34ca <_Z16getConfigCommandRK6StringS1_+0xa22>
    34c0:	f507 7380 	add.w	r3, r7, #256	; 0x100
    34c4:	4618      	mov	r0, r3
    34c6:	f003 f8e3 	bl	6690 <_ZN6StringD1Ev>
    || getDirect("delay"             , "delay"             , arguments, g_iDelay_ms               )
    34ca:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    34ce:	2b00      	cmp	r3, #0
    34d0:	d004      	beq.n	34dc <_Z16getConfigCommandRK6StringS1_+0xa34>
    34d2:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
    34d6:	4618      	mov	r0, r3
    34d8:	f003 f8da 	bl	6690 <_ZN6StringD1Ev>
    34dc:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
    34e0:	2b00      	cmp	r3, #0
    34e2:	d004      	beq.n	34ee <_Z16getConfigCommandRK6StringS1_+0xa46>
    34e4:	f107 03e0 	add.w	r3, r7, #224	; 0xe0
    34e8:	4618      	mov	r0, r3
    34ea:	f003 f8d1 	bl	6690 <_ZN6StringD1Ev>
    || getDirectE<DACModes>("dacMode", "dacmode"           , arguments, g_eDACMode                )
    34ee:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
    34f2:	2b00      	cmp	r3, #0
    34f4:	d004      	beq.n	3500 <_Z16getConfigCommandRK6StringS1_+0xa58>
    34f6:	f107 03d0 	add.w	r3, r7, #208	; 0xd0
    34fa:	4618      	mov	r0, r3
    34fc:	f003 f8c8 	bl	6690 <_ZN6StringD1Ev>
    3500:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
    3504:	2b00      	cmp	r3, #0
    3506:	d004      	beq.n	3512 <_Z16getConfigCommandRK6StringS1_+0xa6a>
    3508:	f107 03c0 	add.w	r3, r7, #192	; 0xc0
    350c:	4618      	mov	r0, r3
    350e:	f003 f8bf 	bl	6690 <_ZN6StringD1Ev>
    || getDirectE<Modes>("mode"      , "mode"              , arguments, g_eMode                   )
    3512:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
    3516:	2b00      	cmp	r3, #0
    3518:	d004      	beq.n	3524 <_Z16getConfigCommandRK6StringS1_+0xa7c>
    351a:	f107 03b0 	add.w	r3, r7, #176	; 0xb0
    351e:	4618      	mov	r0, r3
    3520:	f003 f8b6 	bl	6690 <_ZN6StringD1Ev>
    3524:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
    3528:	2b00      	cmp	r3, #0
    352a:	d004      	beq.n	3536 <_Z16getConfigCommandRK6StringS1_+0xa8e>
    352c:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
    3530:	4618      	mov	r0, r3
    3532:	f003 f8ad 	bl	6690 <_ZN6StringD1Ev>
}
    3536:	4623      	mov	r3, r4
    3538:	4618      	mov	r0, r3
    353a:	f507 7759 	add.w	r7, r7, #868	; 0x364
    353e:	46bd      	mov	sp, r7
    3540:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00003544 <_Z16setConfigCommandRK6StringS1_>:

bool setConfigCommand(String const & command, String const & arguments) 
{
    3544:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3548:	f5ad 7d07 	sub.w	sp, sp, #540	; 0x21c
    354c:	af04      	add	r7, sp, #16
    354e:	f507 7302 	add.w	r3, r7, #520	; 0x208
    3552:	f5a3 73de 	sub.w	r3, r3, #444	; 0x1bc
    3556:	6018      	str	r0, [r3, #0]
    3558:	f507 7302 	add.w	r3, r7, #520	; 0x208
    355c:	f5a3 73e0 	sub.w	r3, r3, #448	; 0x1c0
    3560:	6019      	str	r1, [r3, #0]
    if ( command != "set" ) return false;
    3562:	f507 7302 	add.w	r3, r7, #520	; 0x208
    3566:	f5a3 73de 	sub.w	r3, r3, #444	; 0x1bc
    356a:	493c      	ldr	r1, [pc, #240]	; (365c <_Z16setConfigCommandRK6StringS1_+0x118>)
    356c:	6818      	ldr	r0, [r3, #0]
    356e:	f7fc ffe0 	bl	532 <_ZNK6StringneEPKc>
    3572:	4603      	mov	r3, r0
    3574:	2b00      	cmp	r3, #0
    3576:	bf14      	ite	ne
    3578:	2301      	movne	r3, #1
    357a:	2300      	moveq	r3, #0
    357c:	b2db      	uxtb	r3, r3
    357e:	2b00      	cmp	r3, #0
    3580:	d001      	beq.n	3586 <_Z16setConfigCommandRK6StringS1_+0x42>
    3582:	2400      	movs	r4, #0
    3584:	e35e      	b.n	3c44 <_Z16setConfigCommandRK6StringS1_+0x700>

    auto tok = arguments.indexOf(" ");
    3586:	f107 0374 	add.w	r3, r7, #116	; 0x74
    358a:	4935      	ldr	r1, [pc, #212]	; (3660 <_Z16setConfigCommandRK6StringS1_+0x11c>)
    358c:	4618      	mov	r0, r3
    358e:	f003 f855 	bl	663c <_ZN6StringC1EPKc>
    3592:	f107 0274 	add.w	r2, r7, #116	; 0x74
    3596:	f507 7302 	add.w	r3, r7, #520	; 0x208
    359a:	f5a3 73e0 	sub.w	r3, r3, #448	; 0x1c0
    359e:	4611      	mov	r1, r2
    35a0:	6818      	ldr	r0, [r3, #0]
    35a2:	f003 fa7d 	bl	6aa0 <_ZNK6String7indexOfERKS_>
    35a6:	f8c7 0204 	str.w	r0, [r7, #516]	; 0x204
    35aa:	f107 0374 	add.w	r3, r7, #116	; 0x74
    35ae:	4618      	mov	r0, r3
    35b0:	f003 f86e 	bl	6690 <_ZN6StringD1Ev>
    
    if(tok == -1) return setUsage();
    35b4:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
    35b8:	f1b3 3fff 	cmp.w	r3, #4294967295
    35bc:	d104      	bne.n	35c8 <_Z16setConfigCommandRK6StringS1_+0x84>
    35be:	f7ff f857 	bl	2670 <_Z8setUsagev>
    35c2:	4603      	mov	r3, r0
    35c4:	461c      	mov	r4, r3
    35c6:	e33d      	b.n	3c44 <_Z16setConfigCommandRK6StringS1_+0x700>

    auto arg1 = arguments.substring(0, tok);
    35c8:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
    35cc:	f507 7202 	add.w	r2, r7, #520	; 0x208
    35d0:	f5a2 70d2 	sub.w	r0, r2, #420	; 0x1a4
    35d4:	f507 7202 	add.w	r2, r7, #520	; 0x208
    35d8:	f5a2 71e0 	sub.w	r1, r2, #448	; 0x1c0
    35dc:	2200      	movs	r2, #0
    35de:	6809      	ldr	r1, [r1, #0]
    35e0:	f003 faa5 	bl	6b2e <_ZNK6String9substringEjj>
    auto arg2 = (tok >= arguments.length()) ? "" : arguments.substring(tok+1);
    35e4:	f507 7302 	add.w	r3, r7, #520	; 0x208
    35e8:	f5a3 73e0 	sub.w	r3, r3, #448	; 0x1c0
    35ec:	6818      	ldr	r0, [r3, #0]
    35ee:	f7fc ff73 	bl	4d8 <_ZNK6String6lengthEv>
    35f2:	4602      	mov	r2, r0
    35f4:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
    35f8:	429a      	cmp	r2, r3
    35fa:	d806      	bhi.n	360a <_Z16setConfigCommandRK6StringS1_+0xc6>
    35fc:	f107 0354 	add.w	r3, r7, #84	; 0x54
    3600:	4918      	ldr	r1, [pc, #96]	; (3664 <_Z16setConfigCommandRK6StringS1_+0x120>)
    3602:	4618      	mov	r0, r3
    3604:	f003 f81a 	bl	663c <_ZN6StringC1EPKc>
    3608:	e00e      	b.n	3628 <_Z16setConfigCommandRK6StringS1_+0xe4>
    360a:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
    360e:	3301      	adds	r3, #1
    3610:	461a      	mov	r2, r3
    3612:	f507 7302 	add.w	r3, r7, #520	; 0x208
    3616:	f5a3 70da 	sub.w	r0, r3, #436	; 0x1b4
    361a:	f507 7302 	add.w	r3, r7, #520	; 0x208
    361e:	f5a3 73e0 	sub.w	r3, r3, #448	; 0x1c0
    3622:	6819      	ldr	r1, [r3, #0]
    3624:	f003 fa72 	bl	6b0c <_ZNK6String9substringEj>

    if((arg1.length() == 0) || (arg2.length() == 0)) return setUsage();
    3628:	f107 0364 	add.w	r3, r7, #100	; 0x64
    362c:	4618      	mov	r0, r3
    362e:	f7fc ff53 	bl	4d8 <_ZNK6String6lengthEv>
    3632:	4603      	mov	r3, r0
    3634:	2b00      	cmp	r3, #0
    3636:	d007      	beq.n	3648 <_Z16setConfigCommandRK6StringS1_+0x104>
    3638:	f107 0354 	add.w	r3, r7, #84	; 0x54
    363c:	4618      	mov	r0, r3
    363e:	f7fc ff4b 	bl	4d8 <_ZNK6String6lengthEv>
    3642:	4603      	mov	r3, r0
    3644:	2b00      	cmp	r3, #0
    3646:	d101      	bne.n	364c <_Z16setConfigCommandRK6StringS1_+0x108>
    3648:	2301      	movs	r3, #1
    364a:	e000      	b.n	364e <_Z16setConfigCommandRK6StringS1_+0x10a>
    364c:	2300      	movs	r3, #0
    364e:	2b00      	cmp	r3, #0
    3650:	d00a      	beq.n	3668 <_Z16setConfigCommandRK6StringS1_+0x124>
    3652:	f7ff f80d 	bl	2670 <_Z8setUsagev>
    3656:	4603      	mov	r3, r0
    3658:	461c      	mov	r4, r3
    365a:	e2e9      	b.n	3c30 <_Z16setConfigCommandRK6StringS1_+0x6ec>
    365c:	0000f4a0 	.word	0x0000f4a0
    3660:	0000f4a4 	.word	0x0000f4a4
    3664:	0000f4a8 	.word	0x0000f4a8
     || setDirect("outputGainResistor", "outputgainresistor", arg1, arg2, g_iOutputGainResistor_ohms, g_iOutputGainResistor_min_ohms, g_iOutputGainResistor_max_ohms)
     || setDirect("sampleCycles"      , "samplecycles"      , arg1, arg2, g_iSample_cycles          , g_iSample_cycles_min          , g_iSample_cycles_max)
     || setDirect("samplesPerCycle"   , "samplespercycle"   , arg1, arg2, g_iSamples_per_cycle      , g_iSamples_per_cycle_min      , g_iSamples_per_cycle_max)
     || setDirect("sampleRubbish"     , "samplerubbish"     , arg1, arg2, g_iSample_rubbish         , g_iSample_rubbish_min         , g_iSample_rubbish_max)
     || setDirect("mapToLines"        , "mapToLines"        , arg1, arg2, g_bMapElectrodesToLines             )
     || unknownValue(arg1);
    3668:	2300      	movs	r3, #0
    366a:	647b      	str	r3, [r7, #68]	; 0x44
    366c:	2300      	movs	r3, #0
    366e:	643b      	str	r3, [r7, #64]	; 0x40
    3670:	2300      	movs	r3, #0
    3672:	63fb      	str	r3, [r7, #60]	; 0x3c
    3674:	2300      	movs	r3, #0
    3676:	63bb      	str	r3, [r7, #56]	; 0x38
    3678:	2300      	movs	r3, #0
    367a:	637b      	str	r3, [r7, #52]	; 0x34
    367c:	2300      	movs	r3, #0
    367e:	633b      	str	r3, [r7, #48]	; 0x30
    3680:	2300      	movs	r3, #0
    3682:	62fb      	str	r3, [r7, #44]	; 0x2c
    3684:	2300      	movs	r3, #0
    3686:	62bb      	str	r3, [r7, #40]	; 0x28
    3688:	2300      	movs	r3, #0
    368a:	627b      	str	r3, [r7, #36]	; 0x24
    368c:	2300      	movs	r3, #0
    368e:	623b      	str	r3, [r7, #32]
    3690:	2300      	movs	r3, #0
    3692:	61fb      	str	r3, [r7, #28]
    3694:	2300      	movs	r3, #0
    3696:	61bb      	str	r3, [r7, #24]
    3698:	2300      	movs	r3, #0
    369a:	617b      	str	r3, [r7, #20]
    369c:	2300      	movs	r3, #0
    369e:	613b      	str	r3, [r7, #16]
    36a0:	2300      	movs	r3, #0
    36a2:	60fb      	str	r3, [r7, #12]
    36a4:	2300      	movs	r3, #0
    36a6:	60bb      	str	r3, [r7, #8]
    36a8:	f04f 0b00 	mov.w	fp, #0
    36ac:	f04f 0a00 	mov.w	sl, #0
    36b0:	f04f 0900 	mov.w	r9, #0
    36b4:	f04f 0800 	mov.w	r8, #0
    36b8:	2600      	movs	r6, #0
    36ba:	2500      	movs	r5, #0
     || setDirectE<Modes>("mode"      , "mode"              , arg1, arg2, g_eMode                   )
    36bc:	f107 0384 	add.w	r3, r7, #132	; 0x84
    36c0:	49cd      	ldr	r1, [pc, #820]	; (39f8 <_Z16setConfigCommandRK6StringS1_+0x4b4>)
    36c2:	4618      	mov	r0, r3
    36c4:	f002 ffba 	bl	663c <_ZN6StringC1EPKc>
     || unknownValue(arg1);
    36c8:	2301      	movs	r3, #1
    36ca:	607b      	str	r3, [r7, #4]
     || setDirectE<Modes>("mode"      , "mode"              , arg1, arg2, g_eMode                   )
    36cc:	f107 0394 	add.w	r3, r7, #148	; 0x94
    36d0:	49c9      	ldr	r1, [pc, #804]	; (39f8 <_Z16setConfigCommandRK6StringS1_+0x4b4>)
    36d2:	4618      	mov	r0, r3
    36d4:	f002 ffb2 	bl	663c <_ZN6StringC1EPKc>
     || unknownValue(arg1);
    36d8:	2301      	movs	r3, #1
    36da:	603b      	str	r3, [r7, #0]
     || setDirectE<Modes>("mode"      , "mode"              , arg1, arg2, g_eMode                   )
    36dc:	f107 0454 	add.w	r4, r7, #84	; 0x54
    36e0:	f107 0264 	add.w	r2, r7, #100	; 0x64
    36e4:	f107 0194 	add.w	r1, r7, #148	; 0x94
    36e8:	f107 0084 	add.w	r0, r7, #132	; 0x84
    36ec:	4bc3      	ldr	r3, [pc, #780]	; (39fc <_Z16setConfigCommandRK6StringS1_+0x4b8>)
    36ee:	9300      	str	r3, [sp, #0]
    36f0:	4623      	mov	r3, r4
    36f2:	f000 fe73 	bl	43dc <_Z10setDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_>
    36f6:	4603      	mov	r3, r0
     || unknownValue(arg1);
    36f8:	2b00      	cmp	r3, #0
    36fa:	f040 81d5 	bne.w	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || setDirectE<DACModes>("dacMode", "dacmode"           , arg1, arg2, g_eDACMode                )
    36fe:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
    3702:	49bf      	ldr	r1, [pc, #764]	; (3a00 <_Z16setConfigCommandRK6StringS1_+0x4bc>)
    3704:	4618      	mov	r0, r3
    3706:	f002 ff99 	bl	663c <_ZN6StringC1EPKc>
    370a:	2301      	movs	r3, #1
    370c:	647b      	str	r3, [r7, #68]	; 0x44
    370e:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
    3712:	49bc      	ldr	r1, [pc, #752]	; (3a04 <_Z16setConfigCommandRK6StringS1_+0x4c0>)
    3714:	4618      	mov	r0, r3
    3716:	f002 ff91 	bl	663c <_ZN6StringC1EPKc>
    371a:	2301      	movs	r3, #1
    371c:	643b      	str	r3, [r7, #64]	; 0x40
    371e:	f107 0454 	add.w	r4, r7, #84	; 0x54
    3722:	f107 0264 	add.w	r2, r7, #100	; 0x64
    3726:	f107 01b4 	add.w	r1, r7, #180	; 0xb4
    372a:	f107 00a4 	add.w	r0, r7, #164	; 0xa4
    372e:	4bb6      	ldr	r3, [pc, #728]	; (3a08 <_Z16setConfigCommandRK6StringS1_+0x4c4>)
    3730:	9300      	str	r3, [sp, #0]
    3732:	4623      	mov	r3, r4
    3734:	f000 fe92 	bl	445c <_Z10setDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_>
    3738:	4603      	mov	r3, r0
    373a:	2b00      	cmp	r3, #0
    373c:	f040 81b4 	bne.w	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || setDirect("delay"             , "delay"             , arg1, arg2, g_iDelay_ms               , g_iDelay_min_ms               , g_iDelay_max_ms)
    3740:	f107 03c4 	add.w	r3, r7, #196	; 0xc4
    3744:	49b1      	ldr	r1, [pc, #708]	; (3a0c <_Z16setConfigCommandRK6StringS1_+0x4c8>)
    3746:	4618      	mov	r0, r3
    3748:	f002 ff78 	bl	663c <_ZN6StringC1EPKc>
    374c:	2301      	movs	r3, #1
    374e:	63fb      	str	r3, [r7, #60]	; 0x3c
    3750:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
    3754:	49ad      	ldr	r1, [pc, #692]	; (3a0c <_Z16setConfigCommandRK6StringS1_+0x4c8>)
    3756:	4618      	mov	r0, r3
    3758:	f002 ff70 	bl	663c <_ZN6StringC1EPKc>
    375c:	2301      	movs	r3, #1
    375e:	63bb      	str	r3, [r7, #56]	; 0x38
    3760:	f107 0454 	add.w	r4, r7, #84	; 0x54
    3764:	f107 0264 	add.w	r2, r7, #100	; 0x64
    3768:	f107 01d4 	add.w	r1, r7, #212	; 0xd4
    376c:	f107 00c4 	add.w	r0, r7, #196	; 0xc4
    3770:	f242 7310 	movw	r3, #10000	; 0x2710
    3774:	9302      	str	r3, [sp, #8]
    3776:	2300      	movs	r3, #0
    3778:	9301      	str	r3, [sp, #4]
    377a:	4ba5      	ldr	r3, [pc, #660]	; (3a10 <_Z16setConfigCommandRK6StringS1_+0x4cc>)
    377c:	9300      	str	r3, [sp, #0]
    377e:	4623      	mov	r3, r4
    3780:	f7fe fe84 	bl	248c <_Z9setDirectRK6StringS1_S1_S1_Rmmm>
    3784:	4603      	mov	r3, r0
    3786:	2b00      	cmp	r3, #0
    3788:	f040 818e 	bne.w	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || setDirect("dist"              , "dist"              , arg1, arg2, g_iDrivingDist                   , 1                             , g_iElectrodes/2)
    378c:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
    3790:	49a0      	ldr	r1, [pc, #640]	; (3a14 <_Z16setConfigCommandRK6StringS1_+0x4d0>)
    3792:	4618      	mov	r0, r3
    3794:	f002 ff52 	bl	663c <_ZN6StringC1EPKc>
    3798:	2301      	movs	r3, #1
    379a:	637b      	str	r3, [r7, #52]	; 0x34
    379c:	f107 03f4 	add.w	r3, r7, #244	; 0xf4
    37a0:	499c      	ldr	r1, [pc, #624]	; (3a14 <_Z16setConfigCommandRK6StringS1_+0x4d0>)
    37a2:	4618      	mov	r0, r3
    37a4:	f002 ff4a 	bl	663c <_ZN6StringC1EPKc>
    37a8:	2301      	movs	r3, #1
    37aa:	633b      	str	r3, [r7, #48]	; 0x30
    37ac:	4b9a      	ldr	r3, [pc, #616]	; (3a18 <_Z16setConfigCommandRK6StringS1_+0x4d4>)
    37ae:	681b      	ldr	r3, [r3, #0]
    37b0:	085b      	lsrs	r3, r3, #1
    37b2:	f107 0454 	add.w	r4, r7, #84	; 0x54
    37b6:	f107 0264 	add.w	r2, r7, #100	; 0x64
    37ba:	f107 01f4 	add.w	r1, r7, #244	; 0xf4
    37be:	f107 00e4 	add.w	r0, r7, #228	; 0xe4
    37c2:	9302      	str	r3, [sp, #8]
    37c4:	2301      	movs	r3, #1
    37c6:	9301      	str	r3, [sp, #4]
    37c8:	4b94      	ldr	r3, [pc, #592]	; (3a1c <_Z16setConfigCommandRK6StringS1_+0x4d8>)
    37ca:	9300      	str	r3, [sp, #0]
    37cc:	4623      	mov	r3, r4
    37ce:	f7fe fe5d 	bl	248c <_Z9setDirectRK6StringS1_S1_S1_Rmmm>
    37d2:	4603      	mov	r3, r0
    37d4:	2b00      	cmp	r3, #0
    37d6:	f040 8167 	bne.w	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || setDirect("electrodes"        , "electrodes"        , arg1, arg2, g_iElectrodes             , g_iElectrodes_min             , g_iElectrodes_max)
    37da:	f507 7382 	add.w	r3, r7, #260	; 0x104
    37de:	4990      	ldr	r1, [pc, #576]	; (3a20 <_Z16setConfigCommandRK6StringS1_+0x4dc>)
    37e0:	4618      	mov	r0, r3
    37e2:	f002 ff2b 	bl	663c <_ZN6StringC1EPKc>
    37e6:	2301      	movs	r3, #1
    37e8:	62fb      	str	r3, [r7, #44]	; 0x2c
    37ea:	f507 738a 	add.w	r3, r7, #276	; 0x114
    37ee:	498c      	ldr	r1, [pc, #560]	; (3a20 <_Z16setConfigCommandRK6StringS1_+0x4dc>)
    37f0:	4618      	mov	r0, r3
    37f2:	f002 ff23 	bl	663c <_ZN6StringC1EPKc>
    37f6:	2301      	movs	r3, #1
    37f8:	62bb      	str	r3, [r7, #40]	; 0x28
    37fa:	f107 0454 	add.w	r4, r7, #84	; 0x54
    37fe:	f107 0264 	add.w	r2, r7, #100	; 0x64
    3802:	f507 718a 	add.w	r1, r7, #276	; 0x114
    3806:	f507 7082 	add.w	r0, r7, #260	; 0x104
    380a:	2320      	movs	r3, #32
    380c:	9302      	str	r3, [sp, #8]
    380e:	2304      	movs	r3, #4
    3810:	9301      	str	r3, [sp, #4]
    3812:	4b81      	ldr	r3, [pc, #516]	; (3a18 <_Z16setConfigCommandRK6StringS1_+0x4d4>)
    3814:	9300      	str	r3, [sp, #0]
    3816:	4623      	mov	r3, r4
    3818:	f7fe fe38 	bl	248c <_Z9setDirectRK6StringS1_S1_S1_Rmmm>
    381c:	4603      	mov	r3, r0
    381e:	2b00      	cmp	r3, #0
    3820:	f040 8142 	bne.w	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || setDirect("inputGainResistor1", "inputgainresistor1", arg1, arg2, g_iInputGainResistor1_ohms, g_iInputGainResistor_min_ohms , g_iInputGainResistor_max_ohms)
    3824:	f507 7392 	add.w	r3, r7, #292	; 0x124
    3828:	497e      	ldr	r1, [pc, #504]	; (3a24 <_Z16setConfigCommandRK6StringS1_+0x4e0>)
    382a:	4618      	mov	r0, r3
    382c:	f002 ff06 	bl	663c <_ZN6StringC1EPKc>
    3830:	2301      	movs	r3, #1
    3832:	627b      	str	r3, [r7, #36]	; 0x24
    3834:	f507 739a 	add.w	r3, r7, #308	; 0x134
    3838:	497b      	ldr	r1, [pc, #492]	; (3a28 <_Z16setConfigCommandRK6StringS1_+0x4e4>)
    383a:	4618      	mov	r0, r3
    383c:	f002 fefe 	bl	663c <_ZN6StringC1EPKc>
    3840:	2301      	movs	r3, #1
    3842:	623b      	str	r3, [r7, #32]
    3844:	f107 0454 	add.w	r4, r7, #84	; 0x54
    3848:	f107 0264 	add.w	r2, r7, #100	; 0x64
    384c:	f507 719a 	add.w	r1, r7, #308	; 0x134
    3850:	f507 7092 	add.w	r0, r7, #292	; 0x124
    3854:	f24c 3350 	movw	r3, #50000	; 0xc350
    3858:	9302      	str	r3, [sp, #8]
    385a:	2300      	movs	r3, #0
    385c:	9301      	str	r3, [sp, #4]
    385e:	4b73      	ldr	r3, [pc, #460]	; (3a2c <_Z16setConfigCommandRK6StringS1_+0x4e8>)
    3860:	9300      	str	r3, [sp, #0]
    3862:	4623      	mov	r3, r4
    3864:	f7fe fe12 	bl	248c <_Z9setDirectRK6StringS1_S1_S1_Rmmm>
    3868:	4603      	mov	r3, r0
    386a:	2b00      	cmp	r3, #0
    386c:	f040 811c 	bne.w	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || setDirect("inputGainResistor2", "inputgainresistor2", arg1, arg2, g_iInputGainResistor2_ohms, g_iInputGainResistor_min_ohms , g_iInputGainResistor_max_ohms)
    3870:	f507 73a2 	add.w	r3, r7, #324	; 0x144
    3874:	496e      	ldr	r1, [pc, #440]	; (3a30 <_Z16setConfigCommandRK6StringS1_+0x4ec>)
    3876:	4618      	mov	r0, r3
    3878:	f002 fee0 	bl	663c <_ZN6StringC1EPKc>
    387c:	2301      	movs	r3, #1
    387e:	61fb      	str	r3, [r7, #28]
    3880:	f507 73aa 	add.w	r3, r7, #340	; 0x154
    3884:	496b      	ldr	r1, [pc, #428]	; (3a34 <_Z16setConfigCommandRK6StringS1_+0x4f0>)
    3886:	4618      	mov	r0, r3
    3888:	f002 fed8 	bl	663c <_ZN6StringC1EPKc>
    388c:	2301      	movs	r3, #1
    388e:	61bb      	str	r3, [r7, #24]
    3890:	f107 0454 	add.w	r4, r7, #84	; 0x54
    3894:	f107 0264 	add.w	r2, r7, #100	; 0x64
    3898:	f507 71aa 	add.w	r1, r7, #340	; 0x154
    389c:	f507 70a2 	add.w	r0, r7, #324	; 0x144
    38a0:	f24c 3350 	movw	r3, #50000	; 0xc350
    38a4:	9302      	str	r3, [sp, #8]
    38a6:	2300      	movs	r3, #0
    38a8:	9301      	str	r3, [sp, #4]
    38aa:	4b63      	ldr	r3, [pc, #396]	; (3a38 <_Z16setConfigCommandRK6StringS1_+0x4f4>)
    38ac:	9300      	str	r3, [sp, #0]
    38ae:	4623      	mov	r3, r4
    38b0:	f7fe fdec 	bl	248c <_Z9setDirectRK6StringS1_S1_S1_Rmmm>
    38b4:	4603      	mov	r3, r0
    38b6:	2b00      	cmp	r3, #0
    38b8:	f040 80f6 	bne.w	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || setDirect("outputGainResistor", "outputgainresistor", arg1, arg2, g_iOutputGainResistor_ohms, g_iOutputGainResistor_min_ohms, g_iOutputGainResistor_max_ohms)
    38bc:	f507 73b2 	add.w	r3, r7, #356	; 0x164
    38c0:	495e      	ldr	r1, [pc, #376]	; (3a3c <_Z16setConfigCommandRK6StringS1_+0x4f8>)
    38c2:	4618      	mov	r0, r3
    38c4:	f002 feba 	bl	663c <_ZN6StringC1EPKc>
    38c8:	2301      	movs	r3, #1
    38ca:	617b      	str	r3, [r7, #20]
    38cc:	f507 73ba 	add.w	r3, r7, #372	; 0x174
    38d0:	495b      	ldr	r1, [pc, #364]	; (3a40 <_Z16setConfigCommandRK6StringS1_+0x4fc>)
    38d2:	4618      	mov	r0, r3
    38d4:	f002 feb2 	bl	663c <_ZN6StringC1EPKc>
    38d8:	2301      	movs	r3, #1
    38da:	613b      	str	r3, [r7, #16]
    38dc:	f107 0454 	add.w	r4, r7, #84	; 0x54
    38e0:	f107 0264 	add.w	r2, r7, #100	; 0x64
    38e4:	f507 71ba 	add.w	r1, r7, #372	; 0x174
    38e8:	f507 70b2 	add.w	r0, r7, #356	; 0x164
    38ec:	f24c 3350 	movw	r3, #50000	; 0xc350
    38f0:	9302      	str	r3, [sp, #8]
    38f2:	2300      	movs	r3, #0
    38f4:	9301      	str	r3, [sp, #4]
    38f6:	4b53      	ldr	r3, [pc, #332]	; (3a44 <_Z16setConfigCommandRK6StringS1_+0x500>)
    38f8:	9300      	str	r3, [sp, #0]
    38fa:	4623      	mov	r3, r4
    38fc:	f7fe fdc6 	bl	248c <_Z9setDirectRK6StringS1_S1_S1_Rmmm>
    3900:	4603      	mov	r3, r0
    3902:	2b00      	cmp	r3, #0
    3904:	f040 80d0 	bne.w	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || setDirect("sampleCycles"      , "samplecycles"      , arg1, arg2, g_iSample_cycles          , g_iSample_cycles_min          , g_iSample_cycles_max)
    3908:	f507 73c2 	add.w	r3, r7, #388	; 0x184
    390c:	494e      	ldr	r1, [pc, #312]	; (3a48 <_Z16setConfigCommandRK6StringS1_+0x504>)
    390e:	4618      	mov	r0, r3
    3910:	f002 fe94 	bl	663c <_ZN6StringC1EPKc>
    3914:	2301      	movs	r3, #1
    3916:	60fb      	str	r3, [r7, #12]
    3918:	f507 73ca 	add.w	r3, r7, #404	; 0x194
    391c:	494b      	ldr	r1, [pc, #300]	; (3a4c <_Z16setConfigCommandRK6StringS1_+0x508>)
    391e:	4618      	mov	r0, r3
    3920:	f002 fe8c 	bl	663c <_ZN6StringC1EPKc>
    3924:	2301      	movs	r3, #1
    3926:	60bb      	str	r3, [r7, #8]
    3928:	f107 0454 	add.w	r4, r7, #84	; 0x54
    392c:	f107 0264 	add.w	r2, r7, #100	; 0x64
    3930:	f507 71ca 	add.w	r1, r7, #404	; 0x194
    3934:	f507 70c2 	add.w	r0, r7, #388	; 0x184
    3938:	2314      	movs	r3, #20
    393a:	9302      	str	r3, [sp, #8]
    393c:	2301      	movs	r3, #1
    393e:	9301      	str	r3, [sp, #4]
    3940:	4b43      	ldr	r3, [pc, #268]	; (3a50 <_Z16setConfigCommandRK6StringS1_+0x50c>)
    3942:	9300      	str	r3, [sp, #0]
    3944:	4623      	mov	r3, r4
    3946:	f7fe fda1 	bl	248c <_Z9setDirectRK6StringS1_S1_S1_Rmmm>
    394a:	4603      	mov	r3, r0
    394c:	2b00      	cmp	r3, #0
    394e:	f040 80ab 	bne.w	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || setDirect("samplesPerCycle"   , "samplespercycle"   , arg1, arg2, g_iSamples_per_cycle      , g_iSamples_per_cycle_min      , g_iSamples_per_cycle_max)
    3952:	f507 73d2 	add.w	r3, r7, #420	; 0x1a4
    3956:	493f      	ldr	r1, [pc, #252]	; (3a54 <_Z16setConfigCommandRK6StringS1_+0x510>)
    3958:	4618      	mov	r0, r3
    395a:	f002 fe6f 	bl	663c <_ZN6StringC1EPKc>
    395e:	f04f 0b01 	mov.w	fp, #1
    3962:	f507 73da 	add.w	r3, r7, #436	; 0x1b4
    3966:	493c      	ldr	r1, [pc, #240]	; (3a58 <_Z16setConfigCommandRK6StringS1_+0x514>)
    3968:	4618      	mov	r0, r3
    396a:	f002 fe67 	bl	663c <_ZN6StringC1EPKc>
    396e:	f04f 0a01 	mov.w	sl, #1
    3972:	f107 0454 	add.w	r4, r7, #84	; 0x54
    3976:	f107 0264 	add.w	r2, r7, #100	; 0x64
    397a:	f507 71da 	add.w	r1, r7, #436	; 0x1b4
    397e:	f507 70d2 	add.w	r0, r7, #420	; 0x1a4
    3982:	2314      	movs	r3, #20
    3984:	9302      	str	r3, [sp, #8]
    3986:	2302      	movs	r3, #2
    3988:	9301      	str	r3, [sp, #4]
    398a:	4b34      	ldr	r3, [pc, #208]	; (3a5c <_Z16setConfigCommandRK6StringS1_+0x518>)
    398c:	9300      	str	r3, [sp, #0]
    398e:	4623      	mov	r3, r4
    3990:	f7fe fd7c 	bl	248c <_Z9setDirectRK6StringS1_S1_S1_Rmmm>
    3994:	4603      	mov	r3, r0
    3996:	2b00      	cmp	r3, #0
    3998:	f040 8086 	bne.w	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || setDirect("sampleRubbish"     , "samplerubbish"     , arg1, arg2, g_iSample_rubbish         , g_iSample_rubbish_min         , g_iSample_rubbish_max)
    399c:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
    39a0:	492f      	ldr	r1, [pc, #188]	; (3a60 <_Z16setConfigCommandRK6StringS1_+0x51c>)
    39a2:	4618      	mov	r0, r3
    39a4:	f002 fe4a 	bl	663c <_ZN6StringC1EPKc>
    39a8:	f04f 0901 	mov.w	r9, #1
    39ac:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
    39b0:	492c      	ldr	r1, [pc, #176]	; (3a64 <_Z16setConfigCommandRK6StringS1_+0x520>)
    39b2:	4618      	mov	r0, r3
    39b4:	f002 fe42 	bl	663c <_ZN6StringC1EPKc>
    39b8:	f04f 0801 	mov.w	r8, #1
    39bc:	f107 0454 	add.w	r4, r7, #84	; 0x54
    39c0:	f107 0264 	add.w	r2, r7, #100	; 0x64
    39c4:	f507 71ea 	add.w	r1, r7, #468	; 0x1d4
    39c8:	f507 70e2 	add.w	r0, r7, #452	; 0x1c4
    39cc:	2364      	movs	r3, #100	; 0x64
    39ce:	9302      	str	r3, [sp, #8]
    39d0:	2301      	movs	r3, #1
    39d2:	9301      	str	r3, [sp, #4]
    39d4:	4b24      	ldr	r3, [pc, #144]	; (3a68 <_Z16setConfigCommandRK6StringS1_+0x524>)
    39d6:	9300      	str	r3, [sp, #0]
    39d8:	4623      	mov	r3, r4
    39da:	f7fe fd57 	bl	248c <_Z9setDirectRK6StringS1_S1_S1_Rmmm>
    39de:	4603      	mov	r3, r0
    39e0:	2b00      	cmp	r3, #0
    39e2:	d161      	bne.n	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || setDirect("mapToLines"        , "mapToLines"        , arg1, arg2, g_bMapElectrodesToLines             )
    39e4:	f507 73f2 	add.w	r3, r7, #484	; 0x1e4
    39e8:	4920      	ldr	r1, [pc, #128]	; (3a6c <_Z16setConfigCommandRK6StringS1_+0x528>)
    39ea:	4618      	mov	r0, r3
    39ec:	f002 fe26 	bl	663c <_ZN6StringC1EPKc>
    39f0:	2601      	movs	r6, #1
    39f2:	f507 73fa 	add.w	r3, r7, #500	; 0x1f4
    39f6:	e03b      	b.n	3a70 <_Z16setConfigCommandRK6StringS1_+0x52c>
    39f8:	0000f27c 	.word	0x0000f27c
    39fc:	1fff0ac8 	.word	0x1fff0ac8
    3a00:	0000f284 	.word	0x0000f284
    3a04:	0000f3c0 	.word	0x0000f3c0
    3a08:	1fff0731 	.word	0x1fff0731
    3a0c:	0000f28c 	.word	0x0000f28c
    3a10:	1fff0734 	.word	0x1fff0734
    3a14:	0000f298 	.word	0x0000f298
    3a18:	1fff0738 	.word	0x1fff0738
    3a1c:	1fff073c 	.word	0x1fff073c
    3a20:	0000f2a0 	.word	0x0000f2a0
    3a24:	0000f2ac 	.word	0x0000f2ac
    3a28:	0000f3c8 	.word	0x0000f3c8
    3a2c:	1fff0740 	.word	0x1fff0740
    3a30:	0000f2c8 	.word	0x0000f2c8
    3a34:	0000f3dc 	.word	0x0000f3dc
    3a38:	1fff0744 	.word	0x1fff0744
    3a3c:	0000f2dc 	.word	0x0000f2dc
    3a40:	0000f3f0 	.word	0x0000f3f0
    3a44:	1fff0748 	.word	0x1fff0748
    3a48:	0000f2f0 	.word	0x0000f2f0
    3a4c:	0000f404 	.word	0x0000f404
    3a50:	1fff074c 	.word	0x1fff074c
    3a54:	0000f300 	.word	0x0000f300
    3a58:	0000f414 	.word	0x0000f414
    3a5c:	1fff0750 	.word	0x1fff0750
    3a60:	0000f310 	.word	0x0000f310
    3a64:	0000f424 	.word	0x0000f424
    3a68:	1fff0754 	.word	0x1fff0754
    3a6c:	0000f320 	.word	0x0000f320
    3a70:	4978      	ldr	r1, [pc, #480]	; (3c54 <_Z16setConfigCommandRK6StringS1_+0x710>)
    3a72:	4618      	mov	r0, r3
    3a74:	f002 fde2 	bl	663c <_ZN6StringC1EPKc>
    3a78:	2501      	movs	r5, #1
    3a7a:	f107 0454 	add.w	r4, r7, #84	; 0x54
    3a7e:	f107 0264 	add.w	r2, r7, #100	; 0x64
    3a82:	f507 71fa 	add.w	r1, r7, #500	; 0x1f4
    3a86:	f507 70f2 	add.w	r0, r7, #484	; 0x1e4
    3a8a:	4b73      	ldr	r3, [pc, #460]	; (3c58 <_Z16setConfigCommandRK6StringS1_+0x714>)
    3a8c:	9300      	str	r3, [sp, #0]
    3a8e:	4623      	mov	r3, r4
    3a90:	f7fe fd3a 	bl	2508 <_Z9setDirectRK6StringS1_S1_S1_Rb>
    3a94:	4603      	mov	r3, r0
    3a96:	2b00      	cmp	r3, #0
    3a98:	d106      	bne.n	3aa8 <_Z16setConfigCommandRK6StringS1_+0x564>
     || unknownValue(arg1);
    3a9a:	f107 0364 	add.w	r3, r7, #100	; 0x64
    3a9e:	4618      	mov	r0, r3
    3aa0:	f7fe fdf6 	bl	2690 <_Z12unknownValueRK6String>
    3aa4:	4603      	mov	r3, r0
    3aa6:	2b00      	cmp	r3, #0
    3aa8:	bf00      	nop
     || setDirect("mapToLines"        , "mapToLines"        , arg1, arg2, g_bMapElectrodesToLines             )
    3aaa:	2d00      	cmp	r5, #0
    3aac:	d004      	beq.n	3ab8 <_Z16setConfigCommandRK6StringS1_+0x574>
    3aae:	f507 73fa 	add.w	r3, r7, #500	; 0x1f4
    3ab2:	4618      	mov	r0, r3
    3ab4:	f002 fdec 	bl	6690 <_ZN6StringD1Ev>
    3ab8:	2e00      	cmp	r6, #0
    3aba:	d004      	beq.n	3ac6 <_Z16setConfigCommandRK6StringS1_+0x582>
    3abc:	f507 73f2 	add.w	r3, r7, #484	; 0x1e4
    3ac0:	4618      	mov	r0, r3
    3ac2:	f002 fde5 	bl	6690 <_ZN6StringD1Ev>
     || setDirect("sampleRubbish"     , "samplerubbish"     , arg1, arg2, g_iSample_rubbish         , g_iSample_rubbish_min         , g_iSample_rubbish_max)
    3ac6:	f1b8 0f00 	cmp.w	r8, #0
    3aca:	d004      	beq.n	3ad6 <_Z16setConfigCommandRK6StringS1_+0x592>
    3acc:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
    3ad0:	4618      	mov	r0, r3
    3ad2:	f002 fddd 	bl	6690 <_ZN6StringD1Ev>
    3ad6:	f1b9 0f00 	cmp.w	r9, #0
    3ada:	d004      	beq.n	3ae6 <_Z16setConfigCommandRK6StringS1_+0x5a2>
    3adc:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
    3ae0:	4618      	mov	r0, r3
    3ae2:	f002 fdd5 	bl	6690 <_ZN6StringD1Ev>
     || setDirect("samplesPerCycle"   , "samplespercycle"   , arg1, arg2, g_iSamples_per_cycle      , g_iSamples_per_cycle_min      , g_iSamples_per_cycle_max)
    3ae6:	f1ba 0f00 	cmp.w	sl, #0
    3aea:	d004      	beq.n	3af6 <_Z16setConfigCommandRK6StringS1_+0x5b2>
    3aec:	f507 73da 	add.w	r3, r7, #436	; 0x1b4
    3af0:	4618      	mov	r0, r3
    3af2:	f002 fdcd 	bl	6690 <_ZN6StringD1Ev>
    3af6:	f1bb 0f00 	cmp.w	fp, #0
    3afa:	d004      	beq.n	3b06 <_Z16setConfigCommandRK6StringS1_+0x5c2>
    3afc:	f507 73d2 	add.w	r3, r7, #420	; 0x1a4
    3b00:	4618      	mov	r0, r3
    3b02:	f002 fdc5 	bl	6690 <_ZN6StringD1Ev>
     || setDirect("sampleCycles"      , "samplecycles"      , arg1, arg2, g_iSample_cycles          , g_iSample_cycles_min          , g_iSample_cycles_max)
    3b06:	68bb      	ldr	r3, [r7, #8]
    3b08:	2b00      	cmp	r3, #0
    3b0a:	d004      	beq.n	3b16 <_Z16setConfigCommandRK6StringS1_+0x5d2>
    3b0c:	f507 73ca 	add.w	r3, r7, #404	; 0x194
    3b10:	4618      	mov	r0, r3
    3b12:	f002 fdbd 	bl	6690 <_ZN6StringD1Ev>
    3b16:	68fb      	ldr	r3, [r7, #12]
    3b18:	2b00      	cmp	r3, #0
    3b1a:	d004      	beq.n	3b26 <_Z16setConfigCommandRK6StringS1_+0x5e2>
    3b1c:	f507 73c2 	add.w	r3, r7, #388	; 0x184
    3b20:	4618      	mov	r0, r3
    3b22:	f002 fdb5 	bl	6690 <_ZN6StringD1Ev>
     || setDirect("outputGainResistor", "outputgainresistor", arg1, arg2, g_iOutputGainResistor_ohms, g_iOutputGainResistor_min_ohms, g_iOutputGainResistor_max_ohms)
    3b26:	693b      	ldr	r3, [r7, #16]
    3b28:	2b00      	cmp	r3, #0
    3b2a:	d004      	beq.n	3b36 <_Z16setConfigCommandRK6StringS1_+0x5f2>
    3b2c:	f507 73ba 	add.w	r3, r7, #372	; 0x174
    3b30:	4618      	mov	r0, r3
    3b32:	f002 fdad 	bl	6690 <_ZN6StringD1Ev>
    3b36:	697b      	ldr	r3, [r7, #20]
    3b38:	2b00      	cmp	r3, #0
    3b3a:	d004      	beq.n	3b46 <_Z16setConfigCommandRK6StringS1_+0x602>
    3b3c:	f507 73b2 	add.w	r3, r7, #356	; 0x164
    3b40:	4618      	mov	r0, r3
    3b42:	f002 fda5 	bl	6690 <_ZN6StringD1Ev>
     || setDirect("inputGainResistor2", "inputgainresistor2", arg1, arg2, g_iInputGainResistor2_ohms, g_iInputGainResistor_min_ohms , g_iInputGainResistor_max_ohms)
    3b46:	69bb      	ldr	r3, [r7, #24]
    3b48:	2b00      	cmp	r3, #0
    3b4a:	d004      	beq.n	3b56 <_Z16setConfigCommandRK6StringS1_+0x612>
    3b4c:	f507 73aa 	add.w	r3, r7, #340	; 0x154
    3b50:	4618      	mov	r0, r3
    3b52:	f002 fd9d 	bl	6690 <_ZN6StringD1Ev>
    3b56:	69fb      	ldr	r3, [r7, #28]
    3b58:	2b00      	cmp	r3, #0
    3b5a:	d004      	beq.n	3b66 <_Z16setConfigCommandRK6StringS1_+0x622>
    3b5c:	f507 73a2 	add.w	r3, r7, #324	; 0x144
    3b60:	4618      	mov	r0, r3
    3b62:	f002 fd95 	bl	6690 <_ZN6StringD1Ev>
     || setDirect("inputGainResistor1", "inputgainresistor1", arg1, arg2, g_iInputGainResistor1_ohms, g_iInputGainResistor_min_ohms , g_iInputGainResistor_max_ohms)
    3b66:	6a3b      	ldr	r3, [r7, #32]
    3b68:	2b00      	cmp	r3, #0
    3b6a:	d004      	beq.n	3b76 <_Z16setConfigCommandRK6StringS1_+0x632>
    3b6c:	f507 739a 	add.w	r3, r7, #308	; 0x134
    3b70:	4618      	mov	r0, r3
    3b72:	f002 fd8d 	bl	6690 <_ZN6StringD1Ev>
    3b76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3b78:	2b00      	cmp	r3, #0
    3b7a:	d004      	beq.n	3b86 <_Z16setConfigCommandRK6StringS1_+0x642>
    3b7c:	f507 7392 	add.w	r3, r7, #292	; 0x124
    3b80:	4618      	mov	r0, r3
    3b82:	f002 fd85 	bl	6690 <_ZN6StringD1Ev>
     || setDirect("electrodes"        , "electrodes"        , arg1, arg2, g_iElectrodes             , g_iElectrodes_min             , g_iElectrodes_max)
    3b86:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3b88:	2b00      	cmp	r3, #0
    3b8a:	d004      	beq.n	3b96 <_Z16setConfigCommandRK6StringS1_+0x652>
    3b8c:	f507 738a 	add.w	r3, r7, #276	; 0x114
    3b90:	4618      	mov	r0, r3
    3b92:	f002 fd7d 	bl	6690 <_ZN6StringD1Ev>
    3b96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3b98:	2b00      	cmp	r3, #0
    3b9a:	d004      	beq.n	3ba6 <_Z16setConfigCommandRK6StringS1_+0x662>
    3b9c:	f507 7382 	add.w	r3, r7, #260	; 0x104
    3ba0:	4618      	mov	r0, r3
    3ba2:	f002 fd75 	bl	6690 <_ZN6StringD1Ev>
     || setDirect("dist"              , "dist"              , arg1, arg2, g_iDrivingDist                   , 1                             , g_iElectrodes/2)
    3ba6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    3ba8:	2b00      	cmp	r3, #0
    3baa:	d004      	beq.n	3bb6 <_Z16setConfigCommandRK6StringS1_+0x672>
    3bac:	f107 03f4 	add.w	r3, r7, #244	; 0xf4
    3bb0:	4618      	mov	r0, r3
    3bb2:	f002 fd6d 	bl	6690 <_ZN6StringD1Ev>
    3bb6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    3bb8:	2b00      	cmp	r3, #0
    3bba:	d004      	beq.n	3bc6 <_Z16setConfigCommandRK6StringS1_+0x682>
    3bbc:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
    3bc0:	4618      	mov	r0, r3
    3bc2:	f002 fd65 	bl	6690 <_ZN6StringD1Ev>
     || setDirect("delay"             , "delay"             , arg1, arg2, g_iDelay_ms               , g_iDelay_min_ms               , g_iDelay_max_ms)
    3bc6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    3bc8:	2b00      	cmp	r3, #0
    3bca:	d004      	beq.n	3bd6 <_Z16setConfigCommandRK6StringS1_+0x692>
    3bcc:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
    3bd0:	4618      	mov	r0, r3
    3bd2:	f002 fd5d 	bl	6690 <_ZN6StringD1Ev>
    3bd6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    3bd8:	2b00      	cmp	r3, #0
    3bda:	d004      	beq.n	3be6 <_Z16setConfigCommandRK6StringS1_+0x6a2>
    3bdc:	f107 03c4 	add.w	r3, r7, #196	; 0xc4
    3be0:	4618      	mov	r0, r3
    3be2:	f002 fd55 	bl	6690 <_ZN6StringD1Ev>
     || setDirectE<DACModes>("dacMode", "dacmode"           , arg1, arg2, g_eDACMode                )
    3be6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    3be8:	2b00      	cmp	r3, #0
    3bea:	d004      	beq.n	3bf6 <_Z16setConfigCommandRK6StringS1_+0x6b2>
    3bec:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
    3bf0:	4618      	mov	r0, r3
    3bf2:	f002 fd4d 	bl	6690 <_ZN6StringD1Ev>
    3bf6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    3bf8:	2b00      	cmp	r3, #0
    3bfa:	d004      	beq.n	3c06 <_Z16setConfigCommandRK6StringS1_+0x6c2>
    3bfc:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
    3c00:	4618      	mov	r0, r3
    3c02:	f002 fd45 	bl	6690 <_ZN6StringD1Ev>
     || setDirectE<Modes>("mode"      , "mode"              , arg1, arg2, g_eMode                   )
    3c06:	683b      	ldr	r3, [r7, #0]
    3c08:	2b00      	cmp	r3, #0
    3c0a:	d004      	beq.n	3c16 <_Z16setConfigCommandRK6StringS1_+0x6d2>
    3c0c:	f107 0394 	add.w	r3, r7, #148	; 0x94
    3c10:	4618      	mov	r0, r3
    3c12:	f002 fd3d 	bl	6690 <_ZN6StringD1Ev>
    3c16:	687b      	ldr	r3, [r7, #4]
    3c18:	2b00      	cmp	r3, #0
    3c1a:	d004      	beq.n	3c26 <_Z16setConfigCommandRK6StringS1_+0x6e2>
    3c1c:	f107 0384 	add.w	r3, r7, #132	; 0x84
    3c20:	4618      	mov	r0, r3
    3c22:	f002 fd35 	bl	6690 <_ZN6StringD1Ev>

    recalculateGlobals();
    3c26:	f7fd f83b 	bl	ca0 <_Z18recalculateGlobalsv>
    recalulatePeripherals();
    3c2a:	f000 faff 	bl	422c <_Z21recalulatePeripheralsv>

    return true;
    3c2e:	2401      	movs	r4, #1
}
    3c30:	f107 0354 	add.w	r3, r7, #84	; 0x54
    3c34:	4618      	mov	r0, r3
    3c36:	f002 fd2b 	bl	6690 <_ZN6StringD1Ev>
    3c3a:	f107 0364 	add.w	r3, r7, #100	; 0x64
    3c3e:	4618      	mov	r0, r3
    3c40:	f002 fd26 	bl	6690 <_ZN6StringD1Ev>
    3c44:	4623      	mov	r3, r4
    3c46:	4618      	mov	r0, r3
    3c48:	f507 7703 	add.w	r7, r7, #524	; 0x20c
    3c4c:	46bd      	mov	sp, r7
    3c4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3c52:	bf00      	nop
    3c54:	0000f320 	.word	0x0000f320
    3c58:	1fff0758 	.word	0x1fff0758

00003c5c <_Z11helpCommandRK6StringS1_>:


bool helpCommand(String const & command, String const & arguments) 
{
    3c5c:	b580      	push	{r7, lr}
    3c5e:	b082      	sub	sp, #8
    3c60:	af00      	add	r7, sp, #0
    3c62:	6078      	str	r0, [r7, #4]
    3c64:	6039      	str	r1, [r7, #0]
    if (( command != "help" ) && ( command != "?" )) return false;
    3c66:	490f      	ldr	r1, [pc, #60]	; (3ca4 <_Z11helpCommandRK6StringS1_+0x48>)
    3c68:	6878      	ldr	r0, [r7, #4]
    3c6a:	f7fc fc62 	bl	532 <_ZNK6StringneEPKc>
    3c6e:	4603      	mov	r3, r0
    3c70:	2b00      	cmp	r3, #0
    3c72:	d008      	beq.n	3c86 <_Z11helpCommandRK6StringS1_+0x2a>
    3c74:	490c      	ldr	r1, [pc, #48]	; (3ca8 <_Z11helpCommandRK6StringS1_+0x4c>)
    3c76:	6878      	ldr	r0, [r7, #4]
    3c78:	f7fc fc5b 	bl	532 <_ZNK6StringneEPKc>
    3c7c:	4603      	mov	r3, r0
    3c7e:	2b00      	cmp	r3, #0
    3c80:	d001      	beq.n	3c86 <_Z11helpCommandRK6StringS1_+0x2a>
    3c82:	2301      	movs	r3, #1
    3c84:	e000      	b.n	3c88 <_Z11helpCommandRK6StringS1_+0x2c>
    3c86:	2300      	movs	r3, #0
    3c88:	2b00      	cmp	r3, #0
    3c8a:	d001      	beq.n	3c90 <_Z11helpCommandRK6StringS1_+0x34>
    3c8c:	2300      	movs	r3, #0
    3c8e:	e005      	b.n	3c9c <_Z11helpCommandRK6StringS1_+0x40>
    deviceInfo();
    3c90:	f7fe fb22 	bl	22d8 <_Z10deviceInfov>
    return possibleCommands();
    3c94:	f7fe fd12 	bl	26bc <_Z16possibleCommandsv>
    3c98:	4603      	mov	r3, r0
    3c9a:	bf00      	nop
}
    3c9c:	4618      	mov	r0, r3
    3c9e:	3708      	adds	r7, #8
    3ca0:	46bd      	mov	sp, r7
    3ca2:	bd80      	pop	{r7, pc}
    3ca4:	0000f4ac 	.word	0x0000f4ac
    3ca8:	0000f4b4 	.word	0x0000f4b4

00003cac <_Z10runCommandRK6StringS1_>:


bool runCommand(String const & command, String const & arguments) 
{
    3cac:	b580      	push	{r7, lr}
    3cae:	b082      	sub	sp, #8
    3cb0:	af00      	add	r7, sp, #0
    3cb2:	6078      	str	r0, [r7, #4]
    3cb4:	6039      	str	r1, [r7, #0]
    if ( ( command == "start" )  || ( command == "run" ) )
    3cb6:	4917      	ldr	r1, [pc, #92]	; (3d14 <_Z10runCommandRK6StringS1_+0x68>)
    3cb8:	6878      	ldr	r0, [r7, #4]
    3cba:	f7fc fc19 	bl	4f0 <_ZNK6StringeqEPKc>
    3cbe:	4603      	mov	r3, r0
    3cc0:	2b00      	cmp	r3, #0
    3cc2:	d106      	bne.n	3cd2 <_Z10runCommandRK6StringS1_+0x26>
    3cc4:	4914      	ldr	r1, [pc, #80]	; (3d18 <_Z10runCommandRK6StringS1_+0x6c>)
    3cc6:	6878      	ldr	r0, [r7, #4]
    3cc8:	f7fc fc12 	bl	4f0 <_ZNK6StringeqEPKc>
    3ccc:	4603      	mov	r3, r0
    3cce:	2b00      	cmp	r3, #0
    3cd0:	d001      	beq.n	3cd6 <_Z10runCommandRK6StringS1_+0x2a>
    3cd2:	2301      	movs	r3, #1
    3cd4:	e000      	b.n	3cd8 <_Z10runCommandRK6StringS1_+0x2c>
    3cd6:	2300      	movs	r3, #0
    3cd8:	2b00      	cmp	r3, #0
    3cda:	d003      	beq.n	3ce4 <_Z10runCommandRK6StringS1_+0x38>
    {
        g_bRun = true;
    3cdc:	4b0f      	ldr	r3, [pc, #60]	; (3d1c <_Z10runCommandRK6StringS1_+0x70>)
    3cde:	2201      	movs	r2, #1
    3ce0:	701a      	strb	r2, [r3, #0]
    3ce2:	e011      	b.n	3d08 <_Z10runCommandRK6StringS1_+0x5c>
    }
    else if ( command == "stop" )
    3ce4:	490e      	ldr	r1, [pc, #56]	; (3d20 <_Z10runCommandRK6StringS1_+0x74>)
    3ce6:	6878      	ldr	r0, [r7, #4]
    3ce8:	f7fc fc02 	bl	4f0 <_ZNK6StringeqEPKc>
    3cec:	4603      	mov	r3, r0
    3cee:	2b00      	cmp	r3, #0
    3cf0:	bf14      	ite	ne
    3cf2:	2301      	movne	r3, #1
    3cf4:	2300      	moveq	r3, #0
    3cf6:	b2db      	uxtb	r3, r3
    3cf8:	2b00      	cmp	r3, #0
    3cfa:	d003      	beq.n	3d04 <_Z10runCommandRK6StringS1_+0x58>
    {
        g_bRun = false;
    3cfc:	4b07      	ldr	r3, [pc, #28]	; (3d1c <_Z10runCommandRK6StringS1_+0x70>)
    3cfe:	2200      	movs	r2, #0
    3d00:	701a      	strb	r2, [r3, #0]
    3d02:	e001      	b.n	3d08 <_Z10runCommandRK6StringS1_+0x5c>
    }
    else
    {
        return false;
    3d04:	2300      	movs	r3, #0
    3d06:	e000      	b.n	3d0a <_Z10runCommandRK6StringS1_+0x5e>
    }

    return true;
    3d08:	2301      	movs	r3, #1
}
    3d0a:	4618      	mov	r0, r3
    3d0c:	3708      	adds	r7, #8
    3d0e:	46bd      	mov	sp, r7
    3d10:	bd80      	pop	{r7, pc}
    3d12:	bf00      	nop
    3d14:	0000f4b8 	.word	0x0000f4b8
    3d18:	0000f340 	.word	0x0000f340
    3d1c:	1fff0730 	.word	0x1fff0730
    3d20:	0000f4c0 	.word	0x0000f4c0

00003d24 <_Z15processCommandsv>:



bool processCommands()
{
    3d24:	b590      	push	{r4, r7, lr}
    3d26:	b097      	sub	sp, #92	; 0x5c
    3d28:	af00      	add	r7, sp, #0
    // Is there anything in the input buffer
    if( Serial.peek() == -1 ) return false;
    3d2a:	4864      	ldr	r0, [pc, #400]	; (3ebc <_Z15processCommandsv+0x198>)
    3d2c:	f7fc fcb6 	bl	69c <_ZN16usb_serial_class4peekEv>
    3d30:	4603      	mov	r3, r0
    3d32:	f1b3 3fff 	cmp.w	r3, #4294967295
    3d36:	bf0c      	ite	eq
    3d38:	2301      	moveq	r3, #1
    3d3a:	2300      	movne	r3, #0
    3d3c:	b2db      	uxtb	r3, r3
    3d3e:	2b00      	cmp	r3, #0
    3d40:	d001      	beq.n	3d46 <_Z15processCommandsv+0x22>
    3d42:	2400      	movs	r4, #0
    3d44:	e0b4      	b.n	3eb0 <_Z15processCommandsv+0x18c>
    
    // TODO: use state machine to manage timeout (infinate time time out until newline is pushed)
    String commandString = Serial.readStringUntil('\n').toLowerCase().trim();
    3d46:	f107 0030 	add.w	r0, r7, #48	; 0x30
    3d4a:	2378      	movs	r3, #120	; 0x78
    3d4c:	220a      	movs	r2, #10
    3d4e:	495b      	ldr	r1, [pc, #364]	; (3ebc <_Z15processCommandsv+0x198>)
    3d50:	f001 fbb4 	bl	54bc <_ZN6Stream15readStringUntilEcj>
    3d54:	f107 0330 	add.w	r3, r7, #48	; 0x30
    3d58:	4618      	mov	r0, r3
    3d5a:	f002 ff2a 	bl	6bb2 <_ZN6String11toLowerCaseEv>
    3d5e:	4603      	mov	r3, r0
    3d60:	4618      	mov	r0, r3
    3d62:	f002 ff49 	bl	6bf8 <_ZN6String4trimEv>
    3d66:	4602      	mov	r2, r0
    3d68:	f107 0320 	add.w	r3, r7, #32
    3d6c:	4611      	mov	r1, r2
    3d6e:	4618      	mov	r0, r3
    3d70:	f002 fc7d 	bl	666e <_ZN6StringC1ERKS_>
    3d74:	f107 0330 	add.w	r3, r7, #48	; 0x30
    3d78:	4618      	mov	r0, r3
    3d7a:	f002 fc89 	bl	6690 <_ZN6StringD1Ev>

    Serial.print("\r\n");
    3d7e:	4950      	ldr	r1, [pc, #320]	; (3ec0 <_Z15processCommandsv+0x19c>)
    3d80:	484e      	ldr	r0, [pc, #312]	; (3ebc <_Z15processCommandsv+0x198>)
    3d82:	f7fc fc1d 	bl	5c0 <_ZN5Print5printEPKc>

    // Extract command and arguments
    auto tok = commandString.indexOf(" "); // Everything before the first space is the command, and everything after are the arguments
    3d86:	f107 0340 	add.w	r3, r7, #64	; 0x40
    3d8a:	494e      	ldr	r1, [pc, #312]	; (3ec4 <_Z15processCommandsv+0x1a0>)
    3d8c:	4618      	mov	r0, r3
    3d8e:	f002 fc55 	bl	663c <_ZN6StringC1EPKc>
    3d92:	f107 0240 	add.w	r2, r7, #64	; 0x40
    3d96:	f107 0320 	add.w	r3, r7, #32
    3d9a:	4611      	mov	r1, r2
    3d9c:	4618      	mov	r0, r3
    3d9e:	f002 fe7f 	bl	6aa0 <_ZNK6String7indexOfERKS_>
    3da2:	6578      	str	r0, [r7, #84]	; 0x54
    3da4:	f107 0340 	add.w	r3, r7, #64	; 0x40
    3da8:	4618      	mov	r0, r3
    3daa:	f002 fc71 	bl	6690 <_ZN6StringD1Ev>
    auto command = commandString.length() == 0 ? "" : commandString.substring(0, (tok == -1) ? commandString.length() : tok);
    3dae:	f107 0320 	add.w	r3, r7, #32
    3db2:	4618      	mov	r0, r3
    3db4:	f7fc fb90 	bl	4d8 <_ZNK6String6lengthEv>
    3db8:	4603      	mov	r3, r0
    3dba:	2b00      	cmp	r3, #0
    3dbc:	d106      	bne.n	3dcc <_Z15processCommandsv+0xa8>
    3dbe:	f107 0310 	add.w	r3, r7, #16
    3dc2:	4941      	ldr	r1, [pc, #260]	; (3ec8 <_Z15processCommandsv+0x1a4>)
    3dc4:	4618      	mov	r0, r3
    3dc6:	f002 fc39 	bl	663c <_ZN6StringC1EPKc>
    3dca:	e012      	b.n	3df2 <_Z15processCommandsv+0xce>
    3dcc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    3dce:	f1b3 3fff 	cmp.w	r3, #4294967295
    3dd2:	d106      	bne.n	3de2 <_Z15processCommandsv+0xbe>
    3dd4:	f107 0320 	add.w	r3, r7, #32
    3dd8:	4618      	mov	r0, r3
    3dda:	f7fc fb7d 	bl	4d8 <_ZNK6String6lengthEv>
    3dde:	4603      	mov	r3, r0
    3de0:	e000      	b.n	3de4 <_Z15processCommandsv+0xc0>
    3de2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    3de4:	f107 0010 	add.w	r0, r7, #16
    3de8:	f107 0120 	add.w	r1, r7, #32
    3dec:	2200      	movs	r2, #0
    3dee:	f002 fe9e 	bl	6b2e <_ZNK6String9substringEjj>
    auto arguments = (tok == -1) ? "" : commandString.substring(tok+1);
    3df2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    3df4:	f1b3 3fff 	cmp.w	r3, #4294967295
    3df8:	d105      	bne.n	3e06 <_Z15processCommandsv+0xe2>
    3dfa:	463b      	mov	r3, r7
    3dfc:	4932      	ldr	r1, [pc, #200]	; (3ec8 <_Z15processCommandsv+0x1a4>)
    3dfe:	4618      	mov	r0, r3
    3e00:	f002 fc1c 	bl	663c <_ZN6StringC1EPKc>
    3e04:	e008      	b.n	3e18 <_Z15processCommandsv+0xf4>
    3e06:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    3e08:	3301      	adds	r3, #1
    3e0a:	461a      	mov	r2, r3
    3e0c:	463b      	mov	r3, r7
    3e0e:	f107 0120 	add.w	r1, r7, #32
    3e12:	4618      	mov	r0, r3
    3e14:	f002 fe7a 	bl	6b0c <_ZNK6String9substringEj>

    // Execute the command
    //  Try each command in order, until we find one that works
    bool res = helpCommand(command, arguments)
    3e18:	463a      	mov	r2, r7
    3e1a:	f107 0310 	add.w	r3, r7, #16
    3e1e:	4611      	mov	r1, r2
    3e20:	4618      	mov	r0, r3
    3e22:	f7ff ff1b 	bl	3c5c <_Z11helpCommandRK6StringS1_>
    3e26:	4603      	mov	r3, r0
            || setConfigCommand(command, arguments)
            || getConfigCommand(command, arguments)
            || runCommand(command, arguments)
            || unknownCommand(command);
    3e28:	2b00      	cmp	r3, #0
    3e2a:	d125      	bne.n	3e78 <_Z15processCommandsv+0x154>
            || setConfigCommand(command, arguments)
    3e2c:	463a      	mov	r2, r7
    3e2e:	f107 0310 	add.w	r3, r7, #16
    3e32:	4611      	mov	r1, r2
    3e34:	4618      	mov	r0, r3
    3e36:	f7ff fb85 	bl	3544 <_Z16setConfigCommandRK6StringS1_>
    3e3a:	4603      	mov	r3, r0
    3e3c:	2b00      	cmp	r3, #0
    3e3e:	d11b      	bne.n	3e78 <_Z15processCommandsv+0x154>
            || getConfigCommand(command, arguments)
    3e40:	463a      	mov	r2, r7
    3e42:	f107 0310 	add.w	r3, r7, #16
    3e46:	4611      	mov	r1, r2
    3e48:	4618      	mov	r0, r3
    3e4a:	f7fe fe2d 	bl	2aa8 <_Z16getConfigCommandRK6StringS1_>
    3e4e:	4603      	mov	r3, r0
    3e50:	2b00      	cmp	r3, #0
    3e52:	d111      	bne.n	3e78 <_Z15processCommandsv+0x154>
            || runCommand(command, arguments)
    3e54:	463a      	mov	r2, r7
    3e56:	f107 0310 	add.w	r3, r7, #16
    3e5a:	4611      	mov	r1, r2
    3e5c:	4618      	mov	r0, r3
    3e5e:	f7ff ff25 	bl	3cac <_Z10runCommandRK6StringS1_>
    3e62:	4603      	mov	r3, r0
    3e64:	2b00      	cmp	r3, #0
    3e66:	d107      	bne.n	3e78 <_Z15processCommandsv+0x154>
            || unknownCommand(command);
    3e68:	f107 0310 	add.w	r3, r7, #16
    3e6c:	4618      	mov	r0, r3
    3e6e:	f7fe fc3b 	bl	26e8 <_Z14unknownCommandRK6String>
    3e72:	4603      	mov	r3, r0
    3e74:	2b00      	cmp	r3, #0
    3e76:	d001      	beq.n	3e7c <_Z15processCommandsv+0x158>
    3e78:	2301      	movs	r3, #1
    3e7a:	e000      	b.n	3e7e <_Z15processCommandsv+0x15a>
    3e7c:	2300      	movs	r3, #0
    3e7e:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53

    Serial.clear();
    3e82:	480e      	ldr	r0, [pc, #56]	; (3ebc <_Z15processCommandsv+0x198>)
    3e84:	f7fc fc1f 	bl	6c6 <_ZN16usb_serial_class5clearEv>

    Serial.print("\r\n");
    3e88:	490d      	ldr	r1, [pc, #52]	; (3ec0 <_Z15processCommandsv+0x19c>)
    3e8a:	480c      	ldr	r0, [pc, #48]	; (3ebc <_Z15processCommandsv+0x198>)
    3e8c:	f7fc fb98 	bl	5c0 <_ZN5Print5printEPKc>

    return res;
    3e90:	f897 4053 	ldrb.w	r4, [r7, #83]	; 0x53
    3e94:	463b      	mov	r3, r7
    3e96:	4618      	mov	r0, r3
    3e98:	f002 fbfa 	bl	6690 <_ZN6StringD1Ev>
    3e9c:	f107 0310 	add.w	r3, r7, #16
    3ea0:	4618      	mov	r0, r3
    3ea2:	f002 fbf5 	bl	6690 <_ZN6StringD1Ev>
    3ea6:	f107 0320 	add.w	r3, r7, #32
    3eaa:	4618      	mov	r0, r3
    3eac:	f002 fbf0 	bl	6690 <_ZN6StringD1Ev>
    3eb0:	4623      	mov	r3, r4
    3eb2:	4618      	mov	r0, r3
    3eb4:	375c      	adds	r7, #92	; 0x5c
    3eb6:	46bd      	mov	sp, r7
    3eb8:	bd90      	pop	{r4, r7, pc}
    3eba:	bf00      	nop
    3ebc:	1fff078c 	.word	0x1fff078c
    3ec0:	0000efac 	.word	0x0000efac
    3ec4:	0000f4a4 	.word	0x0000f4a4
    3ec8:	0000f4a8 	.word	0x0000f4a8

00003ecc <main>:
#include "commands.h"

void setup();

extern "C" int main() 
{
    3ecc:	b580      	push	{r7, lr}
    3ece:	b084      	sub	sp, #16
    3ed0:	af00      	add	r7, sp, #0
    #ifdef SEMIHOSTING
  	    initialise_monitor_handles();
    #endif

    // Initialise Hardware
    setup();
    3ed2:	f000 f869 	bl	3fa8 <setup>
    recalculateGlobals();
    3ed6:	f7fc fee3 	bl	ca0 <_Z18recalculateGlobalsv>
    recalulatePeripherals();
    3eda:	f000 f9a7 	bl	422c <_Z21recalulatePeripheralsv>

    // Wait to connect with the PC
    for(; !Serial ;) ; // TODO : Breathe LED here
    3ede:	bf00      	nop
    3ee0:	4827      	ldr	r0, [pc, #156]	; (3f80 <main+0xb4>)
    3ee2:	f7fc fbfb 	bl	6dc <_ZN16usb_serial_classcvbEv>
    3ee6:	4603      	mov	r3, r0
    3ee8:	f083 0301 	eor.w	r3, r3, #1
    3eec:	b2db      	uxtb	r3, r3
    3eee:	2b00      	cmp	r3, #0
    3ef0:	d1f6      	bne.n	3ee0 <main+0x14>

    // NB any text printed to the serial should be escaped with a leading #
    // this is to not confuse any application that ..

    SL(); // Print empty comment line
    3ef2:	f7fe f9e7 	bl	22c4 <_Z2SLv>
    for(auto c : logo) {Serial.print(c);} // Print the logo character by character.. (wHY loop?)
    3ef6:	4b23      	ldr	r3, [pc, #140]	; (3f84 <main+0xb8>)
    3ef8:	60bb      	str	r3, [r7, #8]
    3efa:	4b22      	ldr	r3, [pc, #136]	; (3f84 <main+0xb8>)
    3efc:	60fb      	str	r3, [r7, #12]
    3efe:	4b22      	ldr	r3, [pc, #136]	; (3f88 <main+0xbc>)
    3f00:	607b      	str	r3, [r7, #4]
    3f02:	e00a      	b.n	3f1a <main+0x4e>
    3f04:	68fb      	ldr	r3, [r7, #12]
    3f06:	781b      	ldrb	r3, [r3, #0]
    3f08:	70fb      	strb	r3, [r7, #3]
    3f0a:	78fb      	ldrb	r3, [r7, #3]
    3f0c:	4619      	mov	r1, r3
    3f0e:	481c      	ldr	r0, [pc, #112]	; (3f80 <main+0xb4>)
    3f10:	f7fc fb44 	bl	59c <_ZN5Print5printEc>
    3f14:	68fb      	ldr	r3, [r7, #12]
    3f16:	3301      	adds	r3, #1
    3f18:	60fb      	str	r3, [r7, #12]
    3f1a:	68fa      	ldr	r2, [r7, #12]
    3f1c:	687b      	ldr	r3, [r7, #4]
    3f1e:	429a      	cmp	r2, r3
    3f20:	d1f0      	bne.n	3f04 <main+0x38>
    deviceInfo(); // Print device information (using the device information command)
    3f22:	f7fe f9d9 	bl	22d8 <_Z10deviceInfov>
    SDK_DelayAtLeastUs(g_iStartupDelay_ms * 1000, SystemCoreClock); // Give the user time (g_iStartupDelay_ms) to see the logo
    3f26:	4b19      	ldr	r3, [pc, #100]	; (3f8c <main+0xc0>)
    3f28:	681b      	ldr	r3, [r3, #0]
    3f2a:	4619      	mov	r1, r3
    3f2c:	4818      	ldr	r0, [pc, #96]	; (3f90 <main+0xc4>)
    3f2e:	f007 fbff 	bl	b730 <SDK_DelayAtLeastUs>
    
    // Main Loop
    for (;;)
    {
        #ifdef ARDUINO
            yield(); // For Multitasking arduino libraries including usb serial
    3f32:	f002 ff41 	bl	6db8 <yield>
        #endif

        // Execute current task (depending on the configured mode)
        BOARD_LED_ON();
    3f36:	2201      	movs	r2, #1
    3f38:	2105      	movs	r1, #5
    3f3a:	4816      	ldr	r0, [pc, #88]	; (3f94 <main+0xc8>)
    3f3c:	f7fc fca4 	bl	888 <GPIO_PinWrite>
        if (g_bRun) { // Is there an active task
    3f40:	4b15      	ldr	r3, [pc, #84]	; (3f98 <main+0xcc>)
    3f42:	781b      	ldrb	r3, [r3, #0]
    3f44:	2b00      	cmp	r3, #0
    3f46:	d006      	beq.n	3f56 <main+0x8a>
            g_ModeFunctions[g_eMode](); // Run the desired task
    3f48:	4b14      	ldr	r3, [pc, #80]	; (3f9c <main+0xd0>)
    3f4a:	781b      	ldrb	r3, [r3, #0]
    3f4c:	461a      	mov	r2, r3
    3f4e:	4b14      	ldr	r3, [pc, #80]	; (3fa0 <main+0xd4>)
    3f50:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    3f54:	4798      	blx	r3
        }
        BOARD_LED_OFF();
    3f56:	2200      	movs	r2, #0
    3f58:	2105      	movs	r1, #5
    3f5a:	480e      	ldr	r0, [pc, #56]	; (3f94 <main+0xc8>)
    3f5c:	f7fc fc94 	bl	888 <GPIO_PinWrite>

        // Wait between task executions (g_iDelay_ms)
        SDK_DelayAtLeastUs(g_iDelay_ms * 1000, SystemCoreClock); // TODO: use the system tick counter to be hard real time
    3f60:	4b10      	ldr	r3, [pc, #64]	; (3fa4 <main+0xd8>)
    3f62:	681b      	ldr	r3, [r3, #0]
    3f64:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    3f68:	fb02 f303 	mul.w	r3, r2, r3
    3f6c:	4a07      	ldr	r2, [pc, #28]	; (3f8c <main+0xc0>)
    3f6e:	6812      	ldr	r2, [r2, #0]
    3f70:	4611      	mov	r1, r2
    3f72:	4618      	mov	r0, r3
    3f74:	f007 fbdc 	bl	b730 <SDK_DelayAtLeastUs>
        
        // Check if we have recieved any commands via the serial port and act on them
        processCommands();
    3f78:	f7ff fed4 	bl	3d24 <_Z15processCommandsv>
            yield(); // For Multitasking arduino libraries including usb serial
    3f7c:	e7d9      	b.n	3f32 <main+0x66>
    3f7e:	bf00      	nop
    3f80:	1fff078c 	.word	0x1fff078c
    3f84:	0000e800 	.word	0x0000e800
    3f88:	0000ec24 	.word	0x0000ec24
    3f8c:	1fff0768 	.word	0x1fff0768
    3f90:	005b8d80 	.word	0x005b8d80
    3f94:	400ff080 	.word	0x400ff080
    3f98:	1fff0730 	.word	0x1fff0730
    3f9c:	1fff0ac8 	.word	0x1fff0ac8
    3fa0:	1fff0770 	.word	0x1fff0770
    3fa4:	1fff0734 	.word	0x1fff0734

00003fa8 <setup>:

    return 0;
}

void setup()
{
    3fa8:	b580      	push	{r7, lr}
    3faa:	b084      	sub	sp, #16
    3fac:	af04      	add	r7, sp, #16
    Serial.begin(500000); // Does nothing over USB.
    3fae:	4936      	ldr	r1, [pc, #216]	; (4088 <setup+0xe0>)
    3fb0:	4836      	ldr	r0, [pc, #216]	; (408c <setup+0xe4>)
    3fb2:	f7fc fb68 	bl	686 <_ZN16usb_serial_class5beginEl>
    Serial.setTimeout(1000); // sets the maximum number of milliseconds to wait for an input
    3fb6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    3fba:	4834      	ldr	r0, [pc, #208]	; (408c <setup+0xe4>)
    3fbc:	f001 fa70 	bl	54a0 <_ZN6Stream10setTimeoutEm>

    init_clocks();
    3fc0:	f7fc ff54 	bl	e6c <_Z11init_clocksv>
    // init_systick();
    init_board();
    3fc4:	f7fc fe22 	bl	c0c <_Z10init_boardv>

    // Setup ADC with DMA
    init_edma();
    3fc8:	f7fc ff9a 	bl	f00 <_Z9init_edmav>
    init_dmamux();
    3fcc:	f7fc ffc8 	bl	f60 <_Z11init_dmamuxv>
    init_adc16();
    3fd0:	f7fc ffd8 	bl	f84 <_Z10init_adc16v>

    // Setup PDB triggered DAC
    init_pdb();
    3fd4:	f7fd f812 	bl	ffc <_Z8init_pdbv>
    init_dac();
    3fd8:	f7fd f84c 	bl	1074 <_Z8init_dacv>
    
    // Initalise the Muxes
    driveSourceMux.init();
    3fdc:	482c      	ldr	r0, [pc, #176]	; (4090 <setup+0xe8>)
    3fde:	f006 f87d 	bl	a0dc <_ZN6ADG7324initEv>
    driveGroundMux.init();
    3fe2:	482c      	ldr	r0, [pc, #176]	; (4094 <setup+0xec>)
    3fe4:	f006 f87a 	bl	a0dc <_ZN6ADG7324initEv>
    senseAMux.init();
    3fe8:	482b      	ldr	r0, [pc, #172]	; (4098 <setup+0xf0>)
    3fea:	f006 f877 	bl	a0dc <_ZN6ADG7324initEv>
    senseBMux.init();
    3fee:	482b      	ldr	r0, [pc, #172]	; (409c <setup+0xf4>)
    3ff0:	f006 f874 	bl	a0dc <_ZN6ADG7324initEv>

    // Initalise the digipots
    inputAmpGainResistor.init();
    3ff4:	482a      	ldr	r0, [pc, #168]	; (40a0 <setup+0xf8>)
    3ff6:	f006 fa75 	bl	a4e4 <_ZN6AD52624initEv>
    inputAmpGainResistor.setResistance(AD5262::Channels::RDAC1, g_iInputGainResistor1_ohms);
    3ffa:	4b2a      	ldr	r3, [pc, #168]	; (40a4 <setup+0xfc>)
    3ffc:	681b      	ldr	r3, [r3, #0]
    3ffe:	461a      	mov	r2, r3
    4000:	2100      	movs	r1, #0
    4002:	4827      	ldr	r0, [pc, #156]	; (40a0 <setup+0xf8>)
    4004:	f006 faca 	bl	a59c <_ZN6AD526213setResistanceENS_8Channels4TypeEm>
    inputAmpGainResistor.setResistance(AD5262::Channels::RDAC2, g_iInputGainResistor2_ohms);
    4008:	4b27      	ldr	r3, [pc, #156]	; (40a8 <setup+0x100>)
    400a:	681b      	ldr	r3, [r3, #0]
    400c:	461a      	mov	r2, r3
    400e:	2101      	movs	r1, #1
    4010:	4823      	ldr	r0, [pc, #140]	; (40a0 <setup+0xf8>)
    4012:	f006 fac3 	bl	a59c <_ZN6AD526213setResistanceENS_8Channels4TypeEm>

    howlandShuntResistor.init();
    4016:	4825      	ldr	r0, [pc, #148]	; (40ac <setup+0x104>)
    4018:	f006 fa64 	bl	a4e4 <_ZN6AD52624initEv>
    howlandShuntResistor.setResistance(AD5262::Channels::RDAC1, g_iOutputGainResistor_ohms);
    401c:	4b24      	ldr	r3, [pc, #144]	; (40b0 <setup+0x108>)
    401e:	681b      	ldr	r3, [r3, #0]
    4020:	461a      	mov	r2, r3
    4022:	2100      	movs	r1, #0
    4024:	4821      	ldr	r0, [pc, #132]	; (40ac <setup+0x104>)
    4026:	f006 fab9 	bl	a59c <_ZN6AD526213setResistanceENS_8Channels4TypeEm>

    // Initalise the Waveform Generator
    waveformGenerator.init();
    402a:	4822      	ldr	r0, [pc, #136]	; (40b4 <setup+0x10c>)
    402c:	f006 fbfa 	bl	a824 <_ZN6AD98334initEv>
    waveformGenerator.setReset();
    4030:	4820      	ldr	r0, [pc, #128]	; (40b4 <setup+0x10c>)
    4032:	f006 fdc7 	bl	abc4 <_ZN6AD98338setResetEv>
    waveformGenerator.setFrequency(AD9833::FrequencyRegisters::FREQ0, g_fTarget_frequency);
    4036:	4b20      	ldr	r3, [pc, #128]	; (40b8 <setup+0x110>)
    4038:	681b      	ldr	r3, [r3, #0]
    403a:	4618      	mov	r0, r3
    403c:	f009 fc8a 	bl	d954 <__aeabi_f2d>
    4040:	4602      	mov	r2, r0
    4042:	460b      	mov	r3, r1
    4044:	ec43 2b10 	vmov	d0, r2, r3
    4048:	2100      	movs	r1, #0
    404a:	481a      	ldr	r0, [pc, #104]	; (40b4 <setup+0x10c>)
    404c:	f006 fc48 	bl	a8e0 <_ZN6AD983312setFrequencyENS_18FrequencyRegisters4TypeEd>
    waveformGenerator.setPhase(AD9833::PhaseRegisters::PHASE0, 0);
    4050:	ed9f 0a1a 	vldr	s0, [pc, #104]	; 40bc <setup+0x114>
    4054:	2100      	movs	r1, #0
    4056:	4817      	ldr	r0, [pc, #92]	; (40b4 <setup+0x10c>)
    4058:	f006 fcce 	bl	a9f8 <_ZN6AD98338setPhaseENS_14PhaseRegisters4TypeEf>
    waveformGenerator.setControl();
    405c:	2300      	movs	r3, #0
    405e:	9302      	str	r3, [sp, #8]
    4060:	2300      	movs	r3, #0
    4062:	9301      	str	r3, [sp, #4]
    4064:	2300      	movs	r3, #0
    4066:	9300      	str	r3, [sp, #0]
    4068:	2302      	movs	r3, #2
    406a:	2200      	movs	r2, #0
    406c:	2100      	movs	r1, #0
    406e:	4811      	ldr	r0, [pc, #68]	; (40b4 <setup+0x10c>)
    4070:	f006 fd36 	bl	aae0 <_ZN6AD983310setControlENS_18FrequencyRegisters4TypeENS_14PhaseRegisters4TypeENS_10WriteModes4TypeENS_10SleepModes4TypeENS_11OutputModes4TypeEb>

    // Start DAC
    DAC_SetBufferReadPointer(DAC_base, 0U);
    4074:	2100      	movs	r1, #0
    4076:	4812      	ldr	r0, [pc, #72]	; (40c0 <setup+0x118>)
    4078:	f005 ff0e 	bl	9e98 <DAC_SetBufferReadPointer>
    PDB_DoSoftwareTrigger(PDB_base);
    407c:	4811      	ldr	r0, [pc, #68]	; (40c4 <setup+0x11c>)
    407e:	f7fc fd1b 	bl	ab8 <PDB_DoSoftwareTrigger>
}
    4082:	bf00      	nop
    4084:	46bd      	mov	sp, r7
    4086:	bd80      	pop	{r7, pc}
    4088:	0007a120 	.word	0x0007a120
    408c:	1fff078c 	.word	0x1fff078c
    4090:	1fff098c 	.word	0x1fff098c
    4094:	1fff09ec 	.word	0x1fff09ec
    4098:	1fff08cc 	.word	0x1fff08cc
    409c:	1fff092c 	.word	0x1fff092c
    40a0:	1fff0a74 	.word	0x1fff0a74
    40a4:	1fff0740 	.word	0x1fff0740
    40a8:	1fff0744 	.word	0x1fff0744
    40ac:	1fff0a4c 	.word	0x1fff0a4c
    40b0:	1fff0748 	.word	0x1fff0748
    40b4:	1fff0a9c 	.word	0x1fff0a9c
    40b8:	1fff0ad0 	.word	0x1fff0ad0
    40bc:	00000000 	.word	0x00000000
    40c0:	400cc000 	.word	0x400cc000
    40c4:	40036000 	.word	0x40036000

000040c8 <dma_ch0_isr>:


#ifdef ARDUINO
extern "C" void DMA0_DMA16_DriverIRQHandler(void);
extern "C" void  __attribute__((interrupt("IRQ"))) dma_ch0_isr(void)
{
    40c8:	4668      	mov	r0, sp
    40ca:	f020 0107 	bic.w	r1, r0, #7
    40ce:	468d      	mov	sp, r1
    40d0:	b589      	push	{r0, r3, r7, lr}
    40d2:	af00      	add	r7, sp, #0
    DMA0_DMA16_DriverIRQHandler();
    40d4:	f005 fc6c 	bl	99b0 <DMA0_DMA16_DriverIRQHandler>
}
    40d8:	bf00      	nop
    40da:	46bd      	mov	sp, r7
    40dc:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    40e0:	4685      	mov	sp, r0
    40e2:	4770      	bx	lr

000040e4 <_ZL13Edma_CallbackP12_edma_handlePvbm>:
#endif

static void Edma_Callback(edma_handle_t *handle, void *userData, bool transferDone, uint32_t tcds)
{
    40e4:	b580      	push	{r7, lr}
    40e6:	b084      	sub	sp, #16
    40e8:	af00      	add	r7, sp, #0
    40ea:	60f8      	str	r0, [r7, #12]
    40ec:	60b9      	str	r1, [r7, #8]
    40ee:	603b      	str	r3, [r7, #0]
    40f0:	4613      	mov	r3, r2
    40f2:	71fb      	strb	r3, [r7, #7]
    /* Clear Edma interrupt flag. */
    ADC16_EnableDMA(ADC_measure_base, false);
    40f4:	2100      	movs	r1, #0
    40f6:	4807      	ldr	r0, [pc, #28]	; (4114 <_ZL13Edma_CallbackP12_edma_handlePvbm+0x30>)
    40f8:	f7fc fc1d 	bl	936 <ADC16_EnableDMA>
    EDMA_ClearChannelStatusFlags(DMA0, ADC_measure_DMA_channel, kEDMA_InterruptFlag);
    40fc:	2204      	movs	r2, #4
    40fe:	2100      	movs	r1, #0
    4100:	4805      	ldr	r0, [pc, #20]	; (4118 <_ZL13Edma_CallbackP12_edma_handlePvbm+0x34>)
    4102:	f005 f8a3 	bl	924c <EDMA_ClearChannelStatusFlags>
    //ADC16_EnableHardwareTrigger(ADC_measure_base, false);
    //PDB_ClearADCPreTriggerStatusFlags(PDB_base,kPDB_ADCTriggerChannel0, kPDB_ADCPreTriggerChannel0ErrorFlag |kPDB_ADCPreTriggerChannel0Flag);
    g_bWaitForResults = false;
    4106:	4b05      	ldr	r3, [pc, #20]	; (411c <_ZL13Edma_CallbackP12_edma_handlePvbm+0x38>)
    4108:	2200      	movs	r2, #0
    410a:	701a      	strb	r2, [r3, #0]
}
    410c:	bf00      	nop
    410e:	3710      	adds	r7, #16
    4110:	46bd      	mov	sp, r7
    4112:	bd80      	pop	{r7, pc}
    4114:	4003b000 	.word	0x4003b000
    4118:	40008000 	.word	0x40008000
    411c:	1fff076c 	.word	0x1fff076c

00004120 <DAC0_IRQHandler>:
// Interrupt handlers. The driver library (MCUXpresso) registers these by their names.
#ifdef ARDUINO
void dac0_isr(void)		__attribute__ ((alias("DAC0_IRQHandler")));
#endif
extern "C" void __attribute__((interrupt("IRQ"))) DAC0_IRQHandler() 
{
    4120:	4668      	mov	r0, sp
    4122:	f020 0107 	bic.w	r1, r0, #7
    4126:	468d      	mov	sp, r1
    4128:	b589      	push	{r0, r3, r7, lr}
    412a:	af00      	add	r7, sp, #0
    // Trigger the ADC
    ADC16_SetChannelConfig(ADC_measure_base, ADC_measure_group, &ADC_sense_config);
    412c:	4a0c      	ldr	r2, [pc, #48]	; (4160 <DAC0_IRQHandler+0x40>)
    412e:	2100      	movs	r1, #0
    4130:	480c      	ldr	r0, [pc, #48]	; (4164 <DAC0_IRQHandler+0x44>)
    4132:	f004 fd2b 	bl	8b8c <ADC16_SetChannelConfig>
    DAC_ClearBufferStatusFlags(DAC_base, DAC_GetBufferStatusFlags(DAC_base));
    4136:	480c      	ldr	r0, [pc, #48]	; (4168 <DAC0_IRQHandler+0x48>)
    4138:	f005 ff0e 	bl	9f58 <DAC_GetBufferStatusFlags>
    413c:	4603      	mov	r3, r0
    413e:	4619      	mov	r1, r3
    4140:	4809      	ldr	r0, [pc, #36]	; (4168 <DAC0_IRQHandler+0x48>)
    4142:	f005 ff1a 	bl	9f7a <DAC_ClearBufferStatusFlags>
    DAC_DisableBufferInterrupts(DAC_base, kDAC_BufferWatermarkInterruptEnable);
    4146:	2104      	movs	r1, #4
    4148:	4807      	ldr	r0, [pc, #28]	; (4168 <DAC0_IRQHandler+0x48>)
    414a:	f005 fee9 	bl	9f20 <DAC_DisableBufferInterrupts>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    414e:	f3bf 8f4f 	dsb	sy
}
    4152:	bf00      	nop
    SDK_ISR_EXIT_BARRIER;
}
    4154:	bf00      	nop
    4156:	46bd      	mov	sp, r7
    4158:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    415c:	4685      	mov	sp, r0
    415e:	4770      	bx	lr
    4160:	0000f530 	.word	0x0000f530
    4164:	4003b000 	.word	0x4003b000
    4168:	400cc000 	.word	0x400cc000

0000416c <ADC0_IRQHandler>:
#ifdef ARDUINO
void adc0_isr(void)		__attribute__ ((alias("ADC0_IRQHandler")));
#endif
extern "C" void __attribute__((interrupt("IRQ"))) ADC0_IRQHandler() 
{
    416c:	4668      	mov	r0, sp
    416e:	f020 0107 	bic.w	r1, r0, #7
    4172:	468d      	mov	sp, r1
    4174:	b589      	push	{r0, r3, r7, lr}
    4176:	af00      	add	r7, sp, #0
    // This is used to measure the ADC sample time
    BOARD_ADCFLG_TOGGLE();    
    4178:	f44f 3100 	mov.w	r1, #131072	; 0x20000
    417c:	4804      	ldr	r0, [pc, #16]	; (4190 <ADC0_IRQHandler+0x24>)
    417e:	f7fc fba0 	bl	8c2 <GPIO_PortToggle>
}
    4182:	bf00      	nop
    4184:	46bd      	mov	sp, r7
    4186:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    418a:	4685      	mov	sp, r0
    418c:	4770      	bx	lr
    418e:	bf00      	nop
    4190:	400ff040 	.word	0x400ff040

00004194 <_Z19adc_collect_samplesPmh>:

void adc_collect_samples(uint32_t * sample_array, uint8_t samples)
{
    4194:	b580      	push	{r7, lr}
    4196:	b086      	sub	sp, #24
    4198:	af04      	add	r7, sp, #16
    419a:	6078      	str	r0, [r7, #4]
    419c:	460b      	mov	r3, r1
    419e:	70fb      	strb	r3, [r7, #3]
    g_bWaitForResults = true;
    41a0:	4b1c      	ldr	r3, [pc, #112]	; (4214 <_Z19adc_collect_samplesPmh+0x80>)
    41a2:	2201      	movs	r2, #1
    41a4:	701a      	strb	r2, [r3, #0]
        /* Setup transfer */
    EDMA_PrepareTransfer(&g_sTransferConfig, (void *) & (ADC_measure_base->R[0]), sizeof(ADC_measure_base->R[0]),
    41a6:	4b1c      	ldr	r3, [pc, #112]	; (4218 <_Z19adc_collect_samplesPmh+0x84>)
    41a8:	f103 0110 	add.w	r1, r3, #16
                         (void *)sample_array, sizeof(sample_array[0]), sizeof(ADC_measure_base->R[0]),
                         samples * sizeof(sample_array[0]), kEDMA_PeripheralToMemory);
    41ac:	78fb      	ldrb	r3, [r7, #3]
    41ae:	009b      	lsls	r3, r3, #2
    EDMA_PrepareTransfer(&g_sTransferConfig, (void *) & (ADC_measure_base->R[0]), sizeof(ADC_measure_base->R[0]),
    41b0:	2201      	movs	r2, #1
    41b2:	9203      	str	r2, [sp, #12]
    41b4:	9302      	str	r3, [sp, #8]
    41b6:	2304      	movs	r3, #4
    41b8:	9301      	str	r3, [sp, #4]
    41ba:	2304      	movs	r3, #4
    41bc:	9300      	str	r3, [sp, #0]
    41be:	687b      	ldr	r3, [r7, #4]
    41c0:	2204      	movs	r2, #4
    41c2:	4816      	ldr	r0, [pc, #88]	; (421c <_Z19adc_collect_samplesPmh+0x88>)
    41c4:	f005 fa6e 	bl	96a4 <EDMA_PrepareTransfer>
    //EDMA_SubmitTransfer(&g_hEDMA_Handle, &g_sTransferConfig);
    
    EDMA_SetTransferConfig(DMA0, ADC_measure_DMA_channel, &g_sTransferConfig, NULL);
    41c8:	2300      	movs	r3, #0
    41ca:	4a14      	ldr	r2, [pc, #80]	; (421c <_Z19adc_collect_samplesPmh+0x88>)
    41cc:	2100      	movs	r1, #0
    41ce:	4814      	ldr	r0, [pc, #80]	; (4220 <_Z19adc_collect_samplesPmh+0x8c>)
    41d0:	f004 feb0 	bl	8f34 <EDMA_SetTransferConfig>
    /* Enable transfer. */
    
    EDMA_StartTransfer(&g_hEDMA_Handle);
    41d4:	4813      	ldr	r0, [pc, #76]	; (4224 <_Z19adc_collect_samplesPmh+0x90>)
    41d6:	f005 fac3 	bl	9760 <EDMA_StartTransfer>
    ADC16_EnableDMA(ADC_measure_base, true);
    41da:	2101      	movs	r1, #1
    41dc:	480e      	ldr	r0, [pc, #56]	; (4218 <_Z19adc_collect_samplesPmh+0x84>)
    41de:	f7fc fbaa 	bl	936 <ADC16_EnableDMA>
    //ADC16_SetChannelConfig(ADC_measure_base, ADC_measure_group, &ADC_sense_config);
    DAC_ClearBufferStatusFlags(DAC_base, DAC_GetBufferStatusFlags(DAC_base));
    41e2:	4811      	ldr	r0, [pc, #68]	; (4228 <_Z19adc_collect_samplesPmh+0x94>)
    41e4:	f005 feb8 	bl	9f58 <DAC_GetBufferStatusFlags>
    41e8:	4603      	mov	r3, r0
    41ea:	4619      	mov	r1, r3
    41ec:	480e      	ldr	r0, [pc, #56]	; (4228 <_Z19adc_collect_samplesPmh+0x94>)
    41ee:	f005 fec4 	bl	9f7a <DAC_ClearBufferStatusFlags>
    DAC_EnableBufferInterrupts(DAC_base, kDAC_BufferWatermarkInterruptEnable);
    41f2:	2104      	movs	r1, #4
    41f4:	480c      	ldr	r0, [pc, #48]	; (4228 <_Z19adc_collect_samplesPmh+0x94>)
    41f6:	f005 fe79 	bl	9eec <DAC_EnableBufferInterrupts>

    // The ADC read is started by the DAC watermark interrupt, this keeps the ADC read synchronized with the DAC
    // g_bWaitForResults is cleared when the DMA ADC read is complete
    for (;g_bWaitForResults;) __NOP(); 
    41fa:	e000      	b.n	41fe <_Z19adc_collect_samplesPmh+0x6a>
    41fc:	bf00      	nop
    41fe:	4b05      	ldr	r3, [pc, #20]	; (4214 <_Z19adc_collect_samplesPmh+0x80>)
    4200:	781b      	ldrb	r3, [r3, #0]
    4202:	b2db      	uxtb	r3, r3
    4204:	2b00      	cmp	r3, #0
    4206:	d1f9      	bne.n	41fc <_Z19adc_collect_samplesPmh+0x68>
}
    4208:	bf00      	nop
    420a:	bf00      	nop
    420c:	3708      	adds	r7, #8
    420e:	46bd      	mov	sp, r7
    4210:	bd80      	pop	{r7, pc}
    4212:	bf00      	nop
    4214:	1fff076c 	.word	0x1fff076c
    4218:	4003b000 	.word	0x4003b000
    421c:	1fff12dc 	.word	0x1fff12dc
    4220:	40008000 	.word	0x40008000
    4224:	1fff12c4 	.word	0x1fff12c4
    4228:	400cc000 	.word	0x400cc000

0000422c <_Z21recalulatePeripheralsv>:


void recalulatePeripherals()
{
    422c:	b580      	push	{r7, lr}
    422e:	af00      	add	r7, sp, #0
    // set the digibots
    inputAmpGainResistor.init();
    4230:	4818      	ldr	r0, [pc, #96]	; (4294 <_Z21recalulatePeripheralsv+0x68>)
    4232:	f006 f957 	bl	a4e4 <_ZN6AD52624initEv>
    inputAmpGainResistor.setResistance(AD5262::Channels::RDAC1, g_iInputGainResistor1_ohms);
    4236:	4b18      	ldr	r3, [pc, #96]	; (4298 <_Z21recalulatePeripheralsv+0x6c>)
    4238:	681b      	ldr	r3, [r3, #0]
    423a:	461a      	mov	r2, r3
    423c:	2100      	movs	r1, #0
    423e:	4815      	ldr	r0, [pc, #84]	; (4294 <_Z21recalulatePeripheralsv+0x68>)
    4240:	f006 f9ac 	bl	a59c <_ZN6AD526213setResistanceENS_8Channels4TypeEm>
    inputAmpGainResistor.setResistance(AD5262::Channels::RDAC2, g_iInputGainResistor2_ohms);
    4244:	4b15      	ldr	r3, [pc, #84]	; (429c <_Z21recalulatePeripheralsv+0x70>)
    4246:	681b      	ldr	r3, [r3, #0]
    4248:	461a      	mov	r2, r3
    424a:	2101      	movs	r1, #1
    424c:	4811      	ldr	r0, [pc, #68]	; (4294 <_Z21recalulatePeripheralsv+0x68>)
    424e:	f006 f9a5 	bl	a59c <_ZN6AD526213setResistanceENS_8Channels4TypeEm>

    howlandShuntResistor.init();
    4252:	4813      	ldr	r0, [pc, #76]	; (42a0 <_Z21recalulatePeripheralsv+0x74>)
    4254:	f006 f946 	bl	a4e4 <_ZN6AD52624initEv>
    howlandShuntResistor.setResistance(AD5262::Channels::RDAC1, g_iOutputGainResistor_ohms);
    4258:	4b12      	ldr	r3, [pc, #72]	; (42a4 <_Z21recalulatePeripheralsv+0x78>)
    425a:	681b      	ldr	r3, [r3, #0]
    425c:	461a      	mov	r2, r3
    425e:	2100      	movs	r1, #0
    4260:	480f      	ldr	r0, [pc, #60]	; (42a0 <_Z21recalulatePeripheralsv+0x74>)
    4262:	f006 f99b 	bl	a59c <_ZN6AD526213setResistanceENS_8Channels4TypeEm>

    // Initalise the Waveform Generator
    waveformGenerator.init();
    4266:	4810      	ldr	r0, [pc, #64]	; (42a8 <_Z21recalulatePeripheralsv+0x7c>)
    4268:	f006 fadc 	bl	a824 <_ZN6AD98334initEv>
    waveformGenerator.setFrequency(AD9833::FrequencyRegisters::FREQ0, g_fTarget_frequency);
    426c:	4b0f      	ldr	r3, [pc, #60]	; (42ac <_Z21recalulatePeripheralsv+0x80>)
    426e:	681b      	ldr	r3, [r3, #0]
    4270:	4618      	mov	r0, r3
    4272:	f009 fb6f 	bl	d954 <__aeabi_f2d>
    4276:	4602      	mov	r2, r0
    4278:	460b      	mov	r3, r1
    427a:	ec43 2b10 	vmov	d0, r2, r3
    427e:	2100      	movs	r1, #0
    4280:	4809      	ldr	r0, [pc, #36]	; (42a8 <_Z21recalulatePeripheralsv+0x7c>)
    4282:	f006 fb2d 	bl	a8e0 <_ZN6AD983312setFrequencyENS_18FrequencyRegisters4TypeEd>

    // Set the DAC frequency
    init_dac();
    4286:	f7fc fef5 	bl	1074 <_Z8init_dacv>
    init_pdb();
    428a:	f7fc feb7 	bl	ffc <_Z8init_pdbv>
    428e:	bf00      	nop
    4290:	bd80      	pop	{r7, pc}
    4292:	bf00      	nop
    4294:	1fff0a74 	.word	0x1fff0a74
    4298:	1fff0740 	.word	0x1fff0740
    429c:	1fff0744 	.word	0x1fff0744
    42a0:	1fff0a4c 	.word	0x1fff0a4c
    42a4:	1fff0748 	.word	0x1fff0748
    42a8:	1fff0a9c 	.word	0x1fff0a9c
    42ac:	1fff0ad0 	.word	0x1fff0ad0

000042b0 <_ZSt3powIfiEN9__gnu_cxx11__promote_2IT_T0_NS0_9__promoteIS2_XsrSt12__is_integerIS2_E7__valueEE6__typeENS4_IS3_XsrS5_IS3_E7__valueEE6__typeEE6__typeES2_S3_>:
    pow(_Tp __x, _Up __y)
    42b0:	b5b0      	push	{r4, r5, r7, lr}
    42b2:	b082      	sub	sp, #8
    42b4:	af00      	add	r7, sp, #0
    42b6:	ed87 0a01 	vstr	s0, [r7, #4]
    42ba:	6038      	str	r0, [r7, #0]
      return pow(__type(__x), __type(__y));
    42bc:	6878      	ldr	r0, [r7, #4]
    42be:	f009 fb49 	bl	d954 <__aeabi_f2d>
    42c2:	4604      	mov	r4, r0
    42c4:	460d      	mov	r5, r1
    42c6:	6838      	ldr	r0, [r7, #0]
    42c8:	f009 fb32 	bl	d930 <__aeabi_i2d>
    42cc:	4602      	mov	r2, r0
    42ce:	460b      	mov	r3, r1
    42d0:	ec43 2b11 	vmov	d1, r2, r3
    42d4:	ec45 4b10 	vmov	d0, r4, r5
    42d8:	f007 fbf6 	bl	bac8 <pow>
    42dc:	eeb0 7a40 	vmov.f32	s14, s0
    42e0:	eef0 7a60 	vmov.f32	s15, s1
    }
    42e4:	eeb0 0a47 	vmov.f32	s0, s14
    42e8:	eef0 0a67 	vmov.f32	s1, s15
    42ec:	3708      	adds	r7, #8
    42ee:	46bd      	mov	sp, r7
    42f0:	bdb0      	pop	{r4, r5, r7, pc}

000042f2 <_Z5boundImET_S0_S0_S0_>:
T bound(T value, T min, T max) 
    42f2:	b480      	push	{r7}
    42f4:	b085      	sub	sp, #20
    42f6:	af00      	add	r7, sp, #0
    42f8:	60f8      	str	r0, [r7, #12]
    42fa:	60b9      	str	r1, [r7, #8]
    42fc:	607a      	str	r2, [r7, #4]
  return ( value < min ) ? min : ( ( value > max ) ? max : value ); 
    42fe:	68fa      	ldr	r2, [r7, #12]
    4300:	68bb      	ldr	r3, [r7, #8]
    4302:	429a      	cmp	r2, r3
    4304:	d307      	bcc.n	4316 <_Z5boundImET_S0_S0_S0_+0x24>
    4306:	68fa      	ldr	r2, [r7, #12]
    4308:	687b      	ldr	r3, [r7, #4]
    430a:	429a      	cmp	r2, r3
    430c:	d901      	bls.n	4312 <_Z5boundImET_S0_S0_S0_+0x20>
    430e:	687b      	ldr	r3, [r7, #4]
    4310:	e002      	b.n	4318 <_Z5boundImET_S0_S0_S0_+0x26>
    4312:	68fb      	ldr	r3, [r7, #12]
    4314:	e000      	b.n	4318 <_Z5boundImET_S0_S0_S0_+0x26>
    4316:	68bb      	ldr	r3, [r7, #8]
}
    4318:	4618      	mov	r0, r3
    431a:	3714      	adds	r7, #20
    431c:	46bd      	mov	sp, r7
    431e:	f85d 7b04 	ldr.w	r7, [sp], #4
    4322:	4770      	bx	lr

00004324 <_Z10getDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_RT0_>:
bool getDirectE(String const & name, String const & match, String const & match_to, Type & value)
    4324:	b580      	push	{r7, lr}
    4326:	b084      	sub	sp, #16
    4328:	af00      	add	r7, sp, #0
    432a:	60f8      	str	r0, [r7, #12]
    432c:	60b9      	str	r1, [r7, #8]
    432e:	607a      	str	r2, [r7, #4]
    4330:	603b      	str	r3, [r7, #0]
    if (match != match_to) return false;
    4332:	6879      	ldr	r1, [r7, #4]
    4334:	68b8      	ldr	r0, [r7, #8]
    4336:	f7fc f8e9 	bl	50c <_ZNK6StringneERKS_>
    433a:	4603      	mov	r3, r0
    433c:	2b00      	cmp	r3, #0
    433e:	bf14      	ite	ne
    4340:	2301      	movne	r3, #1
    4342:	2300      	moveq	r3, #0
    4344:	b2db      	uxtb	r3, r3
    4346:	2b00      	cmp	r3, #0
    4348:	d001      	beq.n	434e <_Z10getDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_RT0_+0x2a>
    434a:	2300      	movs	r3, #0
    434c:	e010      	b.n	4370 <_Z10getDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_RT0_+0x4c>
    SL(); LOG(name); LOG(": "); LOG(value); LOG("\r\n");
    434e:	f7fd ffb9 	bl	22c4 <_Z2SLv>
    4352:	68f8      	ldr	r0, [r7, #12]
    4354:	f7fd ff2c 	bl	21b0 <_Z3LOGRK6String>
    4358:	4807      	ldr	r0, [pc, #28]	; (4378 <_Z10getDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_RT0_+0x54>)
    435a:	f7fd ff1b 	bl	2194 <_Z3LOGPKc>
    435e:	683b      	ldr	r3, [r7, #0]
    4360:	781b      	ldrb	r3, [r3, #0]
    4362:	4618      	mov	r0, r3
    4364:	f7fd ff66 	bl	2234 <_Z3LOGN5Modes4TypeE>
    4368:	4804      	ldr	r0, [pc, #16]	; (437c <_Z10getDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_RT0_+0x58>)
    436a:	f7fd ff13 	bl	2194 <_Z3LOGPKc>
    return true;
    436e:	2301      	movs	r3, #1
}
    4370:	4618      	mov	r0, r3
    4372:	3710      	adds	r7, #16
    4374:	46bd      	mov	sp, r7
    4376:	bd80      	pop	{r7, pc}
    4378:	0000f0ec 	.word	0x0000f0ec
    437c:	0000efac 	.word	0x0000efac

00004380 <_Z10getDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_RT0_>:
bool getDirectE(String const & name, String const & match, String const & match_to, Type & value)
    4380:	b580      	push	{r7, lr}
    4382:	b084      	sub	sp, #16
    4384:	af00      	add	r7, sp, #0
    4386:	60f8      	str	r0, [r7, #12]
    4388:	60b9      	str	r1, [r7, #8]
    438a:	607a      	str	r2, [r7, #4]
    438c:	603b      	str	r3, [r7, #0]
    if (match != match_to) return false;
    438e:	6879      	ldr	r1, [r7, #4]
    4390:	68b8      	ldr	r0, [r7, #8]
    4392:	f7fc f8bb 	bl	50c <_ZNK6StringneERKS_>
    4396:	4603      	mov	r3, r0
    4398:	2b00      	cmp	r3, #0
    439a:	bf14      	ite	ne
    439c:	2301      	movne	r3, #1
    439e:	2300      	moveq	r3, #0
    43a0:	b2db      	uxtb	r3, r3
    43a2:	2b00      	cmp	r3, #0
    43a4:	d001      	beq.n	43aa <_Z10getDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_RT0_+0x2a>
    43a6:	2300      	movs	r3, #0
    43a8:	e010      	b.n	43cc <_Z10getDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_RT0_+0x4c>
    SL(); LOG(name); LOG(": "); LOG(value); LOG("\r\n");
    43aa:	f7fd ff8b 	bl	22c4 <_Z2SLv>
    43ae:	68f8      	ldr	r0, [r7, #12]
    43b0:	f7fd fefe 	bl	21b0 <_Z3LOGRK6String>
    43b4:	4807      	ldr	r0, [pc, #28]	; (43d4 <_Z10getDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_RT0_+0x54>)
    43b6:	f7fd feed 	bl	2194 <_Z3LOGPKc>
    43ba:	683b      	ldr	r3, [r7, #0]
    43bc:	781b      	ldrb	r3, [r3, #0]
    43be:	4618      	mov	r0, r3
    43c0:	f7fd ff5c 	bl	227c <_Z3LOGN8DACModes4TypeE>
    43c4:	4804      	ldr	r0, [pc, #16]	; (43d8 <_Z10getDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_RT0_+0x58>)
    43c6:	f7fd fee5 	bl	2194 <_Z3LOGPKc>
    return true;
    43ca:	2301      	movs	r3, #1
}
    43cc:	4618      	mov	r0, r3
    43ce:	3710      	adds	r7, #16
    43d0:	46bd      	mov	sp, r7
    43d2:	bd80      	pop	{r7, pc}
    43d4:	0000f0ec 	.word	0x0000f0ec
    43d8:	0000efac 	.word	0x0000efac

000043dc <_Z10setDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_>:
bool setDirectE(String const & name, String const & match, String const & match_to, String const & new_value, Type & value)
    43dc:	b580      	push	{r7, lr}
    43de:	b084      	sub	sp, #16
    43e0:	af00      	add	r7, sp, #0
    43e2:	60f8      	str	r0, [r7, #12]
    43e4:	60b9      	str	r1, [r7, #8]
    43e6:	607a      	str	r2, [r7, #4]
    43e8:	603b      	str	r3, [r7, #0]
    if (match != match_to) return false;
    43ea:	6879      	ldr	r1, [r7, #4]
    43ec:	68b8      	ldr	r0, [r7, #8]
    43ee:	f7fc f88d 	bl	50c <_ZNK6StringneERKS_>
    43f2:	4603      	mov	r3, r0
    43f4:	2b00      	cmp	r3, #0
    43f6:	bf14      	ite	ne
    43f8:	2301      	movne	r3, #1
    43fa:	2300      	moveq	r3, #0
    43fc:	b2db      	uxtb	r3, r3
    43fe:	2b00      	cmp	r3, #0
    4400:	d001      	beq.n	4406 <_Z10setDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_+0x2a>
    4402:	2300      	movs	r3, #0
    4404:	e021      	b.n	444a <_Z10setDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_+0x6e>
    value = (Type) bound<uint32_t>(atoi(new_value.c_str()), (uint32_t) Enum::_MIN, (uint32_t) Enum::_MAX);
    4406:	6838      	ldr	r0, [r7, #0]
    4408:	f7fc f8a6 	bl	558 <_ZNK6String5c_strEv>
    440c:	4603      	mov	r3, r0
    440e:	4618      	mov	r0, r3
    4410:	f009 ff96 	bl	e340 <atoi>
    4414:	4603      	mov	r3, r0
    4416:	2205      	movs	r2, #5
    4418:	2100      	movs	r1, #0
    441a:	4618      	mov	r0, r3
    441c:	f7ff ff69 	bl	42f2 <_Z5boundImET_S0_S0_S0_>
    4420:	4603      	mov	r3, r0
    4422:	b2da      	uxtb	r2, r3
    4424:	69bb      	ldr	r3, [r7, #24]
    4426:	701a      	strb	r2, [r3, #0]
    SL(); LOG(name); LOG(": "); LOG(value); LOG("\r\n");
    4428:	f7fd ff4c 	bl	22c4 <_Z2SLv>
    442c:	68f8      	ldr	r0, [r7, #12]
    442e:	f7fd febf 	bl	21b0 <_Z3LOGRK6String>
    4432:	4808      	ldr	r0, [pc, #32]	; (4454 <_Z10setDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_+0x78>)
    4434:	f7fd feae 	bl	2194 <_Z3LOGPKc>
    4438:	69bb      	ldr	r3, [r7, #24]
    443a:	781b      	ldrb	r3, [r3, #0]
    443c:	4618      	mov	r0, r3
    443e:	f7fd fef9 	bl	2234 <_Z3LOGN5Modes4TypeE>
    4442:	4805      	ldr	r0, [pc, #20]	; (4458 <_Z10setDirectEI5ModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_+0x7c>)
    4444:	f7fd fea6 	bl	2194 <_Z3LOGPKc>
    return true;
    4448:	2301      	movs	r3, #1
}
    444a:	4618      	mov	r0, r3
    444c:	3710      	adds	r7, #16
    444e:	46bd      	mov	sp, r7
    4450:	bd80      	pop	{r7, pc}
    4452:	bf00      	nop
    4454:	0000f0ec 	.word	0x0000f0ec
    4458:	0000efac 	.word	0x0000efac

0000445c <_Z10setDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_>:
bool setDirectE(String const & name, String const & match, String const & match_to, String const & new_value, Type & value)
    445c:	b580      	push	{r7, lr}
    445e:	b084      	sub	sp, #16
    4460:	af00      	add	r7, sp, #0
    4462:	60f8      	str	r0, [r7, #12]
    4464:	60b9      	str	r1, [r7, #8]
    4466:	607a      	str	r2, [r7, #4]
    4468:	603b      	str	r3, [r7, #0]
    if (match != match_to) return false;
    446a:	6879      	ldr	r1, [r7, #4]
    446c:	68b8      	ldr	r0, [r7, #8]
    446e:	f7fc f84d 	bl	50c <_ZNK6StringneERKS_>
    4472:	4603      	mov	r3, r0
    4474:	2b00      	cmp	r3, #0
    4476:	bf14      	ite	ne
    4478:	2301      	movne	r3, #1
    447a:	2300      	moveq	r3, #0
    447c:	b2db      	uxtb	r3, r3
    447e:	2b00      	cmp	r3, #0
    4480:	d001      	beq.n	4486 <_Z10setDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_+0x2a>
    4482:	2300      	movs	r3, #0
    4484:	e021      	b.n	44ca <_Z10setDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_+0x6e>
    value = (Type) bound<uint32_t>(atoi(new_value.c_str()), (uint32_t) Enum::_MIN, (uint32_t) Enum::_MAX);
    4486:	6838      	ldr	r0, [r7, #0]
    4488:	f7fc f866 	bl	558 <_ZNK6String5c_strEv>
    448c:	4603      	mov	r3, r0
    448e:	4618      	mov	r0, r3
    4490:	f009 ff56 	bl	e340 <atoi>
    4494:	4603      	mov	r3, r0
    4496:	2201      	movs	r2, #1
    4498:	2100      	movs	r1, #0
    449a:	4618      	mov	r0, r3
    449c:	f7ff ff29 	bl	42f2 <_Z5boundImET_S0_S0_S0_>
    44a0:	4603      	mov	r3, r0
    44a2:	b2da      	uxtb	r2, r3
    44a4:	69bb      	ldr	r3, [r7, #24]
    44a6:	701a      	strb	r2, [r3, #0]
    SL(); LOG(name); LOG(": "); LOG(value); LOG("\r\n");
    44a8:	f7fd ff0c 	bl	22c4 <_Z2SLv>
    44ac:	68f8      	ldr	r0, [r7, #12]
    44ae:	f7fd fe7f 	bl	21b0 <_Z3LOGRK6String>
    44b2:	4808      	ldr	r0, [pc, #32]	; (44d4 <_Z10setDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_+0x78>)
    44b4:	f7fd fe6e 	bl	2194 <_Z3LOGPKc>
    44b8:	69bb      	ldr	r3, [r7, #24]
    44ba:	781b      	ldrb	r3, [r3, #0]
    44bc:	4618      	mov	r0, r3
    44be:	f7fd fedd 	bl	227c <_Z3LOGN8DACModes4TypeE>
    44c2:	4805      	ldr	r0, [pc, #20]	; (44d8 <_Z10setDirectEI8DACModesNS0_4TypeEEbRK6StringS4_S4_S4_RT0_+0x7c>)
    44c4:	f7fd fe66 	bl	2194 <_Z3LOGPKc>
    return true;
    44c8:	2301      	movs	r3, #1
}
    44ca:	4618      	mov	r0, r3
    44cc:	3710      	adds	r7, #16
    44ce:	46bd      	mov	sp, r7
    44d0:	bd80      	pop	{r7, pc}
    44d2:	bf00      	nop
    44d4:	0000f0ec 	.word	0x0000f0ec
    44d8:	0000efac 	.word	0x0000efac

000044dc <_Z41__static_initialization_and_destruction_0ii>:
    44dc:	b580      	push	{r7, lr}
    44de:	b098      	sub	sp, #96	; 0x60
    44e0:	af16      	add	r7, sp, #88	; 0x58
    44e2:	6078      	str	r0, [r7, #4]
    44e4:	6039      	str	r1, [r7, #0]
    44e6:	687b      	ldr	r3, [r7, #4]
    44e8:	2b01      	cmp	r3, #1
    44ea:	f040 81a1 	bne.w	4830 <_Z41__static_initialization_and_destruction_0ii+0x354>
    44ee:	683b      	ldr	r3, [r7, #0]
    44f0:	f64f 72ff 	movw	r2, #65535	; 0xffff
    44f4:	4293      	cmp	r3, r2
    44f6:	f040 819b 	bne.w	4830 <_Z41__static_initialization_and_destruction_0ii+0x354>
);
    44fa:	2310      	movs	r3, #16
    44fc:	9314      	str	r3, [sp, #80]	; 0x50
    44fe:	4b96      	ldr	r3, [pc, #600]	; (4758 <_Z41__static_initialization_and_destruction_0ii+0x27c>)
    4500:	9313      	str	r3, [sp, #76]	; 0x4c
    4502:	4b96      	ldr	r3, [pc, #600]	; (475c <_Z41__static_initialization_and_destruction_0ii+0x280>)
    4504:	9312      	str	r3, [sp, #72]	; 0x48
    4506:	2301      	movs	r3, #1
    4508:	9311      	str	r3, [sp, #68]	; 0x44
    450a:	4b95      	ldr	r3, [pc, #596]	; (4760 <_Z41__static_initialization_and_destruction_0ii+0x284>)
    450c:	9310      	str	r3, [sp, #64]	; 0x40
    450e:	4b95      	ldr	r3, [pc, #596]	; (4764 <_Z41__static_initialization_and_destruction_0ii+0x288>)
    4510:	930f      	str	r3, [sp, #60]	; 0x3c
    4512:	2301      	movs	r3, #1
    4514:	930e      	str	r3, [sp, #56]	; 0x38
    4516:	4b92      	ldr	r3, [pc, #584]	; (4760 <_Z41__static_initialization_and_destruction_0ii+0x284>)
    4518:	930d      	str	r3, [sp, #52]	; 0x34
    451a:	4b92      	ldr	r3, [pc, #584]	; (4764 <_Z41__static_initialization_and_destruction_0ii+0x288>)
    451c:	930c      	str	r3, [sp, #48]	; 0x30
    451e:	2310      	movs	r3, #16
    4520:	930b      	str	r3, [sp, #44]	; 0x2c
    4522:	4b91      	ldr	r3, [pc, #580]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    4524:	930a      	str	r3, [sp, #40]	; 0x28
    4526:	4b91      	ldr	r3, [pc, #580]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    4528:	9309      	str	r3, [sp, #36]	; 0x24
    452a:	230f      	movs	r3, #15
    452c:	9308      	str	r3, [sp, #32]
    452e:	4b8e      	ldr	r3, [pc, #568]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    4530:	9307      	str	r3, [sp, #28]
    4532:	4b8e      	ldr	r3, [pc, #568]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    4534:	9306      	str	r3, [sp, #24]
    4536:	230e      	movs	r3, #14
    4538:	9305      	str	r3, [sp, #20]
    453a:	4b8b      	ldr	r3, [pc, #556]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    453c:	9304      	str	r3, [sp, #16]
    453e:	4b8b      	ldr	r3, [pc, #556]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    4540:	9303      	str	r3, [sp, #12]
    4542:	2305      	movs	r3, #5
    4544:	9302      	str	r3, [sp, #8]
    4546:	4b88      	ldr	r3, [pc, #544]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    4548:	9301      	str	r3, [sp, #4]
    454a:	4b88      	ldr	r3, [pc, #544]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    454c:	9300      	str	r3, [sp, #0]
    454e:	231a      	movs	r3, #26
    4550:	4a87      	ldr	r2, [pc, #540]	; (4770 <_Z41__static_initialization_and_destruction_0ii+0x294>)
    4552:	4988      	ldr	r1, [pc, #544]	; (4774 <_Z41__static_initialization_and_destruction_0ii+0x298>)
    4554:	4888      	ldr	r0, [pc, #544]	; (4778 <_Z41__static_initialization_and_destruction_0ii+0x29c>)
    4556:	f005 fd6b 	bl	a030 <_ZN6ADG732C1EP9PORT_TypeP9GPIO_TypemS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_m>
);
    455a:	2310      	movs	r3, #16
    455c:	9314      	str	r3, [sp, #80]	; 0x50
    455e:	4b7e      	ldr	r3, [pc, #504]	; (4758 <_Z41__static_initialization_and_destruction_0ii+0x27c>)
    4560:	9313      	str	r3, [sp, #76]	; 0x4c
    4562:	4b7e      	ldr	r3, [pc, #504]	; (475c <_Z41__static_initialization_and_destruction_0ii+0x280>)
    4564:	9312      	str	r3, [sp, #72]	; 0x48
    4566:	2305      	movs	r3, #5
    4568:	9311      	str	r3, [sp, #68]	; 0x44
    456a:	4b84      	ldr	r3, [pc, #528]	; (477c <_Z41__static_initialization_and_destruction_0ii+0x2a0>)
    456c:	9310      	str	r3, [sp, #64]	; 0x40
    456e:	4b84      	ldr	r3, [pc, #528]	; (4780 <_Z41__static_initialization_and_destruction_0ii+0x2a4>)
    4570:	930f      	str	r3, [sp, #60]	; 0x3c
    4572:	2305      	movs	r3, #5
    4574:	930e      	str	r3, [sp, #56]	; 0x38
    4576:	4b81      	ldr	r3, [pc, #516]	; (477c <_Z41__static_initialization_and_destruction_0ii+0x2a0>)
    4578:	930d      	str	r3, [sp, #52]	; 0x34
    457a:	4b81      	ldr	r3, [pc, #516]	; (4780 <_Z41__static_initialization_and_destruction_0ii+0x2a4>)
    457c:	930c      	str	r3, [sp, #48]	; 0x30
    457e:	2310      	movs	r3, #16
    4580:	930b      	str	r3, [sp, #44]	; 0x2c
    4582:	4b79      	ldr	r3, [pc, #484]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    4584:	930a      	str	r3, [sp, #40]	; 0x28
    4586:	4b79      	ldr	r3, [pc, #484]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    4588:	9309      	str	r3, [sp, #36]	; 0x24
    458a:	230f      	movs	r3, #15
    458c:	9308      	str	r3, [sp, #32]
    458e:	4b76      	ldr	r3, [pc, #472]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    4590:	9307      	str	r3, [sp, #28]
    4592:	4b76      	ldr	r3, [pc, #472]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    4594:	9306      	str	r3, [sp, #24]
    4596:	230e      	movs	r3, #14
    4598:	9305      	str	r3, [sp, #20]
    459a:	4b73      	ldr	r3, [pc, #460]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    459c:	9304      	str	r3, [sp, #16]
    459e:	4b73      	ldr	r3, [pc, #460]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    45a0:	9303      	str	r3, [sp, #12]
    45a2:	2305      	movs	r3, #5
    45a4:	9302      	str	r3, [sp, #8]
    45a6:	4b70      	ldr	r3, [pc, #448]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    45a8:	9301      	str	r3, [sp, #4]
    45aa:	4b70      	ldr	r3, [pc, #448]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    45ac:	9300      	str	r3, [sp, #0]
    45ae:	231a      	movs	r3, #26
    45b0:	4a6f      	ldr	r2, [pc, #444]	; (4770 <_Z41__static_initialization_and_destruction_0ii+0x294>)
    45b2:	4970      	ldr	r1, [pc, #448]	; (4774 <_Z41__static_initialization_and_destruction_0ii+0x298>)
    45b4:	4873      	ldr	r0, [pc, #460]	; (4784 <_Z41__static_initialization_and_destruction_0ii+0x2a8>)
    45b6:	f005 fd3b 	bl	a030 <_ZN6ADG732C1EP9PORT_TypeP9GPIO_TypemS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_m>
);
    45ba:	2318      	movs	r3, #24
    45bc:	9314      	str	r3, [sp, #80]	; 0x50
    45be:	4b6c      	ldr	r3, [pc, #432]	; (4770 <_Z41__static_initialization_and_destruction_0ii+0x294>)
    45c0:	9313      	str	r3, [sp, #76]	; 0x4c
    45c2:	4b6c      	ldr	r3, [pc, #432]	; (4774 <_Z41__static_initialization_and_destruction_0ii+0x298>)
    45c4:	9312      	str	r3, [sp, #72]	; 0x48
    45c6:	2302      	movs	r3, #2
    45c8:	9311      	str	r3, [sp, #68]	; 0x44
    45ca:	4b6c      	ldr	r3, [pc, #432]	; (477c <_Z41__static_initialization_and_destruction_0ii+0x2a0>)
    45cc:	9310      	str	r3, [sp, #64]	; 0x40
    45ce:	4b6c      	ldr	r3, [pc, #432]	; (4780 <_Z41__static_initialization_and_destruction_0ii+0x2a4>)
    45d0:	930f      	str	r3, [sp, #60]	; 0x3c
    45d2:	2302      	movs	r3, #2
    45d4:	930e      	str	r3, [sp, #56]	; 0x38
    45d6:	4b69      	ldr	r3, [pc, #420]	; (477c <_Z41__static_initialization_and_destruction_0ii+0x2a0>)
    45d8:	930d      	str	r3, [sp, #52]	; 0x34
    45da:	4b69      	ldr	r3, [pc, #420]	; (4780 <_Z41__static_initialization_and_destruction_0ii+0x2a4>)
    45dc:	930c      	str	r3, [sp, #48]	; 0x30
    45de:	2310      	movs	r3, #16
    45e0:	930b      	str	r3, [sp, #44]	; 0x2c
    45e2:	4b61      	ldr	r3, [pc, #388]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    45e4:	930a      	str	r3, [sp, #40]	; 0x28
    45e6:	4b61      	ldr	r3, [pc, #388]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    45e8:	9309      	str	r3, [sp, #36]	; 0x24
    45ea:	230f      	movs	r3, #15
    45ec:	9308      	str	r3, [sp, #32]
    45ee:	4b5e      	ldr	r3, [pc, #376]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    45f0:	9307      	str	r3, [sp, #28]
    45f2:	4b5e      	ldr	r3, [pc, #376]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    45f4:	9306      	str	r3, [sp, #24]
    45f6:	230e      	movs	r3, #14
    45f8:	9305      	str	r3, [sp, #20]
    45fa:	4b5b      	ldr	r3, [pc, #364]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    45fc:	9304      	str	r3, [sp, #16]
    45fe:	4b5b      	ldr	r3, [pc, #364]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    4600:	9303      	str	r3, [sp, #12]
    4602:	2305      	movs	r3, #5
    4604:	9302      	str	r3, [sp, #8]
    4606:	4b58      	ldr	r3, [pc, #352]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    4608:	9301      	str	r3, [sp, #4]
    460a:	4b58      	ldr	r3, [pc, #352]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    460c:	9300      	str	r3, [sp, #0]
    460e:	231a      	movs	r3, #26
    4610:	4a57      	ldr	r2, [pc, #348]	; (4770 <_Z41__static_initialization_and_destruction_0ii+0x294>)
    4612:	4958      	ldr	r1, [pc, #352]	; (4774 <_Z41__static_initialization_and_destruction_0ii+0x298>)
    4614:	485c      	ldr	r0, [pc, #368]	; (4788 <_Z41__static_initialization_and_destruction_0ii+0x2ac>)
    4616:	f005 fd0b 	bl	a030 <_ZN6ADG732C1EP9PORT_TypeP9GPIO_TypemS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_m>
);
    461a:	2318      	movs	r3, #24
    461c:	9314      	str	r3, [sp, #80]	; 0x50
    461e:	4b54      	ldr	r3, [pc, #336]	; (4770 <_Z41__static_initialization_and_destruction_0ii+0x294>)
    4620:	9313      	str	r3, [sp, #76]	; 0x4c
    4622:	4b54      	ldr	r3, [pc, #336]	; (4774 <_Z41__static_initialization_and_destruction_0ii+0x298>)
    4624:	9312      	str	r3, [sp, #72]	; 0x48
    4626:	2303      	movs	r3, #3
    4628:	9311      	str	r3, [sp, #68]	; 0x44
    462a:	4b54      	ldr	r3, [pc, #336]	; (477c <_Z41__static_initialization_and_destruction_0ii+0x2a0>)
    462c:	9310      	str	r3, [sp, #64]	; 0x40
    462e:	4b54      	ldr	r3, [pc, #336]	; (4780 <_Z41__static_initialization_and_destruction_0ii+0x2a4>)
    4630:	930f      	str	r3, [sp, #60]	; 0x3c
    4632:	2303      	movs	r3, #3
    4634:	930e      	str	r3, [sp, #56]	; 0x38
    4636:	4b51      	ldr	r3, [pc, #324]	; (477c <_Z41__static_initialization_and_destruction_0ii+0x2a0>)
    4638:	930d      	str	r3, [sp, #52]	; 0x34
    463a:	4b51      	ldr	r3, [pc, #324]	; (4780 <_Z41__static_initialization_and_destruction_0ii+0x2a4>)
    463c:	930c      	str	r3, [sp, #48]	; 0x30
    463e:	2310      	movs	r3, #16
    4640:	930b      	str	r3, [sp, #44]	; 0x2c
    4642:	4b49      	ldr	r3, [pc, #292]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    4644:	930a      	str	r3, [sp, #40]	; 0x28
    4646:	4b49      	ldr	r3, [pc, #292]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    4648:	9309      	str	r3, [sp, #36]	; 0x24
    464a:	230f      	movs	r3, #15
    464c:	9308      	str	r3, [sp, #32]
    464e:	4b46      	ldr	r3, [pc, #280]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    4650:	9307      	str	r3, [sp, #28]
    4652:	4b46      	ldr	r3, [pc, #280]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    4654:	9306      	str	r3, [sp, #24]
    4656:	230e      	movs	r3, #14
    4658:	9305      	str	r3, [sp, #20]
    465a:	4b43      	ldr	r3, [pc, #268]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    465c:	9304      	str	r3, [sp, #16]
    465e:	4b43      	ldr	r3, [pc, #268]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    4660:	9303      	str	r3, [sp, #12]
    4662:	2305      	movs	r3, #5
    4664:	9302      	str	r3, [sp, #8]
    4666:	4b40      	ldr	r3, [pc, #256]	; (4768 <_Z41__static_initialization_and_destruction_0ii+0x28c>)
    4668:	9301      	str	r3, [sp, #4]
    466a:	4b40      	ldr	r3, [pc, #256]	; (476c <_Z41__static_initialization_and_destruction_0ii+0x290>)
    466c:	9300      	str	r3, [sp, #0]
    466e:	231a      	movs	r3, #26
    4670:	4a3f      	ldr	r2, [pc, #252]	; (4770 <_Z41__static_initialization_and_destruction_0ii+0x294>)
    4672:	4940      	ldr	r1, [pc, #256]	; (4774 <_Z41__static_initialization_and_destruction_0ii+0x298>)
    4674:	4845      	ldr	r0, [pc, #276]	; (478c <_Z41__static_initialization_and_destruction_0ii+0x2b0>)
    4676:	f005 fcdb 	bl	a030 <_ZN6ADG732C1EP9PORT_TypeP9GPIO_TypemS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_m>
                            50000);
    467a:	f24c 3350 	movw	r3, #50000	; 0xc350
    467e:	9309      	str	r3, [sp, #36]	; 0x24
    4680:	2302      	movs	r3, #2
    4682:	9308      	str	r3, [sp, #32]
    4684:	2300      	movs	r3, #0
    4686:	9307      	str	r3, [sp, #28]
    4688:	4b36      	ldr	r3, [pc, #216]	; (4764 <_Z41__static_initialization_and_destruction_0ii+0x288>)
    468a:	9306      	str	r3, [sp, #24]
    468c:	2302      	movs	r3, #2
    468e:	9305      	str	r3, [sp, #20]
    4690:	2301      	movs	r3, #1
    4692:	9304      	str	r3, [sp, #16]
    4694:	4b3a      	ldr	r3, [pc, #232]	; (4780 <_Z41__static_initialization_and_destruction_0ii+0x2a4>)
    4696:	9303      	str	r3, [sp, #12]
    4698:	2302      	movs	r3, #2
    469a:	9302      	str	r3, [sp, #8]
    469c:	2306      	movs	r3, #6
    469e:	9301      	str	r3, [sp, #4]
    46a0:	4b30      	ldr	r3, [pc, #192]	; (4764 <_Z41__static_initialization_and_destruction_0ii+0x288>)
    46a2:	9300      	str	r3, [sp, #0]
    46a4:	2310      	movs	r3, #16
    46a6:	2200      	movs	r2, #0
    46a8:	4939      	ldr	r1, [pc, #228]	; (4790 <_Z41__static_initialization_and_destruction_0ii+0x2b4>)
    46aa:	483a      	ldr	r0, [pc, #232]	; (4794 <_Z41__static_initialization_and_destruction_0ii+0x2b8>)
    46ac:	f005 fedb 	bl	a466 <_ZN6AD5262C1EP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configP9PORT_Typem9_port_muxS5_mS6_S5_mS6_m>
                            50000);
    46b0:	f24c 3350 	movw	r3, #50000	; 0xc350
    46b4:	9309      	str	r3, [sp, #36]	; 0x24
    46b6:	2302      	movs	r3, #2
    46b8:	9308      	str	r3, [sp, #32]
    46ba:	2306      	movs	r3, #6
    46bc:	9307      	str	r3, [sp, #28]
    46be:	4b30      	ldr	r3, [pc, #192]	; (4780 <_Z41__static_initialization_and_destruction_0ii+0x2a4>)
    46c0:	9306      	str	r3, [sp, #24]
    46c2:	2302      	movs	r3, #2
    46c4:	9305      	str	r3, [sp, #20]
    46c6:	2301      	movs	r3, #1
    46c8:	9304      	str	r3, [sp, #16]
    46ca:	4b2d      	ldr	r3, [pc, #180]	; (4780 <_Z41__static_initialization_and_destruction_0ii+0x2a4>)
    46cc:	9303      	str	r3, [sp, #12]
    46ce:	2302      	movs	r3, #2
    46d0:	9302      	str	r3, [sp, #8]
    46d2:	2306      	movs	r3, #6
    46d4:	9301      	str	r3, [sp, #4]
    46d6:	4b23      	ldr	r3, [pc, #140]	; (4764 <_Z41__static_initialization_and_destruction_0ii+0x288>)
    46d8:	9300      	str	r3, [sp, #0]
    46da:	2308      	movs	r3, #8
    46dc:	2200      	movs	r2, #0
    46de:	492c      	ldr	r1, [pc, #176]	; (4790 <_Z41__static_initialization_and_destruction_0ii+0x2b4>)
    46e0:	482d      	ldr	r0, [pc, #180]	; (4798 <_Z41__static_initialization_and_destruction_0ii+0x2bc>)
    46e2:	f005 fec0 	bl	a466 <_ZN6AD5262C1EP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configP9PORT_Typem9_port_muxS5_mS6_S5_mS6_m>
                         25000000);
    46e6:	4b2d      	ldr	r3, [pc, #180]	; (479c <_Z41__static_initialization_and_destruction_0ii+0x2c0>)
    46e8:	9309      	str	r3, [sp, #36]	; 0x24
    46ea:	2302      	movs	r3, #2
    46ec:	9308      	str	r3, [sp, #32]
    46ee:	2304      	movs	r3, #4
    46f0:	9307      	str	r3, [sp, #28]
    46f2:	4b1c      	ldr	r3, [pc, #112]	; (4764 <_Z41__static_initialization_and_destruction_0ii+0x288>)
    46f4:	9306      	str	r3, [sp, #24]
    46f6:	2302      	movs	r3, #2
    46f8:	9305      	str	r3, [sp, #20]
    46fa:	2301      	movs	r3, #1
    46fc:	9304      	str	r3, [sp, #16]
    46fe:	4b20      	ldr	r3, [pc, #128]	; (4780 <_Z41__static_initialization_and_destruction_0ii+0x2a4>)
    4700:	9303      	str	r3, [sp, #12]
    4702:	2302      	movs	r3, #2
    4704:	9302      	str	r3, [sp, #8]
    4706:	2306      	movs	r3, #6
    4708:	9301      	str	r3, [sp, #4]
    470a:	4b16      	ldr	r3, [pc, #88]	; (4764 <_Z41__static_initialization_and_destruction_0ii+0x288>)
    470c:	9300      	str	r3, [sp, #0]
    470e:	2301      	movs	r3, #1
    4710:	2201      	movs	r2, #1
    4712:	491f      	ldr	r1, [pc, #124]	; (4790 <_Z41__static_initialization_and_destruction_0ii+0x2b4>)
    4714:	4822      	ldr	r0, [pc, #136]	; (47a0 <_Z41__static_initialization_and_destruction_0ii+0x2c4>)
    4716:	f006 f80e 	bl	a736 <_ZN6AD9833C1EP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configP9PORT_Typem9_port_muxS5_mS6_S5_mS6_m>
uint32_t g_iTarget_frequency  = g_iADC_frequency / g_iSamples_per_cycle;
    471a:	4b22      	ldr	r3, [pc, #136]	; (47a4 <_Z41__static_initialization_and_destruction_0ii+0x2c8>)
    471c:	681a      	ldr	r2, [r3, #0]
    471e:	4b22      	ldr	r3, [pc, #136]	; (47a8 <_Z41__static_initialization_and_destruction_0ii+0x2cc>)
    4720:	681b      	ldr	r3, [r3, #0]
    4722:	fbb2 f3f3 	udiv	r3, r2, r3
    4726:	4a21      	ldr	r2, [pc, #132]	; (47ac <_Z41__static_initialization_and_destruction_0ii+0x2d0>)
    4728:	6013      	str	r3, [r2, #0]
float    g_fTarget_frequency  = g_fADC_frequency / g_iSamples_per_cycle;
    472a:	4b21      	ldr	r3, [pc, #132]	; (47b0 <_Z41__static_initialization_and_destruction_0ii+0x2d4>)
    472c:	edd3 6a00 	vldr	s13, [r3]
    4730:	4b1d      	ldr	r3, [pc, #116]	; (47a8 <_Z41__static_initialization_and_destruction_0ii+0x2cc>)
    4732:	681b      	ldr	r3, [r3, #0]
    4734:	ee07 3a90 	vmov	s15, r3
    4738:	eeb8 7a67 	vcvt.f32.u32	s14, s15
    473c:	eec6 7a87 	vdiv.f32	s15, s13, s14
    4740:	4b1c      	ldr	r3, [pc, #112]	; (47b4 <_Z41__static_initialization_and_destruction_0ii+0x2d8>)
    4742:	edc3 7a00 	vstr	s15, [r3]
float    g_iTarget_period_us  = ( 1.0 / g_fTarget_frequency ) / 1000000.0;
    4746:	4b1b      	ldr	r3, [pc, #108]	; (47b4 <_Z41__static_initialization_and_destruction_0ii+0x2d8>)
    4748:	edd3 7a00 	vldr	s15, [r3]
    474c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    4750:	ee86 7aa7 	vdiv.f32	s14, s13, s15
    4754:	e032      	b.n	47bc <_Z41__static_initialization_and_destruction_0ii+0x2e0>
    4756:	bf00      	nop
    4758:	400ff040 	.word	0x400ff040
    475c:	4004a000 	.word	0x4004a000
    4760:	400ff080 	.word	0x400ff080
    4764:	4004b000 	.word	0x4004b000
    4768:	400ff000 	.word	0x400ff000
    476c:	40049000 	.word	0x40049000
    4770:	400ff100 	.word	0x400ff100
    4774:	4004d000 	.word	0x4004d000
    4778:	1fff08cc 	.word	0x1fff08cc
    477c:	400ff0c0 	.word	0x400ff0c0
    4780:	4004c000 	.word	0x4004c000
    4784:	1fff092c 	.word	0x1fff092c
    4788:	1fff098c 	.word	0x1fff098c
    478c:	1fff09ec 	.word	0x1fff09ec
    4790:	4002c000 	.word	0x4002c000
    4794:	1fff0a4c 	.word	0x1fff0a4c
    4798:	1fff0a74 	.word	0x1fff0a74
    479c:	017d7840 	.word	0x017d7840
    47a0:	1fff0a9c 	.word	0x1fff0a9c
    47a4:	1fff0760 	.word	0x1fff0760
    47a8:	1fff0750 	.word	0x1fff0750
    47ac:	1fff0acc 	.word	0x1fff0acc
    47b0:	1fff0764 	.word	0x1fff0764
    47b4:	1fff0ad0 	.word	0x1fff0ad0
    47b8:	49742400 	.word	0x49742400
    47bc:	ed5f 6a02 	vldr	s13, [pc, #-8]	; 47b8 <_Z41__static_initialization_and_destruction_0ii+0x2dc>
    47c0:	eec7 7a26 	vdiv.f32	s15, s14, s13
    47c4:	4b1c      	ldr	r3, [pc, #112]	; (4838 <_Z41__static_initialization_and_destruction_0ii+0x35c>)
    47c6:	edc3 7a00 	vstr	s15, [r3]
uint32_t g_iSamples_useful    = g_iSamples_per_cycle * g_iSample_cycles;
    47ca:	4b1c      	ldr	r3, [pc, #112]	; (483c <_Z41__static_initialization_and_destruction_0ii+0x360>)
    47cc:	681b      	ldr	r3, [r3, #0]
    47ce:	4a1c      	ldr	r2, [pc, #112]	; (4840 <_Z41__static_initialization_and_destruction_0ii+0x364>)
    47d0:	6812      	ldr	r2, [r2, #0]
    47d2:	fb02 f303 	mul.w	r3, r2, r3
    47d6:	4a1b      	ldr	r2, [pc, #108]	; (4844 <_Z41__static_initialization_and_destruction_0ii+0x368>)
    47d8:	6013      	str	r3, [r2, #0]
uint32_t g_iSamples           = g_iSamples_useful + g_iSample_rubbish;
    47da:	4b1a      	ldr	r3, [pc, #104]	; (4844 <_Z41__static_initialization_and_destruction_0ii+0x368>)
    47dc:	681a      	ldr	r2, [r3, #0]
    47de:	4b1a      	ldr	r3, [pc, #104]	; (4848 <_Z41__static_initialization_and_destruction_0ii+0x36c>)
    47e0:	681b      	ldr	r3, [r3, #0]
    47e2:	4413      	add	r3, r2
    47e4:	4a19      	ldr	r2, [pc, #100]	; (484c <_Z41__static_initialization_and_destruction_0ii+0x370>)
    47e6:	6013      	str	r3, [r2, #0]
uint16_t g_iDAC_points           = g_eDACMode == DACModes::HighRes ? lenof(g_dacValuesHighRes)*2 - 2 : lenof(g_dacValuesLowRes);
    47e8:	4b19      	ldr	r3, [pc, #100]	; (4850 <_Z41__static_initialization_and_destruction_0ii+0x374>)
    47ea:	781b      	ldrb	r3, [r3, #0]
    47ec:	2b01      	cmp	r3, #1
    47ee:	d101      	bne.n	47f4 <_Z41__static_initialization_and_destruction_0ii+0x318>
    47f0:	221e      	movs	r2, #30
    47f2:	e000      	b.n	47f6 <_Z41__static_initialization_and_destruction_0ii+0x31a>
    47f4:	2210      	movs	r2, #16
    47f6:	4b17      	ldr	r3, [pc, #92]	; (4854 <_Z41__static_initialization_and_destruction_0ii+0x378>)
    47f8:	801a      	strh	r2, [r3, #0]
uint16_t g_iPDB_cycleLength      = g_iPerip_frequency / g_iTarget_frequency;
    47fa:	4b17      	ldr	r3, [pc, #92]	; (4858 <_Z41__static_initialization_and_destruction_0ii+0x37c>)
    47fc:	681a      	ldr	r2, [r3, #0]
    47fe:	4b17      	ldr	r3, [pc, #92]	; (485c <_Z41__static_initialization_and_destruction_0ii+0x380>)
    4800:	681b      	ldr	r3, [r3, #0]
    4802:	fbb2 f3f3 	udiv	r3, r2, r3
    4806:	b29a      	uxth	r2, r3
    4808:	4b15      	ldr	r3, [pc, #84]	; (4860 <_Z41__static_initialization_and_destruction_0ii+0x384>)
    480a:	801a      	strh	r2, [r3, #0]
uint16_t g_iDAC_trigger_interval = g_iPDB_cycleLength / g_iDAC_points ;
    480c:	4b14      	ldr	r3, [pc, #80]	; (4860 <_Z41__static_initialization_and_destruction_0ii+0x384>)
    480e:	881a      	ldrh	r2, [r3, #0]
    4810:	4b10      	ldr	r3, [pc, #64]	; (4854 <_Z41__static_initialization_and_destruction_0ii+0x378>)
    4812:	881b      	ldrh	r3, [r3, #0]
    4814:	fbb2 f3f3 	udiv	r3, r2, r3
    4818:	b29a      	uxth	r2, r3
    481a:	4b12      	ldr	r3, [pc, #72]	; (4864 <_Z41__static_initialization_and_destruction_0ii+0x388>)
    481c:	801a      	strh	r2, [r3, #0]
uint16_t g_iPDB_mod              = g_iDAC_trigger_interval * g_iDAC_points;
    481e:	4b11      	ldr	r3, [pc, #68]	; (4864 <_Z41__static_initialization_and_destruction_0ii+0x388>)
    4820:	881a      	ldrh	r2, [r3, #0]
    4822:	4b0c      	ldr	r3, [pc, #48]	; (4854 <_Z41__static_initialization_and_destruction_0ii+0x378>)
    4824:	881b      	ldrh	r3, [r3, #0]
    4826:	fb12 f303 	smulbb	r3, r2, r3
    482a:	b29a      	uxth	r2, r3
    482c:	4b0e      	ldr	r3, [pc, #56]	; (4868 <_Z41__static_initialization_and_destruction_0ii+0x38c>)
    482e:	801a      	strh	r2, [r3, #0]
    4830:	bf00      	nop
    4832:	3708      	adds	r7, #8
    4834:	46bd      	mov	sp, r7
    4836:	bd80      	pop	{r7, pc}
    4838:	1fff0ad4 	.word	0x1fff0ad4
    483c:	1fff0750 	.word	0x1fff0750
    4840:	1fff074c 	.word	0x1fff074c
    4844:	1fff0ad8 	.word	0x1fff0ad8
    4848:	1fff0754 	.word	0x1fff0754
    484c:	1fff0adc 	.word	0x1fff0adc
    4850:	1fff0731 	.word	0x1fff0731
    4854:	1fff0ae0 	.word	0x1fff0ae0
    4858:	1fff075c 	.word	0x1fff075c
    485c:	1fff0acc 	.word	0x1fff0acc
    4860:	1fff0ae2 	.word	0x1fff0ae2
    4864:	1fff0ae4 	.word	0x1fff0ae4
    4868:	1fff0ae6 	.word	0x1fff0ae6

0000486c <_GLOBAL__sub_I_senseAMux>:
    486c:	b580      	push	{r7, lr}
    486e:	af00      	add	r7, sp, #0
    4870:	f64f 71ff 	movw	r1, #65535	; 0xffff
    4874:	2001      	movs	r0, #1
    4876:	f7ff fe31 	bl	44dc <_Z41__static_initialization_and_destruction_0ii>
    487a:	bd80      	pop	{r7, pc}

0000487c <fault_isr>:
{
    487c:	b580      	push	{r7, lr}
    487e:	af00      	add	r7, sp, #0
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    4880:	4b10      	ldr	r3, [pc, #64]	; (48c4 <fault_isr+0x48>)
    4882:	681b      	ldr	r3, [r3, #0]
    4884:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
    4888:	2b00      	cmp	r3, #0
    488a:	d001      	beq.n	4890 <fault_isr+0x14>
    488c:	f001 fa6e 	bl	5d6c <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    4890:	4b0c      	ldr	r3, [pc, #48]	; (48c4 <fault_isr+0x48>)
    4892:	681b      	ldr	r3, [r3, #0]
    4894:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    4898:	2b00      	cmp	r3, #0
    489a:	d001      	beq.n	48a0 <fault_isr+0x24>
    489c:	f000 f814 	bl	48c8 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    48a0:	4b08      	ldr	r3, [pc, #32]	; (48c4 <fault_isr+0x48>)
    48a2:	681b      	ldr	r3, [r3, #0]
    48a4:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    48a8:	2b00      	cmp	r3, #0
    48aa:	d001      	beq.n	48b0 <fault_isr+0x34>
    48ac:	f000 f80c 	bl	48c8 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    48b0:	4b04      	ldr	r3, [pc, #16]	; (48c4 <fault_isr+0x48>)
    48b2:	681b      	ldr	r3, [r3, #0]
    48b4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    48b8:	2b00      	cmp	r3, #0
    48ba:	d0e1      	beq.n	4880 <fault_isr+0x4>
    48bc:	f000 f804 	bl	48c8 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    48c0:	e7de      	b.n	4880 <fault_isr+0x4>
    48c2:	bf00      	nop
    48c4:	40048034 	.word	0x40048034

000048c8 <unused_isr>:
{
    48c8:	b580      	push	{r7, lr}
    48ca:	af00      	add	r7, sp, #0
	fault_isr();
    48cc:	f7ff ffd6 	bl	487c <fault_isr>
}
    48d0:	bf00      	nop
    48d2:	bd80      	pop	{r7, pc}

000048d4 <startup_early_hook>:
static void startup_default_early_hook(void) {
    48d4:	b480      	push	{r7}
    48d6:	af00      	add	r7, sp, #0
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    48d8:	4b03      	ldr	r3, [pc, #12]	; (48e8 <startup_early_hook+0x14>)
    48da:	2210      	movs	r2, #16
    48dc:	801a      	strh	r2, [r3, #0]
}
    48de:	bf00      	nop
    48e0:	46bd      	mov	sp, r7
    48e2:	f85d 7b04 	ldr.w	r7, [sp], #4
    48e6:	4770      	bx	lr
    48e8:	40052000 	.word	0x40052000

000048ec <startup_late_hook>:
static void startup_default_late_hook(void) {}
    48ec:	b480      	push	{r7}
    48ee:	af00      	add	r7, sp, #0
    48f0:	bf00      	nop
    48f2:	46bd      	mov	sp, r7
    48f4:	f85d 7b04 	ldr.w	r7, [sp], #4
    48f8:	4770      	bx	lr
    48fa:	Address 0x000048fa is out of bounds.


000048fc <ResetHandler>:
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
    48fc:	4b60      	ldr	r3, [pc, #384]	; (4a80 <ResetHandler+0x184>)
    48fe:	f24c 5220 	movw	r2, #50464	; 0xc520
{
    4902:	b510      	push	{r4, lr}
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
    4904:	81da      	strh	r2, [r3, #14]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
    4906:	f64d 1228 	movw	r2, #55592	; 0xd928
    490a:	81da      	strh	r2, [r3, #14]
	__asm__ volatile ("nop");
    490c:	bf00      	nop
	__asm__ volatile ("nop");
    490e:	bf00      	nop
	startup_early_hook();
    4910:	f7ff ffe0 	bl	48d4 <startup_early_hook>
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
    4914:	4b5b      	ldr	r3, [pc, #364]	; (4a84 <ResetHandler+0x188>)
    4916:	f04f 6230 	mov.w	r2, #184549376	; 0xb000000
    491a:	631a      	str	r2, [r3, #48]	; 0x30
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
    491c:	4a5a      	ldr	r2, [pc, #360]	; (4a88 <ResetHandler+0x18c>)
    491e:	639a      	str	r2, [r3, #56]	; 0x38
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
    4920:	4a5a      	ldr	r2, [pc, #360]	; (4a8c <ResetHandler+0x190>)
    4922:	63da      	str	r2, [r3, #60]	; 0x3c
	SCB_CPACR = 0x00F00000;
    4924:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    4928:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
    492c:	f8c3 2d88 	str.w	r2, [r3, #3464]	; 0xd88
	LMEM_PCCCR = 0x85000003;
    4930:	f503 23e8 	add.w	r3, r3, #475136	; 0x74000
    4934:	4a56      	ldr	r2, [pc, #344]	; (4a90 <ResetHandler+0x194>)
    4936:	601a      	str	r2, [r3, #0]
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
    4938:	4b56      	ldr	r3, [pc, #344]	; (4a94 <ResetHandler+0x198>)
    493a:	789a      	ldrb	r2, [r3, #2]
    493c:	0711      	lsls	r1, r2, #28
    493e:	d503      	bpl.n	4948 <ResetHandler+0x4c>
    4940:	789a      	ldrb	r2, [r3, #2]
    4942:	f042 0208 	orr.w	r2, r2, #8
    4946:	709a      	strb	r2, [r3, #2]
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
    4948:	4b53      	ldr	r3, [pc, #332]	; (4a98 <ResetHandler+0x19c>)
	while (dest < &_edata) *dest++ = *src++;
    494a:	4854      	ldr	r0, [pc, #336]	; (4a9c <ResetHandler+0x1a0>)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
    494c:	22aa      	movs	r2, #170	; 0xaa
    494e:	701a      	strb	r2, [r3, #0]
	while (dest < &_edata) *dest++ = *src++;
    4950:	4b53      	ldr	r3, [pc, #332]	; (4aa0 <ResetHandler+0x1a4>)
    4952:	1cda      	adds	r2, r3, #3
    4954:	1a12      	subs	r2, r2, r0
    4956:	1ec1      	subs	r1, r0, #3
    4958:	f022 0203 	bic.w	r2, r2, #3
    495c:	4299      	cmp	r1, r3
    495e:	bf88      	it	hi
    4960:	2200      	movhi	r2, #0
    4962:	4950      	ldr	r1, [pc, #320]	; (4aa4 <ResetHandler+0x1a8>)
    4964:	f009 fd2a 	bl	e3bc <memcpy>
	while (dest < &_ebss) *dest++ = 0;
    4968:	4b4f      	ldr	r3, [pc, #316]	; (4aa8 <ResetHandler+0x1ac>)
    496a:	4850      	ldr	r0, [pc, #320]	; (4aac <ResetHandler+0x1b0>)
    496c:	1cda      	adds	r2, r3, #3
    496e:	1a12      	subs	r2, r2, r0
    4970:	1ec1      	subs	r1, r0, #3
    4972:	f022 0203 	bic.w	r2, r2, #3
    4976:	4299      	cmp	r1, r3
    4978:	bf88      	it	hi
    497a:	2200      	movhi	r2, #0
    497c:	2100      	movs	r1, #0
    497e:	f009 fd2b 	bl	e3d8 <memset>
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
    4982:	494b      	ldr	r1, [pc, #300]	; (4ab0 <ResetHandler+0x1b4>)
    4984:	484b      	ldr	r0, [pc, #300]	; (4ab4 <ResetHandler+0x1b8>)
    4986:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
    498a:	f009 fd17 	bl	e3bc <memcpy>
    498e:	4b4a      	ldr	r3, [pc, #296]	; (4ab8 <ResetHandler+0x1bc>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
    4990:	4a4a      	ldr	r2, [pc, #296]	; (4abc <ResetHandler+0x1c0>)
    4992:	2180      	movs	r1, #128	; 0x80
    4994:	f803 1b01 	strb.w	r1, [r3], #1
    4998:	4293      	cmp	r3, r2
    499a:	d1fb      	bne.n	4994 <ResetHandler+0x98>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
    499c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    49a0:	4a44      	ldr	r2, [pc, #272]	; (4ab4 <ResetHandler+0x1b8>)
    49a2:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    49a6:	4b46      	ldr	r3, [pc, #280]	; (4ac0 <ResetHandler+0x1c4>)
    49a8:	228a      	movs	r2, #138	; 0x8a
    49aa:	701a      	strb	r2, [r3, #0]
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
    49ac:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
    49b0:	2224      	movs	r2, #36	; 0x24
    49b2:	705a      	strb	r2, [r3, #1]
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
    49b4:	22a0      	movs	r2, #160	; 0xa0
    49b6:	701a      	strb	r2, [r3, #0]
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
    49b8:	799a      	ldrb	r2, [r3, #6]
    49ba:	0792      	lsls	r2, r2, #30
    49bc:	d5fc      	bpl.n	49b8 <ResetHandler+0xbc>
	while ((MCG_S & MCG_S_IREFST) != 0) ;
    49be:	799a      	ldrb	r2, [r3, #6]
    49c0:	06d4      	lsls	r4, r2, #27
    49c2:	d4fc      	bmi.n	49be <ResetHandler+0xc2>
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
    49c4:	4a3f      	ldr	r2, [pc, #252]	; (4ac4 <ResetHandler+0x1c8>)
    49c6:	7993      	ldrb	r3, [r2, #6]
    49c8:	f003 030c 	and.w	r3, r3, #12
    49cc:	2b08      	cmp	r3, #8
    49ce:	d1fa      	bne.n	49c6 <ResetHandler+0xca>
	SMC_PMCTRL = SMC_PMCTRL_RUNM(3); // enter HSRUN mode
    49d0:	4b31      	ldr	r3, [pc, #196]	; (4a98 <ResetHandler+0x19c>)
    49d2:	2260      	movs	r2, #96	; 0x60
    49d4:	705a      	strb	r2, [r3, #1]
	while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) ; // wait for HSRUN
    49d6:	78da      	ldrb	r2, [r3, #3]
    49d8:	2a80      	cmp	r2, #128	; 0x80
    49da:	d1fc      	bne.n	49d6 <ResetHandler+0xda>
	MCG_C5 = MCG_C5_PRDIV0(1);
    49dc:	4b39      	ldr	r3, [pc, #228]	; (4ac4 <ResetHandler+0x1c8>)
    49de:	2201      	movs	r2, #1
    49e0:	711a      	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(29);
    49e2:	225d      	movs	r2, #93	; 0x5d
    49e4:	715a      	strb	r2, [r3, #5]
	while (!(MCG_S & MCG_S_PLLST)) ;
    49e6:	799a      	ldrb	r2, [r3, #6]
    49e8:	0690      	lsls	r0, r2, #26
    49ea:	d5fc      	bpl.n	49e6 <ResetHandler+0xea>
	while (!(MCG_S & MCG_S_LOCK0)) ;
    49ec:	799a      	ldrb	r2, [r3, #6]
    49ee:	0651      	lsls	r1, r2, #25
    49f0:	d5fc      	bpl.n	49ec <ResetHandler+0xf0>
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(6);
    49f2:	4a24      	ldr	r2, [pc, #144]	; (4a84 <ResetHandler+0x188>)
    49f4:	f04f 7183 	mov.w	r1, #17170432	; 0x1060000
    49f8:	6451      	str	r1, [r2, #68]	; 0x44
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(0);
    49fa:	2100      	movs	r1, #0
    49fc:	6491      	str	r1, [r2, #72]	; 0x48
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
    49fe:	2120      	movs	r1, #32
    4a00:	7019      	strb	r1, [r3, #0]
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
    4a02:	4930      	ldr	r1, [pc, #192]	; (4ac4 <ResetHandler+0x1c8>)
    4a04:	798b      	ldrb	r3, [r1, #6]
    4a06:	f003 030c 	and.w	r3, r3, #12
    4a0a:	2b0c      	cmp	r3, #12
    4a0c:	d1fa      	bne.n	4a04 <ResetHandler+0x108>
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
    4a0e:	4b2e      	ldr	r3, [pc, #184]	; (4ac8 <ResetHandler+0x1cc>)
    4a10:	6053      	str	r3, [r2, #4]
	if (!(RTC_CR & RTC_CR_OSCE)) {
    4a12:	4a2e      	ldr	r2, [pc, #184]	; (4acc <ResetHandler+0x1d0>)
    4a14:	6913      	ldr	r3, [r2, #16]
    4a16:	f413 7380 	ands.w	r3, r3, #256	; 0x100
    4a1a:	d103      	bne.n	4a24 <ResetHandler+0x128>
		RTC_SR = 0;
    4a1c:	6153      	str	r3, [r2, #20]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
    4a1e:	f44f 53a8 	mov.w	r3, #5376	; 0x1500
    4a22:	6113      	str	r3, [r2, #16]
	SYST_RVR = (F_CPU / 1000) - 1;
    4a24:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    4a28:	4a29      	ldr	r2, [pc, #164]	; (4ad0 <ResetHandler+0x1d4>)
    4a2a:	615a      	str	r2, [r3, #20]
	SYST_CVR = 0;
    4a2c:	2200      	movs	r2, #0
    4a2e:	619a      	str	r2, [r3, #24]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
    4a30:	2207      	movs	r2, #7
    4a32:	611a      	str	r2, [r3, #16]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
    4a34:	4a27      	ldr	r2, [pc, #156]	; (4ad4 <ResetHandler+0x1d8>)
    4a36:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
	__enable_irq();
    4a3a:	b662      	cpsie	i
	_init_Teensyduino_internal_();
    4a3c:	f000 f94a 	bl	4cd4 <_init_Teensyduino_internal_>
	if (RTC_SR & RTC_SR_TIF) {
    4a40:	4b22      	ldr	r3, [pc, #136]	; (4acc <ResetHandler+0x1d0>)
    4a42:	695b      	ldr	r3, [r3, #20]
    4a44:	07da      	lsls	r2, r3, #31
    4a46:	d505      	bpl.n	4a54 <ResetHandler+0x158>
		rtc_set((uint32_t)&__rtc_localtime);
    4a48:	4823      	ldr	r0, [pc, #140]	; (4ad8 <ResetHandler+0x1dc>)
    4a4a:	f000 f927 	bl	4c9c <rtc_set>
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
    4a4e:	4b23      	ldr	r3, [pc, #140]	; (4adc <ResetHandler+0x1e0>)
    4a50:	4a23      	ldr	r2, [pc, #140]	; (4ae0 <ResetHandler+0x1e4>)
    4a52:	61da      	str	r2, [r3, #28]
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
    4a54:	4b23      	ldr	r3, [pc, #140]	; (4ae4 <ResetHandler+0x1e8>)
    4a56:	781b      	ldrb	r3, [r3, #0]
    4a58:	065b      	lsls	r3, r3, #25
    4a5a:	d509      	bpl.n	4a70 <ResetHandler+0x174>
    4a5c:	4c1f      	ldr	r4, [pc, #124]	; (4adc <ResetHandler+0x1e0>)
    4a5e:	4b20      	ldr	r3, [pc, #128]	; (4ae0 <ResetHandler+0x1e4>)
    4a60:	69e2      	ldr	r2, [r4, #28]
    4a62:	429a      	cmp	r2, r3
    4a64:	d104      	bne.n	4a70 <ResetHandler+0x174>
		rtc_set((uint32_t)&__rtc_localtime);
    4a66:	481c      	ldr	r0, [pc, #112]	; (4ad8 <ResetHandler+0x1dc>)
    4a68:	f000 f918 	bl	4c9c <rtc_set>
		*(uint32_t *)0x4003E01C = 0;
    4a6c:	2300      	movs	r3, #0
    4a6e:	61e3      	str	r3, [r4, #28]
	__libc_init_array();
    4a70:	f009 fc70 	bl	e354 <__libc_init_array>
	startup_late_hook();
    4a74:	f7ff ff3a 	bl	48ec <startup_late_hook>
	main();
    4a78:	f7ff fa28 	bl	3ecc <main>
    4a7c:	e7fe      	b.n	4a7c <ResetHandler+0x180>
    4a7e:	bf00      	nop
    4a80:	40052000 	.word	0x40052000
    4a84:	40048000 	.word	0x40048000
    4a88:	00043f82 	.word	0x00043f82
    4a8c:	2b000001 	.word	0x2b000001
    4a90:	85000003 	.word	0x85000003
    4a94:	4007d000 	.word	0x4007d000
    4a98:	4007e000 	.word	0x4007e000
    4a9c:	1fff0730 	.word	0x1fff0730
    4aa0:	1fff08b4 	.word	0x1fff08b4
    4aa4:	00010d18 	.word	0x00010d18
    4aa8:	1fff14d0 	.word	0x1fff14d0
    4aac:	1fff08b4 	.word	0x1fff08b4
    4ab0:	00000000 	.word	0x00000000
    4ab4:	1fff0200 	.word	0x1fff0200
    4ab8:	e000e400 	.word	0xe000e400
    4abc:	e000e464 	.word	0xe000e464
    4ac0:	40065000 	.word	0x40065000
    4ac4:	40064000 	.word	0x40064000
    4ac8:	000710c0 	.word	0x000710c0
    4acc:	4003d000 	.word	0x4003d000
    4ad0:	0002bf1f 	.word	0x0002bf1f
    4ad4:	20200000 	.word	0x20200000
    4ad8:	00000000 	.word	0x00000000
    4adc:	4003e000 	.word	0x4003e000
    4ae0:	5a94c3a5 	.word	0x5a94c3a5
    4ae4:	4007f000 	.word	0x4007f000

00004ae8 <_sbrk>:
{
    4ae8:	b580      	push	{r7, lr}
    4aea:	b084      	sub	sp, #16
    4aec:	af00      	add	r7, sp, #0
    4aee:	6078      	str	r0, [r7, #4]
	prev = __brkval;
    4af0:	4b10      	ldr	r3, [pc, #64]	; (4b34 <_sbrk+0x4c>)
    4af2:	681b      	ldr	r3, [r3, #0]
    4af4:	60fb      	str	r3, [r7, #12]
	if (incr != 0) {
    4af6:	687b      	ldr	r3, [r7, #4]
    4af8:	2b00      	cmp	r3, #0
    4afa:	d016      	beq.n	4b2a <_sbrk+0x42>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    4afc:	466b      	mov	r3, sp
    4afe:	60bb      	str	r3, [r7, #8]
		if (prev + incr >= stack - STACK_MARGIN) {
    4b00:	687b      	ldr	r3, [r7, #4]
    4b02:	68fa      	ldr	r2, [r7, #12]
    4b04:	441a      	add	r2, r3
    4b06:	68bb      	ldr	r3, [r7, #8]
    4b08:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
    4b0c:	429a      	cmp	r2, r3
    4b0e:	d307      	bcc.n	4b20 <_sbrk+0x38>
			errno = ENOMEM;
    4b10:	f009 fc1a 	bl	e348 <__errno>
    4b14:	4603      	mov	r3, r0
    4b16:	220c      	movs	r2, #12
    4b18:	601a      	str	r2, [r3, #0]
			return (void *)-1;
    4b1a:	f04f 33ff 	mov.w	r3, #4294967295
    4b1e:	e005      	b.n	4b2c <_sbrk+0x44>
		__brkval = prev + incr;
    4b20:	687b      	ldr	r3, [r7, #4]
    4b22:	68fa      	ldr	r2, [r7, #12]
    4b24:	4413      	add	r3, r2
    4b26:	4a03      	ldr	r2, [pc, #12]	; (4b34 <_sbrk+0x4c>)
    4b28:	6013      	str	r3, [r2, #0]
	return prev;
    4b2a:	68fb      	ldr	r3, [r7, #12]
}
    4b2c:	4618      	mov	r0, r3
    4b2e:	3710      	adds	r7, #16
    4b30:	46bd      	mov	sp, r7
    4b32:	bd80      	pop	{r7, pc}
    4b34:	1fff0788 	.word	0x1fff0788

00004b38 <kinetis_hsrun_disable>:


#if defined(HAS_KINETIS_HSRUN) && F_CPU > 120000000
int kinetis_hsrun_disable(void)
{
    4b38:	b480      	push	{r7}
    4b3a:	af00      	add	r7, sp, #0
	if (SMC_PMSTAT == SMC_PMSTAT_HSRUN) {
    4b3c:	4b0c      	ldr	r3, [pc, #48]	; (4b70 <kinetis_hsrun_disable+0x38>)
    4b3e:	781b      	ldrb	r3, [r3, #0]
    4b40:	b2db      	uxtb	r3, r3
    4b42:	2b80      	cmp	r3, #128	; 0x80
    4b44:	d10d      	bne.n	4b62 <kinetis_hsrun_disable+0x2a>
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
		#elif F_CPU == 180000000 && F_BUS == 90000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
    4b46:	4b0b      	ldr	r3, [pc, #44]	; (4b74 <kinetis_hsrun_disable+0x3c>)
    4b48:	4a0b      	ldr	r2, [pc, #44]	; (4b78 <kinetis_hsrun_disable+0x40>)
    4b4a:	601a      	str	r2, [r3, #0]
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 5); // ok
		#else
			return 0;
		#endif
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
    4b4c:	4b0b      	ldr	r3, [pc, #44]	; (4b7c <kinetis_hsrun_disable+0x44>)
    4b4e:	2200      	movs	r2, #0
    4b50:	701a      	strb	r2, [r3, #0]
		while (SMC_PMSTAT == SMC_PMSTAT_HSRUN) ; // wait
    4b52:	bf00      	nop
    4b54:	4b06      	ldr	r3, [pc, #24]	; (4b70 <kinetis_hsrun_disable+0x38>)
    4b56:	781b      	ldrb	r3, [r3, #0]
    4b58:	b2db      	uxtb	r3, r3
    4b5a:	2b80      	cmp	r3, #128	; 0x80
    4b5c:	d0fa      	beq.n	4b54 <kinetis_hsrun_disable+0x1c>
		return 1;
    4b5e:	2301      	movs	r3, #1
    4b60:	e000      	b.n	4b64 <kinetis_hsrun_disable+0x2c>
	}
	return 0;
    4b62:	2300      	movs	r3, #0
}
    4b64:	4618      	mov	r0, r3
    4b66:	46bd      	mov	sp, r7
    4b68:	f85d 7b04 	ldr.w	r7, [sp], #4
    4b6c:	4770      	bx	lr
    4b6e:	bf00      	nop
    4b70:	4007e003 	.word	0x4007e003
    4b74:	40048044 	.word	0x40048044
    4b78:	11170000 	.word	0x11170000
    4b7c:	4007e001 	.word	0x4007e001

00004b80 <kinetis_hsrun_enable>:

int kinetis_hsrun_enable(void)
{
    4b80:	b480      	push	{r7}
    4b82:	af00      	add	r7, sp, #0
	if (SMC_PMSTAT == SMC_PMSTAT_RUN) {
    4b84:	4b0c      	ldr	r3, [pc, #48]	; (4bb8 <kinetis_hsrun_enable+0x38>)
    4b86:	781b      	ldrb	r3, [r3, #0]
    4b88:	b2db      	uxtb	r3, r3
    4b8a:	2b01      	cmp	r3, #1
    4b8c:	d10e      	bne.n	4bac <kinetis_hsrun_enable+0x2c>
		// Turn HSRUN mode on
		SMC_PMCTRL = SMC_PMCTRL_RUNM(3);
    4b8e:	4b0b      	ldr	r3, [pc, #44]	; (4bbc <kinetis_hsrun_enable+0x3c>)
    4b90:	2260      	movs	r2, #96	; 0x60
    4b92:	701a      	strb	r2, [r3, #0]
		while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) {;} // wait
    4b94:	bf00      	nop
    4b96:	4b08      	ldr	r3, [pc, #32]	; (4bb8 <kinetis_hsrun_enable+0x38>)
    4b98:	781b      	ldrb	r3, [r3, #0]
    4b9a:	b2db      	uxtb	r3, r3
    4b9c:	2b80      	cmp	r3, #128	; 0x80
    4b9e:	d1fa      	bne.n	4b96 <kinetis_hsrun_enable+0x16>
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 6);
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 2, 0, 6);
		#elif F_CPU == 180000000 && F_BUS == 90000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 6);
    4ba0:	4b07      	ldr	r3, [pc, #28]	; (4bc0 <kinetis_hsrun_enable+0x40>)
    4ba2:	f04f 7283 	mov.w	r2, #17170432	; 0x1060000
    4ba6:	601a      	str	r2, [r3, #0]
		#elif F_CPU == 144000000 && F_BUS == 72000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 4);
		#else
			return 0;
		#endif
		return 1;
    4ba8:	2301      	movs	r3, #1
    4baa:	e000      	b.n	4bae <kinetis_hsrun_enable+0x2e>
	}
	return 0;
    4bac:	2300      	movs	r3, #0
}
    4bae:	4618      	mov	r0, r3
    4bb0:	46bd      	mov	sp, r7
    4bb2:	f85d 7b04 	ldr.w	r7, [sp], #4
    4bb6:	4770      	bx	lr
    4bb8:	4007e003 	.word	0x4007e003
    4bbc:	4007e001 	.word	0x4007e001
    4bc0:	40048044 	.word	0x40048044

00004bc4 <_ZN14EventResponder17disableInterruptsEv>:
	static EventResponder *lastYield;
	static EventResponder *firstInterrupt;
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
    4bc4:	b480      	push	{r7}
    4bc6:	b083      	sub	sp, #12
    4bc8:	af00      	add	r7, sp, #0
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    4bca:	f3ef 8310 	mrs	r3, PRIMASK
    4bce:	607b      	str	r3, [r7, #4]
		__disable_irq();
    4bd0:	b672      	cpsid	i
		return (primask == 0) ? true : false;
    4bd2:	687b      	ldr	r3, [r7, #4]
    4bd4:	2b00      	cmp	r3, #0
    4bd6:	bf0c      	ite	eq
    4bd8:	2301      	moveq	r3, #1
    4bda:	2300      	movne	r3, #0
    4bdc:	b2db      	uxtb	r3, r3
	}
    4bde:	4618      	mov	r0, r3
    4be0:	370c      	adds	r7, #12
    4be2:	46bd      	mov	sp, r7
    4be4:	f85d 7b04 	ldr.w	r7, [sp], #4
    4be8:	4770      	bx	lr

00004bea <_ZN14EventResponder16enableInterruptsEb>:
	static void enableInterrupts(bool doit) {
    4bea:	b480      	push	{r7}
    4bec:	b083      	sub	sp, #12
    4bee:	af00      	add	r7, sp, #0
    4bf0:	4603      	mov	r3, r0
    4bf2:	71fb      	strb	r3, [r7, #7]
		if (doit) __enable_irq();
    4bf4:	79fb      	ldrb	r3, [r7, #7]
    4bf6:	2b00      	cmp	r3, #0
    4bf8:	d000      	beq.n	4bfc <_ZN14EventResponder16enableInterruptsEb+0x12>
    4bfa:	b662      	cpsie	i
	}
    4bfc:	bf00      	nop
    4bfe:	370c      	adds	r7, #12
    4c00:	46bd      	mov	sp, r7
    4c02:	f85d 7b04 	ldr.w	r7, [sp], #4
    4c06:	4770      	bx	lr

00004c08 <pendablesrvreq_isr>:
{
    4c08:	b580      	push	{r7, lr}
    4c0a:	af00      	add	r7, sp, #0
	EventResponder::runFromInterrupt();
    4c0c:	f000 f802 	bl	4c14 <_ZN14EventResponder16runFromInterruptEv>
}
    4c10:	bf00      	nop
    4c12:	bd80      	pop	{r7, pc}

00004c14 <_ZN14EventResponder16runFromInterruptEv>:
{
    4c14:	b580      	push	{r7, lr}
    4c16:	b082      	sub	sp, #8
    4c18:	af00      	add	r7, sp, #0
		bool irq = disableInterrupts();
    4c1a:	f7ff ffd3 	bl	4bc4 <_ZN14EventResponder17disableInterruptsEv>
    4c1e:	4603      	mov	r3, r0
    4c20:	71fb      	strb	r3, [r7, #7]
		EventResponder *first = firstInterrupt;
    4c22:	4b15      	ldr	r3, [pc, #84]	; (4c78 <_ZN14EventResponder16runFromInterruptEv+0x64>)
    4c24:	681b      	ldr	r3, [r3, #0]
    4c26:	603b      	str	r3, [r7, #0]
		if (first) {
    4c28:	683b      	ldr	r3, [r7, #0]
    4c2a:	2b00      	cmp	r3, #0
    4c2c:	d01b      	beq.n	4c66 <_ZN14EventResponder16runFromInterruptEv+0x52>
			firstInterrupt = first->_next;
    4c2e:	683b      	ldr	r3, [r7, #0]
    4c30:	695b      	ldr	r3, [r3, #20]
    4c32:	4a11      	ldr	r2, [pc, #68]	; (4c78 <_ZN14EventResponder16runFromInterruptEv+0x64>)
    4c34:	6013      	str	r3, [r2, #0]
			if (firstInterrupt) {
    4c36:	4b10      	ldr	r3, [pc, #64]	; (4c78 <_ZN14EventResponder16runFromInterruptEv+0x64>)
    4c38:	681b      	ldr	r3, [r3, #0]
    4c3a:	2b00      	cmp	r3, #0
    4c3c:	d004      	beq.n	4c48 <_ZN14EventResponder16runFromInterruptEv+0x34>
				firstInterrupt->_prev = nullptr;
    4c3e:	4b0e      	ldr	r3, [pc, #56]	; (4c78 <_ZN14EventResponder16runFromInterruptEv+0x64>)
    4c40:	681b      	ldr	r3, [r3, #0]
    4c42:	2200      	movs	r2, #0
    4c44:	619a      	str	r2, [r3, #24]
    4c46:	e002      	b.n	4c4e <_ZN14EventResponder16runFromInterruptEv+0x3a>
				lastInterrupt = nullptr;
    4c48:	4b0c      	ldr	r3, [pc, #48]	; (4c7c <_ZN14EventResponder16runFromInterruptEv+0x68>)
    4c4a:	2200      	movs	r2, #0
    4c4c:	601a      	str	r2, [r3, #0]
			enableInterrupts(irq);
    4c4e:	79fb      	ldrb	r3, [r7, #7]
    4c50:	4618      	mov	r0, r3
    4c52:	f7ff ffca 	bl	4bea <_ZN14EventResponder16enableInterruptsEb>
			first->_triggered = false;
    4c56:	683b      	ldr	r3, [r7, #0]
    4c58:	2200      	movs	r2, #0
    4c5a:	775a      	strb	r2, [r3, #29]
			(*(first->_function))(*first);
    4c5c:	683b      	ldr	r3, [r7, #0]
    4c5e:	689b      	ldr	r3, [r3, #8]
    4c60:	6838      	ldr	r0, [r7, #0]
    4c62:	4798      	blx	r3
    4c64:	e7d9      	b.n	4c1a <_ZN14EventResponder16runFromInterruptEv+0x6>
			enableInterrupts(irq);
    4c66:	79fb      	ldrb	r3, [r7, #7]
    4c68:	4618      	mov	r0, r3
    4c6a:	f7ff ffbe 	bl	4bea <_ZN14EventResponder16enableInterruptsEb>
			break;
    4c6e:	bf00      	nop
}
    4c70:	bf00      	nop
    4c72:	3708      	adds	r7, #8
    4c74:	46bd      	mov	sp, r7
    4c76:	bd80      	pop	{r7, pc}
    4c78:	1fff12fc 	.word	0x1fff12fc
    4c7c:	1fff1300 	.word	0x1fff1300

00004c80 <systick_isr>:
// with libraries using mid-to-high priority interrupts.

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
    4c80:	b480      	push	{r7}
    4c82:	af00      	add	r7, sp, #0
	systick_millis_count++;
    4c84:	4b04      	ldr	r3, [pc, #16]	; (4c98 <systick_isr+0x18>)
    4c86:	681b      	ldr	r3, [r3, #0]
    4c88:	3301      	adds	r3, #1
    4c8a:	4a03      	ldr	r2, [pc, #12]	; (4c98 <systick_isr+0x18>)
    4c8c:	6013      	str	r3, [r2, #0]
}
    4c8e:	bf00      	nop
    4c90:	46bd      	mov	sp, r7
    4c92:	f85d 7b04 	ldr.w	r7, [sp], #4
    4c96:	4770      	bx	lr
    4c98:	1fff1308 	.word	0x1fff1308

00004c9c <rtc_set>:
{
    4c9c:	b480      	push	{r7}
    4c9e:	b083      	sub	sp, #12
    4ca0:	af00      	add	r7, sp, #0
    4ca2:	6078      	str	r0, [r7, #4]
	RTC_SR = 0;
    4ca4:	4b08      	ldr	r3, [pc, #32]	; (4cc8 <rtc_set+0x2c>)
    4ca6:	2200      	movs	r2, #0
    4ca8:	601a      	str	r2, [r3, #0]
	RTC_TPR = 0;
    4caa:	4b08      	ldr	r3, [pc, #32]	; (4ccc <rtc_set+0x30>)
    4cac:	2200      	movs	r2, #0
    4cae:	601a      	str	r2, [r3, #0]
	RTC_TSR = t;
    4cb0:	4a07      	ldr	r2, [pc, #28]	; (4cd0 <rtc_set+0x34>)
    4cb2:	687b      	ldr	r3, [r7, #4]
    4cb4:	6013      	str	r3, [r2, #0]
	RTC_SR = RTC_SR_TCE;
    4cb6:	4b04      	ldr	r3, [pc, #16]	; (4cc8 <rtc_set+0x2c>)
    4cb8:	2210      	movs	r2, #16
    4cba:	601a      	str	r2, [r3, #0]
}
    4cbc:	bf00      	nop
    4cbe:	370c      	adds	r7, #12
    4cc0:	46bd      	mov	sp, r7
    4cc2:	f85d 7b04 	ldr.w	r7, [sp], #4
    4cc6:	4770      	bx	lr
    4cc8:	4003d014 	.word	0x4003d014
    4ccc:	4003d004 	.word	0x4003d004
    4cd0:	4003d000 	.word	0x4003d000

00004cd4 <_init_Teensyduino_internal_>:
{
    4cd4:	b580      	push	{r7, lr}
    4cd6:	af00      	add	r7, sp, #0
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    4cd8:	4b53      	ldr	r3, [pc, #332]	; (4e28 <_init_Teensyduino_internal_+0x154>)
    4cda:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    4cde:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    4ce0:	4b51      	ldr	r3, [pc, #324]	; (4e28 <_init_Teensyduino_internal_+0x154>)
    4ce2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    4ce6:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    4ce8:	4b4f      	ldr	r3, [pc, #316]	; (4e28 <_init_Teensyduino_internal_+0x154>)
    4cea:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
    4cee:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    4cf0:	4b4d      	ldr	r3, [pc, #308]	; (4e28 <_init_Teensyduino_internal_+0x154>)
    4cf2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4cf6:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    4cf8:	4b4b      	ldr	r3, [pc, #300]	; (4e28 <_init_Teensyduino_internal_+0x154>)
    4cfa:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    4cfe:	601a      	str	r2, [r3, #0]
	FTM0_CNT = 0;
    4d00:	4b4a      	ldr	r3, [pc, #296]	; (4e2c <_init_Teensyduino_internal_+0x158>)
    4d02:	2200      	movs	r2, #0
    4d04:	601a      	str	r2, [r3, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
    4d06:	4b4a      	ldr	r3, [pc, #296]	; (4e30 <_init_Teensyduino_internal_+0x15c>)
    4d08:	f24b 32ff 	movw	r2, #46079	; 0xb3ff
    4d0c:	601a      	str	r2, [r3, #0]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    4d0e:	4b49      	ldr	r3, [pc, #292]	; (4e34 <_init_Teensyduino_internal_+0x160>)
    4d10:	2228      	movs	r2, #40	; 0x28
    4d12:	601a      	str	r2, [r3, #0]
	FTM0_C1SC = 0x28;
    4d14:	4b48      	ldr	r3, [pc, #288]	; (4e38 <_init_Teensyduino_internal_+0x164>)
    4d16:	2228      	movs	r2, #40	; 0x28
    4d18:	601a      	str	r2, [r3, #0]
	FTM0_C2SC = 0x28;
    4d1a:	4b48      	ldr	r3, [pc, #288]	; (4e3c <_init_Teensyduino_internal_+0x168>)
    4d1c:	2228      	movs	r2, #40	; 0x28
    4d1e:	601a      	str	r2, [r3, #0]
	FTM0_C3SC = 0x28;
    4d20:	4b47      	ldr	r3, [pc, #284]	; (4e40 <_init_Teensyduino_internal_+0x16c>)
    4d22:	2228      	movs	r2, #40	; 0x28
    4d24:	601a      	str	r2, [r3, #0]
	FTM0_C4SC = 0x28;
    4d26:	4b47      	ldr	r3, [pc, #284]	; (4e44 <_init_Teensyduino_internal_+0x170>)
    4d28:	2228      	movs	r2, #40	; 0x28
    4d2a:	601a      	str	r2, [r3, #0]
	FTM0_C5SC = 0x28;
    4d2c:	4b46      	ldr	r3, [pc, #280]	; (4e48 <_init_Teensyduino_internal_+0x174>)
    4d2e:	2228      	movs	r2, #40	; 0x28
    4d30:	601a      	str	r2, [r3, #0]
	FTM0_C6SC = 0x28;
    4d32:	4b46      	ldr	r3, [pc, #280]	; (4e4c <_init_Teensyduino_internal_+0x178>)
    4d34:	2228      	movs	r2, #40	; 0x28
    4d36:	601a      	str	r2, [r3, #0]
	FTM0_C7SC = 0x28;
    4d38:	4b45      	ldr	r3, [pc, #276]	; (4e50 <_init_Teensyduino_internal_+0x17c>)
    4d3a:	2228      	movs	r2, #40	; 0x28
    4d3c:	601a      	str	r2, [r3, #0]
	FTM3_C0SC = 0x28;
    4d3e:	4b45      	ldr	r3, [pc, #276]	; (4e54 <_init_Teensyduino_internal_+0x180>)
    4d40:	2228      	movs	r2, #40	; 0x28
    4d42:	601a      	str	r2, [r3, #0]
	FTM3_C1SC = 0x28;
    4d44:	4b44      	ldr	r3, [pc, #272]	; (4e58 <_init_Teensyduino_internal_+0x184>)
    4d46:	2228      	movs	r2, #40	; 0x28
    4d48:	601a      	str	r2, [r3, #0]
	FTM3_C2SC = 0x28;
    4d4a:	4b44      	ldr	r3, [pc, #272]	; (4e5c <_init_Teensyduino_internal_+0x188>)
    4d4c:	2228      	movs	r2, #40	; 0x28
    4d4e:	601a      	str	r2, [r3, #0]
	FTM3_C3SC = 0x28;
    4d50:	4b43      	ldr	r3, [pc, #268]	; (4e60 <_init_Teensyduino_internal_+0x18c>)
    4d52:	2228      	movs	r2, #40	; 0x28
    4d54:	601a      	str	r2, [r3, #0]
	FTM3_C4SC = 0x28;
    4d56:	4b43      	ldr	r3, [pc, #268]	; (4e64 <_init_Teensyduino_internal_+0x190>)
    4d58:	2228      	movs	r2, #40	; 0x28
    4d5a:	601a      	str	r2, [r3, #0]
	FTM3_C5SC = 0x28;
    4d5c:	4b42      	ldr	r3, [pc, #264]	; (4e68 <_init_Teensyduino_internal_+0x194>)
    4d5e:	2228      	movs	r2, #40	; 0x28
    4d60:	601a      	str	r2, [r3, #0]
	FTM3_C6SC = 0x28;
    4d62:	4b42      	ldr	r3, [pc, #264]	; (4e6c <_init_Teensyduino_internal_+0x198>)
    4d64:	2228      	movs	r2, #40	; 0x28
    4d66:	601a      	str	r2, [r3, #0]
	FTM3_C7SC = 0x28;
    4d68:	4b41      	ldr	r3, [pc, #260]	; (4e70 <_init_Teensyduino_internal_+0x19c>)
    4d6a:	2228      	movs	r2, #40	; 0x28
    4d6c:	601a      	str	r2, [r3, #0]
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    4d6e:	4b41      	ldr	r3, [pc, #260]	; (4e74 <_init_Teensyduino_internal_+0x1a0>)
    4d70:	220a      	movs	r2, #10
    4d72:	601a      	str	r2, [r3, #0]
	FTM1_CNT = 0;
    4d74:	4b40      	ldr	r3, [pc, #256]	; (4e78 <_init_Teensyduino_internal_+0x1a4>)
    4d76:	2200      	movs	r2, #0
    4d78:	601a      	str	r2, [r3, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    4d7a:	4b40      	ldr	r3, [pc, #256]	; (4e7c <_init_Teensyduino_internal_+0x1a8>)
    4d7c:	f24b 32ff 	movw	r2, #46079	; 0xb3ff
    4d80:	601a      	str	r2, [r3, #0]
	FTM1_C0SC = 0x28;
    4d82:	4b3f      	ldr	r3, [pc, #252]	; (4e80 <_init_Teensyduino_internal_+0x1ac>)
    4d84:	2228      	movs	r2, #40	; 0x28
    4d86:	601a      	str	r2, [r3, #0]
	FTM1_C1SC = 0x28;
    4d88:	4b3e      	ldr	r3, [pc, #248]	; (4e84 <_init_Teensyduino_internal_+0x1b0>)
    4d8a:	2228      	movs	r2, #40	; 0x28
    4d8c:	601a      	str	r2, [r3, #0]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    4d8e:	4b3e      	ldr	r3, [pc, #248]	; (4e88 <_init_Teensyduino_internal_+0x1b4>)
    4d90:	220a      	movs	r2, #10
    4d92:	601a      	str	r2, [r3, #0]
	FTM2_CNT = 0;
    4d94:	4b3d      	ldr	r3, [pc, #244]	; (4e8c <_init_Teensyduino_internal_+0x1b8>)
    4d96:	2200      	movs	r2, #0
    4d98:	601a      	str	r2, [r3, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    4d9a:	4b3d      	ldr	r3, [pc, #244]	; (4e90 <_init_Teensyduino_internal_+0x1bc>)
    4d9c:	f24b 32ff 	movw	r2, #46079	; 0xb3ff
    4da0:	601a      	str	r2, [r3, #0]
	FTM2_C0SC = 0x28;
    4da2:	4b3c      	ldr	r3, [pc, #240]	; (4e94 <_init_Teensyduino_internal_+0x1c0>)
    4da4:	2228      	movs	r2, #40	; 0x28
    4da6:	601a      	str	r2, [r3, #0]
	FTM2_C1SC = 0x28;
    4da8:	4b3b      	ldr	r3, [pc, #236]	; (4e98 <_init_Teensyduino_internal_+0x1c4>)
    4daa:	2228      	movs	r2, #40	; 0x28
    4dac:	601a      	str	r2, [r3, #0]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    4dae:	4b3b      	ldr	r3, [pc, #236]	; (4e9c <_init_Teensyduino_internal_+0x1c8>)
    4db0:	220a      	movs	r2, #10
    4db2:	601a      	str	r2, [r3, #0]
	FTM3_CNT = 0;
    4db4:	4b3a      	ldr	r3, [pc, #232]	; (4ea0 <_init_Teensyduino_internal_+0x1cc>)
    4db6:	2200      	movs	r2, #0
    4db8:	601a      	str	r2, [r3, #0]
	FTM3_MOD = DEFAULT_FTM_MOD;
    4dba:	4b3a      	ldr	r3, [pc, #232]	; (4ea4 <_init_Teensyduino_internal_+0x1d0>)
    4dbc:	f24b 32ff 	movw	r2, #46079	; 0xb3ff
    4dc0:	601a      	str	r2, [r3, #0]
	FTM3_C0SC = 0x28;
    4dc2:	4b24      	ldr	r3, [pc, #144]	; (4e54 <_init_Teensyduino_internal_+0x180>)
    4dc4:	2228      	movs	r2, #40	; 0x28
    4dc6:	601a      	str	r2, [r3, #0]
	FTM3_C1SC = 0x28;
    4dc8:	4b23      	ldr	r3, [pc, #140]	; (4e58 <_init_Teensyduino_internal_+0x184>)
    4dca:	2228      	movs	r2, #40	; 0x28
    4dcc:	601a      	str	r2, [r3, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    4dce:	4b36      	ldr	r3, [pc, #216]	; (4ea8 <_init_Teensyduino_internal_+0x1d4>)
    4dd0:	220a      	movs	r2, #10
    4dd2:	601a      	str	r2, [r3, #0]
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    4dd4:	4b35      	ldr	r3, [pc, #212]	; (4eac <_init_Teensyduino_internal_+0x1d8>)
    4dd6:	681b      	ldr	r3, [r3, #0]
    4dd8:	4a34      	ldr	r2, [pc, #208]	; (4eac <_init_Teensyduino_internal_+0x1d8>)
    4dda:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    4dde:	6013      	str	r3, [r2, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    4de0:	4b33      	ldr	r3, [pc, #204]	; (4eb0 <_init_Teensyduino_internal_+0x1dc>)
    4de2:	681b      	ldr	r3, [r3, #0]
    4de4:	4a32      	ldr	r2, [pc, #200]	; (4eb0 <_init_Teensyduino_internal_+0x1dc>)
    4de6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    4dea:	6013      	str	r3, [r2, #0]
	TPM1_CNT = 0;
    4dec:	4b31      	ldr	r3, [pc, #196]	; (4eb4 <_init_Teensyduino_internal_+0x1e0>)
    4dee:	2200      	movs	r2, #0
    4df0:	601a      	str	r2, [r3, #0]
	TPM1_MOD = 32767;
    4df2:	4b31      	ldr	r3, [pc, #196]	; (4eb8 <_init_Teensyduino_internal_+0x1e4>)
    4df4:	f647 72ff 	movw	r2, #32767	; 0x7fff
    4df8:	601a      	str	r2, [r3, #0]
	TPM1_C0SC = 0x28;
    4dfa:	4b30      	ldr	r3, [pc, #192]	; (4ebc <_init_Teensyduino_internal_+0x1e8>)
    4dfc:	2228      	movs	r2, #40	; 0x28
    4dfe:	601a      	str	r2, [r3, #0]
	TPM1_C1SC = 0x28;
    4e00:	4b2f      	ldr	r3, [pc, #188]	; (4ec0 <_init_Teensyduino_internal_+0x1ec>)
    4e02:	2228      	movs	r2, #40	; 0x28
    4e04:	601a      	str	r2, [r3, #0]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    4e06:	4b2f      	ldr	r3, [pc, #188]	; (4ec4 <_init_Teensyduino_internal_+0x1f0>)
    4e08:	2208      	movs	r2, #8
    4e0a:	601a      	str	r2, [r3, #0]
	analog_init();
    4e0c:	f002 f820 	bl	6e50 <analog_init>
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    4e10:	2019      	movs	r0, #25
    4e12:	f000 f893 	bl	4f3c <delay>
	usb_init();
    4e16:	f001 f8d3 	bl	5fc0 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    4e1a:	f240 1013 	movw	r0, #275	; 0x113
    4e1e:	f000 f88d 	bl	4f3c <delay>
}
    4e22:	bf00      	nop
    4e24:	bd80      	pop	{r7, pc}
    4e26:	bf00      	nop
    4e28:	e000e104 	.word	0xe000e104
    4e2c:	40038004 	.word	0x40038004
    4e30:	40038008 	.word	0x40038008
    4e34:	4003800c 	.word	0x4003800c
    4e38:	40038014 	.word	0x40038014
    4e3c:	4003801c 	.word	0x4003801c
    4e40:	40038024 	.word	0x40038024
    4e44:	4003802c 	.word	0x4003802c
    4e48:	40038034 	.word	0x40038034
    4e4c:	4003803c 	.word	0x4003803c
    4e50:	40038044 	.word	0x40038044
    4e54:	400b900c 	.word	0x400b900c
    4e58:	400b9014 	.word	0x400b9014
    4e5c:	400b901c 	.word	0x400b901c
    4e60:	400b9024 	.word	0x400b9024
    4e64:	400b902c 	.word	0x400b902c
    4e68:	400b9034 	.word	0x400b9034
    4e6c:	400b903c 	.word	0x400b903c
    4e70:	400b9044 	.word	0x400b9044
    4e74:	40038000 	.word	0x40038000
    4e78:	40039004 	.word	0x40039004
    4e7c:	40039008 	.word	0x40039008
    4e80:	4003900c 	.word	0x4003900c
    4e84:	40039014 	.word	0x40039014
    4e88:	40039000 	.word	0x40039000
    4e8c:	400b8004 	.word	0x400b8004
    4e90:	400b8008 	.word	0x400b8008
    4e94:	400b800c 	.word	0x400b800c
    4e98:	400b8014 	.word	0x400b8014
    4e9c:	400b8000 	.word	0x400b8000
    4ea0:	400b9004 	.word	0x400b9004
    4ea4:	400b9008 	.word	0x400b9008
    4ea8:	400b9000 	.word	0x400b9000
    4eac:	4004802c 	.word	0x4004802c
    4eb0:	40048004 	.word	0x40048004
    4eb4:	400c9004 	.word	0x400c9004
    4eb8:	400c9008 	.word	0x400c9008
    4ebc:	400c900c 	.word	0x400c900c
    4ec0:	400c9014 	.word	0x400c9014
    4ec4:	400c9000 	.word	0x400c9000

00004ec8 <micros>:
volatile uint32_t systick_millis_count = 0;

//uint32_t systick_current, systick_count, systick_istatus;  // testing only

uint32_t micros(void)
{
    4ec8:	b480      	push	{r7}
    4eca:	b085      	sub	sp, #20
    4ecc:	af00      	add	r7, sp, #0
	uint32_t count, current, istatus;

	__disable_irq();
    4ece:	b672      	cpsid	i
	current = SYST_CVR;
    4ed0:	4b16      	ldr	r3, [pc, #88]	; (4f2c <micros+0x64>)
    4ed2:	681b      	ldr	r3, [r3, #0]
    4ed4:	60bb      	str	r3, [r7, #8]
	count = systick_millis_count;
    4ed6:	4b16      	ldr	r3, [pc, #88]	; (4f30 <micros+0x68>)
    4ed8:	681b      	ldr	r3, [r3, #0]
    4eda:	60fb      	str	r3, [r7, #12]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    4edc:	4b15      	ldr	r3, [pc, #84]	; (4f34 <micros+0x6c>)
    4ede:	681b      	ldr	r3, [r3, #0]
    4ee0:	607b      	str	r3, [r7, #4]
	__enable_irq();
    4ee2:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    4ee4:	687b      	ldr	r3, [r7, #4]
    4ee6:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
    4eea:	2b00      	cmp	r3, #0
    4eec:	d005      	beq.n	4efa <micros+0x32>
    4eee:	68bb      	ldr	r3, [r7, #8]
    4ef0:	2b32      	cmp	r3, #50	; 0x32
    4ef2:	d902      	bls.n	4efa <micros+0x32>
    4ef4:	68fb      	ldr	r3, [r7, #12]
    4ef6:	3301      	adds	r3, #1
    4ef8:	60fb      	str	r3, [r7, #12]
	current = ((F_CPU / 1000) - 1) - current;
    4efa:	68bb      	ldr	r3, [r7, #8]
    4efc:	f5c3 332f 	rsb	r3, r3, #179200	; 0x2bc00
    4f00:	f203 331f 	addw	r3, r3, #799	; 0x31f
    4f04:	60bb      	str	r3, [r7, #8]
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    4f06:	68fb      	ldr	r3, [r7, #12]
    4f08:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    4f0c:	fb03 f202 	mul.w	r2, r3, r2
    4f10:	68bb      	ldr	r3, [r7, #8]
    4f12:	089b      	lsrs	r3, r3, #2
    4f14:	4908      	ldr	r1, [pc, #32]	; (4f38 <micros+0x70>)
    4f16:	fba1 1303 	umull	r1, r3, r1, r3
    4f1a:	089b      	lsrs	r3, r3, #2
    4f1c:	4413      	add	r3, r2
}
    4f1e:	4618      	mov	r0, r3
    4f20:	3714      	adds	r7, #20
    4f22:	46bd      	mov	sp, r7
    4f24:	f85d 7b04 	ldr.w	r7, [sp], #4
    4f28:	4770      	bx	lr
    4f2a:	bf00      	nop
    4f2c:	e000e018 	.word	0xe000e018
    4f30:	1fff1308 	.word	0x1fff1308
    4f34:	e000ed04 	.word	0xe000ed04
    4f38:	16c16c17 	.word	0x16c16c17

00004f3c <delay>:

void delay(uint32_t ms)
{
    4f3c:	b580      	push	{r7, lr}
    4f3e:	b084      	sub	sp, #16
    4f40:	af00      	add	r7, sp, #0
    4f42:	6078      	str	r0, [r7, #4]
	uint32_t start = micros();
    4f44:	f7ff ffc0 	bl	4ec8 <micros>
    4f48:	60f8      	str	r0, [r7, #12]

	if (ms > 0) {
    4f4a:	687b      	ldr	r3, [r7, #4]
    4f4c:	2b00      	cmp	r3, #0
    4f4e:	d016      	beq.n	4f7e <delay+0x42>
		while (1) {
			while ((micros() - start) >= 1000) {
    4f50:	e009      	b.n	4f66 <delay+0x2a>
				ms--;
    4f52:	687b      	ldr	r3, [r7, #4]
    4f54:	3b01      	subs	r3, #1
    4f56:	607b      	str	r3, [r7, #4]
				if (ms == 0) return;
    4f58:	687b      	ldr	r3, [r7, #4]
    4f5a:	2b00      	cmp	r3, #0
    4f5c:	d00e      	beq.n	4f7c <delay+0x40>
				start += 1000;
    4f5e:	68fb      	ldr	r3, [r7, #12]
    4f60:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
    4f64:	60fb      	str	r3, [r7, #12]
			while ((micros() - start) >= 1000) {
    4f66:	f7ff ffaf 	bl	4ec8 <micros>
    4f6a:	4602      	mov	r2, r0
    4f6c:	68fb      	ldr	r3, [r7, #12]
    4f6e:	1ad3      	subs	r3, r2, r3
    4f70:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    4f74:	d2ed      	bcs.n	4f52 <delay+0x16>
			}
			yield();
    4f76:	f001 ff1f 	bl	6db8 <yield>
			while ((micros() - start) >= 1000) {
    4f7a:	e7f4      	b.n	4f66 <delay+0x2a>
				if (ms == 0) return;
    4f7c:	bf00      	nop
		}
	}
}
    4f7e:	3710      	adds	r7, #16
    4f80:	46bd      	mov	sp, r7
    4f82:	bd80      	pop	{r7, pc}

00004f84 <_ZSt5isinfd>:
  && !_GLIBCXX_NO_OBSOLETE_ISINF_ISNAN_DYNAMIC
  using ::isinf;
#else
  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }
    4f84:	b5f0      	push	{r4, r5, r6, r7, lr}
    4f86:	b083      	sub	sp, #12
    4f88:	af00      	add	r7, sp, #0
    4f8a:	ed87 0b00 	vstr	d0, [r7]
    4f8e:	683c      	ldr	r4, [r7, #0]
    4f90:	687b      	ldr	r3, [r7, #4]
    4f92:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
    4f96:	2301      	movs	r3, #1
    4f98:	461e      	mov	r6, r3
    4f9a:	f04f 32ff 	mov.w	r2, #4294967295
    4f9e:	4b10      	ldr	r3, [pc, #64]	; (4fe0 <_ZSt5isinfd+0x5c>)
    4fa0:	4620      	mov	r0, r4
    4fa2:	4629      	mov	r1, r5
    4fa4:	f008 ffc8 	bl	df38 <__aeabi_dcmpun>
    4fa8:	4603      	mov	r3, r0
    4faa:	2b00      	cmp	r3, #0
    4fac:	d10b      	bne.n	4fc6 <_ZSt5isinfd+0x42>
    4fae:	f04f 32ff 	mov.w	r2, #4294967295
    4fb2:	4b0b      	ldr	r3, [pc, #44]	; (4fe0 <_ZSt5isinfd+0x5c>)
    4fb4:	4620      	mov	r0, r4
    4fb6:	4629      	mov	r1, r5
    4fb8:	f008 ffa0 	bl	defc <__aeabi_dcmple>
    4fbc:	4603      	mov	r3, r0
    4fbe:	2b00      	cmp	r3, #0
    4fc0:	d101      	bne.n	4fc6 <_ZSt5isinfd+0x42>
    4fc2:	2300      	movs	r3, #0
    4fc4:	461e      	mov	r6, r3
    4fc6:	b2f3      	uxtb	r3, r6
    4fc8:	f083 0301 	eor.w	r3, r3, #1
    4fcc:	b2db      	uxtb	r3, r3
    4fce:	2b00      	cmp	r3, #0
    4fd0:	bf14      	ite	ne
    4fd2:	2301      	movne	r3, #1
    4fd4:	2300      	moveq	r3, #0
    4fd6:	b2db      	uxtb	r3, r3
    4fd8:	4618      	mov	r0, r3
    4fda:	370c      	adds	r7, #12
    4fdc:	46bd      	mov	sp, r7
    4fde:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4fe0:	7fefffff 	.word	0x7fefffff

00004fe4 <_ZSt5isnand>:
  && !_GLIBCXX_NO_OBSOLETE_ISINF_ISNAN_DYNAMIC
  using ::isnan;
#else
  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }
    4fe4:	b590      	push	{r4, r7, lr}
    4fe6:	b083      	sub	sp, #12
    4fe8:	af00      	add	r7, sp, #0
    4fea:	ed87 0b00 	vstr	d0, [r7]
    4fee:	2301      	movs	r3, #1
    4ff0:	461c      	mov	r4, r3
    4ff2:	e9d7 2300 	ldrd	r2, r3, [r7]
    4ff6:	e9d7 0100 	ldrd	r0, r1, [r7]
    4ffa:	f008 ff9d 	bl	df38 <__aeabi_dcmpun>
    4ffe:	4603      	mov	r3, r0
    5000:	2b00      	cmp	r3, #0
    5002:	d101      	bne.n	5008 <_ZSt5isnand+0x24>
    5004:	2300      	movs	r3, #0
    5006:	461c      	mov	r4, r3
    5008:	b2e3      	uxtb	r3, r4
    500a:	2b00      	cmp	r3, #0
    500c:	bf14      	ite	ne
    500e:	2301      	movne	r3, #1
    5010:	2300      	moveq	r3, #0
    5012:	b2db      	uxtb	r3, r3
    5014:	4618      	mov	r0, r3
    5016:	370c      	adds	r7, #12
    5018:	46bd      	mov	sp, r7
    501a:	bd90      	pop	{r4, r7, pc}

0000501c <_ZN5Print5printERK6String>:
	return count;
}


size_t Print::print(const String &s)
{
    501c:	b580      	push	{r7, lr}
    501e:	b090      	sub	sp, #64	; 0x40
    5020:	af00      	add	r7, sp, #0
    5022:	6078      	str	r0, [r7, #4]
    5024:	6039      	str	r1, [r7, #0]
	uint8_t buffer[33];
	size_t count = 0;
    5026:	2300      	movs	r3, #0
    5028:	63fb      	str	r3, [r7, #60]	; 0x3c
	unsigned int index = 0;
    502a:	2300      	movs	r3, #0
    502c:	63bb      	str	r3, [r7, #56]	; 0x38
	unsigned int len = s.length();
    502e:	6838      	ldr	r0, [r7, #0]
    5030:	f7fb fa52 	bl	4d8 <_ZNK6String6lengthEv>
    5034:	6378      	str	r0, [r7, #52]	; 0x34
	while (len > 0) {
    5036:	e022      	b.n	507e <_ZN5Print5printERK6String+0x62>
		s.getBytes(buffer, sizeof(buffer), index);
    5038:	f107 010c 	add.w	r1, r7, #12
    503c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    503e:	2221      	movs	r2, #33	; 0x21
    5040:	6838      	ldr	r0, [r7, #0]
    5042:	f001 fcf5 	bl	6a30 <_ZNK6String8getBytesEPhjj>
		unsigned int nbytes = len;
    5046:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    5048:	633b      	str	r3, [r7, #48]	; 0x30
		if (nbytes > sizeof(buffer)-1) nbytes = sizeof(buffer)-1;
    504a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    504c:	2b20      	cmp	r3, #32
    504e:	d901      	bls.n	5054 <_ZN5Print5printERK6String+0x38>
    5050:	2320      	movs	r3, #32
    5052:	633b      	str	r3, [r7, #48]	; 0x30
		index += nbytes;
    5054:	6bba      	ldr	r2, [r7, #56]	; 0x38
    5056:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    5058:	4413      	add	r3, r2
    505a:	63bb      	str	r3, [r7, #56]	; 0x38
		len -= nbytes;
    505c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    505e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    5060:	1ad3      	subs	r3, r2, r3
    5062:	637b      	str	r3, [r7, #52]	; 0x34
		count += write(buffer, nbytes);
    5064:	687b      	ldr	r3, [r7, #4]
    5066:	681b      	ldr	r3, [r3, #0]
    5068:	3304      	adds	r3, #4
    506a:	681b      	ldr	r3, [r3, #0]
    506c:	f107 010c 	add.w	r1, r7, #12
    5070:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    5072:	6878      	ldr	r0, [r7, #4]
    5074:	4798      	blx	r3
    5076:	4602      	mov	r2, r0
    5078:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    507a:	4413      	add	r3, r2
    507c:	63fb      	str	r3, [r7, #60]	; 0x3c
	while (len > 0) {
    507e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    5080:	2b00      	cmp	r3, #0
    5082:	d1d9      	bne.n	5038 <_ZN5Print5printERK6String+0x1c>
	}
	return count;
    5084:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
    5086:	4618      	mov	r0, r3
    5088:	3740      	adds	r7, #64	; 0x40
    508a:	46bd      	mov	sp, r7
    508c:	bd80      	pop	{r7, pc}

0000508e <_ZN5Print5printEl>:


size_t Print::print(long n)
{
    508e:	b580      	push	{r7, lr}
    5090:	b084      	sub	sp, #16
    5092:	af00      	add	r7, sp, #0
    5094:	6078      	str	r0, [r7, #4]
    5096:	6039      	str	r1, [r7, #0]
	uint8_t sign=0;
    5098:	2300      	movs	r3, #0
    509a:	73fb      	strb	r3, [r7, #15]

	if (n < 0) {
    509c:	683b      	ldr	r3, [r7, #0]
    509e:	2b00      	cmp	r3, #0
    50a0:	da04      	bge.n	50ac <_ZN5Print5printEl+0x1e>
		sign = '-';
    50a2:	232d      	movs	r3, #45	; 0x2d
    50a4:	73fb      	strb	r3, [r7, #15]
		n = -n;
    50a6:	683b      	ldr	r3, [r7, #0]
    50a8:	425b      	negs	r3, r3
    50aa:	603b      	str	r3, [r7, #0]
	}
	return printNumber(n, 10, sign);
    50ac:	6839      	ldr	r1, [r7, #0]
    50ae:	7bfb      	ldrb	r3, [r7, #15]
    50b0:	220a      	movs	r2, #10
    50b2:	6878      	ldr	r0, [r7, #4]
    50b4:	f000 f81a 	bl	50ec <_ZN5Print11printNumberEmhh>
    50b8:	4603      	mov	r3, r0
}
    50ba:	4618      	mov	r0, r3
    50bc:	3710      	adds	r7, #16
    50be:	46bd      	mov	sp, r7
    50c0:	bd80      	pop	{r7, pc}

000050c2 <_ZN5Print7printlnEv>:


size_t Print::println(void)
{
    50c2:	b580      	push	{r7, lr}
    50c4:	b084      	sub	sp, #16
    50c6:	af00      	add	r7, sp, #0
    50c8:	6078      	str	r0, [r7, #4]
	uint8_t buf[2]={'\r', '\n'};
    50ca:	f640 230d 	movw	r3, #2573	; 0xa0d
    50ce:	81bb      	strh	r3, [r7, #12]
	return write(buf, 2);
    50d0:	687b      	ldr	r3, [r7, #4]
    50d2:	681b      	ldr	r3, [r3, #0]
    50d4:	3304      	adds	r3, #4
    50d6:	681b      	ldr	r3, [r3, #0]
    50d8:	f107 010c 	add.w	r1, r7, #12
    50dc:	2202      	movs	r2, #2
    50de:	6878      	ldr	r0, [r7, #4]
    50e0:	4798      	blx	r3
    50e2:	4603      	mov	r3, r0
}
    50e4:	4618      	mov	r0, r3
    50e6:	3710      	adds	r7, #16
    50e8:	46bd      	mov	sp, r7
    50ea:	bd80      	pop	{r7, pc}

000050ec <_ZN5Print11printNumberEmhh>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    50ec:	b580      	push	{r7, lr}
    50ee:	b08e      	sub	sp, #56	; 0x38
    50f0:	af00      	add	r7, sp, #0
    50f2:	60f8      	str	r0, [r7, #12]
    50f4:	60b9      	str	r1, [r7, #8]
    50f6:	4611      	mov	r1, r2
    50f8:	461a      	mov	r2, r3
    50fa:	460b      	mov	r3, r1
    50fc:	71fb      	strb	r3, [r7, #7]
    50fe:	4613      	mov	r3, r2
    5100:	71bb      	strb	r3, [r7, #6]
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    5102:	79fb      	ldrb	r3, [r7, #7]
    5104:	2b00      	cmp	r3, #0
    5106:	d109      	bne.n	511c <_ZN5Print11printNumberEmhh+0x30>
		return write((uint8_t)n);
    5108:	68fb      	ldr	r3, [r7, #12]
    510a:	681b      	ldr	r3, [r3, #0]
    510c:	681b      	ldr	r3, [r3, #0]
    510e:	68ba      	ldr	r2, [r7, #8]
    5110:	b2d2      	uxtb	r2, r2
    5112:	4611      	mov	r1, r2
    5114:	68f8      	ldr	r0, [r7, #12]
    5116:	4798      	blx	r3
    5118:	4603      	mov	r3, r0
    511a:	e05c      	b.n	51d6 <_ZN5Print11printNumberEmhh+0xea>
	} else if (base == 1) {
    511c:	79fb      	ldrb	r3, [r7, #7]
    511e:	2b01      	cmp	r3, #1
    5120:	d101      	bne.n	5126 <_ZN5Print11printNumberEmhh+0x3a>
		base = 10;
    5122:	230a      	movs	r3, #10
    5124:	71fb      	strb	r3, [r7, #7]
	}


	if (n == 0) {
    5126:	68bb      	ldr	r3, [r7, #8]
    5128:	2b00      	cmp	r3, #0
    512a:	d106      	bne.n	513a <_ZN5Print11printNumberEmhh+0x4e>
		buf[sizeof(buf) - 1] = '0';
    512c:	2330      	movs	r3, #48	; 0x30
    512e:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
		i = sizeof(buf) - 1;
    5132:	2321      	movs	r3, #33	; 0x21
    5134:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    5138:	e02d      	b.n	5196 <_ZN5Print11printNumberEmhh+0xaa>
	} else {
		i = sizeof(buf) - 1;
    513a:	2321      	movs	r3, #33	; 0x21
    513c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		while (1) {
			digit = n % base;
    5140:	79fa      	ldrb	r2, [r7, #7]
    5142:	68bb      	ldr	r3, [r7, #8]
    5144:	fbb3 f1f2 	udiv	r1, r3, r2
    5148:	fb01 f202 	mul.w	r2, r1, r2
    514c:	1a9b      	subs	r3, r3, r2
    514e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    5152:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
    5156:	2b09      	cmp	r3, #9
    5158:	d804      	bhi.n	5164 <_ZN5Print11printNumberEmhh+0x78>
    515a:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
    515e:	3330      	adds	r3, #48	; 0x30
    5160:	b2db      	uxtb	r3, r3
    5162:	e003      	b.n	516c <_ZN5Print11printNumberEmhh+0x80>
    5164:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
    5168:	3337      	adds	r3, #55	; 0x37
    516a:	b2db      	uxtb	r3, r3
    516c:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
    5170:	3238      	adds	r2, #56	; 0x38
    5172:	443a      	add	r2, r7
    5174:	f802 3c24 	strb.w	r3, [r2, #-36]
			n /= base;
    5178:	79fb      	ldrb	r3, [r7, #7]
    517a:	68ba      	ldr	r2, [r7, #8]
    517c:	fbb2 f3f3 	udiv	r3, r2, r3
    5180:	60bb      	str	r3, [r7, #8]
			if (n == 0) break;
    5182:	68bb      	ldr	r3, [r7, #8]
    5184:	2b00      	cmp	r3, #0
    5186:	d005      	beq.n	5194 <_ZN5Print11printNumberEmhh+0xa8>
			i--;
    5188:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    518c:	3b01      	subs	r3, #1
    518e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
			digit = n % base;
    5192:	e7d5      	b.n	5140 <_ZN5Print11printNumberEmhh+0x54>
			if (n == 0) break;
    5194:	bf00      	nop
		}
	}
	if (sign) {
    5196:	79bb      	ldrb	r3, [r7, #6]
    5198:	2b00      	cmp	r3, #0
    519a:	d00b      	beq.n	51b4 <_ZN5Print11printNumberEmhh+0xc8>
		i--;
    519c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    51a0:	3b01      	subs	r3, #1
    51a2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		buf[i] = '-';
    51a6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
    51aa:	3338      	adds	r3, #56	; 0x38
    51ac:	443b      	add	r3, r7
    51ae:	222d      	movs	r2, #45	; 0x2d
    51b0:	f803 2c24 	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    51b4:	68fb      	ldr	r3, [r7, #12]
    51b6:	681b      	ldr	r3, [r3, #0]
    51b8:	3304      	adds	r3, #4
    51ba:	681b      	ldr	r3, [r3, #0]
    51bc:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
    51c0:	f107 0114 	add.w	r1, r7, #20
    51c4:	4411      	add	r1, r2
    51c6:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
    51ca:	f1c2 0222 	rsb	r2, r2, #34	; 0x22
    51ce:	68f8      	ldr	r0, [r7, #12]
    51d0:	4798      	blx	r3
    51d2:	4603      	mov	r3, r0
    51d4:	bf00      	nop
}
    51d6:	4618      	mov	r0, r3
    51d8:	3738      	adds	r7, #56	; 0x38
    51da:	46bd      	mov	sp, r7
    51dc:	bd80      	pop	{r7, pc}
    51de:	Address 0x000051de is out of bounds.


000051e0 <_ZN5Print10printFloatEdh>:

#endif

size_t Print::printFloat(double number, uint8_t digits) 
{
    51e0:	b5b0      	push	{r4, r5, r7, lr}
    51e2:	b094      	sub	sp, #80	; 0x50
    51e4:	af00      	add	r7, sp, #0
    51e6:	60f8      	str	r0, [r7, #12]
    51e8:	ed87 0b00 	vstr	d0, [r7]
    51ec:	460b      	mov	r3, r1
    51ee:	72fb      	strb	r3, [r7, #11]
	uint8_t sign=0;
    51f0:	2300      	movs	r3, #0
    51f2:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
	size_t count=0;
    51f6:	2300      	movs	r3, #0
    51f8:	62bb      	str	r3, [r7, #40]	; 0x28

	if (isnan(number)) return print("nan");
    51fa:	ed97 0b00 	vldr	d0, [r7]
    51fe:	f7ff fef1 	bl	4fe4 <_ZSt5isnand>
    5202:	4603      	mov	r3, r0
    5204:	2b00      	cmp	r3, #0
    5206:	d005      	beq.n	5214 <_ZN5Print10printFloatEdh+0x34>
    5208:	4977      	ldr	r1, [pc, #476]	; (53e8 <_ZN5Print10printFloatEdh+0x208>)
    520a:	68f8      	ldr	r0, [r7, #12]
    520c:	f7fb f9d8 	bl	5c0 <_ZN5Print5printEPKc>
    5210:	4603      	mov	r3, r0
    5212:	e0de      	b.n	53d2 <_ZN5Print10printFloatEdh+0x1f2>
    	if (isinf(number)) return print("inf");
    5214:	ed97 0b00 	vldr	d0, [r7]
    5218:	f7ff feb4 	bl	4f84 <_ZSt5isinfd>
    521c:	4603      	mov	r3, r0
    521e:	2b00      	cmp	r3, #0
    5220:	d005      	beq.n	522e <_ZN5Print10printFloatEdh+0x4e>
    5222:	4972      	ldr	r1, [pc, #456]	; (53ec <_ZN5Print10printFloatEdh+0x20c>)
    5224:	68f8      	ldr	r0, [r7, #12]
    5226:	f7fb f9cb 	bl	5c0 <_ZN5Print5printEPKc>
    522a:	4603      	mov	r3, r0
    522c:	e0d1      	b.n	53d2 <_ZN5Print10printFloatEdh+0x1f2>
    	if (number > 4294967040.0f) return print("ovf");  // constant determined empirically
    522e:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
    5232:	4b6f      	ldr	r3, [pc, #444]	; (53f0 <_ZN5Print10printFloatEdh+0x210>)
    5234:	e9d7 0100 	ldrd	r0, r1, [r7]
    5238:	f008 fe74 	bl	df24 <__aeabi_dcmpgt>
    523c:	4603      	mov	r3, r0
    523e:	2b00      	cmp	r3, #0
    5240:	d005      	beq.n	524e <_ZN5Print10printFloatEdh+0x6e>
    5242:	496c      	ldr	r1, [pc, #432]	; (53f4 <_ZN5Print10printFloatEdh+0x214>)
    5244:	68f8      	ldr	r0, [r7, #12]
    5246:	f7fb f9bb 	bl	5c0 <_ZN5Print5printEPKc>
    524a:	4603      	mov	r3, r0
    524c:	e0c1      	b.n	53d2 <_ZN5Print10printFloatEdh+0x1f2>
    	if (number <-4294967040.0f) return print("ovf");  // constant determined empirically
    524e:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
    5252:	4b69      	ldr	r3, [pc, #420]	; (53f8 <_ZN5Print10printFloatEdh+0x218>)
    5254:	e9d7 0100 	ldrd	r0, r1, [r7]
    5258:	f008 fe46 	bl	dee8 <__aeabi_dcmplt>
    525c:	4603      	mov	r3, r0
    525e:	2b00      	cmp	r3, #0
    5260:	d005      	beq.n	526e <_ZN5Print10printFloatEdh+0x8e>
    5262:	4964      	ldr	r1, [pc, #400]	; (53f4 <_ZN5Print10printFloatEdh+0x214>)
    5264:	68f8      	ldr	r0, [r7, #12]
    5266:	f7fb f9ab 	bl	5c0 <_ZN5Print5printEPKc>
    526a:	4603      	mov	r3, r0
    526c:	e0b1      	b.n	53d2 <_ZN5Print10printFloatEdh+0x1f2>
	
	// Handle negative numbers
	if (number < 0.0) {
    526e:	f04f 0200 	mov.w	r2, #0
    5272:	f04f 0300 	mov.w	r3, #0
    5276:	e9d7 0100 	ldrd	r0, r1, [r7]
    527a:	f008 fe35 	bl	dee8 <__aeabi_dcmplt>
    527e:	4603      	mov	r3, r0
    5280:	2b00      	cmp	r3, #0
    5282:	d008      	beq.n	5296 <_ZN5Print10printFloatEdh+0xb6>
		sign = 1;
    5284:	2301      	movs	r3, #1
    5286:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
		number = -number;
    528a:	683c      	ldr	r4, [r7, #0]
    528c:	687b      	ldr	r3, [r7, #4]
    528e:	f083 4500 	eor.w	r5, r3, #2147483648	; 0x80000000
    5292:	e9c7 4500 	strd	r4, r5, [r7]
	}

	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
    5296:	f04f 0200 	mov.w	r2, #0
    529a:	4b58      	ldr	r3, [pc, #352]	; (53fc <_ZN5Print10printFloatEdh+0x21c>)
    529c:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40
	for (uint8_t i=0; i<digits; ++i) {
    52a0:	2300      	movs	r3, #0
    52a2:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    52a6:	e00f      	b.n	52c8 <_ZN5Print10printFloatEdh+0xe8>
		rounding *= 0.1;
    52a8:	a34d      	add	r3, pc, #308	; (adr r3, 53e0 <_ZN5Print10printFloatEdh+0x200>)
    52aa:	e9d3 2300 	ldrd	r2, r3, [r3]
    52ae:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
    52b2:	f008 fba7 	bl	da04 <__aeabi_dmul>
    52b6:	4602      	mov	r2, r0
    52b8:	460b      	mov	r3, r1
    52ba:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40
	for (uint8_t i=0; i<digits; ++i) {
    52be:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
    52c2:	3301      	adds	r3, #1
    52c4:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    52c8:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
    52cc:	7afb      	ldrb	r3, [r7, #11]
    52ce:	429a      	cmp	r2, r3
    52d0:	d3ea      	bcc.n	52a8 <_ZN5Print10printFloatEdh+0xc8>
	}
	number += rounding;
    52d2:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
    52d6:	e9d7 0100 	ldrd	r0, r1, [r7]
    52da:	f008 f9dd 	bl	d698 <__adddf3>
    52de:	4602      	mov	r2, r0
    52e0:	460b      	mov	r3, r1
    52e2:	e9c7 2300 	strd	r2, r3, [r7]

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
    52e6:	e9d7 0100 	ldrd	r0, r1, [r7]
    52ea:	f008 fe3b 	bl	df64 <__aeabi_d2uiz>
    52ee:	4603      	mov	r3, r0
    52f0:	627b      	str	r3, [r7, #36]	; 0x24
	double remainder = number - (double)int_part;
    52f2:	6a78      	ldr	r0, [r7, #36]	; 0x24
    52f4:	f008 fb0c 	bl	d910 <__aeabi_ui2d>
    52f8:	4602      	mov	r2, r0
    52fa:	460b      	mov	r3, r1
    52fc:	e9d7 0100 	ldrd	r0, r1, [r7]
    5300:	f008 f9c8 	bl	d694 <__aeabi_dsub>
    5304:	4602      	mov	r2, r0
    5306:	460b      	mov	r3, r1
    5308:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
	count += printNumber(int_part, 10, sign);
    530c:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
    5310:	220a      	movs	r2, #10
    5312:	6a79      	ldr	r1, [r7, #36]	; 0x24
    5314:	68f8      	ldr	r0, [r7, #12]
    5316:	f7ff fee9 	bl	50ec <_ZN5Print11printNumberEmhh>
    531a:	4602      	mov	r2, r0
    531c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    531e:	4413      	add	r3, r2
    5320:	62bb      	str	r3, [r7, #40]	; 0x28

	// Print the decimal point, but only if there are digits beyond
	if (digits > 0) {
    5322:	7afb      	ldrb	r3, [r7, #11]
    5324:	2b00      	cmp	r3, #0
    5326:	d053      	beq.n	53d0 <_ZN5Print10printFloatEdh+0x1f0>
		uint8_t n, buf[16], count=1;
    5328:	2301      	movs	r3, #1
    532a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		buf[0] = '.';
    532e:	232e      	movs	r3, #46	; 0x2e
    5330:	743b      	strb	r3, [r7, #16]

		// Extract digits from the remainder one at a time
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;
    5332:	7afb      	ldrb	r3, [r7, #11]
    5334:	2b0f      	cmp	r3, #15
    5336:	d930      	bls.n	539a <_ZN5Print10printFloatEdh+0x1ba>
    5338:	230f      	movs	r3, #15
    533a:	72fb      	strb	r3, [r7, #11]

		while (digits-- > 0) {
    533c:	e02d      	b.n	539a <_ZN5Print10printFloatEdh+0x1ba>
			remainder *= 10.0;
    533e:	f04f 0200 	mov.w	r2, #0
    5342:	4b2f      	ldr	r3, [pc, #188]	; (5400 <_ZN5Print10printFloatEdh+0x220>)
    5344:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
    5348:	f008 fb5c 	bl	da04 <__aeabi_dmul>
    534c:	4602      	mov	r2, r0
    534e:	460b      	mov	r3, r1
    5350:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
			n = (uint8_t)(remainder);
    5354:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
    5358:	f008 fe04 	bl	df64 <__aeabi_d2uiz>
    535c:	4603      	mov	r3, r0
    535e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
			buf[count++] = '0' + n;
    5362:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    5366:	3330      	adds	r3, #48	; 0x30
    5368:	b2da      	uxtb	r2, r3
    536a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    536e:	1c59      	adds	r1, r3, #1
    5370:	f887 102f 	strb.w	r1, [r7, #47]	; 0x2f
    5374:	3350      	adds	r3, #80	; 0x50
    5376:	443b      	add	r3, r7
    5378:	f803 2c40 	strb.w	r2, [r3, #-64]
			remainder -= n; 
    537c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    5380:	4618      	mov	r0, r3
    5382:	f008 fad5 	bl	d930 <__aeabi_i2d>
    5386:	4602      	mov	r2, r0
    5388:	460b      	mov	r3, r1
    538a:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	; 0x30
    538e:	f008 f981 	bl	d694 <__aeabi_dsub>
    5392:	4602      	mov	r2, r0
    5394:	460b      	mov	r3, r1
    5396:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
		while (digits-- > 0) {
    539a:	7afb      	ldrb	r3, [r7, #11]
    539c:	1e5a      	subs	r2, r3, #1
    539e:	72fa      	strb	r2, [r7, #11]
    53a0:	2b00      	cmp	r3, #0
    53a2:	bf14      	ite	ne
    53a4:	2301      	movne	r3, #1
    53a6:	2300      	moveq	r3, #0
    53a8:	b2db      	uxtb	r3, r3
    53aa:	2b00      	cmp	r3, #0
    53ac:	d1c7      	bne.n	533e <_ZN5Print10printFloatEdh+0x15e>
		}
		count += write(buf, count);
    53ae:	68fb      	ldr	r3, [r7, #12]
    53b0:	681b      	ldr	r3, [r3, #0]
    53b2:	3304      	adds	r3, #4
    53b4:	681b      	ldr	r3, [r3, #0]
    53b6:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
    53ba:	f107 0110 	add.w	r1, r7, #16
    53be:	68f8      	ldr	r0, [r7, #12]
    53c0:	4798      	blx	r3
    53c2:	4603      	mov	r3, r0
    53c4:	b2da      	uxtb	r2, r3
    53c6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    53ca:	4413      	add	r3, r2
    53cc:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	}
	return count;
    53d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
    53d2:	4618      	mov	r0, r3
    53d4:	3750      	adds	r7, #80	; 0x50
    53d6:	46bd      	mov	sp, r7
    53d8:	bdb0      	pop	{r4, r5, r7, pc}
    53da:	bf00      	nop
    53dc:	f3af 8000 	nop.w
    53e0:	a0000000 	.word	0xa0000000
    53e4:	3fb99999 	.word	0x3fb99999
    53e8:	0000f538 	.word	0x0000f538
    53ec:	0000f53c 	.word	0x0000f53c
    53f0:	41efffff 	.word	0x41efffff
    53f4:	0000f540 	.word	0x0000f540
    53f8:	c1efffff 	.word	0xc1efffff
    53fc:	3fe00000 	.word	0x3fe00000
    5400:	40240000 	.word	0x40240000

00005404 <_ZN6StringpLEc>:
	String & operator += (char c)			{return append(c);}
    5404:	b580      	push	{r7, lr}
    5406:	b082      	sub	sp, #8
    5408:	af00      	add	r7, sp, #0
    540a:	6078      	str	r0, [r7, #4]
    540c:	460b      	mov	r3, r1
    540e:	70fb      	strb	r3, [r7, #3]
    5410:	78fb      	ldrb	r3, [r7, #3]
    5412:	4619      	mov	r1, r3
    5414:	6878      	ldr	r0, [r7, #4]
    5416:	f001 fa76 	bl	6906 <_ZN6String6appendEc>
    541a:	4603      	mov	r3, r0
    541c:	4618      	mov	r0, r3
    541e:	3708      	adds	r7, #8
    5420:	46bd      	mov	sp, r7
    5422:	bd80      	pop	{r7, pc}

00005424 <_ZN6Stream12setReadErrorEi>:
	String readString(size_t max = 120);
	String readStringUntil(char terminator, size_t max = 120);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
    5424:	b480      	push	{r7}
    5426:	b083      	sub	sp, #12
    5428:	af00      	add	r7, sp, #0
    542a:	6078      	str	r0, [r7, #4]
    542c:	6039      	str	r1, [r7, #0]
    542e:	683b      	ldr	r3, [r7, #0]
    5430:	b2da      	uxtb	r2, r3
    5432:	687b      	ldr	r3, [r7, #4]
    5434:	731a      	strb	r2, [r3, #12]
    5436:	bf00      	nop
    5438:	370c      	adds	r7, #12
    543a:	46bd      	mov	sp, r7
    543c:	f85d 7b04 	ldr.w	r7, [sp], #4
    5440:	4770      	bx	lr
    5442:	Address 0x00005442 is out of bounds.


00005444 <_ZN6Stream9timedReadEv>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
    5444:	b580      	push	{r7, lr}
    5446:	b086      	sub	sp, #24
    5448:	af00      	add	r7, sp, #0
    544a:	6078      	str	r0, [r7, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    544c:	4b13      	ldr	r3, [pc, #76]	; (549c <_ZN6Stream9timedReadEv+0x58>)
    544e:	681b      	ldr	r3, [r3, #0]
    5450:	60bb      	str	r3, [r7, #8]
	return ret;
    5452:	68bb      	ldr	r3, [r7, #8]
  int c;
  unsigned long startMillis = millis();
    5454:	617b      	str	r3, [r7, #20]
  do {
    c = read();
    5456:	687b      	ldr	r3, [r7, #4]
    5458:	681b      	ldr	r3, [r3, #0]
    545a:	3314      	adds	r3, #20
    545c:	681b      	ldr	r3, [r3, #0]
    545e:	6878      	ldr	r0, [r7, #4]
    5460:	4798      	blx	r3
    5462:	6138      	str	r0, [r7, #16]
    if (c >= 0) return c;
    5464:	693b      	ldr	r3, [r7, #16]
    5466:	2b00      	cmp	r3, #0
    5468:	db01      	blt.n	546e <_ZN6Stream9timedReadEv+0x2a>
    546a:	693b      	ldr	r3, [r7, #16]
    546c:	e012      	b.n	5494 <_ZN6Stream9timedReadEv+0x50>
    yield();
    546e:	f001 fca3 	bl	6db8 <yield>
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    5472:	4b0a      	ldr	r3, [pc, #40]	; (549c <_ZN6Stream9timedReadEv+0x58>)
    5474:	681b      	ldr	r3, [r3, #0]
    5476:	60fb      	str	r3, [r7, #12]
	return ret;
    5478:	68fa      	ldr	r2, [r7, #12]
  } while(millis() - startMillis < _timeout);
    547a:	697b      	ldr	r3, [r7, #20]
    547c:	1ad2      	subs	r2, r2, r3
    547e:	687b      	ldr	r3, [r7, #4]
    5480:	689b      	ldr	r3, [r3, #8]
    5482:	429a      	cmp	r2, r3
    5484:	bf34      	ite	cc
    5486:	2301      	movcc	r3, #1
    5488:	2300      	movcs	r3, #0
    548a:	b2db      	uxtb	r3, r3
    548c:	2b00      	cmp	r3, #0
    548e:	d1e2      	bne.n	5456 <_ZN6Stream9timedReadEv+0x12>
  return -1;     // -1 indicates timeout
    5490:	f04f 33ff 	mov.w	r3, #4294967295
}
    5494:	4618      	mov	r0, r3
    5496:	3718      	adds	r7, #24
    5498:	46bd      	mov	sp, r7
    549a:	bd80      	pop	{r7, pc}
    549c:	1fff1308 	.word	0x1fff1308

000054a0 <_ZN6Stream10setTimeoutEm>:

// Public Methods
//////////////////////////////////////////////////////////////

void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait
{
    54a0:	b480      	push	{r7}
    54a2:	b083      	sub	sp, #12
    54a4:	af00      	add	r7, sp, #0
    54a6:	6078      	str	r0, [r7, #4]
    54a8:	6039      	str	r1, [r7, #0]
  _timeout = timeout;
    54aa:	687b      	ldr	r3, [r7, #4]
    54ac:	683a      	ldr	r2, [r7, #0]
    54ae:	609a      	str	r2, [r3, #8]
}
    54b0:	bf00      	nop
    54b2:	370c      	adds	r7, #12
    54b4:	46bd      	mov	sp, r7
    54b6:	f85d 7b04 	ldr.w	r7, [sp], #4
    54ba:	4770      	bx	lr

000054bc <_ZN6Stream15readStringUntilEcj>:
	}
	return str;
}

String Stream::readStringUntil(char terminator, size_t max)
{
    54bc:	b580      	push	{r7, lr}
    54be:	b086      	sub	sp, #24
    54c0:	af00      	add	r7, sp, #0
    54c2:	60f8      	str	r0, [r7, #12]
    54c4:	60b9      	str	r1, [r7, #8]
    54c6:	603b      	str	r3, [r7, #0]
    54c8:	4613      	mov	r3, r2
    54ca:	71fb      	strb	r3, [r7, #7]
	String str;
    54cc:	2100      	movs	r1, #0
    54ce:	68f8      	ldr	r0, [r7, #12]
    54d0:	f001 f8b4 	bl	663c <_ZN6StringC1EPKc>
	size_t length = 0;
    54d4:	2300      	movs	r3, #0
    54d6:	617b      	str	r3, [r7, #20]
	while (length < max) {
    54d8:	e01c      	b.n	5514 <_ZN6Stream15readStringUntilEcj+0x58>
		int c = timedRead();
    54da:	68b8      	ldr	r0, [r7, #8]
    54dc:	f7ff ffb2 	bl	5444 <_ZN6Stream9timedReadEv>
    54e0:	6138      	str	r0, [r7, #16]
		if (c < 0) {
    54e2:	693b      	ldr	r3, [r7, #16]
    54e4:	2b00      	cmp	r3, #0
    54e6:	da05      	bge.n	54f4 <_ZN6Stream15readStringUntilEcj+0x38>
			setReadError();
    54e8:	2101      	movs	r1, #1
    54ea:	68b8      	ldr	r0, [r7, #8]
    54ec:	f7ff ff9a 	bl	5424 <_ZN6Stream12setReadErrorEi>
			break;	// timeout
    54f0:	bf00      	nop
		}
		if (c == 0 || c == terminator) break;
		str += (char)c;
		length++;
	}
	return str;
    54f2:	e013      	b.n	551c <_ZN6Stream15readStringUntilEcj+0x60>
		if (c == 0 || c == terminator) break;
    54f4:	693b      	ldr	r3, [r7, #16]
    54f6:	2b00      	cmp	r3, #0
    54f8:	d010      	beq.n	551c <_ZN6Stream15readStringUntilEcj+0x60>
    54fa:	79fb      	ldrb	r3, [r7, #7]
    54fc:	693a      	ldr	r2, [r7, #16]
    54fe:	429a      	cmp	r2, r3
    5500:	d00c      	beq.n	551c <_ZN6Stream15readStringUntilEcj+0x60>
		str += (char)c;
    5502:	693b      	ldr	r3, [r7, #16]
    5504:	b2db      	uxtb	r3, r3
    5506:	4619      	mov	r1, r3
    5508:	68f8      	ldr	r0, [r7, #12]
    550a:	f7ff ff7b 	bl	5404 <_ZN6StringpLEc>
		length++;
    550e:	697b      	ldr	r3, [r7, #20]
    5510:	3301      	adds	r3, #1
    5512:	617b      	str	r3, [r7, #20]
	while (length < max) {
    5514:	697a      	ldr	r2, [r7, #20]
    5516:	683b      	ldr	r3, [r7, #0]
    5518:	429a      	cmp	r2, r3
    551a:	d3de      	bcc.n	54da <_ZN6Stream15readStringUntilEcj+0x1e>
	return str;
    551c:	bf00      	nop
}
    551e:	68f8      	ldr	r0, [r7, #12]
    5520:	3718      	adds	r7, #24
    5522:	46bd      	mov	sp, r7
    5524:	bd80      	pop	{r7, pc}
    5526:	Address 0x00005526 is out of bounds.


00005528 <endpoint0_stall>:
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5528:	4b02      	ldr	r3, [pc, #8]	; (5534 <endpoint0_stall+0xc>)
    552a:	220f      	movs	r2, #15
    552c:	f883 20c0 	strb.w	r2, [r3, #192]	; 0xc0
}
    5530:	4770      	bx	lr
    5532:	bf00      	nop
    5534:	40072000 	.word	0x40072000

00005538 <endpoint0_transmit>:
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5538:	4a0c      	ldr	r2, [pc, #48]	; (556c <endpoint0_transmit+0x34>)
    553a:	7813      	ldrb	r3, [r2, #0]
    553c:	f043 0c02 	orr.w	ip, r3, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    5540:	f083 0301 	eor.w	r3, r3, #1
    5544:	7013      	strb	r3, [r2, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    5546:	4a0a      	ldr	r2, [pc, #40]	; (5570 <endpoint0_transmit+0x38>)
    5548:	7813      	ldrb	r3, [r2, #0]
    554a:	2b00      	cmp	r3, #0
	ep0_tx_data_toggle ^= 1;
    554c:	f083 0301 	eor.w	r3, r3, #1
    5550:	7013      	strb	r3, [r2, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    5552:	4a08      	ldr	r2, [pc, #32]	; (5574 <endpoint0_transmit+0x3c>)
    5554:	eb02 03cc 	add.w	r3, r2, ip, lsl #3
    5558:	6058      	str	r0, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    555a:	bf14      	ite	ne
    555c:	23c8      	movne	r3, #200	; 0xc8
    555e:	2388      	moveq	r3, #136	; 0x88
    5560:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
    5564:	f842 103c 	str.w	r1, [r2, ip, lsl #3]
}
    5568:	4770      	bx	lr
    556a:	bf00      	nop
    556c:	1fff13e6 	.word	0x1fff13e6
    5570:	1fff13e7 	.word	0x1fff13e7
    5574:	1fff0000 	.word	0x1fff0000

00005578 <usb_setup>:

static uint8_t reply_buffer[8];

static void usb_setup(void)
{
    5578:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    557c:	4aa1      	ldr	r2, [pc, #644]	; (5804 <usb_setup+0x28c>)
    557e:	8813      	ldrh	r3, [r2, #0]
    5580:	f240 6181 	movw	r1, #1665	; 0x681
    5584:	428b      	cmp	r3, r1
{
    5586:	b083      	sub	sp, #12
	switch (setup.wRequestAndType) {
    5588:	d81c      	bhi.n	55c4 <usb_setup+0x4c>
    558a:	f5b3 6fd0 	cmp.w	r3, #1664	; 0x680
    558e:	f080 8130 	bcs.w	57f2 <usb_setup+0x27a>
    5592:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    5596:	f000 818e 	beq.w	58b6 <usb_setup+0x33e>
    559a:	d931      	bls.n	5600 <usb_setup+0x88>
    559c:	f240 3102 	movw	r1, #770	; 0x302
    55a0:	428b      	cmp	r3, r1
    55a2:	d123      	bne.n	55ec <usb_setup+0x74>
    55a4:	8893      	ldrh	r3, [r2, #4]
    55a6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    55aa:	2b04      	cmp	r3, #4
    55ac:	d843      	bhi.n	5636 <usb_setup+0xbe>
    55ae:	8852      	ldrh	r2, [r2, #2]
    55b0:	2a00      	cmp	r2, #0
    55b2:	d140      	bne.n	5636 <usb_setup+0xbe>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    55b4:	4994      	ldr	r1, [pc, #592]	; (5808 <usb_setup+0x290>)
    55b6:	f811 2023 	ldrb.w	r2, [r1, r3, lsl #2]
    55ba:	f042 0202 	orr.w	r2, r2, #2
    55be:	f801 2023 	strb.w	r2, [r1, r3, lsl #2]
		// TODO: do we need to clear the data toggle here?
		break;
    55c2:	e016      	b.n	55f2 <usb_setup+0x7a>
	switch (setup.wRequestAndType) {
    55c4:	f242 0121 	movw	r1, #8225	; 0x2021
    55c8:	428b      	cmp	r3, r1
    55ca:	f000 80c8 	beq.w	575e <usb_setup+0x1e6>
    55ce:	d937      	bls.n	5640 <usb_setup+0xc8>
    55d0:	f242 2121 	movw	r1, #8737	; 0x2221
    55d4:	428b      	cmp	r3, r1
    55d6:	d12a      	bne.n	562e <usb_setup+0xb6>
    55d8:	8893      	ldrh	r3, [r2, #4]
    55da:	b953      	cbnz	r3, 55f2 <usb_setup+0x7a>
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    55dc:	488b      	ldr	r0, [pc, #556]	; (580c <usb_setup+0x294>)
    55de:	498c      	ldr	r1, [pc, #560]	; (5810 <usb_setup+0x298>)
			usb_cdc_line_rtsdtr = setup.wValue;
    55e0:	4b8c      	ldr	r3, [pc, #560]	; (5814 <usb_setup+0x29c>)
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    55e2:	6800      	ldr	r0, [r0, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    55e4:	7892      	ldrb	r2, [r2, #2]
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    55e6:	6008      	str	r0, [r1, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    55e8:	701a      	strb	r2, [r3, #0]
			break;
    55ea:	e002      	b.n	55f2 <usb_setup+0x7a>
	switch (setup.wRequestAndType) {
    55ec:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    55f0:	d121      	bne.n	5636 <usb_setup+0xbe>
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    55f2:	2100      	movs	r1, #0
    55f4:	4608      	mov	r0, r1
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
}
    55f6:	b003      	add	sp, #12
    55f8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	endpoint0_transmit(data, size);
    55fc:	f7ff bf9c 	b.w	5538 <endpoint0_transmit>
	switch (setup.wRequestAndType) {
    5600:	2b80      	cmp	r3, #128	; 0x80
    5602:	f000 8153 	beq.w	58ac <usb_setup+0x334>
    5606:	2b82      	cmp	r3, #130	; 0x82
    5608:	d115      	bne.n	5636 <usb_setup+0xbe>
    560a:	8893      	ldrh	r3, [r2, #4]
    560c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
		if (i > NUM_ENDPOINTS) {
    5610:	2b04      	cmp	r3, #4
    5612:	d810      	bhi.n	5636 <usb_setup+0xbe>
		reply_buffer[0] = 0;
    5614:	4980      	ldr	r1, [pc, #512]	; (5818 <usb_setup+0x2a0>)
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    5616:	487c      	ldr	r0, [pc, #496]	; (5808 <usb_setup+0x290>)
		reply_buffer[0] = 0;
    5618:	2400      	movs	r4, #0
    561a:	800c      	strh	r4, [r1, #0]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    561c:	f810 3023 	ldrb.w	r3, [r0, r3, lsl #2]
    5620:	079b      	lsls	r3, r3, #30
    5622:	f140 815a 	bpl.w	58da <usb_setup+0x362>
    5626:	2301      	movs	r3, #1
    5628:	700b      	strb	r3, [r1, #0]
		datalen = 2;
    562a:	2302      	movs	r3, #2
    562c:	e0db      	b.n	57e6 <usb_setup+0x26e>
	switch (setup.wRequestAndType) {
    562e:	f242 3221 	movw	r2, #8993	; 0x2321
    5632:	4293      	cmp	r3, r2
    5634:	d0dd      	beq.n	55f2 <usb_setup+0x7a>
}
    5636:	b003      	add	sp, #12
    5638:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		endpoint0_stall();
    563c:	f7ff bf74 	b.w	5528 <endpoint0_stall>
	switch (setup.wRequestAndType) {
    5640:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    5644:	f000 80ca 	beq.w	57dc <usb_setup+0x264>
    5648:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    564c:	d1f3      	bne.n	5636 <usb_setup+0xbe>
			if (table[i].desc & BDT_OWN) {
    564e:	4c73      	ldr	r4, [pc, #460]	; (581c <usb_setup+0x2a4>)
		usb_configuration = setup.wValue;
    5650:	4973      	ldr	r1, [pc, #460]	; (5820 <usb_setup+0x2a8>)
			if (table[i].desc & BDT_OWN) {
    5652:	6a23      	ldr	r3, [r4, #32]
		usb_configuration = setup.wValue;
    5654:	7892      	ldrb	r2, [r2, #2]
    5656:	700a      	strb	r2, [r1, #0]
			if (table[i].desc & BDT_OWN) {
    5658:	061a      	lsls	r2, r3, #24
    565a:	f100 8140 	bmi.w	58de <usb_setup+0x366>
    565e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    5660:	061b      	lsls	r3, r3, #24
    5662:	f100 8145 	bmi.w	58f0 <usb_setup+0x378>
    5666:	6b23      	ldr	r3, [r4, #48]	; 0x30
    5668:	061f      	lsls	r7, r3, #24
    566a:	f100 81a8 	bmi.w	59be <usb_setup+0x446>
    566e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    5670:	061e      	lsls	r6, r3, #24
    5672:	f100 819f 	bmi.w	59b4 <usb_setup+0x43c>
    5676:	6c23      	ldr	r3, [r4, #64]	; 0x40
    5678:	061d      	lsls	r5, r3, #24
    567a:	f100 8196 	bmi.w	59aa <usb_setup+0x432>
    567e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    5680:	0618      	lsls	r0, r3, #24
    5682:	f100 818d 	bmi.w	59a0 <usb_setup+0x428>
    5686:	6d23      	ldr	r3, [r4, #80]	; 0x50
    5688:	0619      	lsls	r1, r3, #24
    568a:	f100 81b8 	bmi.w	59fe <usb_setup+0x486>
    568e:	6da3      	ldr	r3, [r4, #88]	; 0x58
    5690:	061a      	lsls	r2, r3, #24
    5692:	f100 81af 	bmi.w	59f4 <usb_setup+0x47c>
    5696:	6e23      	ldr	r3, [r4, #96]	; 0x60
    5698:	061b      	lsls	r3, r3, #24
    569a:	f100 81a6 	bmi.w	59ea <usb_setup+0x472>
    569e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    56a0:	061f      	lsls	r7, r3, #24
    56a2:	f100 819d 	bmi.w	59e0 <usb_setup+0x468>
    56a6:	6f23      	ldr	r3, [r4, #112]	; 0x70
    56a8:	061e      	lsls	r6, r3, #24
    56aa:	f100 81b2 	bmi.w	5a12 <usb_setup+0x49a>
    56ae:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    56b0:	061d      	lsls	r5, r3, #24
    56b2:	f100 81a9 	bmi.w	5a08 <usb_setup+0x490>
    56b6:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
    56ba:	0618      	lsls	r0, r3, #24
    56bc:	f100 816a 	bmi.w	5994 <usb_setup+0x41c>
    56c0:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    56c4:	0619      	lsls	r1, r3, #24
    56c6:	f100 815f 	bmi.w	5988 <usb_setup+0x410>
    56ca:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
    56ce:	061a      	lsls	r2, r3, #24
    56d0:	f100 8180 	bmi.w	59d4 <usb_setup+0x45c>
    56d4:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    56d8:	061b      	lsls	r3, r3, #24
    56da:	f100 8175 	bmi.w	59c8 <usb_setup+0x450>
    56de:	4b51      	ldr	r3, [pc, #324]	; (5824 <usb_setup+0x2ac>)
    56e0:	4e51      	ldr	r6, [pc, #324]	; (5828 <usb_setup+0x2b0>)
    56e2:	f8df 8164 	ldr.w	r8, [pc, #356]	; 5848 <usb_setup+0x2d0>
    56e6:	f8df 9164 	ldr.w	r9, [pc, #356]	; 584c <usb_setup+0x2d4>
    56ea:	f8df a164 	ldr.w	sl, [pc, #356]	; 5850 <usb_setup+0x2d8>
    56ee:	f8df b164 	ldr.w	fp, [pc, #356]	; 5854 <usb_setup+0x2dc>
    56f2:	9301      	str	r3, [sp, #4]
			rx_first[i] = NULL;
    56f4:	2500      	movs	r5, #0
			p = rx_first[i];
    56f6:	f856 7b04 	ldr.w	r7, [r6], #4
			while (p) {
    56fa:	b12f      	cbz	r7, 5708 <usb_setup+0x190>
    56fc:	4638      	mov	r0, r7
				n = p->next;
    56fe:	687f      	ldr	r7, [r7, #4]
				usb_free(p);
    5700:	f000 fd2c 	bl	615c <usb_free>
			while (p) {
    5704:	2f00      	cmp	r7, #0
    5706:	d1f9      	bne.n	56fc <usb_setup+0x184>
			p = tx_first[i];
    5708:	f8d8 7000 	ldr.w	r7, [r8]
			rx_last[i] = NULL;
    570c:	f84b 5b04 	str.w	r5, [fp], #4
			rx_first[i] = NULL;
    5710:	f846 5c04 	str.w	r5, [r6, #-4]
			while (p) {
    5714:	b12f      	cbz	r7, 5722 <usb_setup+0x1aa>
    5716:	4638      	mov	r0, r7
				n = p->next;
    5718:	687f      	ldr	r7, [r7, #4]
				usb_free(p);
    571a:	f000 fd1f 	bl	615c <usb_free>
			while (p) {
    571e:	2f00      	cmp	r7, #0
    5720:	d1f9      	bne.n	5716 <usb_setup+0x19e>
    5722:	9b01      	ldr	r3, [sp, #4]
			tx_first[i] = NULL;
    5724:	f848 5b04 	str.w	r5, [r8], #4
    5728:	781b      	ldrb	r3, [r3, #0]
			tx_last[i] = NULL;
    572a:	f849 5b04 	str.w	r5, [r9], #4
    572e:	3b02      	subs	r3, #2
			usb_rx_byte_count_data[i] = 0;
    5730:	f82a 5b02 	strh.w	r5, [sl], #2
    5734:	2b03      	cmp	r3, #3
    5736:	d819      	bhi.n	576c <usb_setup+0x1f4>
    5738:	e8df f003 	tbb	[pc, r3]
    573c:	144d144d 	.word	0x144d144d
    5740:	2d40      	cmp	r5, #64	; 0x40
    5742:	462c      	mov	r4, r5
    5744:	bf28      	it	cs
    5746:	2440      	movcs	r4, #64	; 0x40
	endpoint0_transmit(data, size);
    5748:	4621      	mov	r1, r4
    574a:	f7ff fef5 	bl	5538 <endpoint0_transmit>
	data += size;
    574e:	4420      	add	r0, r4
	if (datalen == 0 && size < EP0_SIZE) return;
    5750:	1b2c      	subs	r4, r5, r4
    5752:	f000 80c9 	beq.w	58e8 <usb_setup+0x370>
	ep0_tx_ptr = data;
    5756:	4a35      	ldr	r2, [pc, #212]	; (582c <usb_setup+0x2b4>)
	ep0_tx_len = datalen;
    5758:	4b35      	ldr	r3, [pc, #212]	; (5830 <usb_setup+0x2b8>)
	ep0_tx_ptr = data;
    575a:	6010      	str	r0, [r2, #0]
	ep0_tx_len = datalen;
    575c:	801c      	strh	r4, [r3, #0]
}
    575e:	b003      	add	sp, #12
    5760:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    5764:	9b01      	ldr	r3, [sp, #4]
    5766:	f04f 0201 	mov.w	r2, #1
    576a:	701a      	strb	r2, [r3, #0]
		for (i=0; i < NUM_ENDPOINTS; i++) {
    576c:	9b01      	ldr	r3, [sp, #4]
    576e:	3301      	adds	r3, #1
    5770:	9301      	str	r3, [sp, #4]
    5772:	4b30      	ldr	r3, [pc, #192]	; (5834 <usb_setup+0x2bc>)
    5774:	429e      	cmp	r6, r3
    5776:	d1be      	bne.n	56f6 <usb_setup+0x17e>
			epconf = *cfg++;
    5778:	4d2f      	ldr	r5, [pc, #188]	; (5838 <usb_setup+0x2c0>)
		usb_rx_memory_needed = 0;
    577a:	4e30      	ldr	r6, [pc, #192]	; (583c <usb_setup+0x2c4>)
			epconf = *cfg++;
    577c:	782b      	ldrb	r3, [r5, #0]
			*reg = epconf;
    577e:	4a30      	ldr	r2, [pc, #192]	; (5840 <usb_setup+0x2c8>)
		usb_rx_memory_needed = 0;
    5780:	2100      	movs	r1, #0
			if (epconf & USB_ENDPT_EPRXEN) {
    5782:	071f      	lsls	r7, r3, #28
		usb_rx_memory_needed = 0;
    5784:	7031      	strb	r1, [r6, #0]
			*reg = epconf;
    5786:	f882 30c4 	strb.w	r3, [r2, #196]	; 0xc4
			if (epconf & USB_ENDPT_EPRXEN) {
    578a:	f100 80ec 	bmi.w	5966 <usb_setup+0x3ee>
			epconf = *cfg++;
    578e:	786b      	ldrb	r3, [r5, #1]
			*reg = epconf;
    5790:	492b      	ldr	r1, [pc, #172]	; (5840 <usb_setup+0x2c8>)
			table[index(i, TX, EVEN)].desc = 0;
    5792:	2200      	movs	r2, #0
			if (epconf & USB_ENDPT_EPRXEN) {
    5794:	0718      	lsls	r0, r3, #28
			*reg = epconf;
    5796:	f881 30c8 	strb.w	r3, [r1, #200]	; 0xc8
			table[index(i, TX, EVEN)].desc = 0;
    579a:	6322      	str	r2, [r4, #48]	; 0x30
			table[index(i, TX, ODD)].desc = 0;
    579c:	63a2      	str	r2, [r4, #56]	; 0x38
			if (epconf & USB_ENDPT_EPRXEN) {
    579e:	f100 80d0 	bmi.w	5942 <usb_setup+0x3ca>
			epconf = *cfg++;
    57a2:	78ab      	ldrb	r3, [r5, #2]
			*reg = epconf;
    57a4:	4926      	ldr	r1, [pc, #152]	; (5840 <usb_setup+0x2c8>)
			table[index(i, TX, EVEN)].desc = 0;
    57a6:	2200      	movs	r2, #0
			*reg = epconf;
    57a8:	f881 30cc 	strb.w	r3, [r1, #204]	; 0xcc
			if (epconf & USB_ENDPT_EPRXEN) {
    57ac:	0719      	lsls	r1, r3, #28
			table[index(i, TX, EVEN)].desc = 0;
    57ae:	6522      	str	r2, [r4, #80]	; 0x50
			table[index(i, TX, ODD)].desc = 0;
    57b0:	65a2      	str	r2, [r4, #88]	; 0x58
			if (epconf & USB_ENDPT_EPRXEN) {
    57b2:	f100 80b5 	bmi.w	5920 <usb_setup+0x3a8>
			epconf = *cfg++;
    57b6:	78eb      	ldrb	r3, [r5, #3]
			*reg = epconf;
    57b8:	4921      	ldr	r1, [pc, #132]	; (5840 <usb_setup+0x2c8>)
			table[index(i, TX, EVEN)].desc = 0;
    57ba:	2200      	movs	r2, #0
    57bc:	6722      	str	r2, [r4, #112]	; 0x70
			table[index(i, TX, ODD)].desc = 0;
    57be:	67a2      	str	r2, [r4, #120]	; 0x78
			if (epconf & USB_ENDPT_EPRXEN) {
    57c0:	071a      	lsls	r2, r3, #28
			*reg = epconf;
    57c2:	f881 30d0 	strb.w	r3, [r1, #208]	; 0xd0
			if (epconf & USB_ENDPT_EPRXEN) {
    57c6:	f100 8098 	bmi.w	58fa <usb_setup+0x382>
			table[index(i, TX, EVEN)].desc = 0;
    57ca:	2300      	movs	r3, #0
    57cc:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
			table[index(i, TX, ODD)].desc = 0;
    57d0:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
    57d4:	e70d      	b.n	55f2 <usb_setup+0x7a>
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    57d6:	9b01      	ldr	r3, [sp, #4]
    57d8:	701d      	strb	r5, [r3, #0]
				break;
    57da:	e7c7      	b.n	576c <usb_setup+0x1f4>
		reply_buffer[0] = usb_configuration;
    57dc:	4910      	ldr	r1, [pc, #64]	; (5820 <usb_setup+0x2a8>)
    57de:	4b0e      	ldr	r3, [pc, #56]	; (5818 <usb_setup+0x2a0>)
    57e0:	7809      	ldrb	r1, [r1, #0]
    57e2:	7019      	strb	r1, [r3, #0]
		datalen = 1;
    57e4:	2301      	movs	r3, #1
	if (datalen > setup.wLength) datalen = setup.wLength;
    57e6:	88d1      	ldrh	r1, [r2, #6]
	endpoint0_transmit(data, size);
    57e8:	480b      	ldr	r0, [pc, #44]	; (5818 <usb_setup+0x2a0>)
    57ea:	4299      	cmp	r1, r3
    57ec:	bf28      	it	cs
    57ee:	4619      	movcs	r1, r3
    57f0:	e701      	b.n	55f6 <usb_setup+0x7e>
			if (list->addr == NULL) break;
    57f2:	4b14      	ldr	r3, [pc, #80]	; (5844 <usb_setup+0x2cc>)
    57f4:	6858      	ldr	r0, [r3, #4]
    57f6:	2800      	cmp	r0, #0
    57f8:	f43f af1d 	beq.w	5636 <usb_setup+0xbe>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    57fc:	8854      	ldrh	r4, [r2, #2]
    57fe:	8895      	ldrh	r5, [r2, #4]
    5800:	e02f      	b.n	5862 <usb_setup+0x2ea>
    5802:	bf00      	nop
    5804:	1fff1358 	.word	0x1fff1358
    5808:	400720c0 	.word	0x400720c0
    580c:	1fff1308 	.word	0x1fff1308
    5810:	1fff13fc 	.word	0x1fff13fc
    5814:	1fff1400 	.word	0x1fff1400
    5818:	1fff13ec 	.word	0x1fff13ec
    581c:	1fff0000 	.word	0x1fff0000
    5820:	1fff13e9 	.word	0x1fff13e9
    5824:	1fff1354 	.word	0x1fff1354
    5828:	1fff130c 	.word	0x1fff130c
    582c:	1fff13e0 	.word	0x1fff13e0
    5830:	1fff13e4 	.word	0x1fff13e4
    5834:	1fff131c 	.word	0x1fff131c
    5838:	0000f5c0 	.word	0x0000f5c0
    583c:	1fff13e8 	.word	0x1fff13e8
    5840:	40072000 	.word	0x40072000
    5844:	0000f56c 	.word	0x0000f56c
    5848:	1fff132c 	.word	0x1fff132c
    584c:	1fff133c 	.word	0x1fff133c
    5850:	1fff134c 	.word	0x1fff134c
    5854:	1fff131c 	.word	0x1fff131c
			if (list->addr == NULL) break;
    5858:	6918      	ldr	r0, [r3, #16]
		for (list = usb_descriptor_list; 1; list++) {
    585a:	330c      	adds	r3, #12
			if (list->addr == NULL) break;
    585c:	2800      	cmp	r0, #0
    585e:	f43f aeea 	beq.w	5636 <usb_setup+0xbe>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    5862:	8819      	ldrh	r1, [r3, #0]
    5864:	42a1      	cmp	r1, r4
    5866:	d1f7      	bne.n	5858 <usb_setup+0x2e0>
    5868:	8859      	ldrh	r1, [r3, #2]
    586a:	42a9      	cmp	r1, r5
    586c:	d1f4      	bne.n	5858 <usb_setup+0x2e0>
				if ((setup.wValue >> 8) == 3) {
    586e:	0a24      	lsrs	r4, r4, #8
    5870:	2c03      	cmp	r4, #3
					datalen = *(list->addr);
    5872:	bf08      	it	eq
    5874:	7803      	ldrbeq	r3, [r0, #0]
	if (datalen > setup.wLength) datalen = setup.wLength;
    5876:	88d4      	ldrh	r4, [r2, #6]
					datalen = list->length;
    5878:	bf18      	it	ne
    587a:	891b      	ldrhne	r3, [r3, #8]
    587c:	429c      	cmp	r4, r3
    587e:	bf28      	it	cs
    5880:	461c      	movcs	r4, r3
    5882:	2c40      	cmp	r4, #64	; 0x40
    5884:	4625      	mov	r5, r4
    5886:	bf28      	it	cs
    5888:	2540      	movcs	r5, #64	; 0x40
	endpoint0_transmit(data, size);
    588a:	4629      	mov	r1, r5
    588c:	f7ff fe54 	bl	5538 <endpoint0_transmit>
	data += size;
    5890:	4428      	add	r0, r5
	if (datalen == 0 && size < EP0_SIZE) return;
    5892:	1b65      	subs	r5, r4, r5
    5894:	f47f af54 	bne.w	5740 <usb_setup+0x1c8>
    5898:	2c3f      	cmp	r4, #63	; 0x3f
	endpoint0_transmit(data, size);
    589a:	bf88      	it	hi
    589c:	4629      	movhi	r1, r5
	if (datalen == 0 && size < EP0_SIZE) return;
    589e:	f67f af5e 	bls.w	575e <usb_setup+0x1e6>
}
    58a2:	b003      	add	sp, #12
    58a4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	endpoint0_transmit(data, size);
    58a8:	f7ff be46 	b.w	5538 <endpoint0_transmit>
		reply_buffer[0] = 0;
    58ac:	4b70      	ldr	r3, [pc, #448]	; (5a70 <usb_setup+0x4f8>)
    58ae:	2100      	movs	r1, #0
    58b0:	8019      	strh	r1, [r3, #0]
		datalen = 2;
    58b2:	2302      	movs	r3, #2
		break;
    58b4:	e797      	b.n	57e6 <usb_setup+0x26e>
    58b6:	8893      	ldrh	r3, [r2, #4]
    58b8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    58bc:	2b04      	cmp	r3, #4
    58be:	f63f aeba 	bhi.w	5636 <usb_setup+0xbe>
    58c2:	8852      	ldrh	r2, [r2, #2]
    58c4:	2a00      	cmp	r2, #0
    58c6:	f47f aeb6 	bne.w	5636 <usb_setup+0xbe>
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    58ca:	496a      	ldr	r1, [pc, #424]	; (5a74 <usb_setup+0x4fc>)
    58cc:	f811 2023 	ldrb.w	r2, [r1, r3, lsl #2]
    58d0:	f022 0202 	bic.w	r2, r2, #2
    58d4:	f801 2023 	strb.w	r2, [r1, r3, lsl #2]
		break;
    58d8:	e68b      	b.n	55f2 <usb_setup+0x7a>
		datalen = 2;
    58da:	2302      	movs	r3, #2
    58dc:	e783      	b.n	57e6 <usb_setup+0x26e>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    58de:	6a60      	ldr	r0, [r4, #36]	; 0x24
    58e0:	3808      	subs	r0, #8
    58e2:	f000 fc3b 	bl	615c <usb_free>
    58e6:	e6ba      	b.n	565e <usb_setup+0xe6>
	if (datalen == 0 && size < EP0_SIZE) return;
    58e8:	2d3f      	cmp	r5, #63	; 0x3f
    58ea:	f63f af34 	bhi.w	5756 <usb_setup+0x1de>
    58ee:	e736      	b.n	575e <usb_setup+0x1e6>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    58f0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    58f2:	3808      	subs	r0, #8
    58f4:	f000 fc32 	bl	615c <usb_free>
    58f8:	e6b5      	b.n	5666 <usb_setup+0xee>
				p = usb_malloc();
    58fa:	f000 fbf7 	bl	60ec <usb_malloc>
				if (p) {
    58fe:	2800      	cmp	r0, #0
    5900:	f000 80b0 	beq.w	5a64 <usb_setup+0x4ec>
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    5904:	4b5c      	ldr	r3, [pc, #368]	; (5a78 <usb_setup+0x500>)
					table[index(i, RX, EVEN)].addr = p->buf;
    5906:	3008      	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    5908:	e9c4 3020 	strd	r3, r0, [r4, #128]	; 0x80
				p = usb_malloc();
    590c:	f000 fbee 	bl	60ec <usb_malloc>
				if (p) {
    5910:	2800      	cmp	r0, #0
    5912:	f000 80a1 	beq.w	5a58 <usb_setup+0x4e0>
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    5916:	4b59      	ldr	r3, [pc, #356]	; (5a7c <usb_setup+0x504>)
					table[index(i, RX, ODD)].addr = p->buf;
    5918:	3008      	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    591a:	e9c4 3022 	strd	r3, r0, [r4, #136]	; 0x88
    591e:	e754      	b.n	57ca <usb_setup+0x252>
				p = usb_malloc();
    5920:	f000 fbe4 	bl	60ec <usb_malloc>
				if (p) {
    5924:	2800      	cmp	r0, #0
    5926:	d07e      	beq.n	5a26 <usb_setup+0x4ae>
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    5928:	4b53      	ldr	r3, [pc, #332]	; (5a78 <usb_setup+0x500>)
					table[index(i, RX, EVEN)].addr = p->buf;
    592a:	3008      	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    592c:	e9c4 3018 	strd	r3, r0, [r4, #96]	; 0x60
				p = usb_malloc();
    5930:	f000 fbdc 	bl	60ec <usb_malloc>
				if (p) {
    5934:	2800      	cmp	r0, #0
    5936:	d071      	beq.n	5a1c <usb_setup+0x4a4>
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    5938:	4b50      	ldr	r3, [pc, #320]	; (5a7c <usb_setup+0x504>)
					table[index(i, RX, ODD)].addr = p->buf;
    593a:	3008      	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    593c:	e9c4 301a 	strd	r3, r0, [r4, #104]	; 0x68
    5940:	e739      	b.n	57b6 <usb_setup+0x23e>
				p = usb_malloc();
    5942:	f000 fbd3 	bl	60ec <usb_malloc>
				if (p) {
    5946:	2800      	cmp	r0, #0
    5948:	f000 8081 	beq.w	5a4e <usb_setup+0x4d6>
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    594c:	4b4a      	ldr	r3, [pc, #296]	; (5a78 <usb_setup+0x500>)
					table[index(i, RX, EVEN)].addr = p->buf;
    594e:	3008      	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    5950:	e9c4 3010 	strd	r3, r0, [r4, #64]	; 0x40
				p = usb_malloc();
    5954:	f000 fbca 	bl	60ec <usb_malloc>
				if (p) {
    5958:	2800      	cmp	r0, #0
    595a:	d073      	beq.n	5a44 <usb_setup+0x4cc>
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    595c:	4b47      	ldr	r3, [pc, #284]	; (5a7c <usb_setup+0x504>)
					table[index(i, RX, ODD)].addr = p->buf;
    595e:	3008      	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    5960:	e9c4 3012 	strd	r3, r0, [r4, #72]	; 0x48
    5964:	e71d      	b.n	57a2 <usb_setup+0x22a>
				p = usb_malloc();
    5966:	f000 fbc1 	bl	60ec <usb_malloc>
				if (p) {
    596a:	2800      	cmp	r0, #0
    596c:	d065      	beq.n	5a3a <usb_setup+0x4c2>
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    596e:	4b42      	ldr	r3, [pc, #264]	; (5a78 <usb_setup+0x500>)
					table[index(i, RX, EVEN)].addr = p->buf;
    5970:	3008      	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    5972:	e9c4 3008 	strd	r3, r0, [r4, #32]
				p = usb_malloc();
    5976:	f000 fbb9 	bl	60ec <usb_malloc>
				if (p) {
    597a:	2800      	cmp	r0, #0
    597c:	d058      	beq.n	5a30 <usb_setup+0x4b8>
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    597e:	4b3f      	ldr	r3, [pc, #252]	; (5a7c <usb_setup+0x504>)
					table[index(i, RX, ODD)].addr = p->buf;
    5980:	3008      	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    5982:	e9c4 300a 	strd	r3, r0, [r4, #40]	; 0x28
    5986:	e702      	b.n	578e <usb_setup+0x216>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    5988:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
    598c:	3808      	subs	r0, #8
    598e:	f000 fbe5 	bl	615c <usb_free>
    5992:	e69a      	b.n	56ca <usb_setup+0x152>
    5994:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
    5998:	3808      	subs	r0, #8
    599a:	f000 fbdf 	bl	615c <usb_free>
    599e:	e68f      	b.n	56c0 <usb_setup+0x148>
    59a0:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    59a2:	3808      	subs	r0, #8
    59a4:	f000 fbda 	bl	615c <usb_free>
    59a8:	e66d      	b.n	5686 <usb_setup+0x10e>
    59aa:	6c60      	ldr	r0, [r4, #68]	; 0x44
    59ac:	3808      	subs	r0, #8
    59ae:	f000 fbd5 	bl	615c <usb_free>
    59b2:	e664      	b.n	567e <usb_setup+0x106>
    59b4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    59b6:	3808      	subs	r0, #8
    59b8:	f000 fbd0 	bl	615c <usb_free>
    59bc:	e65b      	b.n	5676 <usb_setup+0xfe>
    59be:	6b60      	ldr	r0, [r4, #52]	; 0x34
    59c0:	3808      	subs	r0, #8
    59c2:	f000 fbcb 	bl	615c <usb_free>
    59c6:	e652      	b.n	566e <usb_setup+0xf6>
    59c8:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
    59cc:	3808      	subs	r0, #8
    59ce:	f000 fbc5 	bl	615c <usb_free>
    59d2:	e684      	b.n	56de <usb_setup+0x166>
    59d4:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
    59d8:	3808      	subs	r0, #8
    59da:	f000 fbbf 	bl	615c <usb_free>
    59de:	e679      	b.n	56d4 <usb_setup+0x15c>
    59e0:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    59e2:	3808      	subs	r0, #8
    59e4:	f000 fbba 	bl	615c <usb_free>
    59e8:	e65d      	b.n	56a6 <usb_setup+0x12e>
    59ea:	6e60      	ldr	r0, [r4, #100]	; 0x64
    59ec:	3808      	subs	r0, #8
    59ee:	f000 fbb5 	bl	615c <usb_free>
    59f2:	e654      	b.n	569e <usb_setup+0x126>
    59f4:	6de0      	ldr	r0, [r4, #92]	; 0x5c
    59f6:	3808      	subs	r0, #8
    59f8:	f000 fbb0 	bl	615c <usb_free>
    59fc:	e64b      	b.n	5696 <usb_setup+0x11e>
    59fe:	6d60      	ldr	r0, [r4, #84]	; 0x54
    5a00:	3808      	subs	r0, #8
    5a02:	f000 fbab 	bl	615c <usb_free>
    5a06:	e642      	b.n	568e <usb_setup+0x116>
    5a08:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
    5a0a:	3808      	subs	r0, #8
    5a0c:	f000 fba6 	bl	615c <usb_free>
    5a10:	e651      	b.n	56b6 <usb_setup+0x13e>
    5a12:	6f60      	ldr	r0, [r4, #116]	; 0x74
    5a14:	3808      	subs	r0, #8
    5a16:	f000 fba1 	bl	615c <usb_free>
    5a1a:	e648      	b.n	56ae <usb_setup+0x136>
					usb_rx_memory_needed++;
    5a1c:	7833      	ldrb	r3, [r6, #0]
					table[index(i, RX, ODD)].desc = 0;
    5a1e:	66a0      	str	r0, [r4, #104]	; 0x68
					usb_rx_memory_needed++;
    5a20:	3301      	adds	r3, #1
    5a22:	7033      	strb	r3, [r6, #0]
    5a24:	e6c7      	b.n	57b6 <usb_setup+0x23e>
					usb_rx_memory_needed++;
    5a26:	7833      	ldrb	r3, [r6, #0]
					table[index(i, RX, EVEN)].desc = 0;
    5a28:	6620      	str	r0, [r4, #96]	; 0x60
					usb_rx_memory_needed++;
    5a2a:	3301      	adds	r3, #1
    5a2c:	7033      	strb	r3, [r6, #0]
    5a2e:	e77f      	b.n	5930 <usb_setup+0x3b8>
					usb_rx_memory_needed++;
    5a30:	7833      	ldrb	r3, [r6, #0]
					table[index(i, RX, ODD)].desc = 0;
    5a32:	62a0      	str	r0, [r4, #40]	; 0x28
					usb_rx_memory_needed++;
    5a34:	3301      	adds	r3, #1
    5a36:	7033      	strb	r3, [r6, #0]
    5a38:	e6a9      	b.n	578e <usb_setup+0x216>
					usb_rx_memory_needed++;
    5a3a:	7833      	ldrb	r3, [r6, #0]
					table[index(i, RX, EVEN)].desc = 0;
    5a3c:	6220      	str	r0, [r4, #32]
					usb_rx_memory_needed++;
    5a3e:	3301      	adds	r3, #1
    5a40:	7033      	strb	r3, [r6, #0]
    5a42:	e798      	b.n	5976 <usb_setup+0x3fe>
					usb_rx_memory_needed++;
    5a44:	7833      	ldrb	r3, [r6, #0]
					table[index(i, RX, ODD)].desc = 0;
    5a46:	64a0      	str	r0, [r4, #72]	; 0x48
					usb_rx_memory_needed++;
    5a48:	3301      	adds	r3, #1
    5a4a:	7033      	strb	r3, [r6, #0]
    5a4c:	e6a9      	b.n	57a2 <usb_setup+0x22a>
					usb_rx_memory_needed++;
    5a4e:	7833      	ldrb	r3, [r6, #0]
					table[index(i, RX, EVEN)].desc = 0;
    5a50:	6420      	str	r0, [r4, #64]	; 0x40
					usb_rx_memory_needed++;
    5a52:	3301      	adds	r3, #1
    5a54:	7033      	strb	r3, [r6, #0]
    5a56:	e77d      	b.n	5954 <usb_setup+0x3dc>
					usb_rx_memory_needed++;
    5a58:	7833      	ldrb	r3, [r6, #0]
					table[index(i, RX, ODD)].desc = 0;
    5a5a:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
					usb_rx_memory_needed++;
    5a5e:	3301      	adds	r3, #1
    5a60:	7033      	strb	r3, [r6, #0]
    5a62:	e6b2      	b.n	57ca <usb_setup+0x252>
					usb_rx_memory_needed++;
    5a64:	7833      	ldrb	r3, [r6, #0]
					table[index(i, RX, EVEN)].desc = 0;
    5a66:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
					usb_rx_memory_needed++;
    5a6a:	3301      	adds	r3, #1
    5a6c:	7033      	strb	r3, [r6, #0]
    5a6e:	e74d      	b.n	590c <usb_setup+0x394>
    5a70:	1fff13ec 	.word	0x1fff13ec
    5a74:	400720c0 	.word	0x400720c0
    5a78:	00400088 	.word	0x00400088
    5a7c:	004000c8 	.word	0x004000c8

00005a80 <usb_control>:


// #define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

static void usb_control(uint32_t stat)
{
    5a80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    5a82:	4d3f      	ldr	r5, [pc, #252]	; (5b80 <usb_control+0x100>)
    5a84:	0884      	lsrs	r4, r0, #2
    5a86:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
	pid = BDT_PID(b->desc);
    5a8a:	f855 3034 	ldr.w	r3, [r5, r4, lsl #3]
	//count = b->desc >> 16;
	buf = b->addr;
    5a8e:	6852      	ldr	r2, [r2, #4]
	pid = BDT_PID(b->desc);
    5a90:	f3c3 0383 	ubfx	r3, r3, #2, #4
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    5a94:	2b09      	cmp	r3, #9
    5a96:	d02d      	beq.n	5af4 <usb_control+0x74>
    5a98:	d810      	bhi.n	5abc <usb_control+0x3c>
    5a9a:	3b01      	subs	r3, #1
    5a9c:	2b01      	cmp	r3, #1
    5a9e:	d808      	bhi.n	5ab2 <usb_control+0x32>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    5aa0:	4b38      	ldr	r3, [pc, #224]	; (5b84 <usb_control+0x104>)
    5aa2:	8818      	ldrh	r0, [r3, #0]
    5aa4:	f242 0121 	movw	r1, #8225	; 0x2021
    5aa8:	4288      	cmp	r0, r1
    5aaa:	d045      	beq.n	5b38 <usb_control+0xb8>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    5aac:	4b36      	ldr	r3, [pc, #216]	; (5b88 <usb_control+0x108>)
    5aae:	f845 3034 	str.w	r3, [r5, r4, lsl #3]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    5ab2:	4b36      	ldr	r3, [pc, #216]	; (5b8c <usb_control+0x10c>)
    5ab4:	2201      	movs	r2, #1
    5ab6:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
}
    5aba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	switch (pid) {
    5abc:	2b0d      	cmp	r3, #13
    5abe:	d1f8      	bne.n	5ab2 <usb_control+0x32>
		setup.word1 = *(uint32_t *)(buf);
    5ac0:	e9d2 3000 	ldrd	r3, r0, [r2]
    5ac4:	4a2f      	ldr	r2, [pc, #188]	; (5b84 <usb_control+0x104>)
		ep0_tx_ptr = NULL;
    5ac6:	4932      	ldr	r1, [pc, #200]	; (5b90 <usb_control+0x110>)
		setup.word1 = *(uint32_t *)(buf);
    5ac8:	6013      	str	r3, [r2, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    5aca:	4b2f      	ldr	r3, [pc, #188]	; (5b88 <usb_control+0x108>)
    5acc:	f845 3034 	str.w	r3, [r5, r4, lsl #3]
		setup.word1 = *(uint32_t *)(buf);
    5ad0:	6050      	str	r0, [r2, #4]
		ep0_tx_ptr = NULL;
    5ad2:	2300      	movs	r3, #0
		ep0_tx_data_toggle = 1;
    5ad4:	4a2f      	ldr	r2, [pc, #188]	; (5b94 <usb_control+0x114>)
		table[index(0, TX, EVEN)].desc = 0;
    5ad6:	612b      	str	r3, [r5, #16]
		ep0_tx_data_toggle = 1;
    5ad8:	2401      	movs	r4, #1
		table[index(0, TX, ODD)].desc = 0;
    5ada:	61ab      	str	r3, [r5, #24]
		ep0_tx_ptr = NULL;
    5adc:	600b      	str	r3, [r1, #0]
		ep0_tx_data_toggle = 1;
    5ade:	7014      	strb	r4, [r2, #0]
		usb_setup();
    5ae0:	f7ff fd4a 	bl	5578 <usb_setup>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    5ae4:	4b29      	ldr	r3, [pc, #164]	; (5b8c <usb_control+0x10c>)
    5ae6:	f883 4094 	strb.w	r4, [r3, #148]	; 0x94
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    5aea:	4b28      	ldr	r3, [pc, #160]	; (5b8c <usb_control+0x10c>)
    5aec:	2201      	movs	r2, #1
    5aee:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
}
    5af2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		data = ep0_tx_ptr;
    5af4:	4c26      	ldr	r4, [pc, #152]	; (5b90 <usb_control+0x110>)
    5af6:	6820      	ldr	r0, [r4, #0]
		if (data) {
    5af8:	b190      	cbz	r0, 5b20 <usb_control+0xa0>
			size = ep0_tx_len;
    5afa:	4d27      	ldr	r5, [pc, #156]	; (5b98 <usb_control+0x118>)
    5afc:	882f      	ldrh	r7, [r5, #0]
    5afe:	2f40      	cmp	r7, #64	; 0x40
    5b00:	463e      	mov	r6, r7
    5b02:	bf28      	it	cs
    5b04:	2640      	movcs	r6, #64	; 0x40
			endpoint0_transmit(data, size);
    5b06:	4631      	mov	r1, r6
    5b08:	f7ff fd16 	bl	5538 <endpoint0_transmit>
			ep0_tx_len -= size;
    5b0c:	882b      	ldrh	r3, [r5, #0]
    5b0e:	1b9b      	subs	r3, r3, r6
    5b10:	b29b      	uxth	r3, r3
			data += size;
    5b12:	4430      	add	r0, r6
			ep0_tx_len -= size;
    5b14:	802b      	strh	r3, [r5, #0]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    5b16:	b913      	cbnz	r3, 5b1e <usb_control+0x9e>
    5b18:	2f3f      	cmp	r7, #63	; 0x3f
    5b1a:	bf98      	it	ls
    5b1c:	2000      	movls	r0, #0
    5b1e:	6020      	str	r0, [r4, #0]
		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    5b20:	4b18      	ldr	r3, [pc, #96]	; (5b84 <usb_control+0x104>)
    5b22:	881a      	ldrh	r2, [r3, #0]
    5b24:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    5b28:	d1c3      	bne.n	5ab2 <usb_control+0x32>
			USB0_ADDR = setup.wValue;
    5b2a:	4a18      	ldr	r2, [pc, #96]	; (5b8c <usb_control+0x10c>)
    5b2c:	7899      	ldrb	r1, [r3, #2]
			setup.bRequest = 0;
    5b2e:	2000      	movs	r0, #0
    5b30:	7058      	strb	r0, [r3, #1]
			USB0_ADDR = setup.wValue;
    5b32:	f882 1098 	strb.w	r1, [r2, #152]	; 0x98
    5b36:	e7bc      	b.n	5ab2 <usb_control+0x32>
    5b38:	889b      	ldrh	r3, [r3, #4]
    5b3a:	b993      	cbnz	r3, 5b62 <usb_control+0xe2>
    5b3c:	4b17      	ldr	r3, [pc, #92]	; (5b9c <usb_control+0x11c>)
    5b3e:	1c51      	adds	r1, r2, #1
    5b40:	1a59      	subs	r1, r3, r1
    5b42:	2902      	cmp	r1, #2
    5b44:	d912      	bls.n	5b6c <usb_control+0xec>
					*dst++ = *buf++;
    5b46:	6811      	ldr	r1, [r2, #0]
    5b48:	6019      	str	r1, [r3, #0]
    5b4a:	7911      	ldrb	r1, [r2, #4]
    5b4c:	7119      	strb	r1, [r3, #4]
    5b4e:	7951      	ldrb	r1, [r2, #5]
    5b50:	7992      	ldrb	r2, [r2, #6]
    5b52:	7159      	strb	r1, [r3, #5]
    5b54:	719a      	strb	r2, [r3, #6]
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    5b56:	681b      	ldr	r3, [r3, #0]
    5b58:	2b86      	cmp	r3, #134	; 0x86
    5b5a:	d102      	bne.n	5b62 <usb_control+0xe2>
    5b5c:	4b10      	ldr	r3, [pc, #64]	; (5ba0 <usb_control+0x120>)
    5b5e:	220f      	movs	r2, #15
    5b60:	701a      	strb	r2, [r3, #0]
			endpoint0_transmit(NULL, 0);
    5b62:	2100      	movs	r1, #0
    5b64:	4608      	mov	r0, r1
    5b66:	f7ff fce7 	bl	5538 <endpoint0_transmit>
    5b6a:	e79f      	b.n	5aac <usb_control+0x2c>
					*dst++ = *buf++;
    5b6c:	7811      	ldrb	r1, [r2, #0]
    5b6e:	7019      	strb	r1, [r3, #0]
    5b70:	7851      	ldrb	r1, [r2, #1]
    5b72:	7059      	strb	r1, [r3, #1]
    5b74:	7891      	ldrb	r1, [r2, #2]
    5b76:	7099      	strb	r1, [r3, #2]
    5b78:	78d1      	ldrb	r1, [r2, #3]
    5b7a:	70d9      	strb	r1, [r3, #3]
    5b7c:	e7e5      	b.n	5b4a <usb_control+0xca>
    5b7e:	bf00      	nop
    5b80:	1fff0000 	.word	0x1fff0000
    5b84:	1fff1358 	.word	0x1fff1358
    5b88:	004000c8 	.word	0x004000c8
    5b8c:	40072000 	.word	0x40072000
    5b90:	1fff13e0 	.word	0x1fff13e0
    5b94:	1fff13e7 	.word	0x1fff13e7
    5b98:	1fff13e4 	.word	0x1fff13e4
    5b9c:	1fff13f4 	.word	0x1fff13f4
    5ba0:	1fff13ea 	.word	0x1fff13ea

00005ba4 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    5ba4:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    5ba6:	2b03      	cmp	r3, #3
    5ba8:	d816      	bhi.n	5bd8 <usb_rx+0x34>
	__disable_irq();
    5baa:	b672      	cpsid	i
	ret = rx_first[endpoint];
    5bac:	490b      	ldr	r1, [pc, #44]	; (5bdc <usb_rx+0x38>)
    5bae:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    5bb2:	b178      	cbz	r0, 5bd4 <usb_rx+0x30>
{
    5bb4:	b430      	push	{r4, r5}
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    5bb6:	4c0a      	ldr	r4, [pc, #40]	; (5be0 <usb_rx+0x3c>)
    5bb8:	f8b0 c000 	ldrh.w	ip, [r0]
    5bbc:	f834 2013 	ldrh.w	r2, [r4, r3, lsl #1]
		rx_first[endpoint] = ret->next;
    5bc0:	6845      	ldr	r5, [r0, #4]
    5bc2:	f841 5023 	str.w	r5, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    5bc6:	eba2 020c 	sub.w	r2, r2, ip
    5bca:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    5bce:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    5bd0:	bc30      	pop	{r4, r5}
    5bd2:	4770      	bx	lr
	__enable_irq();
    5bd4:	b662      	cpsie	i
}
    5bd6:	4770      	bx	lr
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    5bd8:	2000      	movs	r0, #0
    5bda:	4770      	bx	lr
    5bdc:	1fff130c 	.word	0x1fff130c
    5be0:	1fff134c 	.word	0x1fff134c

00005be4 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    5be4:	3801      	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    5be6:	2803      	cmp	r0, #3
    5be8:	d80b      	bhi.n	5c02 <usb_tx_packet_count+0x1e>
	__disable_irq();
    5bea:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    5bec:	4b07      	ldr	r3, [pc, #28]	; (5c0c <usb_tx_packet_count+0x28>)
    5bee:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5bf2:	b143      	cbz	r3, 5c06 <usb_tx_packet_count+0x22>
	uint32_t count=0;
    5bf4:	2000      	movs	r0, #0
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    5bf6:	685b      	ldr	r3, [r3, #4]
    5bf8:	3001      	adds	r0, #1
    5bfa:	2b00      	cmp	r3, #0
    5bfc:	d1fb      	bne.n	5bf6 <usb_tx_packet_count+0x12>
	__enable_irq();
    5bfe:	b662      	cpsie	i
	return count;
    5c00:	4770      	bx	lr
	if (endpoint >= NUM_ENDPOINTS) return 0;
    5c02:	2000      	movs	r0, #0
}
    5c04:	4770      	bx	lr
	uint32_t count=0;
    5c06:	4618      	mov	r0, r3
    5c08:	e7f9      	b.n	5bfe <usb_tx_packet_count+0x1a>
    5c0a:	bf00      	nop
    5c0c:	1fff132c 	.word	0x1fff132c

00005c10 <usb_rx_memory>:
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    5c10:	b672      	cpsid	i
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    5c12:	4a2e      	ldr	r2, [pc, #184]	; (5ccc <usb_rx_memory+0xbc>)
    5c14:	7813      	ldrb	r3, [r2, #0]
    5c16:	0719      	lsls	r1, r3, #28
    5c18:	d505      	bpl.n	5c26 <usb_rx_memory+0x16>
			if (table[index(i, RX, EVEN)].desc == 0) {
    5c1a:	4b2d      	ldr	r3, [pc, #180]	; (5cd0 <usb_rx_memory+0xc0>)
    5c1c:	6a19      	ldr	r1, [r3, #32]
    5c1e:	2900      	cmp	r1, #0
    5c20:	d038      	beq.n	5c94 <usb_rx_memory+0x84>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    5c22:	6a99      	ldr	r1, [r3, #40]	; 0x28
    5c24:	b339      	cbz	r1, 5c76 <usb_rx_memory+0x66>
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    5c26:	7853      	ldrb	r3, [r2, #1]
    5c28:	071b      	lsls	r3, r3, #28
    5c2a:	d506      	bpl.n	5c3a <usb_rx_memory+0x2a>
			if (table[index(i, RX, EVEN)].desc == 0) {
    5c2c:	4b28      	ldr	r3, [pc, #160]	; (5cd0 <usb_rx_memory+0xc0>)
    5c2e:	6c19      	ldr	r1, [r3, #64]	; 0x40
    5c30:	2900      	cmp	r1, #0
    5c32:	d044      	beq.n	5cbe <usb_rx_memory+0xae>
			if (table[index(i, RX, ODD)].desc == 0) {
    5c34:	6c99      	ldr	r1, [r3, #72]	; 0x48
    5c36:	2900      	cmp	r1, #0
    5c38:	d03b      	beq.n	5cb2 <usb_rx_memory+0xa2>
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    5c3a:	7893      	ldrb	r3, [r2, #2]
    5c3c:	0719      	lsls	r1, r3, #28
    5c3e:	d506      	bpl.n	5c4e <usb_rx_memory+0x3e>
			if (table[index(i, RX, EVEN)].desc == 0) {
    5c40:	4b23      	ldr	r3, [pc, #140]	; (5cd0 <usb_rx_memory+0xc0>)
    5c42:	6e19      	ldr	r1, [r3, #96]	; 0x60
    5c44:	2900      	cmp	r1, #0
    5c46:	d03d      	beq.n	5cc4 <usb_rx_memory+0xb4>
			if (table[index(i, RX, ODD)].desc == 0) {
    5c48:	6e99      	ldr	r1, [r3, #104]	; 0x68
    5c4a:	2900      	cmp	r1, #0
    5c4c:	d034      	beq.n	5cb8 <usb_rx_memory+0xa8>
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    5c4e:	78d3      	ldrb	r3, [r2, #3]
    5c50:	071b      	lsls	r3, r3, #28
    5c52:	d50a      	bpl.n	5c6a <usb_rx_memory+0x5a>
			if (table[index(i, RX, EVEN)].desc == 0) {
    5c54:	4b1e      	ldr	r3, [pc, #120]	; (5cd0 <usb_rx_memory+0xc0>)
    5c56:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
    5c5a:	f04f 0c10 	mov.w	ip, #16
    5c5e:	b1da      	cbz	r2, 5c98 <usb_rx_memory+0x88>
			if (table[index(i, RX, ODD)].desc == 0) {
    5c60:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    5c64:	f04f 0c11 	mov.w	ip, #17
    5c68:	b13a      	cbz	r2, 5c7a <usb_rx_memory+0x6a>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    5c6a:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    5c6c:	4b19      	ldr	r3, [pc, #100]	; (5cd4 <usb_rx_memory+0xc4>)
    5c6e:	2200      	movs	r2, #0
    5c70:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
    5c72:	f000 ba73 	b.w	615c <usb_free>
			if (table[index(i, RX, ODD)].desc == 0) {
    5c76:	f04f 0c05 	mov.w	ip, #5
				usb_rx_memory_needed--;
    5c7a:	4916      	ldr	r1, [pc, #88]	; (5cd4 <usb_rx_memory+0xc4>)
				table[index(i, RX, ODD)].addr = packet->buf;
    5c7c:	eb03 02cc 	add.w	r2, r3, ip, lsl #3
    5c80:	3008      	adds	r0, #8
    5c82:	6050      	str	r0, [r2, #4]
				usb_rx_memory_needed--;
    5c84:	780a      	ldrb	r2, [r1, #0]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    5c86:	4814      	ldr	r0, [pc, #80]	; (5cd8 <usb_rx_memory+0xc8>)
    5c88:	f843 003c 	str.w	r0, [r3, ip, lsl #3]
				usb_rx_memory_needed--;
    5c8c:	3a01      	subs	r2, #1
    5c8e:	700a      	strb	r2, [r1, #0]
				__enable_irq();
    5c90:	b662      	cpsie	i
	return;
}
    5c92:	4770      	bx	lr
			if (table[index(i, RX, EVEN)].desc == 0) {
    5c94:	f04f 0c04 	mov.w	ip, #4
				usb_rx_memory_needed--;
    5c98:	490e      	ldr	r1, [pc, #56]	; (5cd4 <usb_rx_memory+0xc4>)
				table[index(i, RX, EVEN)].addr = packet->buf;
    5c9a:	eb03 02cc 	add.w	r2, r3, ip, lsl #3
    5c9e:	3008      	adds	r0, #8
    5ca0:	6050      	str	r0, [r2, #4]
				usb_rx_memory_needed--;
    5ca2:	780a      	ldrb	r2, [r1, #0]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    5ca4:	480d      	ldr	r0, [pc, #52]	; (5cdc <usb_rx_memory+0xcc>)
    5ca6:	f843 003c 	str.w	r0, [r3, ip, lsl #3]
				usb_rx_memory_needed--;
    5caa:	3a01      	subs	r2, #1
    5cac:	700a      	strb	r2, [r1, #0]
				__enable_irq();
    5cae:	b662      	cpsie	i
				return;
    5cb0:	4770      	bx	lr
			if (table[index(i, RX, ODD)].desc == 0) {
    5cb2:	f04f 0c09 	mov.w	ip, #9
    5cb6:	e7e0      	b.n	5c7a <usb_rx_memory+0x6a>
    5cb8:	f04f 0c0d 	mov.w	ip, #13
    5cbc:	e7dd      	b.n	5c7a <usb_rx_memory+0x6a>
			if (table[index(i, RX, EVEN)].desc == 0) {
    5cbe:	f04f 0c08 	mov.w	ip, #8
    5cc2:	e7e9      	b.n	5c98 <usb_rx_memory+0x88>
    5cc4:	f04f 0c0c 	mov.w	ip, #12
    5cc8:	e7e6      	b.n	5c98 <usb_rx_memory+0x88>
    5cca:	bf00      	nop
    5ccc:	0000f5c0 	.word	0x0000f5c0
    5cd0:	1fff0000 	.word	0x1fff0000
    5cd4:	1fff13e8 	.word	0x1fff13e8
    5cd8:	004000c8 	.word	0x004000c8
    5cdc:	00400088 	.word	0x00400088

00005ce0 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    5ce0:	1e42      	subs	r2, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    5ce2:	2a03      	cmp	r2, #3
    5ce4:	d80e      	bhi.n	5d04 <usb_tx+0x24>
{
    5ce6:	b410      	push	{r4}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    5ce8:	0143      	lsls	r3, r0, #5
    5cea:	4c1b      	ldr	r4, [pc, #108]	; (5d58 <usb_tx+0x78>)
    5cec:	f043 0310 	orr.w	r3, r3, #16
    5cf0:	4423      	add	r3, r4
	__disable_irq();
    5cf2:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    5cf4:	4c19      	ldr	r4, [pc, #100]	; (5d5c <usb_tx+0x7c>)
    5cf6:	5ca0      	ldrb	r0, [r4, r2]
    5cf8:	2803      	cmp	r0, #3
    5cfa:	d81d      	bhi.n	5d38 <usb_tx+0x58>
    5cfc:	e8df f000 	tbb	[pc, r0]
    5d00:	19031614 	.word	0x19031614
    5d04:	4770      	bx	lr
    5d06:	2005      	movs	r0, #5
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    5d08:	54a0      	strb	r0, [r4, r2]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    5d0a:	f013 0f08 	tst.w	r3, #8
    5d0e:	8808      	ldrh	r0, [r1, #0]
    5d10:	bf14      	ite	ne
    5d12:	22c8      	movne	r2, #200	; 0xc8
    5d14:	2288      	moveq	r2, #136	; 0x88
	b->addr = packet->buf;
    5d16:	3108      	adds	r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    5d18:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
    5d1c:	e9c3 2100 	strd	r2, r1, [r3]
	__enable_irq();
    5d20:	b662      	cpsie	i
}
    5d22:	f85d 4b04 	ldr.w	r4, [sp], #4
    5d26:	4770      	bx	lr
		next = TX_STATE_ODD_FREE;
    5d28:	2003      	movs	r0, #3
    5d2a:	e7ed      	b.n	5d08 <usb_tx+0x28>
		b++;
    5d2c:	3308      	adds	r3, #8
		next = TX_STATE_EVEN_FREE;
    5d2e:	2002      	movs	r0, #2
		break;
    5d30:	e7ea      	b.n	5d08 <usb_tx+0x28>
		b++;
    5d32:	3308      	adds	r3, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    5d34:	2004      	movs	r0, #4
		break;
    5d36:	e7e7      	b.n	5d08 <usb_tx+0x28>
		if (tx_first[endpoint] == NULL) {
    5d38:	4b09      	ldr	r3, [pc, #36]	; (5d60 <usb_tx+0x80>)
    5d3a:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    5d3e:	b138      	cbz	r0, 5d50 <usb_tx+0x70>
			tx_last[endpoint]->next = packet;
    5d40:	4b08      	ldr	r3, [pc, #32]	; (5d64 <usb_tx+0x84>)
    5d42:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    5d46:	6041      	str	r1, [r0, #4]
		tx_last[endpoint] = packet;
    5d48:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		__enable_irq();
    5d4c:	b662      	cpsie	i
		return;
    5d4e:	e7e8      	b.n	5d22 <usb_tx+0x42>
			tx_first[endpoint] = packet;
    5d50:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    5d54:	4b03      	ldr	r3, [pc, #12]	; (5d64 <usb_tx+0x84>)
    5d56:	e7f7      	b.n	5d48 <usb_tx+0x68>
    5d58:	1fff0000 	.word	0x1fff0000
    5d5c:	1fff1354 	.word	0x1fff1354
    5d60:	1fff132c 	.word	0x1fff132c
    5d64:	1fff133c 	.word	0x1fff133c

00005d68 <_reboot_Teensyduino_>:


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    5d68:	be00      	bkpt	0x0000
    5d6a:	bf00      	nop

00005d6c <usb_isr>:
}



void usb_isr(void)
{
    5d6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    5d70:	4f83      	ldr	r7, [pc, #524]	; (5f80 <usb_isr+0x214>)

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
		if (usb_configuration) {
    5d72:	4d84      	ldr	r5, [pc, #528]	; (5f84 <usb_isr+0x218>)
			t = usb_reboot_timer;
    5d74:	4e84      	ldr	r6, [pc, #528]	; (5f88 <usb_isr+0x21c>)
    5d76:	e03f      	b.n	5df8 <usb_isr+0x8c>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    5d78:	f8df 8234 	ldr.w	r8, [pc, #564]	; 5fb0 <usb_isr+0x244>
    5d7c:	ea4f 0990 	mov.w	r9, r0, lsr #2
    5d80:	eb08 0ac9 	add.w	sl, r8, r9, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    5d84:	3b01      	subs	r3, #1
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    5d86:	f8da 2004 	ldr.w	r2, [sl, #4]
			endpoint--;	// endpoint is index to zero-based arrays
    5d8a:	b2dc      	uxtb	r4, r3
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    5d8c:	f010 0308 	ands.w	r3, r0, #8
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    5d90:	f1a2 0c08 	sub.w	ip, r2, #8
			if (stat & 0x08) { // transmit
    5d94:	d162      	bne.n	5e5c <usb_isr+0xf0>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    5d96:	f858 1039 	ldr.w	r1, [r8, r9, lsl #3]
    5d9a:	0c08      	lsrs	r0, r1, #16
				if (packet->len > 0) {
    5d9c:	0c09      	lsrs	r1, r1, #16
				packet->len = b->desc >> 16;
    5d9e:	f822 0c08 	strh.w	r0, [r2, #-8]
				if (packet->len > 0) {
    5da2:	d052      	beq.n	5e4a <usb_isr+0xde>
					packet->index = 0;
    5da4:	f822 3c06 	strh.w	r3, [r2, #-6]
					packet->next = NULL;
    5da8:	f842 3c04 	str.w	r3, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    5dac:	4a77      	ldr	r2, [pc, #476]	; (5f8c <usb_isr+0x220>)
    5dae:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
    5db2:	2b00      	cmp	r3, #0
    5db4:	f000 8085 	beq.w	5ec2 <usb_isr+0x156>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    5db8:	4a75      	ldr	r2, [pc, #468]	; (5f90 <usb_isr+0x224>)
    5dba:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
    5dbe:	f8c3 c004 	str.w	ip, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    5dc2:	4b74      	ldr	r3, [pc, #464]	; (5f94 <usb_isr+0x228>)
					rx_last[endpoint] = packet;
    5dc4:	f842 c024 	str.w	ip, [r2, r4, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    5dc8:	f833 2014 	ldrh.w	r2, [r3, r4, lsl #1]
    5dcc:	4410      	add	r0, r2
    5dce:	f823 0014 	strh.w	r0, [r3, r4, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    5dd2:	f000 f98b 	bl	60ec <usb_malloc>
					if (packet) {
    5dd6:	2800      	cmp	r0, #0
    5dd8:	d06c      	beq.n	5eb4 <usb_isr+0x148>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    5dda:	4a6f      	ldr	r2, [pc, #444]	; (5f98 <usb_isr+0x22c>)
    5ddc:	4b6f      	ldr	r3, [pc, #444]	; (5f9c <usb_isr+0x230>)
    5dde:	f01a 0f08 	tst.w	sl, #8
						b->addr = packet->buf;
    5de2:	f100 0008 	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    5de6:	bf08      	it	eq
    5de8:	4613      	moveq	r3, r2
						b->addr = packet->buf;
    5dea:	f8ca 0004 	str.w	r0, [sl, #4]
						b->desc = BDT_DESC(64,
    5dee:	f848 3039 	str.w	r3, [r8, r9, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    5df2:	2308      	movs	r3, #8
    5df4:	f887 3080 	strb.w	r3, [r7, #128]	; 0x80
	status = USB0_ISTAT;
    5df8:	f897 3080 	ldrb.w	r3, [r7, #128]	; 0x80
    5dfc:	b2dc      	uxtb	r4, r3
	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    5dfe:	075b      	lsls	r3, r3, #29
    5e00:	d518      	bpl.n	5e34 <usb_isr+0xc8>
		if (usb_configuration) {
    5e02:	782b      	ldrb	r3, [r5, #0]
    5e04:	b19b      	cbz	r3, 5e2e <usb_isr+0xc2>
			t = usb_reboot_timer;
    5e06:	7832      	ldrb	r2, [r6, #0]
			if (t) {
    5e08:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    5e0c:	b12a      	cbz	r2, 5e1a <usb_isr+0xae>
				usb_reboot_timer = --t;
    5e0e:	3b01      	subs	r3, #1
    5e10:	b2db      	uxtb	r3, r3
    5e12:	7033      	strb	r3, [r6, #0]
				if (!t) _reboot_Teensyduino_();
    5e14:	2b00      	cmp	r3, #0
    5e16:	f000 80b1 	beq.w	5f7c <usb_isr+0x210>
			t = usb_cdc_transmit_flush_timer;
    5e1a:	4961      	ldr	r1, [pc, #388]	; (5fa0 <usb_isr+0x234>)
    5e1c:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    5e1e:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    5e22:	b122      	cbz	r2, 5e2e <usb_isr+0xc2>
				usb_cdc_transmit_flush_timer = --t;
    5e24:	3b01      	subs	r3, #1
    5e26:	b2db      	uxtb	r3, r3
    5e28:	700b      	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    5e2a:	2b00      	cmp	r3, #0
    5e2c:	d06e      	beq.n	5f0c <usb_isr+0x1a0>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    5e2e:	2304      	movs	r3, #4
    5e30:	f887 3080 	strb.w	r3, [r7, #128]	; 0x80
	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    5e34:	f014 0308 	ands.w	r3, r4, #8
    5e38:	d051      	beq.n	5ede <usb_isr+0x172>
		stat = USB0_STAT;
    5e3a:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
    5e3e:	b2d8      	uxtb	r0, r3
		if (endpoint == 0) {
    5e40:	091b      	lsrs	r3, r3, #4
    5e42:	d199      	bne.n	5d78 <usb_isr+0xc>
			usb_control(stat);
    5e44:	f7ff fe1c 	bl	5a80 <usb_control>
    5e48:	e7d3      	b.n	5df2 <usb_isr+0x86>
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    5e4a:	4a53      	ldr	r2, [pc, #332]	; (5f98 <usb_isr+0x22c>)
    5e4c:	4b53      	ldr	r3, [pc, #332]	; (5f9c <usb_isr+0x230>)
    5e4e:	f01a 0f08 	tst.w	sl, #8
    5e52:	bf08      	it	eq
    5e54:	4613      	moveq	r3, r2
    5e56:	f848 3039 	str.w	r3, [r8, r9, lsl #3]
    5e5a:	e7ca      	b.n	5df2 <usb_isr+0x86>
				usb_free(packet);
    5e5c:	4660      	mov	r0, ip
    5e5e:	f000 f97d 	bl	615c <usb_free>
				packet = tx_first[endpoint];
    5e62:	4950      	ldr	r1, [pc, #320]	; (5fa4 <usb_isr+0x238>)
    5e64:	f851 2024 	ldr.w	r2, [r1, r4, lsl #2]
				if (packet) {
    5e68:	b37a      	cbz	r2, 5eca <usb_isr+0x15e>
					tx_first[endpoint] = packet->next;
    5e6a:	6853      	ldr	r3, [r2, #4]
    5e6c:	f841 3024 	str.w	r3, [r1, r4, lsl #2]
					switch (tx_state[endpoint]) {
    5e70:	4b4d      	ldr	r3, [pc, #308]	; (5fa8 <usb_isr+0x23c>)
					b->addr = packet->buf;
    5e72:	f102 0108 	add.w	r1, r2, #8
    5e76:	f8ca 1004 	str.w	r1, [sl, #4]
					switch (tx_state[endpoint]) {
    5e7a:	5d19      	ldrb	r1, [r3, r4]
    5e7c:	2903      	cmp	r1, #3
    5e7e:	d805      	bhi.n	5e8c <usb_isr+0x120>
    5e80:	e8df f001 	tbb	[pc, r1]
    5e84:	020f1215 	.word	0x020f1215
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    5e88:	2104      	movs	r1, #4
    5e8a:	5519      	strb	r1, [r3, r4]
					b->desc = BDT_DESC(packet->len,
    5e8c:	8812      	ldrh	r2, [r2, #0]
    5e8e:	f01a 0f08 	tst.w	sl, #8
    5e92:	bf14      	ite	ne
    5e94:	23c8      	movne	r3, #200	; 0xc8
    5e96:	2388      	moveq	r3, #136	; 0x88
    5e98:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    5e9c:	f848 3039 	str.w	r3, [r8, r9, lsl #3]
    5ea0:	e7a7      	b.n	5df2 <usb_isr+0x86>
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    5ea2:	2105      	movs	r1, #5
    5ea4:	5519      	strb	r1, [r3, r4]
						break;
    5ea6:	e7f1      	b.n	5e8c <usb_isr+0x120>
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    5ea8:	2102      	movs	r1, #2
    5eaa:	5519      	strb	r1, [r3, r4]
						break;
    5eac:	e7ee      	b.n	5e8c <usb_isr+0x120>
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    5eae:	2103      	movs	r1, #3
    5eb0:	5519      	strb	r1, [r3, r4]
						break;
    5eb2:	e7eb      	b.n	5e8c <usb_isr+0x120>
						usb_rx_memory_needed++;
    5eb4:	4a3d      	ldr	r2, [pc, #244]	; (5fac <usb_isr+0x240>)
						b->desc = 0;
    5eb6:	f848 0039 	str.w	r0, [r8, r9, lsl #3]
						usb_rx_memory_needed++;
    5eba:	7813      	ldrb	r3, [r2, #0]
    5ebc:	3301      	adds	r3, #1
    5ebe:	7013      	strb	r3, [r2, #0]
    5ec0:	e797      	b.n	5df2 <usb_isr+0x86>
						rx_first[endpoint] = packet;
    5ec2:	f842 c024 	str.w	ip, [r2, r4, lsl #2]
    5ec6:	4a32      	ldr	r2, [pc, #200]	; (5f90 <usb_isr+0x224>)
    5ec8:	e77b      	b.n	5dc2 <usb_isr+0x56>
					switch (tx_state[endpoint]) {
    5eca:	4b37      	ldr	r3, [pc, #220]	; (5fa8 <usb_isr+0x23c>)
    5ecc:	5d19      	ldrb	r1, [r3, r4]
    5ece:	2902      	cmp	r1, #2
    5ed0:	d024      	beq.n	5f1c <usb_isr+0x1b0>
    5ed2:	d98e      	bls.n	5df2 <usb_isr+0x86>
    5ed4:	2903      	cmp	r1, #3
    5ed6:	d11c      	bne.n	5f12 <usb_isr+0x1a6>
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    5ed8:	2201      	movs	r2, #1
    5eda:	551a      	strb	r2, [r3, r4]
						break;
    5edc:	e789      	b.n	5df2 <usb_isr+0x86>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    5ede:	07e0      	lsls	r0, r4, #31
    5ee0:	d428      	bmi.n	5f34 <usb_isr+0x1c8>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    5ee2:	0621      	lsls	r1, r4, #24
    5ee4:	d41c      	bmi.n	5f20 <usb_isr+0x1b4>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    5ee6:	07a2      	lsls	r2, r4, #30
    5ee8:	d508      	bpl.n	5efc <usb_isr+0x190>
		uint8_t err = USB0_ERRSTAT;
    5eea:	4b25      	ldr	r3, [pc, #148]	; (5f80 <usb_isr+0x214>)
    5eec:	f893 2088 	ldrb.w	r2, [r3, #136]	; 0x88
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    5ef0:	2102      	movs	r1, #2
		uint8_t err = USB0_ERRSTAT;
    5ef2:	b2d2      	uxtb	r2, r2
		USB0_ERRSTAT = err;
    5ef4:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
		USB0_ISTAT = USB_ISTAT_ERROR;
    5ef8:	f883 1080 	strb.w	r1, [r3, #128]	; 0x80
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    5efc:	06e3      	lsls	r3, r4, #27
    5efe:	d503      	bpl.n	5f08 <usb_isr+0x19c>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    5f00:	4b1f      	ldr	r3, [pc, #124]	; (5f80 <usb_isr+0x214>)
    5f02:	2210      	movs	r2, #16
    5f04:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	}

}
    5f08:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if (t == 0) usb_serial_flush_callback();
    5f0c:	f000 fb60 	bl	65d0 <usb_serial_flush_callback>
    5f10:	e78d      	b.n	5e2e <usb_isr+0xc2>
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    5f12:	f01a 0f08 	tst.w	sl, #8
    5f16:	bf14      	ite	ne
    5f18:	2203      	movne	r2, #3
    5f1a:	2202      	moveq	r2, #2
    5f1c:	551a      	strb	r2, [r3, r4]
						break;
    5f1e:	e768      	b.n	5df2 <usb_isr+0x86>
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5f20:	4b17      	ldr	r3, [pc, #92]	; (5f80 <usb_isr+0x214>)
		USB0_ISTAT = USB_ISTAT_STALL;
    5f22:	2280      	movs	r2, #128	; 0x80
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5f24:	210d      	movs	r1, #13
    5f26:	f883 10c0 	strb.w	r1, [r3, #192]	; 0xc0
		USB0_ISTAT = USB_ISTAT_STALL;
    5f2a:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    5f2e:	07a2      	lsls	r2, r4, #30
    5f30:	d5e4      	bpl.n	5efc <usb_isr+0x190>
    5f32:	e7da      	b.n	5eea <usb_isr+0x17e>
		USB0_CTL = USB_CTL_ODDRST;
    5f34:	4a12      	ldr	r2, [pc, #72]	; (5f80 <usb_isr+0x214>)
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    5f36:	491e      	ldr	r1, [pc, #120]	; (5fb0 <usb_isr+0x244>)
    5f38:	4c17      	ldr	r4, [pc, #92]	; (5f98 <usb_isr+0x22c>)
		ep0_tx_bdt_bank = 0;
    5f3a:	481e      	ldr	r0, [pc, #120]	; (5fb4 <usb_isr+0x248>)
		USB0_CTL = USB_CTL_ODDRST;
    5f3c:	2502      	movs	r5, #2
    5f3e:	f882 5094 	strb.w	r5, [r2, #148]	; 0x94
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    5f42:	4d1d      	ldr	r5, [pc, #116]	; (5fb8 <usb_isr+0x24c>)
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    5f44:	608c      	str	r4, [r1, #8]
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    5f46:	e9c1 4500 	strd	r4, r5, [r1]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    5f4a:	4c1c      	ldr	r4, [pc, #112]	; (5fbc <usb_isr+0x250>)
		ep0_tx_bdt_bank = 0;
    5f4c:	7003      	strb	r3, [r0, #0]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    5f4e:	60cc      	str	r4, [r1, #12]
		USB0_ERRSTAT = 0xFF;
    5f50:	20ff      	movs	r0, #255	; 0xff
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5f52:	240d      	movs	r4, #13
		table[index(0, TX, EVEN)].desc = 0;
    5f54:	610b      	str	r3, [r1, #16]
		table[index(0, TX, ODD)].desc = 0;
    5f56:	618b      	str	r3, [r1, #24]
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    5f58:	f882 40c0 	strb.w	r4, [r2, #192]	; 0xc0
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    5f5c:	219f      	movs	r1, #159	; 0x9f
		USB0_ERRSTAT = 0xFF;
    5f5e:	f882 0088 	strb.w	r0, [r2, #136]	; 0x88
		USB0_ISTAT = 0xFF;
    5f62:	f882 0080 	strb.w	r0, [r2, #128]	; 0x80
		USB0_ADDR = 0;
    5f66:	f882 3098 	strb.w	r3, [r2, #152]	; 0x98
		USB0_CTL = USB_CTL_USBENSOFEN;
    5f6a:	2301      	movs	r3, #1
		USB0_ERREN = 0xFF;
    5f6c:	f882 008c 	strb.w	r0, [r2, #140]	; 0x8c
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    5f70:	f882 1084 	strb.w	r1, [r2, #132]	; 0x84
		USB0_CTL = USB_CTL_USBENSOFEN;
    5f74:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
}
    5f78:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if (!t) _reboot_Teensyduino_();
    5f7c:	f7ff fef4 	bl	5d68 <_reboot_Teensyduino_>
    5f80:	40072000 	.word	0x40072000
    5f84:	1fff13e9 	.word	0x1fff13e9
    5f88:	1fff13ea 	.word	0x1fff13ea
    5f8c:	1fff130c 	.word	0x1fff130c
    5f90:	1fff131c 	.word	0x1fff131c
    5f94:	1fff134c 	.word	0x1fff134c
    5f98:	00400088 	.word	0x00400088
    5f9c:	004000c8 	.word	0x004000c8
    5fa0:	1fff1401 	.word	0x1fff1401
    5fa4:	1fff132c 	.word	0x1fff132c
    5fa8:	1fff1354 	.word	0x1fff1354
    5fac:	1fff13e8 	.word	0x1fff13e8
    5fb0:	1fff0000 	.word	0x1fff0000
    5fb4:	1fff13e6 	.word	0x1fff13e6
    5fb8:	1fff1360 	.word	0x1fff1360
    5fbc:	1fff13a0 	.word	0x1fff13a0

00005fc0 <usb_init>:



void usb_init(void)
{
    5fc0:	b510      	push	{r4, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    5fc2:	f001 f855 	bl	7070 <usb_init_serialnumber>
    5fc6:	4824      	ldr	r0, [pc, #144]	; (6058 <usb_init+0x98>)

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
		table[i].desc = 0;
    5fc8:	2200      	movs	r2, #0
    5fca:	f100 01a0 	add.w	r1, r0, #160	; 0xa0
	usb_init_serialnumber();
    5fce:	4603      	mov	r3, r0
		table[i].addr = 0;
    5fd0:	e9c3 2200 	strd	r2, r2, [r3]
	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    5fd4:	3308      	adds	r3, #8
    5fd6:	428b      	cmp	r3, r1
    5fd8:	d1fa      	bne.n	5fd0 <usb_init+0x10>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    5fda:	4920      	ldr	r1, [pc, #128]	; (605c <usb_init+0x9c>)
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    5fdc:	4c20      	ldr	r4, [pc, #128]	; (6060 <usb_init+0xa0>)
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    5fde:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    5fe0:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    5fe4:	634b      	str	r3, [r1, #52]	; 0x34
	MPU_RGDAAC0 |= 0x03000000;
    5fe6:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    5fea:	f501 3128 	add.w	r1, r1, #172032	; 0x2a000
    5fee:	f501 7180 	add.w	r1, r1, #256	; 0x100
	MPU_RGDAAC0 |= 0x03000000;
    5ff2:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
    5ff6:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    5ffa:	2403      	movs	r4, #3
    5ffc:	f881 4044 	strb.w	r4, [r1, #68]	; 0x44
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    6000:	4b18      	ldr	r3, [pc, #96]	; (6064 <usb_init+0xa4>)
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    6002:	24a0      	movs	r4, #160	; 0xa0
    6004:	f881 4040 	strb.w	r4, [r1, #64]	; 0x40
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    6008:	f3c0 2407 	ubfx	r4, r0, #8, #8
    600c:	f883 409c 	strb.w	r4, [r3, #156]	; 0x9c
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6010:	f3c0 4407 	ubfx	r4, r0, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    6014:	0e00      	lsrs	r0, r0, #24
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    6016:	f883 40b0 	strb.w	r4, [r3, #176]	; 0xb0

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    601a:	f04f 0cff 	mov.w	ip, #255	; 0xff
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    601e:	f883 00b4 	strb.w	r0, [r3, #180]	; 0xb4
	USB0_OTGISTAT = 0xFF;

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    6022:	2001      	movs	r0, #1
	USB0_ISTAT = 0xFF;
    6024:	f883 c080 	strb.w	ip, [r3, #128]	; 0x80

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    6028:	4c0f      	ldr	r4, [pc, #60]	; (6068 <usb_init+0xa8>)
	USB0_ERRSTAT = 0xFF;
    602a:	f883 c088 	strb.w	ip, [r3, #136]	; 0x88
	USB0_OTGISTAT = 0xFF;
    602e:	f883 c010 	strb.w	ip, [r3, #16]
	USB0_CTL = USB_CTL_USBENSOFEN;
    6032:	f883 0094 	strb.w	r0, [r3, #148]	; 0x94
	USB0_USBCTRL = 0;
    6036:	700a      	strb	r2, [r1, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    6038:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
	USB0_INTEN = USB_INTEN_USBRSTEN;
    603c:	f883 0084 	strb.w	r0, [r3, #132]	; 0x84
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    6040:	f04f 0c70 	mov.w	ip, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    6044:	f44f 1000 	mov.w	r0, #2097152	; 0x200000

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    6048:	2310      	movs	r3, #16
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    604a:	f884 c035 	strb.w	ip, [r4, #53]	; 0x35
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    604e:	f8c2 0104 	str.w	r0, [r2, #260]	; 0x104
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    6052:	720b      	strb	r3, [r1, #8]
}
    6054:	bd10      	pop	{r4, pc}
    6056:	bf00      	nop
    6058:	1fff0000 	.word	0x1fff0000
    605c:	40048000 	.word	0x40048000
    6060:	4000d000 	.word	0x4000d000
    6064:	40072000 	.word	0x40072000
    6068:	e000e400 	.word	0xe000e400

0000606c <_ZN16usb_serial_class9availableEv>:
        virtual int available() { return usb_serial_available(); }
    606c:	b580      	push	{r7, lr}
    606e:	b082      	sub	sp, #8
    6070:	af00      	add	r7, sp, #0
    6072:	6078      	str	r0, [r7, #4]
    6074:	f000 f922 	bl	62bc <usb_serial_available>
    6078:	4603      	mov	r3, r0
    607a:	4618      	mov	r0, r3
    607c:	3708      	adds	r7, #8
    607e:	46bd      	mov	sp, r7
    6080:	bd80      	pop	{r7, pc}

00006082 <_ZN16usb_serial_class4readEv>:
        virtual int read() { return usb_serial_getchar(); }
    6082:	b580      	push	{r7, lr}
    6084:	b082      	sub	sp, #8
    6086:	af00      	add	r7, sp, #0
    6088:	6078      	str	r0, [r7, #4]
    608a:	f000 f8a1 	bl	61d0 <usb_serial_getchar>
    608e:	4603      	mov	r3, r0
    6090:	4618      	mov	r0, r3
    6092:	3708      	adds	r7, #8
    6094:	46bd      	mov	sp, r7
    6096:	bd80      	pop	{r7, pc}

00006098 <_ZN16usb_serial_class5writeEh>:
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    6098:	b580      	push	{r7, lr}
    609a:	b082      	sub	sp, #8
    609c:	af00      	add	r7, sp, #0
    609e:	6078      	str	r0, [r7, #4]
    60a0:	460b      	mov	r3, r1
    60a2:	70fb      	strb	r3, [r7, #3]
    60a4:	78fb      	ldrb	r3, [r7, #3]
    60a6:	4618      	mov	r0, r3
    60a8:	f000 f95e 	bl	6368 <usb_serial_putchar>
    60ac:	4603      	mov	r3, r0
    60ae:	4618      	mov	r0, r3
    60b0:	3708      	adds	r7, #8
    60b2:	46bd      	mov	sp, r7
    60b4:	bd80      	pop	{r7, pc}

000060b6 <_ZN16usb_serial_class5writeEPKhj>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    60b6:	b580      	push	{r7, lr}
    60b8:	b084      	sub	sp, #16
    60ba:	af00      	add	r7, sp, #0
    60bc:	60f8      	str	r0, [r7, #12]
    60be:	60b9      	str	r1, [r7, #8]
    60c0:	607a      	str	r2, [r7, #4]
    60c2:	6879      	ldr	r1, [r7, #4]
    60c4:	68b8      	ldr	r0, [r7, #8]
    60c6:	f000 f95f 	bl	6388 <usb_serial_write>
    60ca:	4603      	mov	r3, r0
    60cc:	4618      	mov	r0, r3
    60ce:	3710      	adds	r7, #16
    60d0:	46bd      	mov	sp, r7
    60d2:	bd80      	pop	{r7, pc}

000060d4 <_ZN16usb_serial_class17availableForWriteEv>:
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    60d4:	b580      	push	{r7, lr}
    60d6:	b082      	sub	sp, #8
    60d8:	af00      	add	r7, sp, #0
    60da:	6078      	str	r0, [r7, #4]
    60dc:	f000 f9fc 	bl	64d8 <usb_serial_write_buffer_free>
    60e0:	4603      	mov	r3, r0
    60e2:	4618      	mov	r0, r3
    60e4:	3708      	adds	r7, #8
    60e6:	46bd      	mov	sp, r7
    60e8:	bd80      	pop	{r7, pc}
    60ea:	Address 0x000060ea is out of bounds.


000060ec <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t * usb_malloc(void)
{
    60ec:	b480      	push	{r7}
    60ee:	b085      	sub	sp, #20
    60f0:	af00      	add	r7, sp, #0
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    60f2:	b672      	cpsid	i
	avail = usb_buffer_available;
    60f4:	4b17      	ldr	r3, [pc, #92]	; (6154 <usb_malloc+0x68>)
    60f6:	681b      	ldr	r3, [r3, #0]
    60f8:	60fb      	str	r3, [r7, #12]
	n = __builtin_clz(avail); // clz = count leading zeros
    60fa:	68fb      	ldr	r3, [r7, #12]
    60fc:	fab3 f383 	clz	r3, r3
    6100:	60bb      	str	r3, [r7, #8]
	if (n >= NUM_USB_BUFFERS) {
    6102:	68bb      	ldr	r3, [r7, #8]
    6104:	2b0b      	cmp	r3, #11
    6106:	d902      	bls.n	610e <usb_malloc+0x22>
		__enable_irq();
    6108:	b662      	cpsie	i
		return NULL;
    610a:	2300      	movs	r3, #0
    610c:	e01b      	b.n	6146 <usb_malloc+0x5a>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    610e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    6112:	68bb      	ldr	r3, [r7, #8]
    6114:	fa22 f303 	lsr.w	r3, r2, r3
    6118:	43da      	mvns	r2, r3
    611a:	68fb      	ldr	r3, [r7, #12]
    611c:	4013      	ands	r3, r2
    611e:	4a0d      	ldr	r2, [pc, #52]	; (6154 <usb_malloc+0x68>)
    6120:	6013      	str	r3, [r2, #0]
	__enable_irq();
    6122:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    6124:	68ba      	ldr	r2, [r7, #8]
    6126:	4613      	mov	r3, r2
    6128:	00db      	lsls	r3, r3, #3
    612a:	4413      	add	r3, r2
    612c:	00db      	lsls	r3, r3, #3
    612e:	461a      	mov	r2, r3
    6130:	4b09      	ldr	r3, [pc, #36]	; (6158 <usb_malloc+0x6c>)
    6132:	4413      	add	r3, r2
    6134:	607b      	str	r3, [r7, #4]
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    6136:	687b      	ldr	r3, [r7, #4]
    6138:	2200      	movs	r2, #0
    613a:	601a      	str	r2, [r3, #0]
	*(uint32_t *)(p + 4) = 0;
    613c:	687b      	ldr	r3, [r7, #4]
    613e:	3304      	adds	r3, #4
    6140:	2200      	movs	r2, #0
    6142:	601a      	str	r2, [r3, #0]
	return (usb_packet_t *)p;
    6144:	687b      	ldr	r3, [r7, #4]
}
    6146:	4618      	mov	r0, r3
    6148:	3714      	adds	r7, #20
    614a:	46bd      	mov	sp, r7
    614c:	f85d 7b04 	ldr.w	r7, [sp], #4
    6150:	4770      	bx	lr
    6152:	bf00      	nop
    6154:	1fff079c 	.word	0x1fff079c
    6158:	1fff03d0 	.word	0x1fff03d0

0000615c <usb_free>:
// for the receive endpoints to request memory
extern uint8_t usb_rx_memory_needed;
extern void usb_rx_memory(usb_packet_t *packet);

void usb_free(usb_packet_t *p)
{
    615c:	b580      	push	{r7, lr}
    615e:	b084      	sub	sp, #16
    6160:	af00      	add	r7, sp, #0
    6162:	6078      	str	r0, [r7, #4]
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    6164:	687b      	ldr	r3, [r7, #4]
    6166:	4a15      	ldr	r2, [pc, #84]	; (61bc <usb_free+0x60>)
    6168:	1a9b      	subs	r3, r3, r2
    616a:	461a      	mov	r2, r3
    616c:	4b14      	ldr	r3, [pc, #80]	; (61c0 <usb_free+0x64>)
    616e:	fba3 2302 	umull	r2, r3, r3, r2
    6172:	091b      	lsrs	r3, r3, #4
    6174:	60fb      	str	r3, [r7, #12]
	if (n >= NUM_USB_BUFFERS) return;
    6176:	68fb      	ldr	r3, [r7, #12]
    6178:	2b0b      	cmp	r3, #11
    617a:	d81b      	bhi.n	61b4 <usb_free+0x58>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    617c:	4b11      	ldr	r3, [pc, #68]	; (61c4 <usb_free+0x68>)
    617e:	781b      	ldrb	r3, [r3, #0]
    6180:	2b00      	cmp	r3, #0
    6182:	d008      	beq.n	6196 <usb_free+0x3a>
    6184:	4b10      	ldr	r3, [pc, #64]	; (61c8 <usb_free+0x6c>)
    6186:	781b      	ldrb	r3, [r3, #0]
    6188:	b2db      	uxtb	r3, r3
    618a:	2b00      	cmp	r3, #0
    618c:	d003      	beq.n	6196 <usb_free+0x3a>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    618e:	6878      	ldr	r0, [r7, #4]
    6190:	f7ff fd3e 	bl	5c10 <usb_rx_memory>
		return;
    6194:	e00f      	b.n	61b6 <usb_free+0x5a>
	}

	mask = (0x80000000 >> n);
    6196:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    619a:	68fb      	ldr	r3, [r7, #12]
    619c:	fa22 f303 	lsr.w	r3, r2, r3
    61a0:	60bb      	str	r3, [r7, #8]
	__disable_irq();
    61a2:	b672      	cpsid	i
	usb_buffer_available |= mask;
    61a4:	4b09      	ldr	r3, [pc, #36]	; (61cc <usb_free+0x70>)
    61a6:	681a      	ldr	r2, [r3, #0]
    61a8:	68bb      	ldr	r3, [r7, #8]
    61aa:	4313      	orrs	r3, r2
    61ac:	4a07      	ldr	r2, [pc, #28]	; (61cc <usb_free+0x70>)
    61ae:	6013      	str	r3, [r2, #0]
	__enable_irq();
    61b0:	b662      	cpsie	i
    61b2:	e000      	b.n	61b6 <usb_free+0x5a>
	if (n >= NUM_USB_BUFFERS) return;
    61b4:	bf00      	nop

	//serial_print("free:");
	//serial_phex32((int)p);
	//serial_print("\n");
}
    61b6:	3710      	adds	r7, #16
    61b8:	46bd      	mov	sp, r7
    61ba:	bd80      	pop	{r7, pc}
    61bc:	1fff03d0 	.word	0x1fff03d0
    61c0:	38e38e39 	.word	0x38e38e39
    61c4:	1fff13e8 	.word	0x1fff13e8
    61c8:	1fff13e9 	.word	0x1fff13e9
    61cc:	1fff079c 	.word	0x1fff079c

000061d0 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    61d0:	b580      	push	{r7, lr}
    61d2:	b082      	sub	sp, #8
    61d4:	af00      	add	r7, sp, #0
	unsigned int i;
	int c;

	if (!rx_packet) {
    61d6:	4b1f      	ldr	r3, [pc, #124]	; (6254 <usb_serial_getchar+0x84>)
    61d8:	681b      	ldr	r3, [r3, #0]
    61da:	2b00      	cmp	r3, #0
    61dc:	d114      	bne.n	6208 <usb_serial_getchar+0x38>
		if (!usb_configuration) return -1;
    61de:	4b1e      	ldr	r3, [pc, #120]	; (6258 <usb_serial_getchar+0x88>)
    61e0:	781b      	ldrb	r3, [r3, #0]
    61e2:	b2db      	uxtb	r3, r3
    61e4:	2b00      	cmp	r3, #0
    61e6:	d102      	bne.n	61ee <usb_serial_getchar+0x1e>
    61e8:	f04f 33ff 	mov.w	r3, #4294967295
    61ec:	e02e      	b.n	624c <usb_serial_getchar+0x7c>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    61ee:	2003      	movs	r0, #3
    61f0:	f7ff fcd8 	bl	5ba4 <usb_rx>
    61f4:	4603      	mov	r3, r0
    61f6:	4a17      	ldr	r2, [pc, #92]	; (6254 <usb_serial_getchar+0x84>)
    61f8:	6013      	str	r3, [r2, #0]
		if (!rx_packet) return -1;
    61fa:	4b16      	ldr	r3, [pc, #88]	; (6254 <usb_serial_getchar+0x84>)
    61fc:	681b      	ldr	r3, [r3, #0]
    61fe:	2b00      	cmp	r3, #0
    6200:	d102      	bne.n	6208 <usb_serial_getchar+0x38>
    6202:	f04f 33ff 	mov.w	r3, #4294967295
    6206:	e021      	b.n	624c <usb_serial_getchar+0x7c>
	}
	i = rx_packet->index;
    6208:	4b12      	ldr	r3, [pc, #72]	; (6254 <usb_serial_getchar+0x84>)
    620a:	681b      	ldr	r3, [r3, #0]
    620c:	885b      	ldrh	r3, [r3, #2]
    620e:	607b      	str	r3, [r7, #4]
	c = rx_packet->buf[i++];
    6210:	4b10      	ldr	r3, [pc, #64]	; (6254 <usb_serial_getchar+0x84>)
    6212:	681a      	ldr	r2, [r3, #0]
    6214:	687b      	ldr	r3, [r7, #4]
    6216:	1c59      	adds	r1, r3, #1
    6218:	6079      	str	r1, [r7, #4]
    621a:	4413      	add	r3, r2
    621c:	7a1b      	ldrb	r3, [r3, #8]
    621e:	603b      	str	r3, [r7, #0]
	if (i >= rx_packet->len) {
    6220:	4b0c      	ldr	r3, [pc, #48]	; (6254 <usb_serial_getchar+0x84>)
    6222:	681b      	ldr	r3, [r3, #0]
    6224:	881b      	ldrh	r3, [r3, #0]
    6226:	461a      	mov	r2, r3
    6228:	687b      	ldr	r3, [r7, #4]
    622a:	4293      	cmp	r3, r2
    622c:	d308      	bcc.n	6240 <usb_serial_getchar+0x70>
		usb_free(rx_packet);
    622e:	4b09      	ldr	r3, [pc, #36]	; (6254 <usb_serial_getchar+0x84>)
    6230:	681b      	ldr	r3, [r3, #0]
    6232:	4618      	mov	r0, r3
    6234:	f7ff ff92 	bl	615c <usb_free>
		rx_packet = NULL;
    6238:	4b06      	ldr	r3, [pc, #24]	; (6254 <usb_serial_getchar+0x84>)
    623a:	2200      	movs	r2, #0
    623c:	601a      	str	r2, [r3, #0]
    623e:	e004      	b.n	624a <usb_serial_getchar+0x7a>
	} else {
		rx_packet->index = i;
    6240:	4b04      	ldr	r3, [pc, #16]	; (6254 <usb_serial_getchar+0x84>)
    6242:	681b      	ldr	r3, [r3, #0]
    6244:	687a      	ldr	r2, [r7, #4]
    6246:	b292      	uxth	r2, r2
    6248:	805a      	strh	r2, [r3, #2]
	}
	return c;
    624a:	683b      	ldr	r3, [r7, #0]
}
    624c:	4618      	mov	r0, r3
    624e:	3708      	adds	r7, #8
    6250:	46bd      	mov	sp, r7
    6252:	bd80      	pop	{r7, pc}
    6254:	1fff1404 	.word	0x1fff1404
    6258:	1fff13e9 	.word	0x1fff13e9

0000625c <usb_serial_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    625c:	b580      	push	{r7, lr}
    625e:	af00      	add	r7, sp, #0
	if (!rx_packet) {
    6260:	4b14      	ldr	r3, [pc, #80]	; (62b4 <usb_serial_peekchar+0x58>)
    6262:	681b      	ldr	r3, [r3, #0]
    6264:	2b00      	cmp	r3, #0
    6266:	d114      	bne.n	6292 <usb_serial_peekchar+0x36>
		if (!usb_configuration) return -1;
    6268:	4b13      	ldr	r3, [pc, #76]	; (62b8 <usb_serial_peekchar+0x5c>)
    626a:	781b      	ldrb	r3, [r3, #0]
    626c:	b2db      	uxtb	r3, r3
    626e:	2b00      	cmp	r3, #0
    6270:	d102      	bne.n	6278 <usb_serial_peekchar+0x1c>
    6272:	f04f 33ff 	mov.w	r3, #4294967295
    6276:	e01a      	b.n	62ae <usb_serial_peekchar+0x52>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    6278:	2003      	movs	r0, #3
    627a:	f7ff fc93 	bl	5ba4 <usb_rx>
    627e:	4603      	mov	r3, r0
    6280:	4a0c      	ldr	r2, [pc, #48]	; (62b4 <usb_serial_peekchar+0x58>)
    6282:	6013      	str	r3, [r2, #0]
		if (!rx_packet) return -1;
    6284:	4b0b      	ldr	r3, [pc, #44]	; (62b4 <usb_serial_peekchar+0x58>)
    6286:	681b      	ldr	r3, [r3, #0]
    6288:	2b00      	cmp	r3, #0
    628a:	d102      	bne.n	6292 <usb_serial_peekchar+0x36>
    628c:	f04f 33ff 	mov.w	r3, #4294967295
    6290:	e00d      	b.n	62ae <usb_serial_peekchar+0x52>
	}
	if (!rx_packet) return -1;
    6292:	4b08      	ldr	r3, [pc, #32]	; (62b4 <usb_serial_peekchar+0x58>)
    6294:	681b      	ldr	r3, [r3, #0]
    6296:	2b00      	cmp	r3, #0
    6298:	d102      	bne.n	62a0 <usb_serial_peekchar+0x44>
    629a:	f04f 33ff 	mov.w	r3, #4294967295
    629e:	e006      	b.n	62ae <usb_serial_peekchar+0x52>
	return rx_packet->buf[rx_packet->index];
    62a0:	4b04      	ldr	r3, [pc, #16]	; (62b4 <usb_serial_peekchar+0x58>)
    62a2:	681b      	ldr	r3, [r3, #0]
    62a4:	4a03      	ldr	r2, [pc, #12]	; (62b4 <usb_serial_peekchar+0x58>)
    62a6:	6812      	ldr	r2, [r2, #0]
    62a8:	8852      	ldrh	r2, [r2, #2]
    62aa:	4413      	add	r3, r2
    62ac:	7a1b      	ldrb	r3, [r3, #8]
}
    62ae:	4618      	mov	r0, r3
    62b0:	bd80      	pop	{r7, pc}
    62b2:	bf00      	nop
    62b4:	1fff1404 	.word	0x1fff1404
    62b8:	1fff13e9 	.word	0x1fff13e9

000062bc <usb_serial_available>:

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
    62bc:	b480      	push	{r7}
    62be:	b083      	sub	sp, #12
    62c0:	af00      	add	r7, sp, #0
    62c2:	2303      	movs	r3, #3
    62c4:	603b      	str	r3, [r7, #0]

extern uint16_t usb_rx_byte_count_data[NUM_ENDPOINTS];
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
    62c6:	683b      	ldr	r3, [r7, #0]
    62c8:	3b01      	subs	r3, #1
    62ca:	603b      	str	r3, [r7, #0]
        if (endpoint >= NUM_ENDPOINTS) return 0;
    62cc:	683b      	ldr	r3, [r7, #0]
    62ce:	2b03      	cmp	r3, #3
    62d0:	d901      	bls.n	62d6 <usb_serial_available+0x1a>
    62d2:	2300      	movs	r3, #0
    62d4:	e003      	b.n	62de <usb_serial_available+0x22>
        return usb_rx_byte_count_data[endpoint];
    62d6:	4a0d      	ldr	r2, [pc, #52]	; (630c <usb_serial_available+0x50>)
    62d8:	683b      	ldr	r3, [r7, #0]
    62da:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    62de:	607b      	str	r3, [r7, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    62e0:	4b0b      	ldr	r3, [pc, #44]	; (6310 <usb_serial_available+0x54>)
    62e2:	681b      	ldr	r3, [r3, #0]
    62e4:	2b00      	cmp	r3, #0
    62e6:	d00a      	beq.n	62fe <usb_serial_available+0x42>
    62e8:	4b09      	ldr	r3, [pc, #36]	; (6310 <usb_serial_available+0x54>)
    62ea:	681b      	ldr	r3, [r3, #0]
    62ec:	881b      	ldrh	r3, [r3, #0]
    62ee:	461a      	mov	r2, r3
    62f0:	4b07      	ldr	r3, [pc, #28]	; (6310 <usb_serial_available+0x54>)
    62f2:	681b      	ldr	r3, [r3, #0]
    62f4:	885b      	ldrh	r3, [r3, #2]
    62f6:	1ad3      	subs	r3, r2, r3
    62f8:	687a      	ldr	r2, [r7, #4]
    62fa:	4413      	add	r3, r2
    62fc:	607b      	str	r3, [r7, #4]
	return count;
    62fe:	687b      	ldr	r3, [r7, #4]
}
    6300:	4618      	mov	r0, r3
    6302:	370c      	adds	r7, #12
    6304:	46bd      	mov	sp, r7
    6306:	f85d 7b04 	ldr.w	r7, [sp], #4
    630a:	4770      	bx	lr
    630c:	1fff134c 	.word	0x1fff134c
    6310:	1fff1404 	.word	0x1fff1404

00006314 <usb_serial_flush_input>:
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    6314:	b580      	push	{r7, lr}
    6316:	b082      	sub	sp, #8
    6318:	af00      	add	r7, sp, #0
	usb_packet_t *rx;

	if (!usb_configuration) return;
    631a:	4b11      	ldr	r3, [pc, #68]	; (6360 <usb_serial_flush_input+0x4c>)
    631c:	781b      	ldrb	r3, [r3, #0]
    631e:	b2db      	uxtb	r3, r3
    6320:	2b00      	cmp	r3, #0
    6322:	d016      	beq.n	6352 <usb_serial_flush_input+0x3e>
	if (rx_packet) {
    6324:	4b0f      	ldr	r3, [pc, #60]	; (6364 <usb_serial_flush_input+0x50>)
    6326:	681b      	ldr	r3, [r3, #0]
    6328:	2b00      	cmp	r3, #0
    632a:	d007      	beq.n	633c <usb_serial_flush_input+0x28>
		usb_free(rx_packet);
    632c:	4b0d      	ldr	r3, [pc, #52]	; (6364 <usb_serial_flush_input+0x50>)
    632e:	681b      	ldr	r3, [r3, #0]
    6330:	4618      	mov	r0, r3
    6332:	f7ff ff13 	bl	615c <usb_free>
		rx_packet = NULL;
    6336:	4b0b      	ldr	r3, [pc, #44]	; (6364 <usb_serial_flush_input+0x50>)
    6338:	2200      	movs	r2, #0
    633a:	601a      	str	r2, [r3, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    633c:	2003      	movs	r0, #3
    633e:	f7ff fc31 	bl	5ba4 <usb_rx>
    6342:	6078      	str	r0, [r7, #4]
		if (!rx) break;
    6344:	687b      	ldr	r3, [r7, #4]
    6346:	2b00      	cmp	r3, #0
    6348:	d005      	beq.n	6356 <usb_serial_flush_input+0x42>
		usb_free(rx);
    634a:	6878      	ldr	r0, [r7, #4]
    634c:	f7ff ff06 	bl	615c <usb_free>
		rx = usb_rx(CDC_RX_ENDPOINT);
    6350:	e7f4      	b.n	633c <usb_serial_flush_input+0x28>
	if (!usb_configuration) return;
    6352:	bf00      	nop
    6354:	e000      	b.n	6358 <usb_serial_flush_input+0x44>
		if (!rx) break;
    6356:	bf00      	nop
	}
}
    6358:	3708      	adds	r7, #8
    635a:	46bd      	mov	sp, r7
    635c:	bd80      	pop	{r7, pc}
    635e:	bf00      	nop
    6360:	1fff13e9 	.word	0x1fff13e9
    6364:	1fff1404 	.word	0x1fff1404

00006368 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    6368:	b580      	push	{r7, lr}
    636a:	b082      	sub	sp, #8
    636c:	af00      	add	r7, sp, #0
    636e:	4603      	mov	r3, r0
    6370:	71fb      	strb	r3, [r7, #7]
	return usb_serial_write(&c, 1);
    6372:	1dfb      	adds	r3, r7, #7
    6374:	2101      	movs	r1, #1
    6376:	4618      	mov	r0, r3
    6378:	f000 f806 	bl	6388 <usb_serial_write>
    637c:	4603      	mov	r3, r0
}
    637e:	4618      	mov	r0, r3
    6380:	3708      	adds	r7, #8
    6382:	46bd      	mov	sp, r7
    6384:	bd80      	pop	{r7, pc}
    6386:	Address 0x00006386 is out of bounds.


00006388 <usb_serial_write>:


int usb_serial_write(const void *buffer, uint32_t size)
{
    6388:	b580      	push	{r7, lr}
    638a:	b088      	sub	sp, #32
    638c:	af00      	add	r7, sp, #0
    638e:	6078      	str	r0, [r7, #4]
    6390:	6039      	str	r1, [r7, #0]
	uint32_t ret = size;
    6392:	683b      	ldr	r3, [r7, #0]
    6394:	60fb      	str	r3, [r7, #12]
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
    6396:	687b      	ldr	r3, [r7, #4]
    6398:	617b      	str	r3, [r7, #20]
	uint8_t *dest;

	tx_noautoflush = 1;
    639a:	4b49      	ldr	r3, [pc, #292]	; (64c0 <usb_serial_write+0x138>)
    639c:	2201      	movs	r2, #1
    639e:	701a      	strb	r2, [r3, #0]
	while (size > 0) {
    63a0:	e082      	b.n	64a8 <usb_serial_write+0x120>
		if (!tx_packet) {
    63a2:	4b48      	ldr	r3, [pc, #288]	; (64c4 <usb_serial_write+0x13c>)
    63a4:	681b      	ldr	r3, [r3, #0]
    63a6:	2b00      	cmp	r3, #0
    63a8:	d136      	bne.n	6418 <usb_serial_write+0x90>
			wait_count = 0;
    63aa:	2300      	movs	r3, #0
    63ac:	61bb      	str	r3, [r7, #24]
			while (1) {
				if (!usb_configuration) {
    63ae:	4b46      	ldr	r3, [pc, #280]	; (64c8 <usb_serial_write+0x140>)
    63b0:	781b      	ldrb	r3, [r3, #0]
    63b2:	b2db      	uxtb	r3, r3
    63b4:	2b00      	cmp	r3, #0
    63b6:	d105      	bne.n	63c4 <usb_serial_write+0x3c>
					tx_noautoflush = 0;
    63b8:	4b41      	ldr	r3, [pc, #260]	; (64c0 <usb_serial_write+0x138>)
    63ba:	2200      	movs	r2, #0
    63bc:	701a      	strb	r2, [r3, #0]
					return -1;
    63be:	f04f 33ff 	mov.w	r3, #4294967295
    63c2:	e079      	b.n	64b8 <usb_serial_write+0x130>
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    63c4:	2004      	movs	r0, #4
    63c6:	f7ff fc0d 	bl	5be4 <usb_tx_packet_count>
    63ca:	4603      	mov	r3, r0
    63cc:	2b07      	cmp	r3, #7
    63ce:	d80e      	bhi.n	63ee <usb_serial_write+0x66>
					tx_noautoflush = 1;
    63d0:	4b3b      	ldr	r3, [pc, #236]	; (64c0 <usb_serial_write+0x138>)
    63d2:	2201      	movs	r2, #1
    63d4:	701a      	strb	r2, [r3, #0]
					tx_packet = usb_malloc();
    63d6:	f7ff fe89 	bl	60ec <usb_malloc>
    63da:	4603      	mov	r3, r0
    63dc:	4a39      	ldr	r2, [pc, #228]	; (64c4 <usb_serial_write+0x13c>)
    63de:	6013      	str	r3, [r2, #0]
					if (tx_packet) break;
    63e0:	4b38      	ldr	r3, [pc, #224]	; (64c4 <usb_serial_write+0x13c>)
    63e2:	681b      	ldr	r3, [r3, #0]
    63e4:	2b00      	cmp	r3, #0
    63e6:	d116      	bne.n	6416 <usb_serial_write+0x8e>
					tx_noautoflush = 0;
    63e8:	4b35      	ldr	r3, [pc, #212]	; (64c0 <usb_serial_write+0x138>)
    63ea:	2200      	movs	r2, #0
    63ec:	701a      	strb	r2, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    63ee:	69bb      	ldr	r3, [r7, #24]
    63f0:	3301      	adds	r3, #1
    63f2:	61bb      	str	r3, [r7, #24]
    63f4:	69bb      	ldr	r3, [r7, #24]
    63f6:	4a35      	ldr	r2, [pc, #212]	; (64cc <usb_serial_write+0x144>)
    63f8:	4293      	cmp	r3, r2
    63fa:	d803      	bhi.n	6404 <usb_serial_write+0x7c>
    63fc:	4b34      	ldr	r3, [pc, #208]	; (64d0 <usb_serial_write+0x148>)
    63fe:	781b      	ldrb	r3, [r3, #0]
    6400:	2b00      	cmp	r3, #0
    6402:	d005      	beq.n	6410 <usb_serial_write+0x88>
					transmit_previous_timeout = 1;
    6404:	4b32      	ldr	r3, [pc, #200]	; (64d0 <usb_serial_write+0x148>)
    6406:	2201      	movs	r2, #1
    6408:	701a      	strb	r2, [r3, #0]
					return -1;
    640a:	f04f 33ff 	mov.w	r3, #4294967295
    640e:	e053      	b.n	64b8 <usb_serial_write+0x130>
				}
				yield();
    6410:	f000 fcd2 	bl	6db8 <yield>
				if (!usb_configuration) {
    6414:	e7cb      	b.n	63ae <usb_serial_write+0x26>
					if (tx_packet) break;
    6416:	bf00      	nop
			}
		}
		transmit_previous_timeout = 0;
    6418:	4b2d      	ldr	r3, [pc, #180]	; (64d0 <usb_serial_write+0x148>)
    641a:	2200      	movs	r2, #0
    641c:	701a      	strb	r2, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    641e:	4b29      	ldr	r3, [pc, #164]	; (64c4 <usb_serial_write+0x13c>)
    6420:	681b      	ldr	r3, [r3, #0]
    6422:	885b      	ldrh	r3, [r3, #2]
    6424:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
    6428:	61fb      	str	r3, [r7, #28]
		if (len > size) len = size;
    642a:	69fa      	ldr	r2, [r7, #28]
    642c:	683b      	ldr	r3, [r7, #0]
    642e:	429a      	cmp	r2, r3
    6430:	d901      	bls.n	6436 <usb_serial_write+0xae>
    6432:	683b      	ldr	r3, [r7, #0]
    6434:	61fb      	str	r3, [r7, #28]
		dest = tx_packet->buf + tx_packet->index;
    6436:	4b23      	ldr	r3, [pc, #140]	; (64c4 <usb_serial_write+0x13c>)
    6438:	681b      	ldr	r3, [r3, #0]
    643a:	3308      	adds	r3, #8
    643c:	4a21      	ldr	r2, [pc, #132]	; (64c4 <usb_serial_write+0x13c>)
    643e:	6812      	ldr	r2, [r2, #0]
    6440:	8852      	ldrh	r2, [r2, #2]
    6442:	4413      	add	r3, r2
    6444:	613b      	str	r3, [r7, #16]
		tx_packet->index += len;
    6446:	4b1f      	ldr	r3, [pc, #124]	; (64c4 <usb_serial_write+0x13c>)
    6448:	681b      	ldr	r3, [r3, #0]
    644a:	8859      	ldrh	r1, [r3, #2]
    644c:	69fb      	ldr	r3, [r7, #28]
    644e:	b29a      	uxth	r2, r3
    6450:	4b1c      	ldr	r3, [pc, #112]	; (64c4 <usb_serial_write+0x13c>)
    6452:	681b      	ldr	r3, [r3, #0]
    6454:	440a      	add	r2, r1
    6456:	b292      	uxth	r2, r2
    6458:	805a      	strh	r2, [r3, #2]
		size -= len;
    645a:	683a      	ldr	r2, [r7, #0]
    645c:	69fb      	ldr	r3, [r7, #28]
    645e:	1ad3      	subs	r3, r2, r3
    6460:	603b      	str	r3, [r7, #0]
		while (len-- > 0) *dest++ = *src++;
    6462:	e007      	b.n	6474 <usb_serial_write+0xec>
    6464:	697a      	ldr	r2, [r7, #20]
    6466:	1c53      	adds	r3, r2, #1
    6468:	617b      	str	r3, [r7, #20]
    646a:	693b      	ldr	r3, [r7, #16]
    646c:	1c59      	adds	r1, r3, #1
    646e:	6139      	str	r1, [r7, #16]
    6470:	7812      	ldrb	r2, [r2, #0]
    6472:	701a      	strb	r2, [r3, #0]
    6474:	69fb      	ldr	r3, [r7, #28]
    6476:	1e5a      	subs	r2, r3, #1
    6478:	61fa      	str	r2, [r7, #28]
    647a:	2b00      	cmp	r3, #0
    647c:	d1f2      	bne.n	6464 <usb_serial_write+0xdc>
		if (tx_packet->index >= CDC_TX_SIZE) {
    647e:	4b11      	ldr	r3, [pc, #68]	; (64c4 <usb_serial_write+0x13c>)
    6480:	681b      	ldr	r3, [r3, #0]
    6482:	885b      	ldrh	r3, [r3, #2]
    6484:	2b3f      	cmp	r3, #63	; 0x3f
    6486:	d90c      	bls.n	64a2 <usb_serial_write+0x11a>
			tx_packet->len = CDC_TX_SIZE;
    6488:	4b0e      	ldr	r3, [pc, #56]	; (64c4 <usb_serial_write+0x13c>)
    648a:	681b      	ldr	r3, [r3, #0]
    648c:	2240      	movs	r2, #64	; 0x40
    648e:	801a      	strh	r2, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    6490:	4b0c      	ldr	r3, [pc, #48]	; (64c4 <usb_serial_write+0x13c>)
    6492:	681b      	ldr	r3, [r3, #0]
    6494:	4619      	mov	r1, r3
    6496:	2004      	movs	r0, #4
    6498:	f7ff fc22 	bl	5ce0 <usb_tx>
			tx_packet = NULL;
    649c:	4b09      	ldr	r3, [pc, #36]	; (64c4 <usb_serial_write+0x13c>)
    649e:	2200      	movs	r2, #0
    64a0:	601a      	str	r2, [r3, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    64a2:	4b0c      	ldr	r3, [pc, #48]	; (64d4 <usb_serial_write+0x14c>)
    64a4:	2205      	movs	r2, #5
    64a6:	701a      	strb	r2, [r3, #0]
	while (size > 0) {
    64a8:	683b      	ldr	r3, [r7, #0]
    64aa:	2b00      	cmp	r3, #0
    64ac:	f47f af79 	bne.w	63a2 <usb_serial_write+0x1a>
	}
	tx_noautoflush = 0;
    64b0:	4b03      	ldr	r3, [pc, #12]	; (64c0 <usb_serial_write+0x138>)
    64b2:	2200      	movs	r2, #0
    64b4:	701a      	strb	r2, [r3, #0]
	return ret;
    64b6:	68fb      	ldr	r3, [r7, #12]
}
    64b8:	4618      	mov	r0, r3
    64ba:	3720      	adds	r7, #32
    64bc:	46bd      	mov	sp, r7
    64be:	bd80      	pop	{r7, pc}
    64c0:	1fff140c 	.word	0x1fff140c
    64c4:	1fff1408 	.word	0x1fff1408
    64c8:	1fff13e9 	.word	0x1fff13e9
    64cc:	00014820 	.word	0x00014820
    64d0:	1fff140d 	.word	0x1fff140d
    64d4:	1fff1401 	.word	0x1fff1401

000064d8 <usb_serial_write_buffer_free>:

int usb_serial_write_buffer_free(void)
{
    64d8:	b580      	push	{r7, lr}
    64da:	b082      	sub	sp, #8
    64dc:	af00      	add	r7, sp, #0
	uint32_t len;

	tx_noautoflush = 1;
    64de:	4b17      	ldr	r3, [pc, #92]	; (653c <usb_serial_write_buffer_free+0x64>)
    64e0:	2201      	movs	r2, #1
    64e2:	701a      	strb	r2, [r3, #0]
	if (!tx_packet) {
    64e4:	4b16      	ldr	r3, [pc, #88]	; (6540 <usb_serial_write_buffer_free+0x68>)
    64e6:	681b      	ldr	r3, [r3, #0]
    64e8:	2b00      	cmp	r3, #0
    64ea:	d118      	bne.n	651e <usb_serial_write_buffer_free+0x46>
		if (!usb_configuration ||
    64ec:	4b15      	ldr	r3, [pc, #84]	; (6544 <usb_serial_write_buffer_free+0x6c>)
    64ee:	781b      	ldrb	r3, [r3, #0]
    64f0:	b2db      	uxtb	r3, r3
    64f2:	2b00      	cmp	r3, #0
    64f4:	d00e      	beq.n	6514 <usb_serial_write_buffer_free+0x3c>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    64f6:	2004      	movs	r0, #4
    64f8:	f7ff fb74 	bl	5be4 <usb_tx_packet_count>
    64fc:	4603      	mov	r3, r0
		if (!usb_configuration ||
    64fe:	2b07      	cmp	r3, #7
    6500:	d808      	bhi.n	6514 <usb_serial_write_buffer_free+0x3c>
		  (tx_packet = usb_malloc()) == NULL) {
    6502:	f7ff fdf3 	bl	60ec <usb_malloc>
    6506:	4603      	mov	r3, r0
    6508:	4a0d      	ldr	r2, [pc, #52]	; (6540 <usb_serial_write_buffer_free+0x68>)
    650a:	6013      	str	r3, [r2, #0]
    650c:	4b0c      	ldr	r3, [pc, #48]	; (6540 <usb_serial_write_buffer_free+0x68>)
    650e:	681b      	ldr	r3, [r3, #0]
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    6510:	2b00      	cmp	r3, #0
    6512:	d104      	bne.n	651e <usb_serial_write_buffer_free+0x46>
			tx_noautoflush = 0;
    6514:	4b09      	ldr	r3, [pc, #36]	; (653c <usb_serial_write_buffer_free+0x64>)
    6516:	2200      	movs	r2, #0
    6518:	701a      	strb	r2, [r3, #0]
			return 0;
    651a:	2300      	movs	r3, #0
    651c:	e009      	b.n	6532 <usb_serial_write_buffer_free+0x5a>
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    651e:	4b08      	ldr	r3, [pc, #32]	; (6540 <usb_serial_write_buffer_free+0x68>)
    6520:	681b      	ldr	r3, [r3, #0]
    6522:	885b      	ldrh	r3, [r3, #2]
    6524:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
    6528:	607b      	str	r3, [r7, #4]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    652a:	4b04      	ldr	r3, [pc, #16]	; (653c <usb_serial_write_buffer_free+0x64>)
    652c:	2200      	movs	r2, #0
    652e:	701a      	strb	r2, [r3, #0]
	return len;
    6530:	687b      	ldr	r3, [r7, #4]
}
    6532:	4618      	mov	r0, r3
    6534:	3708      	adds	r7, #8
    6536:	46bd      	mov	sp, r7
    6538:	bd80      	pop	{r7, pc}
    653a:	bf00      	nop
    653c:	1fff140c 	.word	0x1fff140c
    6540:	1fff1408 	.word	0x1fff1408
    6544:	1fff13e9 	.word	0x1fff13e9

00006548 <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
    6548:	b580      	push	{r7, lr}
    654a:	b082      	sub	sp, #8
    654c:	af00      	add	r7, sp, #0
	if (!usb_configuration) return;
    654e:	4b1c      	ldr	r3, [pc, #112]	; (65c0 <usb_serial_flush_output+0x78>)
    6550:	781b      	ldrb	r3, [r3, #0]
    6552:	b2db      	uxtb	r3, r3
    6554:	2b00      	cmp	r3, #0
    6556:	d02e      	beq.n	65b6 <usb_serial_flush_output+0x6e>
	tx_noautoflush = 1;
    6558:	4b1a      	ldr	r3, [pc, #104]	; (65c4 <usb_serial_flush_output+0x7c>)
    655a:	2201      	movs	r2, #1
    655c:	701a      	strb	r2, [r3, #0]
	if (tx_packet) {
    655e:	4b1a      	ldr	r3, [pc, #104]	; (65c8 <usb_serial_flush_output+0x80>)
    6560:	681b      	ldr	r3, [r3, #0]
    6562:	2b00      	cmp	r3, #0
    6564:	d012      	beq.n	658c <usb_serial_flush_output+0x44>
		usb_cdc_transmit_flush_timer = 0;
    6566:	4b19      	ldr	r3, [pc, #100]	; (65cc <usb_serial_flush_output+0x84>)
    6568:	2200      	movs	r2, #0
    656a:	701a      	strb	r2, [r3, #0]
		tx_packet->len = tx_packet->index;
    656c:	4b16      	ldr	r3, [pc, #88]	; (65c8 <usb_serial_flush_output+0x80>)
    656e:	681a      	ldr	r2, [r3, #0]
    6570:	4b15      	ldr	r3, [pc, #84]	; (65c8 <usb_serial_flush_output+0x80>)
    6572:	681b      	ldr	r3, [r3, #0]
    6574:	8852      	ldrh	r2, [r2, #2]
    6576:	801a      	strh	r2, [r3, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    6578:	4b13      	ldr	r3, [pc, #76]	; (65c8 <usb_serial_flush_output+0x80>)
    657a:	681b      	ldr	r3, [r3, #0]
    657c:	4619      	mov	r1, r3
    657e:	2004      	movs	r0, #4
    6580:	f7ff fbae 	bl	5ce0 <usb_tx>
		tx_packet = NULL;
    6584:	4b10      	ldr	r3, [pc, #64]	; (65c8 <usb_serial_flush_output+0x80>)
    6586:	2200      	movs	r2, #0
    6588:	601a      	str	r2, [r3, #0]
    658a:	e010      	b.n	65ae <usb_serial_flush_output+0x66>
	} else {
		usb_packet_t *tx = usb_malloc();
    658c:	f7ff fdae 	bl	60ec <usb_malloc>
    6590:	6078      	str	r0, [r7, #4]
		if (tx) {
    6592:	687b      	ldr	r3, [r7, #4]
    6594:	2b00      	cmp	r3, #0
    6596:	d007      	beq.n	65a8 <usb_serial_flush_output+0x60>
			usb_cdc_transmit_flush_timer = 0;
    6598:	4b0c      	ldr	r3, [pc, #48]	; (65cc <usb_serial_flush_output+0x84>)
    659a:	2200      	movs	r2, #0
    659c:	701a      	strb	r2, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    659e:	6879      	ldr	r1, [r7, #4]
    65a0:	2004      	movs	r0, #4
    65a2:	f7ff fb9d 	bl	5ce0 <usb_tx>
    65a6:	e002      	b.n	65ae <usb_serial_flush_output+0x66>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    65a8:	4b08      	ldr	r3, [pc, #32]	; (65cc <usb_serial_flush_output+0x84>)
    65aa:	2201      	movs	r2, #1
    65ac:	701a      	strb	r2, [r3, #0]
		}
	}
	tx_noautoflush = 0;
    65ae:	4b05      	ldr	r3, [pc, #20]	; (65c4 <usb_serial_flush_output+0x7c>)
    65b0:	2200      	movs	r2, #0
    65b2:	701a      	strb	r2, [r3, #0]
    65b4:	e000      	b.n	65b8 <usb_serial_flush_output+0x70>
	if (!usb_configuration) return;
    65b6:	bf00      	nop
}
    65b8:	3708      	adds	r7, #8
    65ba:	46bd      	mov	sp, r7
    65bc:	bd80      	pop	{r7, pc}
    65be:	bf00      	nop
    65c0:	1fff13e9 	.word	0x1fff13e9
    65c4:	1fff140c 	.word	0x1fff140c
    65c8:	1fff1408 	.word	0x1fff1408
    65cc:	1fff1401 	.word	0x1fff1401

000065d0 <usb_serial_flush_callback>:

void usb_serial_flush_callback(void)
{
    65d0:	b580      	push	{r7, lr}
    65d2:	b082      	sub	sp, #8
    65d4:	af00      	add	r7, sp, #0
	if (tx_noautoflush) return;
    65d6:	4b16      	ldr	r3, [pc, #88]	; (6630 <usb_serial_flush_callback+0x60>)
    65d8:	781b      	ldrb	r3, [r3, #0]
    65da:	b2db      	uxtb	r3, r3
    65dc:	2b00      	cmp	r3, #0
    65de:	d122      	bne.n	6626 <usb_serial_flush_callback+0x56>
	if (tx_packet) {
    65e0:	4b14      	ldr	r3, [pc, #80]	; (6634 <usb_serial_flush_callback+0x64>)
    65e2:	681b      	ldr	r3, [r3, #0]
    65e4:	2b00      	cmp	r3, #0
    65e6:	d00f      	beq.n	6608 <usb_serial_flush_callback+0x38>
		tx_packet->len = tx_packet->index;
    65e8:	4b12      	ldr	r3, [pc, #72]	; (6634 <usb_serial_flush_callback+0x64>)
    65ea:	681a      	ldr	r2, [r3, #0]
    65ec:	4b11      	ldr	r3, [pc, #68]	; (6634 <usb_serial_flush_callback+0x64>)
    65ee:	681b      	ldr	r3, [r3, #0]
    65f0:	8852      	ldrh	r2, [r2, #2]
    65f2:	801a      	strh	r2, [r3, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    65f4:	4b0f      	ldr	r3, [pc, #60]	; (6634 <usb_serial_flush_callback+0x64>)
    65f6:	681b      	ldr	r3, [r3, #0]
    65f8:	4619      	mov	r1, r3
    65fa:	2004      	movs	r0, #4
    65fc:	f7ff fb70 	bl	5ce0 <usb_tx>
		tx_packet = NULL;
    6600:	4b0c      	ldr	r3, [pc, #48]	; (6634 <usb_serial_flush_callback+0x64>)
    6602:	2200      	movs	r2, #0
    6604:	601a      	str	r2, [r3, #0]
    6606:	e00f      	b.n	6628 <usb_serial_flush_callback+0x58>
	} else {
		usb_packet_t *tx = usb_malloc();
    6608:	f7ff fd70 	bl	60ec <usb_malloc>
    660c:	6078      	str	r0, [r7, #4]
		if (tx) {
    660e:	687b      	ldr	r3, [r7, #4]
    6610:	2b00      	cmp	r3, #0
    6612:	d004      	beq.n	661e <usb_serial_flush_callback+0x4e>
			usb_tx(CDC_TX_ENDPOINT, tx);
    6614:	6879      	ldr	r1, [r7, #4]
    6616:	2004      	movs	r0, #4
    6618:	f7ff fb62 	bl	5ce0 <usb_tx>
    661c:	e004      	b.n	6628 <usb_serial_flush_callback+0x58>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    661e:	4b06      	ldr	r3, [pc, #24]	; (6638 <usb_serial_flush_callback+0x68>)
    6620:	2201      	movs	r2, #1
    6622:	701a      	strb	r2, [r3, #0]
    6624:	e000      	b.n	6628 <usb_serial_flush_callback+0x58>
	if (tx_noautoflush) return;
    6626:	bf00      	nop
		}
	}
}
    6628:	3708      	adds	r7, #8
    662a:	46bd      	mov	sp, r7
    662c:	bd80      	pop	{r7, pc}
    662e:	bf00      	nop
    6630:	1fff140c 	.word	0x1fff140c
    6634:	1fff1408 	.word	0x1fff1408
    6638:	1fff1401 	.word	0x1fff1401

0000663c <_ZN6StringC1EPKc>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    663c:	b580      	push	{r7, lr}
    663e:	b082      	sub	sp, #8
    6640:	af00      	add	r7, sp, #0
    6642:	6078      	str	r0, [r7, #4]
    6644:	6039      	str	r1, [r7, #0]
{
	init();
    6646:	6878      	ldr	r0, [r7, #4]
    6648:	f000 f830 	bl	66ac <_ZN6String4initEv>
	if (cstr) copy(cstr, strlen(cstr));
    664c:	683b      	ldr	r3, [r7, #0]
    664e:	2b00      	cmp	r3, #0
    6650:	d008      	beq.n	6664 <_ZN6StringC1EPKc+0x28>
    6652:	6838      	ldr	r0, [r7, #0]
    6654:	f007 ffd2 	bl	e5fc <strlen>
    6658:	4603      	mov	r3, r0
    665a:	461a      	mov	r2, r3
    665c:	6839      	ldr	r1, [r7, #0]
    665e:	6878      	ldr	r0, [r7, #4]
    6660:	f000 f87f 	bl	6762 <_ZN6String4copyEPKcj>
}
    6664:	687b      	ldr	r3, [r7, #4]
    6666:	4618      	mov	r0, r3
    6668:	3708      	adds	r7, #8
    666a:	46bd      	mov	sp, r7
    666c:	bd80      	pop	{r7, pc}

0000666e <_ZN6StringC1ERKS_>:
{
	init();
	*this = pgmstr;
}

String::String(const String &value)
    666e:	b580      	push	{r7, lr}
    6670:	b082      	sub	sp, #8
    6672:	af00      	add	r7, sp, #0
    6674:	6078      	str	r0, [r7, #4]
    6676:	6039      	str	r1, [r7, #0]
{
	init();
    6678:	6878      	ldr	r0, [r7, #4]
    667a:	f000 f817 	bl	66ac <_ZN6String4initEv>
	*this = value;
    667e:	6839      	ldr	r1, [r7, #0]
    6680:	6878      	ldr	r0, [r7, #4]
    6682:	f000 f8b3 	bl	67ec <_ZN6StringaSERKS_>
}
    6686:	687b      	ldr	r3, [r7, #4]
    6688:	4618      	mov	r0, r3
    668a:	3708      	adds	r7, #8
    668c:	46bd      	mov	sp, r7
    668e:	bd80      	pop	{r7, pc}

00006690 <_ZN6StringD1Ev>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    6690:	b580      	push	{r7, lr}
    6692:	b082      	sub	sp, #8
    6694:	af00      	add	r7, sp, #0
    6696:	6078      	str	r0, [r7, #4]
{
	free(buffer);
    6698:	687b      	ldr	r3, [r7, #4]
    669a:	681b      	ldr	r3, [r3, #0]
    669c:	4618      	mov	r0, r3
    669e:	f007 fe85 	bl	e3ac <free>
}
    66a2:	687b      	ldr	r3, [r7, #4]
    66a4:	4618      	mov	r0, r3
    66a6:	3708      	adds	r7, #8
    66a8:	46bd      	mov	sp, r7
    66aa:	bd80      	pop	{r7, pc}

000066ac <_ZN6String4initEv>:
/*********************************************/
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
    66ac:	b480      	push	{r7}
    66ae:	b083      	sub	sp, #12
    66b0:	af00      	add	r7, sp, #0
    66b2:	6078      	str	r0, [r7, #4]
	buffer = NULL;
    66b4:	687b      	ldr	r3, [r7, #4]
    66b6:	2200      	movs	r2, #0
    66b8:	601a      	str	r2, [r3, #0]
	capacity = 0;
    66ba:	687b      	ldr	r3, [r7, #4]
    66bc:	2200      	movs	r2, #0
    66be:	605a      	str	r2, [r3, #4]
	len = 0;
    66c0:	687b      	ldr	r3, [r7, #4]
    66c2:	2200      	movs	r2, #0
    66c4:	609a      	str	r2, [r3, #8]
	flags = 0;
    66c6:	687b      	ldr	r3, [r7, #4]
    66c8:	2200      	movs	r2, #0
    66ca:	731a      	strb	r2, [r3, #12]
}
    66cc:	bf00      	nop
    66ce:	370c      	adds	r7, #12
    66d0:	46bd      	mov	sp, r7
    66d2:	f85d 7b04 	ldr.w	r7, [sp], #4
    66d6:	4770      	bx	lr

000066d8 <_ZN6String7reserveEj>:

unsigned char String::reserve(unsigned int size)
{
    66d8:	b580      	push	{r7, lr}
    66da:	b082      	sub	sp, #8
    66dc:	af00      	add	r7, sp, #0
    66de:	6078      	str	r0, [r7, #4]
    66e0:	6039      	str	r1, [r7, #0]
	if (capacity >= size) return 1;
    66e2:	687b      	ldr	r3, [r7, #4]
    66e4:	685b      	ldr	r3, [r3, #4]
    66e6:	683a      	ldr	r2, [r7, #0]
    66e8:	429a      	cmp	r2, r3
    66ea:	d801      	bhi.n	66f0 <_ZN6String7reserveEj+0x18>
    66ec:	2301      	movs	r3, #1
    66ee:	e016      	b.n	671e <_ZN6String7reserveEj+0x46>
	if (changeBuffer(size)) {
    66f0:	6839      	ldr	r1, [r7, #0]
    66f2:	6878      	ldr	r0, [r7, #4]
    66f4:	f000 f817 	bl	6726 <_ZN6String12changeBufferEj>
    66f8:	4603      	mov	r3, r0
    66fa:	2b00      	cmp	r3, #0
    66fc:	bf14      	ite	ne
    66fe:	2301      	movne	r3, #1
    6700:	2300      	moveq	r3, #0
    6702:	b2db      	uxtb	r3, r3
    6704:	2b00      	cmp	r3, #0
    6706:	d009      	beq.n	671c <_ZN6String7reserveEj+0x44>
		if (len == 0) buffer[0] = 0;
    6708:	687b      	ldr	r3, [r7, #4]
    670a:	689b      	ldr	r3, [r3, #8]
    670c:	2b00      	cmp	r3, #0
    670e:	d103      	bne.n	6718 <_ZN6String7reserveEj+0x40>
    6710:	687b      	ldr	r3, [r7, #4]
    6712:	681b      	ldr	r3, [r3, #0]
    6714:	2200      	movs	r2, #0
    6716:	701a      	strb	r2, [r3, #0]
		return 1;
    6718:	2301      	movs	r3, #1
    671a:	e000      	b.n	671e <_ZN6String7reserveEj+0x46>
	}
	return 0;
    671c:	2300      	movs	r3, #0
}
    671e:	4618      	mov	r0, r3
    6720:	3708      	adds	r7, #8
    6722:	46bd      	mov	sp, r7
    6724:	bd80      	pop	{r7, pc}

00006726 <_ZN6String12changeBufferEj>:

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
    6726:	b580      	push	{r7, lr}
    6728:	b084      	sub	sp, #16
    672a:	af00      	add	r7, sp, #0
    672c:	6078      	str	r0, [r7, #4]
    672e:	6039      	str	r1, [r7, #0]
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    6730:	687b      	ldr	r3, [r7, #4]
    6732:	681a      	ldr	r2, [r3, #0]
    6734:	683b      	ldr	r3, [r7, #0]
    6736:	3301      	adds	r3, #1
    6738:	4619      	mov	r1, r3
    673a:	4610      	mov	r0, r2
    673c:	f007 ff34 	bl	e5a8 <realloc>
    6740:	60f8      	str	r0, [r7, #12]
	if (newbuffer) {
    6742:	68fb      	ldr	r3, [r7, #12]
    6744:	2b00      	cmp	r3, #0
    6746:	d007      	beq.n	6758 <_ZN6String12changeBufferEj+0x32>
		buffer = newbuffer;
    6748:	687b      	ldr	r3, [r7, #4]
    674a:	68fa      	ldr	r2, [r7, #12]
    674c:	601a      	str	r2, [r3, #0]
		capacity = maxStrLen;
    674e:	687b      	ldr	r3, [r7, #4]
    6750:	683a      	ldr	r2, [r7, #0]
    6752:	605a      	str	r2, [r3, #4]
		return 1;
    6754:	2301      	movs	r3, #1
    6756:	e000      	b.n	675a <_ZN6String12changeBufferEj+0x34>
	}
	return 0;
    6758:	2300      	movs	r3, #0
}
    675a:	4618      	mov	r0, r3
    675c:	3710      	adds	r7, #16
    675e:	46bd      	mov	sp, r7
    6760:	bd80      	pop	{r7, pc}

00006762 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    6762:	b580      	push	{r7, lr}
    6764:	b084      	sub	sp, #16
    6766:	af00      	add	r7, sp, #0
    6768:	60f8      	str	r0, [r7, #12]
    676a:	60b9      	str	r1, [r7, #8]
    676c:	607a      	str	r2, [r7, #4]
	if (length == 0) {
    676e:	687b      	ldr	r3, [r7, #4]
    6770:	2b00      	cmp	r3, #0
    6772:	d10c      	bne.n	678e <_ZN6String4copyEPKcj+0x2c>
		if (buffer) buffer[0] = 0;
    6774:	68fb      	ldr	r3, [r7, #12]
    6776:	681b      	ldr	r3, [r3, #0]
    6778:	2b00      	cmp	r3, #0
    677a:	d003      	beq.n	6784 <_ZN6String4copyEPKcj+0x22>
    677c:	68fb      	ldr	r3, [r7, #12]
    677e:	681b      	ldr	r3, [r3, #0]
    6780:	2200      	movs	r2, #0
    6782:	701a      	strb	r2, [r3, #0]
		len = 0;
    6784:	68fb      	ldr	r3, [r7, #12]
    6786:	2200      	movs	r2, #0
    6788:	609a      	str	r2, [r3, #8]
		return *this;
    678a:	68fb      	ldr	r3, [r7, #12]
    678c:	e02a      	b.n	67e4 <_ZN6String4copyEPKcj+0x82>
	}
	if (!reserve(length)) {
    678e:	6879      	ldr	r1, [r7, #4]
    6790:	68f8      	ldr	r0, [r7, #12]
    6792:	f7ff ffa1 	bl	66d8 <_ZN6String7reserveEj>
    6796:	4603      	mov	r3, r0
    6798:	2b00      	cmp	r3, #0
    679a:	bf0c      	ite	eq
    679c:	2301      	moveq	r3, #1
    679e:	2300      	movne	r3, #0
    67a0:	b2db      	uxtb	r3, r3
    67a2:	2b00      	cmp	r3, #0
    67a4:	d014      	beq.n	67d0 <_ZN6String4copyEPKcj+0x6e>
		if (buffer) {
    67a6:	68fb      	ldr	r3, [r7, #12]
    67a8:	681b      	ldr	r3, [r3, #0]
    67aa:	2b00      	cmp	r3, #0
    67ac:	d007      	beq.n	67be <_ZN6String4copyEPKcj+0x5c>
			free(buffer);
    67ae:	68fb      	ldr	r3, [r7, #12]
    67b0:	681b      	ldr	r3, [r3, #0]
    67b2:	4618      	mov	r0, r3
    67b4:	f007 fdfa 	bl	e3ac <free>
			buffer = NULL;
    67b8:	68fb      	ldr	r3, [r7, #12]
    67ba:	2200      	movs	r2, #0
    67bc:	601a      	str	r2, [r3, #0]
		}
		len = capacity = 0;
    67be:	68fb      	ldr	r3, [r7, #12]
    67c0:	2200      	movs	r2, #0
    67c2:	605a      	str	r2, [r3, #4]
    67c4:	68fb      	ldr	r3, [r7, #12]
    67c6:	685a      	ldr	r2, [r3, #4]
    67c8:	68fb      	ldr	r3, [r7, #12]
    67ca:	609a      	str	r2, [r3, #8]
		return *this;
    67cc:	68fb      	ldr	r3, [r7, #12]
    67ce:	e009      	b.n	67e4 <_ZN6String4copyEPKcj+0x82>
	}
	len = length;
    67d0:	68fb      	ldr	r3, [r7, #12]
    67d2:	687a      	ldr	r2, [r7, #4]
    67d4:	609a      	str	r2, [r3, #8]
	strcpy(buffer, cstr);
    67d6:	68fb      	ldr	r3, [r7, #12]
    67d8:	681b      	ldr	r3, [r3, #0]
    67da:	68b9      	ldr	r1, [r7, #8]
    67dc:	4618      	mov	r0, r3
    67de:	f007 ff05 	bl	e5ec <strcpy>
	return *this;
    67e2:	68fb      	ldr	r3, [r7, #12]
}
    67e4:	4618      	mov	r0, r3
    67e6:	3710      	adds	r7, #16
    67e8:	46bd      	mov	sp, r7
    67ea:	bd80      	pop	{r7, pc}

000067ec <_ZN6StringaSERKS_>:
	rhs.capacity = 0;
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
    67ec:	b580      	push	{r7, lr}
    67ee:	b082      	sub	sp, #8
    67f0:	af00      	add	r7, sp, #0
    67f2:	6078      	str	r0, [r7, #4]
    67f4:	6039      	str	r1, [r7, #0]
	if (this == &rhs) return *this;
    67f6:	687a      	ldr	r2, [r7, #4]
    67f8:	683b      	ldr	r3, [r7, #0]
    67fa:	429a      	cmp	r2, r3
    67fc:	d101      	bne.n	6802 <_ZN6StringaSERKS_+0x16>
    67fe:	687b      	ldr	r3, [r7, #4]
    6800:	e009      	b.n	6816 <_ZN6StringaSERKS_+0x2a>
	return copy(rhs.buffer, rhs.len);
    6802:	683b      	ldr	r3, [r7, #0]
    6804:	6819      	ldr	r1, [r3, #0]
    6806:	683b      	ldr	r3, [r7, #0]
    6808:	689b      	ldr	r3, [r3, #8]
    680a:	461a      	mov	r2, r3
    680c:	6878      	ldr	r0, [r7, #4]
    680e:	f7ff ffa8 	bl	6762 <_ZN6String4copyEPKcj>
    6812:	4603      	mov	r3, r0
    6814:	bf00      	nop
}
    6816:	4618      	mov	r0, r3
    6818:	3708      	adds	r7, #8
    681a:	46bd      	mov	sp, r7
    681c:	bd80      	pop	{r7, pc}

0000681e <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
    681e:	b580      	push	{r7, lr}
    6820:	b082      	sub	sp, #8
    6822:	af00      	add	r7, sp, #0
    6824:	6078      	str	r0, [r7, #4]
    6826:	6039      	str	r1, [r7, #0]
	if (cstr) {
    6828:	683b      	ldr	r3, [r7, #0]
    682a:	2b00      	cmp	r3, #0
    682c:	d009      	beq.n	6842 <_ZN6StringaSEPKc+0x24>
		copy(cstr, strlen(cstr));
    682e:	6838      	ldr	r0, [r7, #0]
    6830:	f007 fee4 	bl	e5fc <strlen>
    6834:	4603      	mov	r3, r0
    6836:	461a      	mov	r2, r3
    6838:	6839      	ldr	r1, [r7, #0]
    683a:	6878      	ldr	r0, [r7, #4]
    683c:	f7ff ff91 	bl	6762 <_ZN6String4copyEPKcj>
    6840:	e002      	b.n	6848 <_ZN6StringaSEPKc+0x2a>
	} else {
		len = 0;
    6842:	687b      	ldr	r3, [r7, #4]
    6844:	2200      	movs	r2, #0
    6846:	609a      	str	r2, [r3, #8]
	}
	return *this;
    6848:	687b      	ldr	r3, [r7, #4]
}
    684a:	4618      	mov	r0, r3
    684c:	3708      	adds	r7, #8
    684e:	46bd      	mov	sp, r7
    6850:	bd80      	pop	{r7, pc}

00006852 <_ZN6String6appendEPKcj>:
{
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
    6852:	b580      	push	{r7, lr}
    6854:	b088      	sub	sp, #32
    6856:	af00      	add	r7, sp, #0
    6858:	60f8      	str	r0, [r7, #12]
    685a:	60b9      	str	r1, [r7, #8]
    685c:	607a      	str	r2, [r7, #4]
	unsigned int newlen = len + length;
    685e:	68fb      	ldr	r3, [r7, #12]
    6860:	689b      	ldr	r3, [r3, #8]
    6862:	687a      	ldr	r2, [r7, #4]
    6864:	4413      	add	r3, r2
    6866:	617b      	str	r3, [r7, #20]
	bool self = false;
    6868:	2300      	movs	r3, #0
    686a:	77fb      	strb	r3, [r7, #31]
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
    686c:	68fb      	ldr	r3, [r7, #12]
    686e:	681b      	ldr	r3, [r3, #0]
    6870:	68ba      	ldr	r2, [r7, #8]
    6872:	429a      	cmp	r2, r3
    6874:	d30e      	bcc.n	6894 <_ZN6String6appendEPKcj+0x42>
    6876:	68fb      	ldr	r3, [r7, #12]
    6878:	681a      	ldr	r2, [r3, #0]
    687a:	68fb      	ldr	r3, [r7, #12]
    687c:	689b      	ldr	r3, [r3, #8]
    687e:	4413      	add	r3, r2
    6880:	68ba      	ldr	r2, [r7, #8]
    6882:	429a      	cmp	r2, r3
    6884:	d206      	bcs.n	6894 <_ZN6String6appendEPKcj+0x42>
		self = true;
    6886:	2301      	movs	r3, #1
    6888:	77fb      	strb	r3, [r7, #31]
		buffer_offset = (unsigned int)(cstr-buffer);
    688a:	68fb      	ldr	r3, [r7, #12]
    688c:	681b      	ldr	r3, [r3, #0]
    688e:	68ba      	ldr	r2, [r7, #8]
    6890:	1ad3      	subs	r3, r2, r3
    6892:	61bb      	str	r3, [r7, #24]
	}
	if (length == 0 || !reserve(newlen)) return *this;
    6894:	687b      	ldr	r3, [r7, #4]
    6896:	2b00      	cmp	r3, #0
    6898:	d006      	beq.n	68a8 <_ZN6String6appendEPKcj+0x56>
    689a:	6979      	ldr	r1, [r7, #20]
    689c:	68f8      	ldr	r0, [r7, #12]
    689e:	f7ff ff1b 	bl	66d8 <_ZN6String7reserveEj>
    68a2:	4603      	mov	r3, r0
    68a4:	2b00      	cmp	r3, #0
    68a6:	d101      	bne.n	68ac <_ZN6String6appendEPKcj+0x5a>
    68a8:	2301      	movs	r3, #1
    68aa:	e000      	b.n	68ae <_ZN6String6appendEPKcj+0x5c>
    68ac:	2300      	movs	r3, #0
    68ae:	2b00      	cmp	r3, #0
    68b0:	d001      	beq.n	68b6 <_ZN6String6appendEPKcj+0x64>
    68b2:	68fb      	ldr	r3, [r7, #12]
    68b4:	e023      	b.n	68fe <_ZN6String6appendEPKcj+0xac>
	if ( self ) {
    68b6:	7ffb      	ldrb	r3, [r7, #31]
    68b8:	2b00      	cmp	r3, #0
    68ba:	d013      	beq.n	68e4 <_ZN6String6appendEPKcj+0x92>
		memcpy(buffer + len, buffer+buffer_offset, length);
    68bc:	68fb      	ldr	r3, [r7, #12]
    68be:	681a      	ldr	r2, [r3, #0]
    68c0:	68fb      	ldr	r3, [r7, #12]
    68c2:	689b      	ldr	r3, [r3, #8]
    68c4:	18d0      	adds	r0, r2, r3
    68c6:	68fb      	ldr	r3, [r7, #12]
    68c8:	681a      	ldr	r2, [r3, #0]
    68ca:	69bb      	ldr	r3, [r7, #24]
    68cc:	4413      	add	r3, r2
    68ce:	687a      	ldr	r2, [r7, #4]
    68d0:	4619      	mov	r1, r3
    68d2:	f007 fd73 	bl	e3bc <memcpy>
		buffer[newlen] = 0;
    68d6:	68fb      	ldr	r3, [r7, #12]
    68d8:	681a      	ldr	r2, [r3, #0]
    68da:	697b      	ldr	r3, [r7, #20]
    68dc:	4413      	add	r3, r2
    68de:	2200      	movs	r2, #0
    68e0:	701a      	strb	r2, [r3, #0]
    68e2:	e008      	b.n	68f6 <_ZN6String6appendEPKcj+0xa4>
		}
	else
		strcpy(buffer + len, cstr);
    68e4:	68fb      	ldr	r3, [r7, #12]
    68e6:	681a      	ldr	r2, [r3, #0]
    68e8:	68fb      	ldr	r3, [r7, #12]
    68ea:	689b      	ldr	r3, [r3, #8]
    68ec:	4413      	add	r3, r2
    68ee:	68b9      	ldr	r1, [r7, #8]
    68f0:	4618      	mov	r0, r3
    68f2:	f007 fe7b 	bl	e5ec <strcpy>
	len = newlen;
    68f6:	68fb      	ldr	r3, [r7, #12]
    68f8:	697a      	ldr	r2, [r7, #20]
    68fa:	609a      	str	r2, [r3, #8]
	return *this;
    68fc:	68fb      	ldr	r3, [r7, #12]
}
    68fe:	4618      	mov	r0, r3
    6900:	3720      	adds	r7, #32
    6902:	46bd      	mov	sp, r7
    6904:	bd80      	pop	{r7, pc}

00006906 <_ZN6String6appendEc>:
	if (cstr) append(cstr, strlen(cstr));
	return *this;
}

String & String::append(char c)
{
    6906:	b580      	push	{r7, lr}
    6908:	b084      	sub	sp, #16
    690a:	af00      	add	r7, sp, #0
    690c:	6078      	str	r0, [r7, #4]
    690e:	460b      	mov	r3, r1
    6910:	70fb      	strb	r3, [r7, #3]
	char buf[2];
	buf[0] = c;
    6912:	78fb      	ldrb	r3, [r7, #3]
    6914:	733b      	strb	r3, [r7, #12]
	buf[1] = 0;
    6916:	2300      	movs	r3, #0
    6918:	737b      	strb	r3, [r7, #13]
	append(buf, 1);
    691a:	f107 030c 	add.w	r3, r7, #12
    691e:	2201      	movs	r2, #1
    6920:	4619      	mov	r1, r3
    6922:	6878      	ldr	r0, [r7, #4]
    6924:	f7ff ff95 	bl	6852 <_ZN6String6appendEPKcj>
	return *this;
    6928:	687b      	ldr	r3, [r7, #4]
}
    692a:	4618      	mov	r0, r3
    692c:	3710      	adds	r7, #16
    692e:	46bd      	mov	sp, r7
    6930:	bd80      	pop	{r7, pc}

00006932 <_ZNK6String9compareToERKS_>:
/*********************************************/
/*  Comparison                               */
/*********************************************/

int String::compareTo(const String &s) const
{
    6932:	b580      	push	{r7, lr}
    6934:	b082      	sub	sp, #8
    6936:	af00      	add	r7, sp, #0
    6938:	6078      	str	r0, [r7, #4]
    693a:	6039      	str	r1, [r7, #0]
	if (!buffer || !s.buffer) {
    693c:	687b      	ldr	r3, [r7, #4]
    693e:	681b      	ldr	r3, [r3, #0]
    6940:	2b00      	cmp	r3, #0
    6942:	d003      	beq.n	694c <_ZNK6String9compareToERKS_+0x1a>
    6944:	683b      	ldr	r3, [r7, #0]
    6946:	681b      	ldr	r3, [r3, #0]
    6948:	2b00      	cmp	r3, #0
    694a:	d11a      	bne.n	6982 <_ZNK6String9compareToERKS_+0x50>
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
    694c:	683b      	ldr	r3, [r7, #0]
    694e:	681b      	ldr	r3, [r3, #0]
    6950:	2b00      	cmp	r3, #0
    6952:	d008      	beq.n	6966 <_ZNK6String9compareToERKS_+0x34>
    6954:	683b      	ldr	r3, [r7, #0]
    6956:	689b      	ldr	r3, [r3, #8]
    6958:	2b00      	cmp	r3, #0
    695a:	d004      	beq.n	6966 <_ZNK6String9compareToERKS_+0x34>
    695c:	683b      	ldr	r3, [r7, #0]
    695e:	681b      	ldr	r3, [r3, #0]
    6960:	781b      	ldrb	r3, [r3, #0]
    6962:	425b      	negs	r3, r3
    6964:	e017      	b.n	6996 <_ZNK6String9compareToERKS_+0x64>
		if (buffer && len > 0) return *(unsigned char *)buffer;
    6966:	687b      	ldr	r3, [r7, #4]
    6968:	681b      	ldr	r3, [r3, #0]
    696a:	2b00      	cmp	r3, #0
    696c:	d007      	beq.n	697e <_ZNK6String9compareToERKS_+0x4c>
    696e:	687b      	ldr	r3, [r7, #4]
    6970:	689b      	ldr	r3, [r3, #8]
    6972:	2b00      	cmp	r3, #0
    6974:	d003      	beq.n	697e <_ZNK6String9compareToERKS_+0x4c>
    6976:	687b      	ldr	r3, [r7, #4]
    6978:	681b      	ldr	r3, [r3, #0]
    697a:	781b      	ldrb	r3, [r3, #0]
    697c:	e00b      	b.n	6996 <_ZNK6String9compareToERKS_+0x64>
		return 0;
    697e:	2300      	movs	r3, #0
    6980:	e009      	b.n	6996 <_ZNK6String9compareToERKS_+0x64>
	}
	return strcmp(buffer, s.buffer);
    6982:	687b      	ldr	r3, [r7, #4]
    6984:	681a      	ldr	r2, [r3, #0]
    6986:	683b      	ldr	r3, [r7, #0]
    6988:	681b      	ldr	r3, [r3, #0]
    698a:	4619      	mov	r1, r3
    698c:	4610      	mov	r0, r2
    698e:	f007 fe23 	bl	e5d8 <strcmp>
    6992:	4603      	mov	r3, r0
    6994:	bf00      	nop
}
    6996:	4618      	mov	r0, r3
    6998:	3708      	adds	r7, #8
    699a:	46bd      	mov	sp, r7
    699c:	bd80      	pop	{r7, pc}

0000699e <_ZNK6String6equalsERKS_>:

unsigned char String::equals(const String &s2) const
{
    699e:	b580      	push	{r7, lr}
    69a0:	b082      	sub	sp, #8
    69a2:	af00      	add	r7, sp, #0
    69a4:	6078      	str	r0, [r7, #4]
    69a6:	6039      	str	r1, [r7, #0]
	return (len == s2.len && compareTo(s2) == 0);
    69a8:	687b      	ldr	r3, [r7, #4]
    69aa:	689a      	ldr	r2, [r3, #8]
    69ac:	683b      	ldr	r3, [r7, #0]
    69ae:	689b      	ldr	r3, [r3, #8]
    69b0:	429a      	cmp	r2, r3
    69b2:	d108      	bne.n	69c6 <_ZNK6String6equalsERKS_+0x28>
    69b4:	6839      	ldr	r1, [r7, #0]
    69b6:	6878      	ldr	r0, [r7, #4]
    69b8:	f7ff ffbb 	bl	6932 <_ZNK6String9compareToERKS_>
    69bc:	4603      	mov	r3, r0
    69be:	2b00      	cmp	r3, #0
    69c0:	d101      	bne.n	69c6 <_ZNK6String6equalsERKS_+0x28>
    69c2:	2301      	movs	r3, #1
    69c4:	e000      	b.n	69c8 <_ZNK6String6equalsERKS_+0x2a>
    69c6:	2300      	movs	r3, #0
}
    69c8:	4618      	mov	r0, r3
    69ca:	3708      	adds	r7, #8
    69cc:	46bd      	mov	sp, r7
    69ce:	bd80      	pop	{r7, pc}

000069d0 <_ZNK6String6equalsEPKc>:

unsigned char String::equals(const char *cstr) const
{
    69d0:	b580      	push	{r7, lr}
    69d2:	b082      	sub	sp, #8
    69d4:	af00      	add	r7, sp, #0
    69d6:	6078      	str	r0, [r7, #4]
    69d8:	6039      	str	r1, [r7, #0]
	if (len == 0) return (cstr == NULL || *cstr == 0);
    69da:	687b      	ldr	r3, [r7, #4]
    69dc:	689b      	ldr	r3, [r3, #8]
    69de:	2b00      	cmp	r3, #0
    69e0:	d10a      	bne.n	69f8 <_ZNK6String6equalsEPKc+0x28>
    69e2:	683b      	ldr	r3, [r7, #0]
    69e4:	2b00      	cmp	r3, #0
    69e6:	d003      	beq.n	69f0 <_ZNK6String6equalsEPKc+0x20>
    69e8:	683b      	ldr	r3, [r7, #0]
    69ea:	781b      	ldrb	r3, [r3, #0]
    69ec:	2b00      	cmp	r3, #0
    69ee:	d101      	bne.n	69f4 <_ZNK6String6equalsEPKc+0x24>
    69f0:	2301      	movs	r3, #1
    69f2:	e000      	b.n	69f6 <_ZNK6String6equalsEPKc+0x26>
    69f4:	2300      	movs	r3, #0
    69f6:	e017      	b.n	6a28 <_ZNK6String6equalsEPKc+0x58>
	if (cstr == NULL) return buffer[0] == 0;
    69f8:	683b      	ldr	r3, [r7, #0]
    69fa:	2b00      	cmp	r3, #0
    69fc:	d108      	bne.n	6a10 <_ZNK6String6equalsEPKc+0x40>
    69fe:	687b      	ldr	r3, [r7, #4]
    6a00:	681b      	ldr	r3, [r3, #0]
    6a02:	781b      	ldrb	r3, [r3, #0]
    6a04:	2b00      	cmp	r3, #0
    6a06:	bf0c      	ite	eq
    6a08:	2301      	moveq	r3, #1
    6a0a:	2300      	movne	r3, #0
    6a0c:	b2db      	uxtb	r3, r3
    6a0e:	e00b      	b.n	6a28 <_ZNK6String6equalsEPKc+0x58>
	return strcmp(buffer, cstr) == 0;
    6a10:	687b      	ldr	r3, [r7, #4]
    6a12:	681b      	ldr	r3, [r3, #0]
    6a14:	6839      	ldr	r1, [r7, #0]
    6a16:	4618      	mov	r0, r3
    6a18:	f007 fdde 	bl	e5d8 <strcmp>
    6a1c:	4603      	mov	r3, r0
    6a1e:	2b00      	cmp	r3, #0
    6a20:	bf0c      	ite	eq
    6a22:	2301      	moveq	r3, #1
    6a24:	2300      	movne	r3, #0
    6a26:	b2db      	uxtb	r3, r3
}
    6a28:	4618      	mov	r0, r3
    6a2a:	3708      	adds	r7, #8
    6a2c:	46bd      	mov	sp, r7
    6a2e:	bd80      	pop	{r7, pc}

00006a30 <_ZNK6String8getBytesEPhjj>:
	if (index >= len || !buffer) return 0;
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
    6a30:	b580      	push	{r7, lr}
    6a32:	b086      	sub	sp, #24
    6a34:	af00      	add	r7, sp, #0
    6a36:	60f8      	str	r0, [r7, #12]
    6a38:	60b9      	str	r1, [r7, #8]
    6a3a:	607a      	str	r2, [r7, #4]
    6a3c:	603b      	str	r3, [r7, #0]
	if (!bufsize || !buf) return;
    6a3e:	687b      	ldr	r3, [r7, #4]
    6a40:	2b00      	cmp	r3, #0
    6a42:	d029      	beq.n	6a98 <_ZNK6String8getBytesEPhjj+0x68>
    6a44:	68bb      	ldr	r3, [r7, #8]
    6a46:	2b00      	cmp	r3, #0
    6a48:	d026      	beq.n	6a98 <_ZNK6String8getBytesEPhjj+0x68>
	if (index >= len) {
    6a4a:	68fb      	ldr	r3, [r7, #12]
    6a4c:	689b      	ldr	r3, [r3, #8]
    6a4e:	683a      	ldr	r2, [r7, #0]
    6a50:	429a      	cmp	r2, r3
    6a52:	d303      	bcc.n	6a5c <_ZNK6String8getBytesEPhjj+0x2c>
		buf[0] = 0;
    6a54:	68bb      	ldr	r3, [r7, #8]
    6a56:	2200      	movs	r2, #0
    6a58:	701a      	strb	r2, [r3, #0]
		return;
    6a5a:	e01e      	b.n	6a9a <_ZNK6String8getBytesEPhjj+0x6a>
	}
	unsigned int n = bufsize - 1;
    6a5c:	687b      	ldr	r3, [r7, #4]
    6a5e:	3b01      	subs	r3, #1
    6a60:	617b      	str	r3, [r7, #20]
	if (n > len - index) n = len - index;
    6a62:	68fb      	ldr	r3, [r7, #12]
    6a64:	689a      	ldr	r2, [r3, #8]
    6a66:	683b      	ldr	r3, [r7, #0]
    6a68:	1ad3      	subs	r3, r2, r3
    6a6a:	697a      	ldr	r2, [r7, #20]
    6a6c:	429a      	cmp	r2, r3
    6a6e:	d904      	bls.n	6a7a <_ZNK6String8getBytesEPhjj+0x4a>
    6a70:	68fb      	ldr	r3, [r7, #12]
    6a72:	689a      	ldr	r2, [r3, #8]
    6a74:	683b      	ldr	r3, [r7, #0]
    6a76:	1ad3      	subs	r3, r2, r3
    6a78:	617b      	str	r3, [r7, #20]
	strncpy((char *)buf, buffer + index, n);
    6a7a:	68fb      	ldr	r3, [r7, #12]
    6a7c:	681a      	ldr	r2, [r3, #0]
    6a7e:	683b      	ldr	r3, [r7, #0]
    6a80:	4413      	add	r3, r2
    6a82:	697a      	ldr	r2, [r7, #20]
    6a84:	4619      	mov	r1, r3
    6a86:	68b8      	ldr	r0, [r7, #8]
    6a88:	f007 fdc0 	bl	e60c <strncpy>
	buf[n] = 0;
    6a8c:	68ba      	ldr	r2, [r7, #8]
    6a8e:	697b      	ldr	r3, [r7, #20]
    6a90:	4413      	add	r3, r2
    6a92:	2200      	movs	r2, #0
    6a94:	701a      	strb	r2, [r3, #0]
    6a96:	e000      	b.n	6a9a <_ZNK6String8getBytesEPhjj+0x6a>
	if (!bufsize || !buf) return;
    6a98:	bf00      	nop
}
    6a9a:	3718      	adds	r7, #24
    6a9c:	46bd      	mov	sp, r7
    6a9e:	bd80      	pop	{r7, pc}

00006aa0 <_ZNK6String7indexOfERKS_>:
	if (temp == NULL) return -1;
	return temp - buffer;
}

int String::indexOf(const String &s2) const
{
    6aa0:	b580      	push	{r7, lr}
    6aa2:	b082      	sub	sp, #8
    6aa4:	af00      	add	r7, sp, #0
    6aa6:	6078      	str	r0, [r7, #4]
    6aa8:	6039      	str	r1, [r7, #0]
	return indexOf(s2, 0);
    6aaa:	2200      	movs	r2, #0
    6aac:	6839      	ldr	r1, [r7, #0]
    6aae:	6878      	ldr	r0, [r7, #4]
    6ab0:	f000 f805 	bl	6abe <_ZNK6String7indexOfERKS_j>
    6ab4:	4603      	mov	r3, r0
}
    6ab6:	4618      	mov	r0, r3
    6ab8:	3708      	adds	r7, #8
    6aba:	46bd      	mov	sp, r7
    6abc:	bd80      	pop	{r7, pc}

00006abe <_ZNK6String7indexOfERKS_j>:

int String::indexOf(const String &s2, unsigned int fromIndex) const
{
    6abe:	b580      	push	{r7, lr}
    6ac0:	b086      	sub	sp, #24
    6ac2:	af00      	add	r7, sp, #0
    6ac4:	60f8      	str	r0, [r7, #12]
    6ac6:	60b9      	str	r1, [r7, #8]
    6ac8:	607a      	str	r2, [r7, #4]
	if (fromIndex >= len) return -1;
    6aca:	68fb      	ldr	r3, [r7, #12]
    6acc:	689b      	ldr	r3, [r3, #8]
    6ace:	687a      	ldr	r2, [r7, #4]
    6ad0:	429a      	cmp	r2, r3
    6ad2:	d302      	bcc.n	6ada <_ZNK6String7indexOfERKS_j+0x1c>
    6ad4:	f04f 33ff 	mov.w	r3, #4294967295
    6ad8:	e014      	b.n	6b04 <_ZNK6String7indexOfERKS_j+0x46>
	const char *found = strstr(buffer + fromIndex, s2.buffer);
    6ada:	68fb      	ldr	r3, [r7, #12]
    6adc:	681a      	ldr	r2, [r3, #0]
    6ade:	687b      	ldr	r3, [r7, #4]
    6ae0:	441a      	add	r2, r3
    6ae2:	68bb      	ldr	r3, [r7, #8]
    6ae4:	681b      	ldr	r3, [r3, #0]
    6ae6:	4619      	mov	r1, r3
    6ae8:	4610      	mov	r0, r2
    6aea:	f007 fda2 	bl	e632 <strstr>
    6aee:	6178      	str	r0, [r7, #20]
	if (found == NULL) return -1;
    6af0:	697b      	ldr	r3, [r7, #20]
    6af2:	2b00      	cmp	r3, #0
    6af4:	d102      	bne.n	6afc <_ZNK6String7indexOfERKS_j+0x3e>
    6af6:	f04f 33ff 	mov.w	r3, #4294967295
    6afa:	e003      	b.n	6b04 <_ZNK6String7indexOfERKS_j+0x46>
	return found - buffer;
    6afc:	68fb      	ldr	r3, [r7, #12]
    6afe:	681b      	ldr	r3, [r3, #0]
    6b00:	697a      	ldr	r2, [r7, #20]
    6b02:	1ad3      	subs	r3, r2, r3
}
    6b04:	4618      	mov	r0, r3
    6b06:	3718      	adds	r7, #24
    6b08:	46bd      	mov	sp, r7
    6b0a:	bd80      	pop	{r7, pc}

00006b0c <_ZNK6String9substringEj>:
	}
	return found;
}

String String::substring( unsigned int left ) const
{
    6b0c:	b580      	push	{r7, lr}
    6b0e:	b084      	sub	sp, #16
    6b10:	af00      	add	r7, sp, #0
    6b12:	60f8      	str	r0, [r7, #12]
    6b14:	60b9      	str	r1, [r7, #8]
    6b16:	607a      	str	r2, [r7, #4]
	return substring(left, len);
    6b18:	68bb      	ldr	r3, [r7, #8]
    6b1a:	689b      	ldr	r3, [r3, #8]
    6b1c:	68f8      	ldr	r0, [r7, #12]
    6b1e:	687a      	ldr	r2, [r7, #4]
    6b20:	68b9      	ldr	r1, [r7, #8]
    6b22:	f000 f804 	bl	6b2e <_ZNK6String9substringEjj>
}
    6b26:	68f8      	ldr	r0, [r7, #12]
    6b28:	3710      	adds	r7, #16
    6b2a:	46bd      	mov	sp, r7
    6b2c:	bd80      	pop	{r7, pc}

00006b2e <_ZNK6String9substringEjj>:

String String::substring(unsigned int left, unsigned int right) const
{
    6b2e:	b580      	push	{r7, lr}
    6b30:	b086      	sub	sp, #24
    6b32:	af00      	add	r7, sp, #0
    6b34:	60f8      	str	r0, [r7, #12]
    6b36:	60b9      	str	r1, [r7, #8]
    6b38:	607a      	str	r2, [r7, #4]
    6b3a:	603b      	str	r3, [r7, #0]
	if (left > right) {
    6b3c:	687a      	ldr	r2, [r7, #4]
    6b3e:	683b      	ldr	r3, [r7, #0]
    6b40:	429a      	cmp	r2, r3
    6b42:	d905      	bls.n	6b50 <_ZNK6String9substringEjj+0x22>
		unsigned int temp = right;
    6b44:	683b      	ldr	r3, [r7, #0]
    6b46:	617b      	str	r3, [r7, #20]
		right = left;
    6b48:	687b      	ldr	r3, [r7, #4]
    6b4a:	603b      	str	r3, [r7, #0]
		left = temp;
    6b4c:	697b      	ldr	r3, [r7, #20]
    6b4e:	607b      	str	r3, [r7, #4]
	}
	String out;
    6b50:	2100      	movs	r1, #0
    6b52:	68f8      	ldr	r0, [r7, #12]
    6b54:	f7ff fd72 	bl	663c <_ZN6StringC1EPKc>
	if (left > len) return out;
    6b58:	68bb      	ldr	r3, [r7, #8]
    6b5a:	689b      	ldr	r3, [r3, #8]
    6b5c:	687a      	ldr	r2, [r7, #4]
    6b5e:	429a      	cmp	r2, r3
    6b60:	d822      	bhi.n	6ba8 <_ZNK6String9substringEjj+0x7a>
	if (right > len) right = len;
    6b62:	68bb      	ldr	r3, [r7, #8]
    6b64:	689b      	ldr	r3, [r3, #8]
    6b66:	683a      	ldr	r2, [r7, #0]
    6b68:	429a      	cmp	r2, r3
    6b6a:	d902      	bls.n	6b72 <_ZNK6String9substringEjj+0x44>
    6b6c:	68bb      	ldr	r3, [r7, #8]
    6b6e:	689b      	ldr	r3, [r3, #8]
    6b70:	603b      	str	r3, [r7, #0]
	char temp = buffer[right];  // save the replaced character
    6b72:	68bb      	ldr	r3, [r7, #8]
    6b74:	681a      	ldr	r2, [r3, #0]
    6b76:	683b      	ldr	r3, [r7, #0]
    6b78:	4413      	add	r3, r2
    6b7a:	781b      	ldrb	r3, [r3, #0]
    6b7c:	74fb      	strb	r3, [r7, #19]
	buffer[right] = '\0';	
    6b7e:	68bb      	ldr	r3, [r7, #8]
    6b80:	681a      	ldr	r2, [r3, #0]
    6b82:	683b      	ldr	r3, [r7, #0]
    6b84:	4413      	add	r3, r2
    6b86:	2200      	movs	r2, #0
    6b88:	701a      	strb	r2, [r3, #0]
	out = buffer + left;  // pointer arithmetic
    6b8a:	68bb      	ldr	r3, [r7, #8]
    6b8c:	681a      	ldr	r2, [r3, #0]
    6b8e:	687b      	ldr	r3, [r7, #4]
    6b90:	4413      	add	r3, r2
    6b92:	4619      	mov	r1, r3
    6b94:	68f8      	ldr	r0, [r7, #12]
    6b96:	f7ff fe42 	bl	681e <_ZN6StringaSEPKc>
	buffer[right] = temp;  //restore character
    6b9a:	68bb      	ldr	r3, [r7, #8]
    6b9c:	681a      	ldr	r2, [r3, #0]
    6b9e:	683b      	ldr	r3, [r7, #0]
    6ba0:	4413      	add	r3, r2
    6ba2:	7cfa      	ldrb	r2, [r7, #19]
    6ba4:	701a      	strb	r2, [r3, #0]
	return out;
    6ba6:	e000      	b.n	6baa <_ZNK6String9substringEjj+0x7c>
	if (left > len) return out;
    6ba8:	bf00      	nop
}
    6baa:	68f8      	ldr	r0, [r7, #12]
    6bac:	3718      	adds	r7, #24
    6bae:	46bd      	mov	sp, r7
    6bb0:	bd80      	pop	{r7, pc}

00006bb2 <_ZN6String11toLowerCaseEv>:
	}
	return *this;
}

String & String::toLowerCase(void)
{
    6bb2:	b580      	push	{r7, lr}
    6bb4:	b084      	sub	sp, #16
    6bb6:	af00      	add	r7, sp, #0
    6bb8:	6078      	str	r0, [r7, #4]
	if (!buffer) return *this;
    6bba:	687b      	ldr	r3, [r7, #4]
    6bbc:	681b      	ldr	r3, [r3, #0]
    6bbe:	2b00      	cmp	r3, #0
    6bc0:	d101      	bne.n	6bc6 <_ZN6String11toLowerCaseEv+0x14>
    6bc2:	687b      	ldr	r3, [r7, #4]
    6bc4:	e014      	b.n	6bf0 <_ZN6String11toLowerCaseEv+0x3e>
	for (char *p = buffer; *p; p++) {
    6bc6:	687b      	ldr	r3, [r7, #4]
    6bc8:	681b      	ldr	r3, [r3, #0]
    6bca:	60fb      	str	r3, [r7, #12]
    6bcc:	e00b      	b.n	6be6 <_ZN6String11toLowerCaseEv+0x34>
		*p = tolower(*p);
    6bce:	68fb      	ldr	r3, [r7, #12]
    6bd0:	781b      	ldrb	r3, [r3, #0]
    6bd2:	4618      	mov	r0, r3
    6bd4:	f007 fdd0 	bl	e778 <tolower>
    6bd8:	4603      	mov	r3, r0
    6bda:	b2da      	uxtb	r2, r3
    6bdc:	68fb      	ldr	r3, [r7, #12]
    6bde:	701a      	strb	r2, [r3, #0]
	for (char *p = buffer; *p; p++) {
    6be0:	68fb      	ldr	r3, [r7, #12]
    6be2:	3301      	adds	r3, #1
    6be4:	60fb      	str	r3, [r7, #12]
    6be6:	68fb      	ldr	r3, [r7, #12]
    6be8:	781b      	ldrb	r3, [r3, #0]
    6bea:	2b00      	cmp	r3, #0
    6bec:	d1ef      	bne.n	6bce <_ZN6String11toLowerCaseEv+0x1c>
	}
	return *this;
    6bee:	687b      	ldr	r3, [r7, #4]
}
    6bf0:	4618      	mov	r0, r3
    6bf2:	3710      	adds	r7, #16
    6bf4:	46bd      	mov	sp, r7
    6bf6:	bd80      	pop	{r7, pc}

00006bf8 <_ZN6String4trimEv>:
	}
	return *this;
}

String & String::trim(void)
{
    6bf8:	b580      	push	{r7, lr}
    6bfa:	b084      	sub	sp, #16
    6bfc:	af00      	add	r7, sp, #0
    6bfe:	6078      	str	r0, [r7, #4]
	if (!buffer || len == 0) return *this;
    6c00:	687b      	ldr	r3, [r7, #4]
    6c02:	681b      	ldr	r3, [r3, #0]
    6c04:	2b00      	cmp	r3, #0
    6c06:	d003      	beq.n	6c10 <_ZN6String4trimEv+0x18>
    6c08:	687b      	ldr	r3, [r7, #4]
    6c0a:	689b      	ldr	r3, [r3, #8]
    6c0c:	2b00      	cmp	r3, #0
    6c0e:	d101      	bne.n	6c14 <_ZN6String4trimEv+0x1c>
    6c10:	687b      	ldr	r3, [r7, #4]
    6c12:	e041      	b.n	6c98 <_ZN6String4trimEv+0xa0>
	char *begin = buffer;
    6c14:	687b      	ldr	r3, [r7, #4]
    6c16:	681b      	ldr	r3, [r3, #0]
    6c18:	60fb      	str	r3, [r7, #12]
	while (isspace(*begin)) begin++;
    6c1a:	e002      	b.n	6c22 <_ZN6String4trimEv+0x2a>
    6c1c:	68fb      	ldr	r3, [r7, #12]
    6c1e:	3301      	adds	r3, #1
    6c20:	60fb      	str	r3, [r7, #12]
    6c22:	68fb      	ldr	r3, [r7, #12]
    6c24:	781b      	ldrb	r3, [r3, #0]
    6c26:	4618      	mov	r0, r3
    6c28:	f007 fbb8 	bl	e39c <isspace>
    6c2c:	4603      	mov	r3, r0
    6c2e:	2b00      	cmp	r3, #0
    6c30:	d1f4      	bne.n	6c1c <_ZN6String4trimEv+0x24>
	char *end = buffer + len - 1;
    6c32:	687b      	ldr	r3, [r7, #4]
    6c34:	681a      	ldr	r2, [r3, #0]
    6c36:	687b      	ldr	r3, [r7, #4]
    6c38:	689b      	ldr	r3, [r3, #8]
    6c3a:	3b01      	subs	r3, #1
    6c3c:	4413      	add	r3, r2
    6c3e:	60bb      	str	r3, [r7, #8]
	while (isspace(*end) && end >= begin) end--;
    6c40:	e002      	b.n	6c48 <_ZN6String4trimEv+0x50>
    6c42:	68bb      	ldr	r3, [r7, #8]
    6c44:	3b01      	subs	r3, #1
    6c46:	60bb      	str	r3, [r7, #8]
    6c48:	68bb      	ldr	r3, [r7, #8]
    6c4a:	781b      	ldrb	r3, [r3, #0]
    6c4c:	4618      	mov	r0, r3
    6c4e:	f007 fba5 	bl	e39c <isspace>
    6c52:	4603      	mov	r3, r0
    6c54:	2b00      	cmp	r3, #0
    6c56:	d003      	beq.n	6c60 <_ZN6String4trimEv+0x68>
    6c58:	68ba      	ldr	r2, [r7, #8]
    6c5a:	68fb      	ldr	r3, [r7, #12]
    6c5c:	429a      	cmp	r2, r3
    6c5e:	d2f0      	bcs.n	6c42 <_ZN6String4trimEv+0x4a>
	len = end + 1 - begin;
    6c60:	68bb      	ldr	r3, [r7, #8]
    6c62:	1c5a      	adds	r2, r3, #1
    6c64:	68fb      	ldr	r3, [r7, #12]
    6c66:	1ad3      	subs	r3, r2, r3
    6c68:	461a      	mov	r2, r3
    6c6a:	687b      	ldr	r3, [r7, #4]
    6c6c:	609a      	str	r2, [r3, #8]
	if (begin > buffer) memcpy(buffer, begin, len);
    6c6e:	687b      	ldr	r3, [r7, #4]
    6c70:	681b      	ldr	r3, [r3, #0]
    6c72:	68fa      	ldr	r2, [r7, #12]
    6c74:	429a      	cmp	r2, r3
    6c76:	d907      	bls.n	6c88 <_ZN6String4trimEv+0x90>
    6c78:	687b      	ldr	r3, [r7, #4]
    6c7a:	6818      	ldr	r0, [r3, #0]
    6c7c:	687b      	ldr	r3, [r7, #4]
    6c7e:	689b      	ldr	r3, [r3, #8]
    6c80:	461a      	mov	r2, r3
    6c82:	68f9      	ldr	r1, [r7, #12]
    6c84:	f007 fb9a 	bl	e3bc <memcpy>
	buffer[len] = 0;
    6c88:	687b      	ldr	r3, [r7, #4]
    6c8a:	681a      	ldr	r2, [r3, #0]
    6c8c:	687b      	ldr	r3, [r7, #4]
    6c8e:	689b      	ldr	r3, [r3, #8]
    6c90:	4413      	add	r3, r2
    6c92:	2200      	movs	r2, #0
    6c94:	701a      	strb	r2, [r3, #0]
	return *this;
    6c96:	687b      	ldr	r3, [r7, #4]
}
    6c98:	4618      	mov	r0, r3
    6c9a:	3710      	adds	r7, #16
    6c9c:	46bd      	mov	sp, r7
    6c9e:	bd80      	pop	{r7, pc}

00006ca0 <_ZN14HardwareSerial23processSerialEventsListEv>:
					  serial_write((const uint8_t *)str, len);
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
    6ca0:	b580      	push	{r7, lr}
    6ca2:	b082      	sub	sp, #8
    6ca4:	af00      	add	r7, sp, #0
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    6ca6:	2300      	movs	r3, #0
    6ca8:	71fb      	strb	r3, [r7, #7]
    6caa:	e009      	b.n	6cc0 <_ZN14HardwareSerial23processSerialEventsListEv+0x20>
			s_serials_with_serial_events[i]->doYieldCode();
    6cac:	79fb      	ldrb	r3, [r7, #7]
    6cae:	4a09      	ldr	r2, [pc, #36]	; (6cd4 <_ZN14HardwareSerial23processSerialEventsListEv+0x34>)
    6cb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6cb4:	4618      	mov	r0, r3
    6cb6:	f000 f811 	bl	6cdc <_ZN14HardwareSerial11doYieldCodeEv>
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    6cba:	79fb      	ldrb	r3, [r7, #7]
    6cbc:	3301      	adds	r3, #1
    6cbe:	71fb      	strb	r3, [r7, #7]
    6cc0:	4b05      	ldr	r3, [pc, #20]	; (6cd8 <_ZN14HardwareSerial23processSerialEventsListEv+0x38>)
    6cc2:	781b      	ldrb	r3, [r3, #0]
    6cc4:	79fa      	ldrb	r2, [r7, #7]
    6cc6:	429a      	cmp	r2, r3
    6cc8:	d3f0      	bcc.n	6cac <_ZN14HardwareSerial23processSerialEventsListEv+0xc>
		}
	}
    6cca:	bf00      	nop
    6ccc:	bf00      	nop
    6cce:	3708      	adds	r7, #8
    6cd0:	46bd      	mov	sp, r7
    6cd2:	bd80      	pop	{r7, pc}
    6cd4:	1fff1414 	.word	0x1fff1414
    6cd8:	1fff142c 	.word	0x1fff142c

00006cdc <_ZN14HardwareSerial11doYieldCodeEv>:
protected:
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
    6cdc:	b580      	push	{r7, lr}
    6cde:	b082      	sub	sp, #8
    6ce0:	af00      	add	r7, sp, #0
    6ce2:	6078      	str	r0, [r7, #4]
		if (available()) (*_serialEvent)();
    6ce4:	687b      	ldr	r3, [r7, #4]
    6ce6:	681b      	ldr	r3, [r3, #0]
    6ce8:	3310      	adds	r3, #16
    6cea:	681b      	ldr	r3, [r3, #0]
    6cec:	6878      	ldr	r0, [r7, #4]
    6cee:	4798      	blx	r3
    6cf0:	4603      	mov	r3, r0
    6cf2:	2b00      	cmp	r3, #0
    6cf4:	bf14      	ite	ne
    6cf6:	2301      	movne	r3, #1
    6cf8:	2300      	moveq	r3, #0
    6cfa:	b2db      	uxtb	r3, r3
    6cfc:	2b00      	cmp	r3, #0
    6cfe:	d002      	beq.n	6d06 <_ZN14HardwareSerial11doYieldCodeEv+0x2a>
    6d00:	687b      	ldr	r3, [r7, #4]
    6d02:	691b      	ldr	r3, [r3, #16]
    6d04:	4798      	blx	r3
	}
    6d06:	bf00      	nop
    6d08:	3708      	adds	r7, #8
    6d0a:	46bd      	mov	sp, r7
    6d0c:	bd80      	pop	{r7, pc}
    6d0e:	Address 0x00006d0e is out of bounds.


00006d10 <_ZN14EventResponder12runFromYieldEv>:
	static void runFromYield() {
    6d10:	b580      	push	{r7, lr}
    6d12:	b084      	sub	sp, #16
    6d14:	af00      	add	r7, sp, #0
		if (!firstYield) return;  
    6d16:	4b25      	ldr	r3, [pc, #148]	; (6dac <_ZN14EventResponder12runFromYieldEv+0x9c>)
    6d18:	681b      	ldr	r3, [r3, #0]
    6d1a:	2b00      	cmp	r3, #0
    6d1c:	d03f      	beq.n	6d9e <_ZN14EventResponder12runFromYieldEv+0x8e>
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    6d1e:	f3ef 8305 	mrs	r3, IPSR
    6d22:	60fb      	str	r3, [r7, #12]
		if (ipsr != 0) return;
    6d24:	68fb      	ldr	r3, [r7, #12]
    6d26:	2b00      	cmp	r3, #0
    6d28:	d13b      	bne.n	6da2 <_ZN14EventResponder12runFromYieldEv+0x92>
		bool irq = disableInterrupts();
    6d2a:	f7fd ff4b 	bl	4bc4 <_ZN14EventResponder17disableInterruptsEv>
    6d2e:	4603      	mov	r3, r0
    6d30:	72fb      	strb	r3, [r7, #11]
		EventResponder *first = firstYield;
    6d32:	4b1e      	ldr	r3, [pc, #120]	; (6dac <_ZN14EventResponder12runFromYieldEv+0x9c>)
    6d34:	681b      	ldr	r3, [r3, #0]
    6d36:	607b      	str	r3, [r7, #4]
		if (first == nullptr) {
    6d38:	687b      	ldr	r3, [r7, #4]
    6d3a:	2b00      	cmp	r3, #0
    6d3c:	d104      	bne.n	6d48 <_ZN14EventResponder12runFromYieldEv+0x38>
			enableInterrupts(irq);
    6d3e:	7afb      	ldrb	r3, [r7, #11]
    6d40:	4618      	mov	r0, r3
    6d42:	f7fd ff52 	bl	4bea <_ZN14EventResponder16enableInterruptsEb>
			return;
    6d46:	e02d      	b.n	6da4 <_ZN14EventResponder12runFromYieldEv+0x94>
		if (runningFromYield) {
    6d48:	4b19      	ldr	r3, [pc, #100]	; (6db0 <_ZN14EventResponder12runFromYieldEv+0xa0>)
    6d4a:	781b      	ldrb	r3, [r3, #0]
    6d4c:	2b00      	cmp	r3, #0
    6d4e:	d004      	beq.n	6d5a <_ZN14EventResponder12runFromYieldEv+0x4a>
			enableInterrupts(irq);
    6d50:	7afb      	ldrb	r3, [r7, #11]
    6d52:	4618      	mov	r0, r3
    6d54:	f7fd ff49 	bl	4bea <_ZN14EventResponder16enableInterruptsEb>
			return;
    6d58:	e024      	b.n	6da4 <_ZN14EventResponder12runFromYieldEv+0x94>
		runningFromYield = true;
    6d5a:	4b15      	ldr	r3, [pc, #84]	; (6db0 <_ZN14EventResponder12runFromYieldEv+0xa0>)
    6d5c:	2201      	movs	r2, #1
    6d5e:	701a      	strb	r2, [r3, #0]
		firstYield = first->_next;
    6d60:	687b      	ldr	r3, [r7, #4]
    6d62:	695b      	ldr	r3, [r3, #20]
    6d64:	4a11      	ldr	r2, [pc, #68]	; (6dac <_ZN14EventResponder12runFromYieldEv+0x9c>)
    6d66:	6013      	str	r3, [r2, #0]
		if (firstYield) {
    6d68:	4b10      	ldr	r3, [pc, #64]	; (6dac <_ZN14EventResponder12runFromYieldEv+0x9c>)
    6d6a:	681b      	ldr	r3, [r3, #0]
    6d6c:	2b00      	cmp	r3, #0
    6d6e:	d004      	beq.n	6d7a <_ZN14EventResponder12runFromYieldEv+0x6a>
			firstYield->_prev = nullptr;
    6d70:	4b0e      	ldr	r3, [pc, #56]	; (6dac <_ZN14EventResponder12runFromYieldEv+0x9c>)
    6d72:	681b      	ldr	r3, [r3, #0]
    6d74:	2200      	movs	r2, #0
    6d76:	619a      	str	r2, [r3, #24]
    6d78:	e002      	b.n	6d80 <_ZN14EventResponder12runFromYieldEv+0x70>
			lastYield = nullptr;
    6d7a:	4b0e      	ldr	r3, [pc, #56]	; (6db4 <_ZN14EventResponder12runFromYieldEv+0xa4>)
    6d7c:	2200      	movs	r2, #0
    6d7e:	601a      	str	r2, [r3, #0]
		enableInterrupts(irq);
    6d80:	7afb      	ldrb	r3, [r7, #11]
    6d82:	4618      	mov	r0, r3
    6d84:	f7fd ff31 	bl	4bea <_ZN14EventResponder16enableInterruptsEb>
		first->_triggered = false;
    6d88:	687b      	ldr	r3, [r7, #4]
    6d8a:	2200      	movs	r2, #0
    6d8c:	775a      	strb	r2, [r3, #29]
		(*(first->_function))(*first);
    6d8e:	687b      	ldr	r3, [r7, #4]
    6d90:	689b      	ldr	r3, [r3, #8]
    6d92:	6878      	ldr	r0, [r7, #4]
    6d94:	4798      	blx	r3
		runningFromYield = false;
    6d96:	4b06      	ldr	r3, [pc, #24]	; (6db0 <_ZN14EventResponder12runFromYieldEv+0xa0>)
    6d98:	2200      	movs	r2, #0
    6d9a:	701a      	strb	r2, [r3, #0]
    6d9c:	e002      	b.n	6da4 <_ZN14EventResponder12runFromYieldEv+0x94>
		if (!firstYield) return;  
    6d9e:	bf00      	nop
    6da0:	e000      	b.n	6da4 <_ZN14EventResponder12runFromYieldEv+0x94>
		if (ipsr != 0) return;
    6da2:	bf00      	nop
	}
    6da4:	3710      	adds	r7, #16
    6da6:	46bd      	mov	sp, r7
    6da8:	bd80      	pop	{r7, pc}
    6daa:	bf00      	nop
    6dac:	1fff12f4 	.word	0x1fff12f4
    6db0:	1fff1304 	.word	0x1fff1304
    6db4:	1fff12f8 	.word	0x1fff12f8

00006db8 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    6db8:	b580      	push	{r7, lr}
    6dba:	af00      	add	r7, sp, #0
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    6dbc:	4b20      	ldr	r3, [pc, #128]	; (6e40 <yield+0x88>)
    6dbe:	781b      	ldrb	r3, [r3, #0]
    6dc0:	2b00      	cmp	r3, #0
    6dc2:	d038      	beq.n	6e36 <yield+0x7e>
	if (running) return; // TODO: does this need to be atomic?
    6dc4:	4b1f      	ldr	r3, [pc, #124]	; (6e44 <yield+0x8c>)
    6dc6:	781b      	ldrb	r3, [r3, #0]
    6dc8:	2b00      	cmp	r3, #0
    6dca:	d136      	bne.n	6e3a <yield+0x82>
	running = 1;
    6dcc:	4b1d      	ldr	r3, [pc, #116]	; (6e44 <yield+0x8c>)
    6dce:	2201      	movs	r2, #1
    6dd0:	701a      	strb	r2, [r3, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    6dd2:	4b1b      	ldr	r3, [pc, #108]	; (6e40 <yield+0x88>)
    6dd4:	781b      	ldrb	r3, [r3, #0]
    6dd6:	f003 0301 	and.w	r3, r3, #1
    6dda:	2b00      	cmp	r3, #0
    6ddc:	d017      	beq.n	6e0e <yield+0x56>
		if (Serial.available()) serialEvent();
    6dde:	481a      	ldr	r0, [pc, #104]	; (6e48 <yield+0x90>)
    6de0:	f7ff f944 	bl	606c <_ZN16usb_serial_class9availableEv>
    6de4:	4603      	mov	r3, r0
    6de6:	2b00      	cmp	r3, #0
    6de8:	bf14      	ite	ne
    6dea:	2301      	movne	r3, #1
    6dec:	2300      	moveq	r3, #0
    6dee:	b2db      	uxtb	r3, r3
    6df0:	2b00      	cmp	r3, #0
    6df2:	d001      	beq.n	6df8 <yield+0x40>
    6df4:	f000 f935 	bl	7062 <_Z11serialEventv>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    6df8:	4b14      	ldr	r3, [pc, #80]	; (6e4c <yield+0x94>)
    6dfa:	781b      	ldrb	r3, [r3, #0]
    6dfc:	2b00      	cmp	r3, #0
    6dfe:	d006      	beq.n	6e0e <yield+0x56>
    6e00:	4b0f      	ldr	r3, [pc, #60]	; (6e40 <yield+0x88>)
    6e02:	781b      	ldrb	r3, [r3, #0]
    6e04:	f023 0301 	bic.w	r3, r3, #1
    6e08:	b2da      	uxtb	r2, r3
    6e0a:	4b0d      	ldr	r3, [pc, #52]	; (6e40 <yield+0x88>)
    6e0c:	701a      	strb	r2, [r3, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    6e0e:	4b0c      	ldr	r3, [pc, #48]	; (6e40 <yield+0x88>)
    6e10:	781b      	ldrb	r3, [r3, #0]
    6e12:	f003 0302 	and.w	r3, r3, #2
    6e16:	2b00      	cmp	r3, #0
    6e18:	d001      	beq.n	6e1e <yield+0x66>
		HardwareSerial::processSerialEventsList();
    6e1a:	f7ff ff41 	bl	6ca0 <_ZN14HardwareSerial23processSerialEventsListEv>
	}
	running = 0;
    6e1e:	4b09      	ldr	r3, [pc, #36]	; (6e44 <yield+0x8c>)
    6e20:	2200      	movs	r2, #0
    6e22:	701a      	strb	r2, [r3, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    6e24:	4b06      	ldr	r3, [pc, #24]	; (6e40 <yield+0x88>)
    6e26:	781b      	ldrb	r3, [r3, #0]
    6e28:	f003 0304 	and.w	r3, r3, #4
    6e2c:	2b00      	cmp	r3, #0
    6e2e:	d005      	beq.n	6e3c <yield+0x84>
    6e30:	f7ff ff6e 	bl	6d10 <_ZN14EventResponder12runFromYieldEv>
    6e34:	e002      	b.n	6e3c <yield+0x84>
	if (!yield_active_check_flags) return;	// nothing to do
    6e36:	bf00      	nop
    6e38:	e000      	b.n	6e3c <yield+0x84>
	if (running) return; // TODO: does this need to be atomic?
    6e3a:	bf00      	nop
	
};
    6e3c:	bd80      	pop	{r7, pc}
    6e3e:	bf00      	nop
    6e40:	1fff07a0 	.word	0x1fff07a0
    6e44:	1fff140e 	.word	0x1fff140e
    6e48:	1fff078c 	.word	0x1fff078c
    6e4c:	1fff07a3 	.word	0x1fff07a3

00006e50 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    6e50:	b480      	push	{r7}
    6e52:	b083      	sub	sp, #12
    6e54:	af00      	add	r7, sp, #0
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    6e56:	4b48      	ldr	r3, [pc, #288]	; (6f78 <analog_init+0x128>)
    6e58:	2260      	movs	r2, #96	; 0x60
    6e5a:	701a      	strb	r2, [r3, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    6e5c:	4b47      	ldr	r3, [pc, #284]	; (6f7c <analog_init+0x12c>)
    6e5e:	22e1      	movs	r2, #225	; 0xe1
    6e60:	701a      	strb	r2, [r3, #0]
	#endif

	if (analog_config_bits == 8) {
    6e62:	4b47      	ldr	r3, [pc, #284]	; (6f80 <analog_init+0x130>)
    6e64:	781b      	ldrb	r3, [r3, #0]
    6e66:	2b08      	cmp	r3, #8
    6e68:	d10c      	bne.n	6e84 <analog_init+0x34>
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    6e6a:	4b46      	ldr	r3, [pc, #280]	; (6f84 <analog_init+0x134>)
    6e6c:	2221      	movs	r2, #33	; 0x21
    6e6e:	601a      	str	r2, [r3, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6e70:	4b45      	ldr	r3, [pc, #276]	; (6f88 <analog_init+0x138>)
    6e72:	2213      	movs	r2, #19
    6e74:	601a      	str	r2, [r3, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    6e76:	4b45      	ldr	r3, [pc, #276]	; (6f8c <analog_init+0x13c>)
    6e78:	2221      	movs	r2, #33	; 0x21
    6e7a:	601a      	str	r2, [r3, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6e7c:	4b44      	ldr	r3, [pc, #272]	; (6f90 <analog_init+0x140>)
    6e7e:	2213      	movs	r2, #19
    6e80:	601a      	str	r2, [r3, #0]
    6e82:	e02d      	b.n	6ee0 <analog_init+0x90>
		#endif
	} else if (analog_config_bits == 10) {
    6e84:	4b3e      	ldr	r3, [pc, #248]	; (6f80 <analog_init+0x130>)
    6e86:	781b      	ldrb	r3, [r3, #0]
    6e88:	2b0a      	cmp	r3, #10
    6e8a:	d10c      	bne.n	6ea6 <analog_init+0x56>
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    6e8c:	4b3d      	ldr	r3, [pc, #244]	; (6f84 <analog_init+0x134>)
    6e8e:	2259      	movs	r2, #89	; 0x59
    6e90:	601a      	str	r2, [r3, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6e92:	4b3d      	ldr	r3, [pc, #244]	; (6f88 <analog_init+0x138>)
    6e94:	2213      	movs	r2, #19
    6e96:	601a      	str	r2, [r3, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    6e98:	4b3c      	ldr	r3, [pc, #240]	; (6f8c <analog_init+0x13c>)
    6e9a:	2259      	movs	r2, #89	; 0x59
    6e9c:	601a      	str	r2, [r3, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    6e9e:	4b3c      	ldr	r3, [pc, #240]	; (6f90 <analog_init+0x140>)
    6ea0:	2213      	movs	r2, #19
    6ea2:	601a      	str	r2, [r3, #0]
    6ea4:	e01c      	b.n	6ee0 <analog_init+0x90>
		#endif
	} else if (analog_config_bits == 12) {
    6ea6:	4b36      	ldr	r3, [pc, #216]	; (6f80 <analog_init+0x130>)
    6ea8:	781b      	ldrb	r3, [r3, #0]
    6eaa:	2b0c      	cmp	r3, #12
    6eac:	d10c      	bne.n	6ec8 <analog_init+0x78>
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    6eae:	4b35      	ldr	r3, [pc, #212]	; (6f84 <analog_init+0x134>)
    6eb0:	2255      	movs	r2, #85	; 0x55
    6eb2:	601a      	str	r2, [r3, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    6eb4:	4b34      	ldr	r3, [pc, #208]	; (6f88 <analog_init+0x138>)
    6eb6:	2212      	movs	r2, #18
    6eb8:	601a      	str	r2, [r3, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    6eba:	4b34      	ldr	r3, [pc, #208]	; (6f8c <analog_init+0x13c>)
    6ebc:	2255      	movs	r2, #85	; 0x55
    6ebe:	601a      	str	r2, [r3, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    6ec0:	4b33      	ldr	r3, [pc, #204]	; (6f90 <analog_init+0x140>)
    6ec2:	2212      	movs	r2, #18
    6ec4:	601a      	str	r2, [r3, #0]
    6ec6:	e00b      	b.n	6ee0 <analog_init+0x90>
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    6ec8:	4b2e      	ldr	r3, [pc, #184]	; (6f84 <analog_init+0x134>)
    6eca:	225d      	movs	r2, #93	; 0x5d
    6ecc:	601a      	str	r2, [r3, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    6ece:	4b2e      	ldr	r3, [pc, #184]	; (6f88 <analog_init+0x138>)
    6ed0:	2212      	movs	r2, #18
    6ed2:	601a      	str	r2, [r3, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    6ed4:	4b2d      	ldr	r3, [pc, #180]	; (6f8c <analog_init+0x13c>)
    6ed6:	225d      	movs	r2, #93	; 0x5d
    6ed8:	601a      	str	r2, [r3, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    6eda:	4b2d      	ldr	r3, [pc, #180]	; (6f90 <analog_init+0x140>)
    6edc:	2212      	movs	r2, #18
    6ede:	601a      	str	r2, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    6ee0:	4b2c      	ldr	r3, [pc, #176]	; (6f94 <analog_init+0x144>)
    6ee2:	781b      	ldrb	r3, [r3, #0]
    6ee4:	2b00      	cmp	r3, #0
    6ee6:	d006      	beq.n	6ef6 <analog_init+0xa6>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    6ee8:	4b2b      	ldr	r3, [pc, #172]	; (6f98 <analog_init+0x148>)
    6eea:	2201      	movs	r2, #1
    6eec:	601a      	str	r2, [r3, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    6eee:	4b2b      	ldr	r3, [pc, #172]	; (6f9c <analog_init+0x14c>)
    6ef0:	2201      	movs	r2, #1
    6ef2:	601a      	str	r2, [r3, #0]
    6ef4:	e005      	b.n	6f02 <analog_init+0xb2>
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    6ef6:	4b28      	ldr	r3, [pc, #160]	; (6f98 <analog_init+0x148>)
    6ef8:	2200      	movs	r2, #0
    6efa:	601a      	str	r2, [r3, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    6efc:	4b27      	ldr	r3, [pc, #156]	; (6f9c <analog_init+0x14c>)
    6efe:	2200      	movs	r2, #0
    6f00:	601a      	str	r2, [r3, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    6f02:	4b27      	ldr	r3, [pc, #156]	; (6fa0 <analog_init+0x150>)
    6f04:	781b      	ldrb	r3, [r3, #0]
    6f06:	607b      	str	r3, [r7, #4]
	if (num <= 1) {
    6f08:	687b      	ldr	r3, [r7, #4]
    6f0a:	2b01      	cmp	r3, #1
    6f0c:	d806      	bhi.n	6f1c <analog_init+0xcc>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    6f0e:	4b25      	ldr	r3, [pc, #148]	; (6fa4 <analog_init+0x154>)
    6f10:	2280      	movs	r2, #128	; 0x80
    6f12:	601a      	str	r2, [r3, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    6f14:	4b24      	ldr	r3, [pc, #144]	; (6fa8 <analog_init+0x158>)
    6f16:	2280      	movs	r2, #128	; 0x80
    6f18:	601a      	str	r2, [r3, #0]
    6f1a:	e023      	b.n	6f64 <analog_init+0x114>
		#endif
	} else if (num <= 4) {
    6f1c:	687b      	ldr	r3, [r7, #4]
    6f1e:	2b04      	cmp	r3, #4
    6f20:	d806      	bhi.n	6f30 <analog_init+0xe0>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    6f22:	4b20      	ldr	r3, [pc, #128]	; (6fa4 <analog_init+0x154>)
    6f24:	2284      	movs	r2, #132	; 0x84
    6f26:	601a      	str	r2, [r3, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    6f28:	4b1f      	ldr	r3, [pc, #124]	; (6fa8 <analog_init+0x158>)
    6f2a:	2284      	movs	r2, #132	; 0x84
    6f2c:	601a      	str	r2, [r3, #0]
    6f2e:	e019      	b.n	6f64 <analog_init+0x114>
		#endif
	} else if (num <= 8) {
    6f30:	687b      	ldr	r3, [r7, #4]
    6f32:	2b08      	cmp	r3, #8
    6f34:	d806      	bhi.n	6f44 <analog_init+0xf4>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    6f36:	4b1b      	ldr	r3, [pc, #108]	; (6fa4 <analog_init+0x154>)
    6f38:	2285      	movs	r2, #133	; 0x85
    6f3a:	601a      	str	r2, [r3, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    6f3c:	4b1a      	ldr	r3, [pc, #104]	; (6fa8 <analog_init+0x158>)
    6f3e:	2285      	movs	r2, #133	; 0x85
    6f40:	601a      	str	r2, [r3, #0]
    6f42:	e00f      	b.n	6f64 <analog_init+0x114>
		#endif
	} else if (num <= 16) {
    6f44:	687b      	ldr	r3, [r7, #4]
    6f46:	2b10      	cmp	r3, #16
    6f48:	d806      	bhi.n	6f58 <analog_init+0x108>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    6f4a:	4b16      	ldr	r3, [pc, #88]	; (6fa4 <analog_init+0x154>)
    6f4c:	2286      	movs	r2, #134	; 0x86
    6f4e:	601a      	str	r2, [r3, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    6f50:	4b15      	ldr	r3, [pc, #84]	; (6fa8 <analog_init+0x158>)
    6f52:	2286      	movs	r2, #134	; 0x86
    6f54:	601a      	str	r2, [r3, #0]
    6f56:	e005      	b.n	6f64 <analog_init+0x114>
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    6f58:	4b12      	ldr	r3, [pc, #72]	; (6fa4 <analog_init+0x154>)
    6f5a:	2287      	movs	r2, #135	; 0x87
    6f5c:	601a      	str	r2, [r3, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    6f5e:	4b12      	ldr	r3, [pc, #72]	; (6fa8 <analog_init+0x158>)
    6f60:	2287      	movs	r2, #135	; 0x87
    6f62:	601a      	str	r2, [r3, #0]
		#endif
	}
	calibrating = 1;
    6f64:	4b11      	ldr	r3, [pc, #68]	; (6fac <analog_init+0x15c>)
    6f66:	2201      	movs	r2, #1
    6f68:	701a      	strb	r2, [r3, #0]
}
    6f6a:	bf00      	nop
    6f6c:	370c      	adds	r7, #12
    6f6e:	46bd      	mov	sp, r7
    6f70:	f85d 7b04 	ldr.w	r7, [sp], #4
    6f74:	4770      	bx	lr
    6f76:	bf00      	nop
    6f78:	40074000 	.word	0x40074000
    6f7c:	40074001 	.word	0x40074001
    6f80:	1fff07a1 	.word	0x1fff07a1
    6f84:	4003b008 	.word	0x4003b008
    6f88:	4003b00c 	.word	0x4003b00c
    6f8c:	400bb008 	.word	0x400bb008
    6f90:	400bb00c 	.word	0x400bb00c
    6f94:	1fff1410 	.word	0x1fff1410
    6f98:	4003b020 	.word	0x4003b020
    6f9c:	400bb020 	.word	0x400bb020
    6fa0:	1fff07a2 	.word	0x1fff07a2
    6fa4:	4003b024 	.word	0x4003b024
    6fa8:	400bb024 	.word	0x400bb024
    6fac:	1fff140f 	.word	0x1fff140f

00006fb0 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    6fb0:	b480      	push	{r7}
    6fb2:	b089      	sub	sp, #36	; 0x24
    6fb4:	af00      	add	r7, sp, #0
    6fb6:	60f8      	str	r0, [r7, #12]
    6fb8:	60b9      	str	r1, [r7, #8]
    6fba:	607a      	str	r2, [r7, #4]
	unsigned digit;
	int i=0, j;
    6fbc:	2300      	movs	r3, #0
    6fbe:	61fb      	str	r3, [r7, #28]
	char t;

	while (1) {
		digit = val % radix;
    6fc0:	687a      	ldr	r2, [r7, #4]
    6fc2:	68fb      	ldr	r3, [r7, #12]
    6fc4:	fbb3 f1f2 	udiv	r1, r3, r2
    6fc8:	fb01 f202 	mul.w	r2, r1, r2
    6fcc:	1a9b      	subs	r3, r3, r2
    6fce:	617b      	str	r3, [r7, #20]
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    6fd0:	697b      	ldr	r3, [r7, #20]
    6fd2:	2b09      	cmp	r3, #9
    6fd4:	d804      	bhi.n	6fe0 <ultoa+0x30>
    6fd6:	697b      	ldr	r3, [r7, #20]
    6fd8:	b2db      	uxtb	r3, r3
    6fda:	3330      	adds	r3, #48	; 0x30
    6fdc:	b2db      	uxtb	r3, r3
    6fde:	e003      	b.n	6fe8 <ultoa+0x38>
    6fe0:	697b      	ldr	r3, [r7, #20]
    6fe2:	b2db      	uxtb	r3, r3
    6fe4:	3337      	adds	r3, #55	; 0x37
    6fe6:	b2db      	uxtb	r3, r3
    6fe8:	69fa      	ldr	r2, [r7, #28]
    6fea:	68b9      	ldr	r1, [r7, #8]
    6fec:	440a      	add	r2, r1
    6fee:	7013      	strb	r3, [r2, #0]
		val /= radix;
    6ff0:	687b      	ldr	r3, [r7, #4]
    6ff2:	68fa      	ldr	r2, [r7, #12]
    6ff4:	fbb2 f3f3 	udiv	r3, r2, r3
    6ff8:	60fb      	str	r3, [r7, #12]
		if (val == 0) break;
    6ffa:	68fb      	ldr	r3, [r7, #12]
    6ffc:	2b00      	cmp	r3, #0
    6ffe:	d003      	beq.n	7008 <ultoa+0x58>
		i++;
    7000:	69fb      	ldr	r3, [r7, #28]
    7002:	3301      	adds	r3, #1
    7004:	61fb      	str	r3, [r7, #28]
		digit = val % radix;
    7006:	e7db      	b.n	6fc0 <ultoa+0x10>
		if (val == 0) break;
    7008:	bf00      	nop
	}
	buf[i + 1] = 0;
    700a:	69fb      	ldr	r3, [r7, #28]
    700c:	3301      	adds	r3, #1
    700e:	68ba      	ldr	r2, [r7, #8]
    7010:	4413      	add	r3, r2
    7012:	2200      	movs	r2, #0
    7014:	701a      	strb	r2, [r3, #0]
	for (j=0; j < i; j++, i--) {
    7016:	2300      	movs	r3, #0
    7018:	61bb      	str	r3, [r7, #24]
    701a:	e017      	b.n	704c <ultoa+0x9c>
		t = buf[j];
    701c:	69bb      	ldr	r3, [r7, #24]
    701e:	68ba      	ldr	r2, [r7, #8]
    7020:	4413      	add	r3, r2
    7022:	781b      	ldrb	r3, [r3, #0]
    7024:	74fb      	strb	r3, [r7, #19]
		buf[j] = buf[i];
    7026:	69fb      	ldr	r3, [r7, #28]
    7028:	68ba      	ldr	r2, [r7, #8]
    702a:	441a      	add	r2, r3
    702c:	69bb      	ldr	r3, [r7, #24]
    702e:	68b9      	ldr	r1, [r7, #8]
    7030:	440b      	add	r3, r1
    7032:	7812      	ldrb	r2, [r2, #0]
    7034:	701a      	strb	r2, [r3, #0]
		buf[i] = t;
    7036:	69fb      	ldr	r3, [r7, #28]
    7038:	68ba      	ldr	r2, [r7, #8]
    703a:	4413      	add	r3, r2
    703c:	7cfa      	ldrb	r2, [r7, #19]
    703e:	701a      	strb	r2, [r3, #0]
	for (j=0; j < i; j++, i--) {
    7040:	69bb      	ldr	r3, [r7, #24]
    7042:	3301      	adds	r3, #1
    7044:	61bb      	str	r3, [r7, #24]
    7046:	69fb      	ldr	r3, [r7, #28]
    7048:	3b01      	subs	r3, #1
    704a:	61fb      	str	r3, [r7, #28]
    704c:	69ba      	ldr	r2, [r7, #24]
    704e:	69fb      	ldr	r3, [r7, #28]
    7050:	429a      	cmp	r2, r3
    7052:	dbe3      	blt.n	701c <ultoa+0x6c>
	}
	return buf;
    7054:	68bb      	ldr	r3, [r7, #8]
}
    7056:	4618      	mov	r0, r3
    7058:	3724      	adds	r7, #36	; 0x24
    705a:	46bd      	mov	sp, r7
    705c:	f85d 7b04 	ldr.w	r7, [sp], #4
    7060:	4770      	bx	lr

00007062 <_Z11serialEventv>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    7062:	b480      	push	{r7}
    7064:	af00      	add	r7, sp, #0
}
    7066:	bf00      	nop
    7068:	46bd      	mov	sp, r7
    706a:	f85d 7b04 	ldr.w	r7, [sp], #4
    706e:	4770      	bx	lr

00007070 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    7070:	b580      	push	{r7, lr}
    7072:	b086      	sub	sp, #24
    7074:	af00      	add	r7, sp, #0
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    7076:	b672      	cpsid	i
	FTFL_FCCOB1 = 15;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
    7078:	f7fd fd5e 	bl	4b38 <kinetis_hsrun_disable>
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    707c:	4b25      	ldr	r3, [pc, #148]	; (7114 <usb_init_serialnumber+0xa4>)
    707e:	2270      	movs	r2, #112	; 0x70
    7080:	701a      	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    7082:	4b25      	ldr	r3, [pc, #148]	; (7118 <usb_init_serialnumber+0xa8>)
    7084:	4a25      	ldr	r2, [pc, #148]	; (711c <usb_init_serialnumber+0xac>)
    7086:	601a      	str	r2, [r3, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    7088:	4b22      	ldr	r3, [pc, #136]	; (7114 <usb_init_serialnumber+0xa4>)
    708a:	2280      	movs	r2, #128	; 0x80
    708c:	701a      	strb	r2, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    708e:	bf00      	nop
    7090:	4b20      	ldr	r3, [pc, #128]	; (7114 <usb_init_serialnumber+0xa4>)
    7092:	781b      	ldrb	r3, [r3, #0]
    7094:	b2db      	uxtb	r3, r3
    7096:	b25b      	sxtb	r3, r3
    7098:	2b00      	cmp	r3, #0
    709a:	daf9      	bge.n	7090 <usb_init_serialnumber+0x20>
	num = *(uint32_t *)&FTFL_FCCOBB;
    709c:	4b20      	ldr	r3, [pc, #128]	; (7120 <usb_init_serialnumber+0xb0>)
    709e:	681b      	ldr	r3, [r3, #0]
    70a0:	613b      	str	r3, [r7, #16]
	kinetis_hsrun_enable();
    70a2:	f7fd fd6d 	bl	4b80 <kinetis_hsrun_enable>
#endif
	__enable_irq();
    70a6:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    70a8:	693b      	ldr	r3, [r7, #16]
    70aa:	4a1e      	ldr	r2, [pc, #120]	; (7124 <usb_init_serialnumber+0xb4>)
    70ac:	4293      	cmp	r3, r2
    70ae:	d205      	bcs.n	70bc <usb_init_serialnumber+0x4c>
    70b0:	693a      	ldr	r2, [r7, #16]
    70b2:	4613      	mov	r3, r2
    70b4:	009b      	lsls	r3, r3, #2
    70b6:	4413      	add	r3, r2
    70b8:	005b      	lsls	r3, r3, #1
    70ba:	613b      	str	r3, [r7, #16]
	ultoa(num, buf, 10);
    70bc:	1d3b      	adds	r3, r7, #4
    70be:	220a      	movs	r2, #10
    70c0:	4619      	mov	r1, r3
    70c2:	6938      	ldr	r0, [r7, #16]
    70c4:	f7ff ff74 	bl	6fb0 <ultoa>
	for (i=0; i<10; i++) {
    70c8:	2300      	movs	r3, #0
    70ca:	617b      	str	r3, [r7, #20]
    70cc:	e012      	b.n	70f4 <usb_init_serialnumber+0x84>
		char c = buf[i];
    70ce:	1d3a      	adds	r2, r7, #4
    70d0:	697b      	ldr	r3, [r7, #20]
    70d2:	4413      	add	r3, r2
    70d4:	781b      	ldrb	r3, [r3, #0]
    70d6:	73fb      	strb	r3, [r7, #15]
		if (!c) break;
    70d8:	7bfb      	ldrb	r3, [r7, #15]
    70da:	2b00      	cmp	r3, #0
    70dc:	d00e      	beq.n	70fc <usb_init_serialnumber+0x8c>
		usb_string_serial_number_default.wString[i] = c;
    70de:	7bfb      	ldrb	r3, [r7, #15]
    70e0:	b299      	uxth	r1, r3
    70e2:	4a11      	ldr	r2, [pc, #68]	; (7128 <usb_init_serialnumber+0xb8>)
    70e4:	697b      	ldr	r3, [r7, #20]
    70e6:	005b      	lsls	r3, r3, #1
    70e8:	4413      	add	r3, r2
    70ea:	460a      	mov	r2, r1
    70ec:	805a      	strh	r2, [r3, #2]
	for (i=0; i<10; i++) {
    70ee:	697b      	ldr	r3, [r7, #20]
    70f0:	3301      	adds	r3, #1
    70f2:	617b      	str	r3, [r7, #20]
    70f4:	697b      	ldr	r3, [r7, #20]
    70f6:	2b09      	cmp	r3, #9
    70f8:	d9e9      	bls.n	70ce <usb_init_serialnumber+0x5e>
    70fa:	e000      	b.n	70fe <usb_init_serialnumber+0x8e>
		if (!c) break;
    70fc:	bf00      	nop
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    70fe:	697b      	ldr	r3, [r7, #20]
    7100:	3301      	adds	r3, #1
    7102:	b2db      	uxtb	r3, r3
    7104:	005b      	lsls	r3, r3, #1
    7106:	b2da      	uxtb	r2, r3
    7108:	4b07      	ldr	r3, [pc, #28]	; (7128 <usb_init_serialnumber+0xb8>)
    710a:	701a      	strb	r2, [r3, #0]
}
    710c:	bf00      	nop
    710e:	3718      	adds	r7, #24
    7110:	46bd      	mov	sp, r7
    7112:	bd80      	pop	{r7, pc}
    7114:	40020000 	.word	0x40020000
    7118:	40020004 	.word	0x40020004
    711c:	41070000 	.word	0x41070000
    7120:	4002000c 	.word	0x4002000c
    7124:	00989680 	.word	0x00989680
    7128:	1fff0830 	.word	0x1fff0830

0000712c <GPIO_PinWrite>:
{
    712c:	b480      	push	{r7}
    712e:	b087      	sub	sp, #28
    7130:	af00      	add	r7, sp, #0
    7132:	60f8      	str	r0, [r7, #12]
    7134:	60b9      	str	r1, [r7, #8]
    7136:	4613      	mov	r3, r2
    7138:	71fb      	strb	r3, [r7, #7]
    uint32_t u32flag = 1;
    713a:	2301      	movs	r3, #1
    713c:	617b      	str	r3, [r7, #20]
    if (output == 0U)
    713e:	79fb      	ldrb	r3, [r7, #7]
    7140:	2b00      	cmp	r3, #0
    7142:	d105      	bne.n	7150 <GPIO_PinWrite+0x24>
        base->PCOR = GPIO_FIT_REG(u32flag << pin);
    7144:	697a      	ldr	r2, [r7, #20]
    7146:	68bb      	ldr	r3, [r7, #8]
    7148:	409a      	lsls	r2, r3
    714a:	68fb      	ldr	r3, [r7, #12]
    714c:	609a      	str	r2, [r3, #8]
}
    714e:	e004      	b.n	715a <GPIO_PinWrite+0x2e>
        base->PSOR = GPIO_FIT_REG(u32flag << pin);
    7150:	697a      	ldr	r2, [r7, #20]
    7152:	68bb      	ldr	r3, [r7, #8]
    7154:	409a      	lsls	r2, r3
    7156:	68fb      	ldr	r3, [r7, #12]
    7158:	605a      	str	r2, [r3, #4]
}
    715a:	bf00      	nop
    715c:	371c      	adds	r7, #28
    715e:	46bd      	mov	sp, r7
    7160:	f85d 7b04 	ldr.w	r7, [sp], #4
    7164:	4770      	bx	lr
    7166:	Address 0x00007166 is out of bounds.


00007168 <GPIO_PinInit>:
 * param base   GPIO peripheral base pointer (GPIOA, GPIOB, GPIOC, and so on.)
 * param pin    GPIO port pin number
 * param config GPIO pin configuration pointer
 */
void GPIO_PinInit(GPIO_Type *base, uint32_t pin, const gpio_pin_config_t *config)
{
    7168:	b580      	push	{r7, lr}
    716a:	b086      	sub	sp, #24
    716c:	af00      	add	r7, sp, #0
    716e:	60f8      	str	r0, [r7, #12]
    7170:	60b9      	str	r1, [r7, #8]
    7172:	607a      	str	r2, [r7, #4]
    assert(NULL != config);
    7174:	687b      	ldr	r3, [r7, #4]
    7176:	2b00      	cmp	r3, #0
    7178:	d105      	bne.n	7186 <GPIO_PinInit+0x1e>
    717a:	4b15      	ldr	r3, [pc, #84]	; (71d0 <GPIO_PinInit+0x68>)
    717c:	4a15      	ldr	r2, [pc, #84]	; (71d4 <GPIO_PinInit+0x6c>)
    717e:	2164      	movs	r1, #100	; 0x64
    7180:	4815      	ldr	r0, [pc, #84]	; (71d8 <GPIO_PinInit+0x70>)
    7182:	f000 f82b 	bl	71dc <__assert_func>

    uint32_t u32flag = 1;
    7186:	2301      	movs	r3, #1
    7188:	617b      	str	r3, [r7, #20]

    if (config->pinDirection == kGPIO_DigitalInput)
    718a:	687b      	ldr	r3, [r7, #4]
    718c:	781b      	ldrb	r3, [r3, #0]
    718e:	2b00      	cmp	r3, #0
    7190:	d10a      	bne.n	71a8 <GPIO_PinInit+0x40>
    {
        base->PDDR &= GPIO_FIT_REG(~(u32flag << pin));
    7192:	68fb      	ldr	r3, [r7, #12]
    7194:	695a      	ldr	r2, [r3, #20]
    7196:	6979      	ldr	r1, [r7, #20]
    7198:	68bb      	ldr	r3, [r7, #8]
    719a:	fa01 f303 	lsl.w	r3, r1, r3
    719e:	43db      	mvns	r3, r3
    71a0:	401a      	ands	r2, r3
    71a2:	68fb      	ldr	r3, [r7, #12]
    71a4:	615a      	str	r2, [r3, #20]
    else
    {
        GPIO_PinWrite(base, pin, config->outputLogic);
        base->PDDR |= GPIO_FIT_REG((u32flag << pin));
    }
}
    71a6:	e00f      	b.n	71c8 <GPIO_PinInit+0x60>
        GPIO_PinWrite(base, pin, config->outputLogic);
    71a8:	687b      	ldr	r3, [r7, #4]
    71aa:	785b      	ldrb	r3, [r3, #1]
    71ac:	461a      	mov	r2, r3
    71ae:	68b9      	ldr	r1, [r7, #8]
    71b0:	68f8      	ldr	r0, [r7, #12]
    71b2:	f7ff ffbb 	bl	712c <GPIO_PinWrite>
        base->PDDR |= GPIO_FIT_REG((u32flag << pin));
    71b6:	68fb      	ldr	r3, [r7, #12]
    71b8:	695a      	ldr	r2, [r3, #20]
    71ba:	6979      	ldr	r1, [r7, #20]
    71bc:	68bb      	ldr	r3, [r7, #8]
    71be:	fa01 f303 	lsl.w	r3, r1, r3
    71c2:	431a      	orrs	r2, r3
    71c4:	68fb      	ldr	r3, [r7, #12]
    71c6:	615a      	str	r2, [r3, #20]
}
    71c8:	bf00      	nop
    71ca:	3718      	adds	r7, #24
    71cc:	46bd      	mov	sp, r7
    71ce:	bd80      	pop	{r7, pc}
    71d0:	0000f640 	.word	0x0000f640
    71d4:	0000f650 	.word	0x0000f650
    71d8:	0000f5e8 	.word	0x0000f5e8

000071dc <__assert_func>:
    __builtin_unreachable();
}

__attribute__((weak, noreturn)) 
void __assert_func(const char *file, int line, const char *func, const char *failedExpr)
{
    71dc:	b480      	push	{r7}
    71de:	b085      	sub	sp, #20
    71e0:	af00      	add	r7, sp, #0
    71e2:	60f8      	str	r0, [r7, #12]
    71e4:	60b9      	str	r1, [r7, #8]
    71e6:	607a      	str	r2, [r7, #4]
    71e8:	603b      	str	r3, [r7, #0]
    for (;;)
    {
        __BKPT(0);
    71ea:	be00      	bkpt	0x0000
    71ec:	e7fd      	b.n	71ea <__assert_func+0xe>

000071ee <CLOCK_EnableClock>:
{
    71ee:	b480      	push	{r7}
    71f0:	b085      	sub	sp, #20
    71f2:	af00      	add	r7, sp, #0
    71f4:	6078      	str	r0, [r7, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    71f6:	687b      	ldr	r3, [r7, #4]
    71f8:	0c1b      	lsrs	r3, r3, #16
    71fa:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    71fe:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    7202:	60fb      	str	r3, [r7, #12]
    (*(volatile uint32_t *)regAddr) |= (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
    7204:	68fb      	ldr	r3, [r7, #12]
    7206:	6819      	ldr	r1, [r3, #0]
    7208:	687b      	ldr	r3, [r7, #4]
    720a:	b29b      	uxth	r3, r3
    720c:	2201      	movs	r2, #1
    720e:	409a      	lsls	r2, r3
    7210:	68fb      	ldr	r3, [r7, #12]
    7212:	430a      	orrs	r2, r1
    7214:	601a      	str	r2, [r3, #0]
}
    7216:	bf00      	nop
    7218:	3714      	adds	r7, #20
    721a:	46bd      	mov	sp, r7
    721c:	f85d 7b04 	ldr.w	r7, [sp], #4
    7220:	4770      	bx	lr

00007222 <CLOCK_DisableClock>:
{
    7222:	b480      	push	{r7}
    7224:	b085      	sub	sp, #20
    7226:	af00      	add	r7, sp, #0
    7228:	6078      	str	r0, [r7, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    722a:	687b      	ldr	r3, [r7, #4]
    722c:	0c1b      	lsrs	r3, r3, #16
    722e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    7232:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    7236:	60fb      	str	r3, [r7, #12]
    (*(volatile uint32_t *)regAddr) &= ~(1UL << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
    7238:	68fb      	ldr	r3, [r7, #12]
    723a:	6819      	ldr	r1, [r3, #0]
    723c:	687b      	ldr	r3, [r7, #4]
    723e:	b29b      	uxth	r3, r3
    7240:	2201      	movs	r2, #1
    7242:	fa02 f303 	lsl.w	r3, r2, r3
    7246:	43da      	mvns	r2, r3
    7248:	68fb      	ldr	r3, [r7, #12]
    724a:	400a      	ands	r2, r1
    724c:	601a      	str	r2, [r3, #0]
}
    724e:	bf00      	nop
    7250:	3714      	adds	r7, #20
    7252:	46bd      	mov	sp, r7
    7254:	f85d 7b04 	ldr.w	r7, [sp], #4
    7258:	4770      	bx	lr
    725a:	Address 0x0000725a is out of bounds.


0000725c <CLOCK_SetEr32kClock>:
{
    725c:	b480      	push	{r7}
    725e:	b083      	sub	sp, #12
    7260:	af00      	add	r7, sp, #0
    7262:	6078      	str	r0, [r7, #4]
    SIM->SOPT1 = ((SIM->SOPT1 & ~SIM_SOPT1_OSC32KSEL_MASK) | SIM_SOPT1_OSC32KSEL(src));
    7264:	4b08      	ldr	r3, [pc, #32]	; (7288 <CLOCK_SetEr32kClock+0x2c>)
    7266:	681b      	ldr	r3, [r3, #0]
    7268:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
    726c:	687b      	ldr	r3, [r7, #4]
    726e:	049b      	lsls	r3, r3, #18
    7270:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
    7274:	4904      	ldr	r1, [pc, #16]	; (7288 <CLOCK_SetEr32kClock+0x2c>)
    7276:	4313      	orrs	r3, r2
    7278:	600b      	str	r3, [r1, #0]
}
    727a:	bf00      	nop
    727c:	370c      	adds	r7, #12
    727e:	46bd      	mov	sp, r7
    7280:	f85d 7b04 	ldr.w	r7, [sp], #4
    7284:	4770      	bx	lr
    7286:	bf00      	nop
    7288:	40047000 	.word	0x40047000

0000728c <CLOCK_SetPllFllSelClock>:
{
    728c:	b480      	push	{r7}
    728e:	b085      	sub	sp, #20
    7290:	af00      	add	r7, sp, #0
    7292:	60f8      	str	r0, [r7, #12]
    7294:	60b9      	str	r1, [r7, #8]
    7296:	607a      	str	r2, [r7, #4]
    SIM->SOPT2   = ((SIM->SOPT2 & ~SIM_SOPT2_PLLFLLSEL_MASK) | SIM_SOPT2_PLLFLLSEL(src));
    7298:	4b10      	ldr	r3, [pc, #64]	; (72dc <CLOCK_SetPllFllSelClock+0x50>)
    729a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    729e:	685b      	ldr	r3, [r3, #4]
    72a0:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
    72a4:	68fb      	ldr	r3, [r7, #12]
    72a6:	041b      	lsls	r3, r3, #16
    72a8:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
    72ac:	490b      	ldr	r1, [pc, #44]	; (72dc <CLOCK_SetPllFllSelClock+0x50>)
    72ae:	4313      	orrs	r3, r2
    72b0:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    72b4:	6053      	str	r3, [r2, #4]
    SIM->CLKDIV3 = SIM_CLKDIV3_PLLFLLDIV(divValue) | SIM_CLKDIV3_PLLFLLFRAC(fracValue);
    72b6:	68bb      	ldr	r3, [r7, #8]
    72b8:	005b      	lsls	r3, r3, #1
    72ba:	f003 020e 	and.w	r2, r3, #14
    72be:	687b      	ldr	r3, [r7, #4]
    72c0:	f003 0301 	and.w	r3, r3, #1
    72c4:	4905      	ldr	r1, [pc, #20]	; (72dc <CLOCK_SetPllFllSelClock+0x50>)
    72c6:	4313      	orrs	r3, r2
    72c8:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    72cc:	6653      	str	r3, [r2, #100]	; 0x64
}
    72ce:	bf00      	nop
    72d0:	3714      	adds	r7, #20
    72d2:	46bd      	mov	sp, r7
    72d4:	f85d 7b04 	ldr.w	r7, [sp], #4
    72d8:	4770      	bx	lr
    72da:	bf00      	nop
    72dc:	40047000 	.word	0x40047000

000072e0 <OSC_SetExtRefClkConfig>:
{
    72e0:	b480      	push	{r7}
    72e2:	b085      	sub	sp, #20
    72e4:	af00      	add	r7, sp, #0
    72e6:	6078      	str	r0, [r7, #4]
    72e8:	6039      	str	r1, [r7, #0]
    uint8_t reg = base->CR;
    72ea:	687b      	ldr	r3, [r7, #4]
    72ec:	781b      	ldrb	r3, [r3, #0]
    72ee:	73fb      	strb	r3, [r7, #15]
    reg &= (uint8_t)(~(OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK));
    72f0:	7bfb      	ldrb	r3, [r7, #15]
    72f2:	f003 035f 	and.w	r3, r3, #95	; 0x5f
    72f6:	73fb      	strb	r3, [r7, #15]
    reg |= config->enableMode;
    72f8:	683b      	ldr	r3, [r7, #0]
    72fa:	781a      	ldrb	r2, [r3, #0]
    72fc:	7bfb      	ldrb	r3, [r7, #15]
    72fe:	4313      	orrs	r3, r2
    7300:	73fb      	strb	r3, [r7, #15]
    base->CR = reg;
    7302:	687b      	ldr	r3, [r7, #4]
    7304:	7bfa      	ldrb	r2, [r7, #15]
    7306:	701a      	strb	r2, [r3, #0]
    base->DIV = OSC_DIV_ERPS(config->erclkDiv);
    7308:	683b      	ldr	r3, [r7, #0]
    730a:	785b      	ldrb	r3, [r3, #1]
    730c:	019b      	lsls	r3, r3, #6
    730e:	b2da      	uxtb	r2, r3
    7310:	687b      	ldr	r3, [r7, #4]
    7312:	709a      	strb	r2, [r3, #2]
}
    7314:	bf00      	nop
    7316:	3714      	adds	r7, #20
    7318:	46bd      	mov	sp, r7
    731a:	f85d 7b04 	ldr.w	r7, [sp], #4
    731e:	4770      	bx	lr

00007320 <OSC_SetCapLoad>:
{
    7320:	b480      	push	{r7}
    7322:	b085      	sub	sp, #20
    7324:	af00      	add	r7, sp, #0
    7326:	6078      	str	r0, [r7, #4]
    7328:	460b      	mov	r3, r1
    732a:	70fb      	strb	r3, [r7, #3]
    uint8_t reg = base->CR;
    732c:	687b      	ldr	r3, [r7, #4]
    732e:	781b      	ldrb	r3, [r3, #0]
    7330:	73fb      	strb	r3, [r7, #15]
    reg &= (uint8_t)(~(OSC_CR_SC2P_MASK | OSC_CR_SC4P_MASK | OSC_CR_SC8P_MASK | OSC_CR_SC16P_MASK));
    7332:	7bfb      	ldrb	r3, [r7, #15]
    7334:	f023 030f 	bic.w	r3, r3, #15
    7338:	73fb      	strb	r3, [r7, #15]
    reg |= capLoad;
    733a:	7bfa      	ldrb	r2, [r7, #15]
    733c:	78fb      	ldrb	r3, [r7, #3]
    733e:	4313      	orrs	r3, r2
    7340:	73fb      	strb	r3, [r7, #15]
    base->CR = reg;
    7342:	687b      	ldr	r3, [r7, #4]
    7344:	7bfa      	ldrb	r2, [r7, #15]
    7346:	701a      	strb	r2, [r3, #0]
}
    7348:	bf00      	nop
    734a:	3714      	adds	r7, #20
    734c:	46bd      	mov	sp, r7
    734e:	f85d 7b04 	ldr.w	r7, [sp], #4
    7352:	4770      	bx	lr

00007354 <CLOCK_FllStableDelay>:
 * Code
 ******************************************************************************/

#ifndef MCG_USER_CONFIG_FLL_STABLE_DELAY_EN
static void CLOCK_FllStableDelay(void)
{
    7354:	b480      	push	{r7}
    7356:	b083      	sub	sp, #12
    7358:	af00      	add	r7, sp, #0
    /*
       Should wait at least 1ms. Because in these modes, the core clock is 100MHz
       at most, so this function could obtain the 1ms delay.
     */
    volatile uint32_t i = 30000U;
    735a:	f247 5330 	movw	r3, #30000	; 0x7530
    735e:	607b      	str	r3, [r7, #4]
    while (0U != (i--))
    7360:	e000      	b.n	7364 <CLOCK_FllStableDelay+0x10>
    {
        __NOP();
    7362:	bf00      	nop
    while (0U != (i--))
    7364:	687b      	ldr	r3, [r7, #4]
    7366:	1e5a      	subs	r2, r3, #1
    7368:	607a      	str	r2, [r7, #4]
    736a:	2b00      	cmp	r3, #0
    736c:	d1f9      	bne.n	7362 <CLOCK_FllStableDelay+0xe>
    }
}
    736e:	bf00      	nop
    7370:	bf00      	nop
    7372:	370c      	adds	r7, #12
    7374:	46bd      	mov	sp, r7
    7376:	f85d 7b04 	ldr.w	r7, [sp], #4
    737a:	4770      	bx	lr

0000737c <CLOCK_GetMcgExtClkFreq>:
 */
extern void CLOCK_FllStableDelay(void);
#endif /* MCG_USER_CONFIG_FLL_STABLE_DELAY_EN */

static uint32_t CLOCK_GetMcgExtClkFreq(void)
{
    737c:	b580      	push	{r7, lr}
    737e:	b082      	sub	sp, #8
    7380:	af00      	add	r7, sp, #0
    uint32_t freq;

    switch (MCG_C7_OSCSEL_VAL)
    7382:	4b1a      	ldr	r3, [pc, #104]	; (73ec <CLOCK_GetMcgExtClkFreq+0x70>)
    7384:	7b1b      	ldrb	r3, [r3, #12]
    7386:	b2db      	uxtb	r3, r3
    7388:	f003 0303 	and.w	r3, r3, #3
    738c:	2b02      	cmp	r3, #2
    738e:	d022      	beq.n	73d6 <CLOCK_GetMcgExtClkFreq+0x5a>
    7390:	2b02      	cmp	r3, #2
    7392:	d823      	bhi.n	73dc <CLOCK_GetMcgExtClkFreq+0x60>
    7394:	2b00      	cmp	r3, #0
    7396:	d002      	beq.n	739e <CLOCK_GetMcgExtClkFreq+0x22>
    7398:	2b01      	cmp	r3, #1
    739a:	d00e      	beq.n	73ba <CLOCK_GetMcgExtClkFreq+0x3e>
    739c:	e01e      	b.n	73dc <CLOCK_GetMcgExtClkFreq+0x60>
    {
        case 0U:
            /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
            assert(0U != g_xtal0Freq);
    739e:	4b14      	ldr	r3, [pc, #80]	; (73f0 <CLOCK_GetMcgExtClkFreq+0x74>)
    73a0:	681b      	ldr	r3, [r3, #0]
    73a2:	2b00      	cmp	r3, #0
    73a4:	d105      	bne.n	73b2 <CLOCK_GetMcgExtClkFreq+0x36>
    73a6:	4b13      	ldr	r3, [pc, #76]	; (73f4 <CLOCK_GetMcgExtClkFreq+0x78>)
    73a8:	4a13      	ldr	r2, [pc, #76]	; (73f8 <CLOCK_GetMcgExtClkFreq+0x7c>)
    73aa:	21de      	movs	r1, #222	; 0xde
    73ac:	4813      	ldr	r0, [pc, #76]	; (73fc <CLOCK_GetMcgExtClkFreq+0x80>)
    73ae:	f7ff ff15 	bl	71dc <__assert_func>
            freq = g_xtal0Freq;
    73b2:	4b0f      	ldr	r3, [pc, #60]	; (73f0 <CLOCK_GetMcgExtClkFreq+0x74>)
    73b4:	681b      	ldr	r3, [r3, #0]
    73b6:	607b      	str	r3, [r7, #4]
            break;
    73b8:	e013      	b.n	73e2 <CLOCK_GetMcgExtClkFreq+0x66>
        case 1U:
            /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN clock. */
            assert(0U != g_xtal32Freq);
    73ba:	4b11      	ldr	r3, [pc, #68]	; (7400 <CLOCK_GetMcgExtClkFreq+0x84>)
    73bc:	681b      	ldr	r3, [r3, #0]
    73be:	2b00      	cmp	r3, #0
    73c0:	d105      	bne.n	73ce <CLOCK_GetMcgExtClkFreq+0x52>
    73c2:	4b10      	ldr	r3, [pc, #64]	; (7404 <CLOCK_GetMcgExtClkFreq+0x88>)
    73c4:	4a0c      	ldr	r2, [pc, #48]	; (73f8 <CLOCK_GetMcgExtClkFreq+0x7c>)
    73c6:	21e3      	movs	r1, #227	; 0xe3
    73c8:	480c      	ldr	r0, [pc, #48]	; (73fc <CLOCK_GetMcgExtClkFreq+0x80>)
    73ca:	f7ff ff07 	bl	71dc <__assert_func>
            freq = g_xtal32Freq;
    73ce:	4b0c      	ldr	r3, [pc, #48]	; (7400 <CLOCK_GetMcgExtClkFreq+0x84>)
    73d0:	681b      	ldr	r3, [r3, #0]
    73d2:	607b      	str	r3, [r7, #4]
            break;
    73d4:	e005      	b.n	73e2 <CLOCK_GetMcgExtClkFreq+0x66>
        case 2U:
            freq = MCG_INTERNAL_IRC_48M;
    73d6:	4b0c      	ldr	r3, [pc, #48]	; (7408 <CLOCK_GetMcgExtClkFreq+0x8c>)
    73d8:	607b      	str	r3, [r7, #4]
            break;
    73da:	e002      	b.n	73e2 <CLOCK_GetMcgExtClkFreq+0x66>
        default:
            freq = 0U;
    73dc:	2300      	movs	r3, #0
    73de:	607b      	str	r3, [r7, #4]
            break;
    73e0:	bf00      	nop
    }

    return freq;
    73e2:	687b      	ldr	r3, [r7, #4]
}
    73e4:	4618      	mov	r0, r3
    73e6:	3708      	adds	r7, #8
    73e8:	46bd      	mov	sp, r7
    73ea:	bd80      	pop	{r7, pc}
    73ec:	40064000 	.word	0x40064000
    73f0:	1fff1434 	.word	0x1fff1434
    73f4:	0000f660 	.word	0x0000f660
    73f8:	0000f7fc 	.word	0x0000f7fc
    73fc:	0000f674 	.word	0x0000f674
    7400:	1fff1438 	.word	0x1fff1438
    7404:	0000f6d0 	.word	0x0000f6d0
    7408:	02dc6c00 	.word	0x02dc6c00

0000740c <CLOCK_GetFllExtRefClkFreq>:

static uint32_t CLOCK_GetFllExtRefClkFreq(void)
{
    740c:	b580      	push	{r7, lr}
    740e:	b082      	sub	sp, #8
    7410:	af00      	add	r7, sp, #0
    /* FllExtRef = McgExtRef / FllExtRefDiv */
    uint8_t frdiv;
    uint8_t range;
    uint8_t oscsel;

    uint32_t freq = CLOCK_GetMcgExtClkFreq();
    7412:	f7ff ffb3 	bl	737c <CLOCK_GetMcgExtClkFreq>
    7416:	6078      	str	r0, [r7, #4]

    frdiv = MCG_C1_FRDIV_VAL;
    7418:	4b25      	ldr	r3, [pc, #148]	; (74b0 <CLOCK_GetFllExtRefClkFreq+0xa4>)
    741a:	781b      	ldrb	r3, [r3, #0]
    741c:	b2db      	uxtb	r3, r3
    741e:	08db      	lsrs	r3, r3, #3
    7420:	b2db      	uxtb	r3, r3
    7422:	f003 0307 	and.w	r3, r3, #7
    7426:	70fb      	strb	r3, [r7, #3]
    freq >>= frdiv;
    7428:	78fb      	ldrb	r3, [r7, #3]
    742a:	687a      	ldr	r2, [r7, #4]
    742c:	fa22 f303 	lsr.w	r3, r2, r3
    7430:	607b      	str	r3, [r7, #4]

    range  = MCG_C2_RANGE_VAL;
    7432:	4b1f      	ldr	r3, [pc, #124]	; (74b0 <CLOCK_GetFllExtRefClkFreq+0xa4>)
    7434:	785b      	ldrb	r3, [r3, #1]
    7436:	b2db      	uxtb	r3, r3
    7438:	091b      	lsrs	r3, r3, #4
    743a:	b2db      	uxtb	r3, r3
    743c:	f003 0303 	and.w	r3, r3, #3
    7440:	70bb      	strb	r3, [r7, #2]
    oscsel = MCG_C7_OSCSEL_VAL;
    7442:	4b1b      	ldr	r3, [pc, #108]	; (74b0 <CLOCK_GetFllExtRefClkFreq+0xa4>)
    7444:	7b1b      	ldrb	r3, [r3, #12]
    7446:	b2db      	uxtb	r3, r3
    7448:	f003 0303 	and.w	r3, r3, #3
    744c:	707b      	strb	r3, [r7, #1]
    /*
       When should use divider 32, 64, 128, 256, 512, 1024, 1280, 1536.
       1. MCG_C7[OSCSEL] selects IRC48M.
       2. MCG_C7[OSCSEL] selects OSC0 and MCG_C2[RANGE] is not 0.
    */
    if (((0U != range) && ((uint8_t)kMCG_OscselOsc == oscsel)) || ((uint8_t)kMCG_OscselIrc == oscsel))
    744e:	78bb      	ldrb	r3, [r7, #2]
    7450:	2b00      	cmp	r3, #0
    7452:	d002      	beq.n	745a <CLOCK_GetFllExtRefClkFreq+0x4e>
    7454:	787b      	ldrb	r3, [r7, #1]
    7456:	2b00      	cmp	r3, #0
    7458:	d002      	beq.n	7460 <CLOCK_GetFllExtRefClkFreq+0x54>
    745a:	787b      	ldrb	r3, [r7, #1]
    745c:	2b02      	cmp	r3, #2
    745e:	d121      	bne.n	74a4 <CLOCK_GetFllExtRefClkFreq+0x98>
    {
        switch (frdiv)
    7460:	78fb      	ldrb	r3, [r7, #3]
    7462:	2b07      	cmp	r3, #7
    7464:	d014      	beq.n	7490 <CLOCK_GetFllExtRefClkFreq+0x84>
    7466:	2b07      	cmp	r3, #7
    7468:	dc19      	bgt.n	749e <CLOCK_GetFllExtRefClkFreq+0x92>
    746a:	2b05      	cmp	r3, #5
    746c:	dc02      	bgt.n	7474 <CLOCK_GetFllExtRefClkFreq+0x68>
    746e:	2b00      	cmp	r3, #0
    7470:	da03      	bge.n	747a <CLOCK_GetFllExtRefClkFreq+0x6e>
    7472:	e014      	b.n	749e <CLOCK_GetFllExtRefClkFreq+0x92>
    7474:	2b06      	cmp	r3, #6
    7476:	d004      	beq.n	7482 <CLOCK_GetFllExtRefClkFreq+0x76>
    7478:	e011      	b.n	749e <CLOCK_GetFllExtRefClkFreq+0x92>
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                freq >>= 5u;
    747a:	687b      	ldr	r3, [r7, #4]
    747c:	095b      	lsrs	r3, r3, #5
    747e:	607b      	str	r3, [r7, #4]
                break;
    7480:	e010      	b.n	74a4 <CLOCK_GetFllExtRefClkFreq+0x98>
            case 6:
                /* 64*20=1280 */
                freq /= 20u;
    7482:	687b      	ldr	r3, [r7, #4]
    7484:	4a0b      	ldr	r2, [pc, #44]	; (74b4 <CLOCK_GetFllExtRefClkFreq+0xa8>)
    7486:	fba2 2303 	umull	r2, r3, r2, r3
    748a:	091b      	lsrs	r3, r3, #4
    748c:	607b      	str	r3, [r7, #4]
                break;
    748e:	e009      	b.n	74a4 <CLOCK_GetFllExtRefClkFreq+0x98>
            case 7:
                /* 128*12=1536 */
                freq /= 12u;
    7490:	687b      	ldr	r3, [r7, #4]
    7492:	4a09      	ldr	r2, [pc, #36]	; (74b8 <CLOCK_GetFllExtRefClkFreq+0xac>)
    7494:	fba2 2303 	umull	r2, r3, r2, r3
    7498:	08db      	lsrs	r3, r3, #3
    749a:	607b      	str	r3, [r7, #4]
                break;
    749c:	e002      	b.n	74a4 <CLOCK_GetFllExtRefClkFreq+0x98>
            default:
                freq = 0u;
    749e:	2300      	movs	r3, #0
    74a0:	607b      	str	r3, [r7, #4]
                break;
    74a2:	bf00      	nop
        }
    }

    return freq;
    74a4:	687b      	ldr	r3, [r7, #4]
}
    74a6:	4618      	mov	r0, r3
    74a8:	3708      	adds	r7, #8
    74aa:	46bd      	mov	sp, r7
    74ac:	bd80      	pop	{r7, pc}
    74ae:	bf00      	nop
    74b0:	40064000 	.word	0x40064000
    74b4:	cccccccd 	.word	0xcccccccd
    74b8:	aaaaaaab 	.word	0xaaaaaaab

000074bc <CLOCK_GetInternalRefClkSelectFreq>:

static uint32_t CLOCK_GetInternalRefClkSelectFreq(void)
{
    74bc:	b480      	push	{r7}
    74be:	b083      	sub	sp, #12
    74c0:	af00      	add	r7, sp, #0
    uint32_t freq;

    if ((uint8_t)kMCG_IrcSlow == MCG_S_IRCST_VAL)
    74c2:	4b0e      	ldr	r3, [pc, #56]	; (74fc <CLOCK_GetInternalRefClkSelectFreq+0x40>)
    74c4:	799b      	ldrb	r3, [r3, #6]
    74c6:	b2db      	uxtb	r3, r3
    74c8:	f003 0301 	and.w	r3, r3, #1
    74cc:	2b00      	cmp	r3, #0
    74ce:	d103      	bne.n	74d8 <CLOCK_GetInternalRefClkSelectFreq+0x1c>
    {
        /* Slow internal reference clock selected*/
        freq = s_slowIrcFreq;
    74d0:	4b0b      	ldr	r3, [pc, #44]	; (7500 <CLOCK_GetInternalRefClkSelectFreq+0x44>)
    74d2:	681b      	ldr	r3, [r3, #0]
    74d4:	607b      	str	r3, [r7, #4]
    74d6:	e00a      	b.n	74ee <CLOCK_GetInternalRefClkSelectFreq+0x32>
    }
    else
    {
        /* Fast internal reference clock selected*/
        freq = s_fastIrcFreq >> MCG_SC_FCRDIV_VAL;
    74d8:	4b0a      	ldr	r3, [pc, #40]	; (7504 <CLOCK_GetInternalRefClkSelectFreq+0x48>)
    74da:	681a      	ldr	r2, [r3, #0]
    74dc:	4b07      	ldr	r3, [pc, #28]	; (74fc <CLOCK_GetInternalRefClkSelectFreq+0x40>)
    74de:	7a1b      	ldrb	r3, [r3, #8]
    74e0:	b2db      	uxtb	r3, r3
    74e2:	085b      	lsrs	r3, r3, #1
    74e4:	f003 0307 	and.w	r3, r3, #7
    74e8:	fa22 f303 	lsr.w	r3, r2, r3
    74ec:	607b      	str	r3, [r7, #4]
    }

    return freq;
    74ee:	687b      	ldr	r3, [r7, #4]
}
    74f0:	4618      	mov	r0, r3
    74f2:	370c      	adds	r7, #12
    74f4:	46bd      	mov	sp, r7
    74f6:	f85d 7b04 	ldr.w	r7, [sp], #4
    74fa:	4770      	bx	lr
    74fc:	40064000 	.word	0x40064000
    7500:	1fff0848 	.word	0x1fff0848
    7504:	1fff084c 	.word	0x1fff084c

00007508 <CLOCK_GetFllRefClkFreq>:

static uint32_t CLOCK_GetFllRefClkFreq(void)
{
    7508:	b580      	push	{r7, lr}
    750a:	b082      	sub	sp, #8
    750c:	af00      	add	r7, sp, #0
    uint32_t freq;

    /* If use external reference clock. */
    if ((uint8_t)kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
    750e:	4b09      	ldr	r3, [pc, #36]	; (7534 <CLOCK_GetFllRefClkFreq+0x2c>)
    7510:	799b      	ldrb	r3, [r3, #6]
    7512:	b2db      	uxtb	r3, r3
    7514:	f003 0310 	and.w	r3, r3, #16
    7518:	2b00      	cmp	r3, #0
    751a:	d103      	bne.n	7524 <CLOCK_GetFllRefClkFreq+0x1c>
    {
        freq = CLOCK_GetFllExtRefClkFreq();
    751c:	f7ff ff76 	bl	740c <CLOCK_GetFllExtRefClkFreq>
    7520:	6078      	str	r0, [r7, #4]
    7522:	e002      	b.n	752a <CLOCK_GetFllRefClkFreq+0x22>
    }
    /* If use internal reference clock. */
    else
    {
        freq = s_slowIrcFreq;
    7524:	4b04      	ldr	r3, [pc, #16]	; (7538 <CLOCK_GetFllRefClkFreq+0x30>)
    7526:	681b      	ldr	r3, [r3, #0]
    7528:	607b      	str	r3, [r7, #4]
    }

    return freq;
    752a:	687b      	ldr	r3, [r7, #4]
}
    752c:	4618      	mov	r0, r3
    752e:	3708      	adds	r7, #8
    7530:	46bd      	mov	sp, r7
    7532:	bd80      	pop	{r7, pc}
    7534:	40064000 	.word	0x40064000
    7538:	1fff0848 	.word	0x1fff0848

0000753c <CLOCK_GetPll0RefFreq>:

static uint32_t CLOCK_GetPll0RefFreq(void)
{
    753c:	b580      	push	{r7, lr}
    753e:	af00      	add	r7, sp, #0
    /* MCG external reference clock. */
    return CLOCK_GetMcgExtClkFreq();
    7540:	f7ff ff1c 	bl	737c <CLOCK_GetMcgExtClkFreq>
    7544:	4603      	mov	r3, r0
}
    7546:	4618      	mov	r0, r3
    7548:	bd80      	pop	{r7, pc}
    754a:	Address 0x0000754a is out of bounds.


0000754c <CLOCK_GetOscRangeFromFreq>:

static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq)
{
    754c:	b480      	push	{r7}
    754e:	b085      	sub	sp, #20
    7550:	af00      	add	r7, sp, #0
    7552:	6078      	str	r0, [r7, #4]
    uint8_t range;

    if (freq <= 39063U)
    7554:	687b      	ldr	r3, [r7, #4]
    7556:	f649 0297 	movw	r2, #39063	; 0x9897
    755a:	4293      	cmp	r3, r2
    755c:	d802      	bhi.n	7564 <CLOCK_GetOscRangeFromFreq+0x18>
    {
        range = 0U;
    755e:	2300      	movs	r3, #0
    7560:	73fb      	strb	r3, [r7, #15]
    7562:	e008      	b.n	7576 <CLOCK_GetOscRangeFromFreq+0x2a>
    }
    else if (freq <= 8000000U)
    7564:	687b      	ldr	r3, [r7, #4]
    7566:	4a07      	ldr	r2, [pc, #28]	; (7584 <CLOCK_GetOscRangeFromFreq+0x38>)
    7568:	4293      	cmp	r3, r2
    756a:	d802      	bhi.n	7572 <CLOCK_GetOscRangeFromFreq+0x26>
    {
        range = 1U;
    756c:	2301      	movs	r3, #1
    756e:	73fb      	strb	r3, [r7, #15]
    7570:	e001      	b.n	7576 <CLOCK_GetOscRangeFromFreq+0x2a>
    }
    else
    {
        range = 2U;
    7572:	2302      	movs	r3, #2
    7574:	73fb      	strb	r3, [r7, #15]
    }

    return range;
    7576:	7bfb      	ldrb	r3, [r7, #15]
}
    7578:	4618      	mov	r0, r3
    757a:	3714      	adds	r7, #20
    757c:	46bd      	mov	sp, r7
    757e:	f85d 7b04 	ldr.w	r7, [sp], #4
    7582:	4770      	bx	lr
    7584:	007a1200 	.word	0x007a1200

00007588 <CLOCK_GetOsc0ErClkUndivFreq>:
 * brief Get the OSC0 external reference undivided clock frequency (OSC0ERCLK_UNDIV).
 *
 * return Clock frequency in Hz.
 */
uint32_t CLOCK_GetOsc0ErClkUndivFreq(void)
{
    7588:	b580      	push	{r7, lr}
    758a:	b082      	sub	sp, #8
    758c:	af00      	add	r7, sp, #0
    uint32_t freq;
    if ((OSC0->CR & OSC_CR_ERCLKEN_MASK) != 0U)
    758e:	4b0e      	ldr	r3, [pc, #56]	; (75c8 <CLOCK_GetOsc0ErClkUndivFreq+0x40>)
    7590:	781b      	ldrb	r3, [r3, #0]
    7592:	b2db      	uxtb	r3, r3
    7594:	b25b      	sxtb	r3, r3
    7596:	2b00      	cmp	r3, #0
    7598:	da0e      	bge.n	75b8 <CLOCK_GetOsc0ErClkUndivFreq+0x30>
    {
        /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
        assert(g_xtal0Freq);
    759a:	4b0c      	ldr	r3, [pc, #48]	; (75cc <CLOCK_GetOsc0ErClkUndivFreq+0x44>)
    759c:	681b      	ldr	r3, [r3, #0]
    759e:	2b00      	cmp	r3, #0
    75a0:	d106      	bne.n	75b0 <CLOCK_GetOsc0ErClkUndivFreq+0x28>
    75a2:	4b0b      	ldr	r3, [pc, #44]	; (75d0 <CLOCK_GetOsc0ErClkUndivFreq+0x48>)
    75a4:	4a0b      	ldr	r2, [pc, #44]	; (75d4 <CLOCK_GetOsc0ErClkUndivFreq+0x4c>)
    75a6:	f240 116b 	movw	r1, #363	; 0x16b
    75aa:	480b      	ldr	r0, [pc, #44]	; (75d8 <CLOCK_GetOsc0ErClkUndivFreq+0x50>)
    75ac:	f7ff fe16 	bl	71dc <__assert_func>
        freq = g_xtal0Freq;
    75b0:	4b06      	ldr	r3, [pc, #24]	; (75cc <CLOCK_GetOsc0ErClkUndivFreq+0x44>)
    75b2:	681b      	ldr	r3, [r3, #0]
    75b4:	607b      	str	r3, [r7, #4]
    75b6:	e001      	b.n	75bc <CLOCK_GetOsc0ErClkUndivFreq+0x34>
    }
    else
    {
        freq = 0U;
    75b8:	2300      	movs	r3, #0
    75ba:	607b      	str	r3, [r7, #4]
    }
    return freq;
    75bc:	687b      	ldr	r3, [r7, #4]
}
    75be:	4618      	mov	r0, r3
    75c0:	3708      	adds	r7, #8
    75c2:	46bd      	mov	sp, r7
    75c4:	bd80      	pop	{r7, pc}
    75c6:	bf00      	nop
    75c8:	40065000 	.word	0x40065000
    75cc:	1fff1434 	.word	0x1fff1434
    75d0:	0000f6e4 	.word	0x0000f6e4
    75d4:	0000f814 	.word	0x0000f814
    75d8:	0000f674 	.word	0x0000f674

000075dc <CLOCK_GetOsc0ErClkDivFreq>:
 * brief Get the OSC0 external reference divided clock frequency.
 *
 * return Clock frequency in Hz.
 */
uint32_t CLOCK_GetOsc0ErClkDivFreq(void)
{
    75dc:	b580      	push	{r7, lr}
    75de:	b082      	sub	sp, #8
    75e0:	af00      	add	r7, sp, #0
    uint32_t freq;
    uint8_t temp;
    if ((OSC0->CR & OSC_CR_ERCLKEN_MASK) != 0U)
    75e2:	4b13      	ldr	r3, [pc, #76]	; (7630 <CLOCK_GetOsc0ErClkDivFreq+0x54>)
    75e4:	781b      	ldrb	r3, [r3, #0]
    75e6:	b2db      	uxtb	r3, r3
    75e8:	b25b      	sxtb	r3, r3
    75ea:	2b00      	cmp	r3, #0
    75ec:	da18      	bge.n	7620 <CLOCK_GetOsc0ErClkDivFreq+0x44>
    {
        /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
        assert(g_xtal0Freq);
    75ee:	4b11      	ldr	r3, [pc, #68]	; (7634 <CLOCK_GetOsc0ErClkDivFreq+0x58>)
    75f0:	681b      	ldr	r3, [r3, #0]
    75f2:	2b00      	cmp	r3, #0
    75f4:	d106      	bne.n	7604 <CLOCK_GetOsc0ErClkDivFreq+0x28>
    75f6:	4b10      	ldr	r3, [pc, #64]	; (7638 <CLOCK_GetOsc0ErClkDivFreq+0x5c>)
    75f8:	4a10      	ldr	r2, [pc, #64]	; (763c <CLOCK_GetOsc0ErClkDivFreq+0x60>)
    75fa:	f240 1181 	movw	r1, #385	; 0x181
    75fe:	4810      	ldr	r0, [pc, #64]	; (7640 <CLOCK_GetOsc0ErClkDivFreq+0x64>)
    7600:	f7ff fdec 	bl	71dc <__assert_func>
        temp = OSC0->DIV & OSC_DIV_ERPS_MASK;
    7604:	4b0a      	ldr	r3, [pc, #40]	; (7630 <CLOCK_GetOsc0ErClkDivFreq+0x54>)
    7606:	789b      	ldrb	r3, [r3, #2]
    7608:	b2db      	uxtb	r3, r3
    760a:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
    760e:	70fb      	strb	r3, [r7, #3]
        freq = g_xtal0Freq >> ((temp) >> OSC_DIV_ERPS_SHIFT);
    7610:	4b08      	ldr	r3, [pc, #32]	; (7634 <CLOCK_GetOsc0ErClkDivFreq+0x58>)
    7612:	681b      	ldr	r3, [r3, #0]
    7614:	78fa      	ldrb	r2, [r7, #3]
    7616:	0992      	lsrs	r2, r2, #6
    7618:	b2d2      	uxtb	r2, r2
    761a:	40d3      	lsrs	r3, r2
    761c:	607b      	str	r3, [r7, #4]
    761e:	e001      	b.n	7624 <CLOCK_GetOsc0ErClkDivFreq+0x48>
    }
    else
    {
        freq = 0U;
    7620:	2300      	movs	r3, #0
    7622:	607b      	str	r3, [r7, #4]
    }
    return freq;
    7624:	687b      	ldr	r3, [r7, #4]
}
    7626:	4618      	mov	r0, r3
    7628:	3708      	adds	r7, #8
    762a:	46bd      	mov	sp, r7
    762c:	bd80      	pop	{r7, pc}
    762e:	bf00      	nop
    7630:	40065000 	.word	0x40065000
    7634:	1fff1434 	.word	0x1fff1434
    7638:	0000f6e4 	.word	0x0000f6e4
    763c:	0000f830 	.word	0x0000f830
    7640:	0000f674 	.word	0x0000f674

00007644 <CLOCK_GetEr32kClkFreq>:
 * brief Get the external reference 32K clock frequency (ERCLK32K).
 *
 * return Clock frequency in Hz.
 */
uint32_t CLOCK_GetEr32kClkFreq(void)
{
    7644:	b580      	push	{r7, lr}
    7646:	b082      	sub	sp, #8
    7648:	af00      	add	r7, sp, #0
    uint32_t freq;

    switch (SIM_SOPT1_OSC32KSEL_VAL)
    764a:	4b1a      	ldr	r3, [pc, #104]	; (76b4 <CLOCK_GetEr32kClkFreq+0x70>)
    764c:	681b      	ldr	r3, [r3, #0]
    764e:	0c9b      	lsrs	r3, r3, #18
    7650:	f003 0303 	and.w	r3, r3, #3
    7654:	2b03      	cmp	r3, #3
    7656:	d021      	beq.n	769c <CLOCK_GetEr32kClkFreq+0x58>
    7658:	2b03      	cmp	r3, #3
    765a:	d823      	bhi.n	76a4 <CLOCK_GetEr32kClkFreq+0x60>
    765c:	2b00      	cmp	r3, #0
    765e:	d002      	beq.n	7666 <CLOCK_GetEr32kClkFreq+0x22>
    7660:	2b02      	cmp	r3, #2
    7662:	d00c      	beq.n	767e <CLOCK_GetEr32kClkFreq+0x3a>
    7664:	e01e      	b.n	76a4 <CLOCK_GetEr32kClkFreq+0x60>
    {
        case 0U: /* OSC 32k clock  */
            freq = (CLOCK_GetOsc0ErClkDivFreq() == 32768U) ? 32768U : 0U;
    7666:	f7ff ffb9 	bl	75dc <CLOCK_GetOsc0ErClkDivFreq>
    766a:	4603      	mov	r3, r0
    766c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    7670:	d102      	bne.n	7678 <CLOCK_GetEr32kClkFreq+0x34>
    7672:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    7676:	e000      	b.n	767a <CLOCK_GetEr32kClkFreq+0x36>
    7678:	2300      	movs	r3, #0
    767a:	607b      	str	r3, [r7, #4]
            break;
    767c:	e015      	b.n	76aa <CLOCK_GetEr32kClkFreq+0x66>
        case 2U: /* RTC 32k clock  */
            /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN clock. */
            assert(g_xtal32Freq);
    767e:	4b0e      	ldr	r3, [pc, #56]	; (76b8 <CLOCK_GetEr32kClkFreq+0x74>)
    7680:	681b      	ldr	r3, [r3, #0]
    7682:	2b00      	cmp	r3, #0
    7684:	d106      	bne.n	7694 <CLOCK_GetEr32kClkFreq+0x50>
    7686:	4b0d      	ldr	r3, [pc, #52]	; (76bc <CLOCK_GetEr32kClkFreq+0x78>)
    7688:	4a0d      	ldr	r2, [pc, #52]	; (76c0 <CLOCK_GetEr32kClkFreq+0x7c>)
    768a:	f44f 71ce 	mov.w	r1, #412	; 0x19c
    768e:	480d      	ldr	r0, [pc, #52]	; (76c4 <CLOCK_GetEr32kClkFreq+0x80>)
    7690:	f7ff fda4 	bl	71dc <__assert_func>
            freq = g_xtal32Freq;
    7694:	4b08      	ldr	r3, [pc, #32]	; (76b8 <CLOCK_GetEr32kClkFreq+0x74>)
    7696:	681b      	ldr	r3, [r3, #0]
    7698:	607b      	str	r3, [r7, #4]
            break;
    769a:	e006      	b.n	76aa <CLOCK_GetEr32kClkFreq+0x66>
        case 3U: /* LPO clock      */
            freq = LPO_CLK_FREQ;
    769c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    76a0:	607b      	str	r3, [r7, #4]
            break;
    76a2:	e002      	b.n	76aa <CLOCK_GetEr32kClkFreq+0x66>
        default:
            freq = 0U;
    76a4:	2300      	movs	r3, #0
    76a6:	607b      	str	r3, [r7, #4]
            break;
    76a8:	bf00      	nop
    }
    return freq;
    76aa:	687b      	ldr	r3, [r7, #4]
}
    76ac:	4618      	mov	r0, r3
    76ae:	3708      	adds	r7, #8
    76b0:	46bd      	mov	sp, r7
    76b2:	bd80      	pop	{r7, pc}
    76b4:	40047000 	.word	0x40047000
    76b8:	1fff1438 	.word	0x1fff1438
    76bc:	0000f6f0 	.word	0x0000f6f0
    76c0:	0000f84c 	.word	0x0000f84c
    76c4:	0000f674 	.word	0x0000f674

000076c8 <CLOCK_GetPllFllSelClkFreq>:
 * brief Get the output clock frequency selected by SIM[PLLFLLSEL].
 *
 * return Clock frequency in Hz.
 */
uint32_t CLOCK_GetPllFllSelClkFreq(void)
{
    76c8:	b580      	push	{r7, lr}
    76ca:	b082      	sub	sp, #8
    76cc:	af00      	add	r7, sp, #0
    uint32_t freq;

    switch (SIM_SOPT2_PLLFLLSEL_VAL)
    76ce:	4b20      	ldr	r3, [pc, #128]	; (7750 <CLOCK_GetPllFllSelClkFreq+0x88>)
    76d0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    76d4:	685b      	ldr	r3, [r3, #4]
    76d6:	0c1b      	lsrs	r3, r3, #16
    76d8:	f003 0303 	and.w	r3, r3, #3
    76dc:	2b03      	cmp	r3, #3
    76de:	d81a      	bhi.n	7716 <CLOCK_GetPllFllSelClkFreq+0x4e>
    76e0:	a201      	add	r2, pc, #4	; (adr r2, 76e8 <CLOCK_GetPllFllSelClkFreq+0x20>)
    76e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    76e6:	bf00      	nop
    76e8:	000076f9 	.word	0x000076f9
    76ec:	00007701 	.word	0x00007701
    76f0:	00007709 	.word	0x00007709
    76f4:	00007711 	.word	0x00007711
    {
        case 0U: /* FLL. */
            freq = CLOCK_GetFllFreq();
    76f8:	f000 fa0c 	bl	7b14 <CLOCK_GetFllFreq>
    76fc:	6078      	str	r0, [r7, #4]
            break;
    76fe:	e00d      	b.n	771c <CLOCK_GetPllFllSelClkFreq+0x54>
        case 1U: /* PLL. */
            freq = CLOCK_GetPll0Freq();
    7700:	f000 fa7c 	bl	7bfc <CLOCK_GetPll0Freq>
    7704:	6078      	str	r0, [r7, #4]
            break;
    7706:	e009      	b.n	771c <CLOCK_GetPllFllSelClkFreq+0x54>
        case 2U: /* USB1 PFD */
            freq = CLOCK_GetExtPllFreq();
    7708:	f000 fabe 	bl	7c88 <CLOCK_GetExtPllFreq>
    770c:	6078      	str	r0, [r7, #4]
            break;
    770e:	e005      	b.n	771c <CLOCK_GetPllFllSelClkFreq+0x54>
        case 3U: /* MCG IRC48M. */
            freq = MCG_INTERNAL_IRC_48M;
    7710:	4b10      	ldr	r3, [pc, #64]	; (7754 <CLOCK_GetPllFllSelClkFreq+0x8c>)
    7712:	607b      	str	r3, [r7, #4]
            break;
    7714:	e002      	b.n	771c <CLOCK_GetPllFllSelClkFreq+0x54>
        default:
            freq = 0U;
    7716:	2300      	movs	r3, #0
    7718:	607b      	str	r3, [r7, #4]
            break;
    771a:	bf00      	nop
    }

    freq *= (SIM_CLKDIV3_PLLFLLFRAC_VAL + 1U);
    771c:	4b0c      	ldr	r3, [pc, #48]	; (7750 <CLOCK_GetPllFllSelClkFreq+0x88>)
    771e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    7722:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    7724:	f003 0301 	and.w	r3, r3, #1
    7728:	1c5a      	adds	r2, r3, #1
    772a:	687b      	ldr	r3, [r7, #4]
    772c:	fb02 f303 	mul.w	r3, r2, r3
    7730:	607b      	str	r3, [r7, #4]
    return freq / (SIM_CLKDIV3_PLLFLLDIV_VAL + 1U);
    7732:	4b07      	ldr	r3, [pc, #28]	; (7750 <CLOCK_GetPllFllSelClkFreq+0x88>)
    7734:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    7738:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    773a:	085b      	lsrs	r3, r3, #1
    773c:	f003 0307 	and.w	r3, r3, #7
    7740:	3301      	adds	r3, #1
    7742:	687a      	ldr	r2, [r7, #4]
    7744:	fbb2 f3f3 	udiv	r3, r2, r3
}
    7748:	4618      	mov	r0, r3
    774a:	3708      	adds	r7, #8
    774c:	46bd      	mov	sp, r7
    774e:	bd80      	pop	{r7, pc}
    7750:	40047000 	.word	0x40047000
    7754:	02dc6c00 	.word	0x02dc6c00

00007758 <CLOCK_GetPlatClkFreq>:
 * brief Get the platform clock frequency.
 *
 * return Clock frequency in Hz.
 */
uint32_t CLOCK_GetPlatClkFreq(void)
{
    7758:	b580      	push	{r7, lr}
    775a:	af00      	add	r7, sp, #0
    return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1UL);
    775c:	f000 f992 	bl	7a84 <CLOCK_GetOutClkFreq>
    7760:	4602      	mov	r2, r0
    7762:	4b06      	ldr	r3, [pc, #24]	; (777c <CLOCK_GetPlatClkFreq+0x24>)
    7764:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    7768:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    776a:	0f1b      	lsrs	r3, r3, #28
    776c:	f003 030f 	and.w	r3, r3, #15
    7770:	3301      	adds	r3, #1
    7772:	fbb2 f3f3 	udiv	r3, r2, r3
}
    7776:	4618      	mov	r0, r3
    7778:	bd80      	pop	{r7, pc}
    777a:	bf00      	nop
    777c:	40047000 	.word	0x40047000

00007780 <CLOCK_GetBusClkFreq>:
 * brief Get the bus clock frequency.
 *
 * return Clock frequency in Hz.
 */
uint32_t CLOCK_GetBusClkFreq(void)
{
    7780:	b580      	push	{r7, lr}
    7782:	af00      	add	r7, sp, #0
    return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1UL);
    7784:	f000 f97e 	bl	7a84 <CLOCK_GetOutClkFreq>
    7788:	4602      	mov	r2, r0
    778a:	4b06      	ldr	r3, [pc, #24]	; (77a4 <CLOCK_GetBusClkFreq+0x24>)
    778c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    7790:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7792:	0e1b      	lsrs	r3, r3, #24
    7794:	f003 030f 	and.w	r3, r3, #15
    7798:	3301      	adds	r3, #1
    779a:	fbb2 f3f3 	udiv	r3, r2, r3
}
    779e:	4618      	mov	r0, r3
    77a0:	bd80      	pop	{r7, pc}
    77a2:	bf00      	nop
    77a4:	40047000 	.word	0x40047000

000077a8 <CLOCK_GetCoreSysClkFreq>:
 * brief Get the core clock or system clock frequency.
 *
 * return Clock frequency in Hz.
 */
uint32_t CLOCK_GetCoreSysClkFreq(void)
{
    77a8:	b580      	push	{r7, lr}
    77aa:	af00      	add	r7, sp, #0
    return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1UL);
    77ac:	f000 f96a 	bl	7a84 <CLOCK_GetOutClkFreq>
    77b0:	4602      	mov	r2, r0
    77b2:	4b06      	ldr	r3, [pc, #24]	; (77cc <CLOCK_GetCoreSysClkFreq+0x24>)
    77b4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    77b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    77ba:	0f1b      	lsrs	r3, r3, #28
    77bc:	f003 030f 	and.w	r3, r3, #15
    77c0:	3301      	adds	r3, #1
    77c2:	fbb2 f3f3 	udiv	r3, r2, r3
}
    77c6:	4618      	mov	r0, r3
    77c8:	bd80      	pop	{r7, pc}
    77ca:	bf00      	nop
    77cc:	40047000 	.word	0x40047000

000077d0 <CLOCK_GetFreq>:
 *
 * param clockName Clock names defined in clock_name_t
 * return Clock frequency value in Hertz
 */
uint32_t CLOCK_GetFreq(clock_name_t clockName)
{
    77d0:	b580      	push	{r7, lr}
    77d2:	b084      	sub	sp, #16
    77d4:	af00      	add	r7, sp, #0
    77d6:	4603      	mov	r3, r0
    77d8:	71fb      	strb	r3, [r7, #7]
    uint32_t freq;

    switch (clockName)
    77da:	79fb      	ldrb	r3, [r7, #7]
    77dc:	2b13      	cmp	r3, #19
    77de:	f200 808e 	bhi.w	78fe <CLOCK_GetFreq+0x12e>
    77e2:	a201      	add	r2, pc, #4	; (adr r2, 77e8 <CLOCK_GetFreq+0x18>)
    77e4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    77e8:	00007839 	.word	0x00007839
    77ec:	00007839 	.word	0x00007839
    77f0:	00007857 	.word	0x00007857
    77f4:	00007875 	.word	0x00007875
    77f8:	00007893 	.word	0x00007893
    77fc:	000078ff 	.word	0x000078ff
    7800:	000078b1 	.word	0x000078b1
    7804:	000078b9 	.word	0x000078b9
    7808:	000078c1 	.word	0x000078c1
    780c:	000078ff 	.word	0x000078ff
    7810:	000078c9 	.word	0x000078c9
    7814:	000078d1 	.word	0x000078d1
    7818:	000078d9 	.word	0x000078d9
    781c:	000078e1 	.word	0x000078e1
    7820:	000078e9 	.word	0x000078e9
    7824:	000078ff 	.word	0x000078ff
    7828:	000078ff 	.word	0x000078ff
    782c:	000078ff 	.word	0x000078ff
    7830:	000078f1 	.word	0x000078f1
    7834:	000078f7 	.word	0x000078f7
    {
        case kCLOCK_CoreSysClk:
        case kCLOCK_PlatClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1UL);
    7838:	f000 f924 	bl	7a84 <CLOCK_GetOutClkFreq>
    783c:	4602      	mov	r2, r0
    783e:	4b34      	ldr	r3, [pc, #208]	; (7910 <CLOCK_GetFreq+0x140>)
    7840:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    7844:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7846:	0f1b      	lsrs	r3, r3, #28
    7848:	f003 030f 	and.w	r3, r3, #15
    784c:	3301      	adds	r3, #1
    784e:	fbb2 f3f3 	udiv	r3, r2, r3
    7852:	60fb      	str	r3, [r7, #12]
            break;
    7854:	e056      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_BusClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1UL);
    7856:	f000 f915 	bl	7a84 <CLOCK_GetOutClkFreq>
    785a:	4602      	mov	r2, r0
    785c:	4b2c      	ldr	r3, [pc, #176]	; (7910 <CLOCK_GetFreq+0x140>)
    785e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    7862:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7864:	0e1b      	lsrs	r3, r3, #24
    7866:	f003 030f 	and.w	r3, r3, #15
    786a:	3301      	adds	r3, #1
    786c:	fbb2 f3f3 	udiv	r3, r2, r3
    7870:	60fb      	str	r3, [r7, #12]
            break;
    7872:	e047      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_FlexBusClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV3_VAL + 1UL);
    7874:	f000 f906 	bl	7a84 <CLOCK_GetOutClkFreq>
    7878:	4602      	mov	r2, r0
    787a:	4b25      	ldr	r3, [pc, #148]	; (7910 <CLOCK_GetFreq+0x140>)
    787c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    7880:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7882:	0d1b      	lsrs	r3, r3, #20
    7884:	f003 030f 	and.w	r3, r3, #15
    7888:	3301      	adds	r3, #1
    788a:	fbb2 f3f3 	udiv	r3, r2, r3
    788e:	60fb      	str	r3, [r7, #12]
            break;
    7890:	e038      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_FlashClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1UL);
    7892:	f000 f8f7 	bl	7a84 <CLOCK_GetOutClkFreq>
    7896:	4602      	mov	r2, r0
    7898:	4b1d      	ldr	r3, [pc, #116]	; (7910 <CLOCK_GetFreq+0x140>)
    789a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    789e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    78a0:	0c1b      	lsrs	r3, r3, #16
    78a2:	f003 030f 	and.w	r3, r3, #15
    78a6:	3301      	adds	r3, #1
    78a8:	fbb2 f3f3 	udiv	r3, r2, r3
    78ac:	60fb      	str	r3, [r7, #12]
            break;
    78ae:	e029      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_PllFllSelClk:
            freq = CLOCK_GetPllFllSelClkFreq();
    78b0:	f7ff ff0a 	bl	76c8 <CLOCK_GetPllFllSelClkFreq>
    78b4:	60f8      	str	r0, [r7, #12]
            break;
    78b6:	e025      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_Er32kClk:
            freq = CLOCK_GetEr32kClkFreq();
    78b8:	f7ff fec4 	bl	7644 <CLOCK_GetEr32kClkFreq>
    78bc:	60f8      	str	r0, [r7, #12]
            break;
    78be:	e021      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_Osc0ErClk:
            freq = CLOCK_GetOsc0ErClkDivFreq();
    78c0:	f7ff fe8c 	bl	75dc <CLOCK_GetOsc0ErClkDivFreq>
    78c4:	60f8      	str	r0, [r7, #12]
            break;
    78c6:	e01d      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_Osc0ErClkUndiv:
            freq = CLOCK_GetOsc0ErClkUndivFreq();
    78c8:	f7ff fe5e 	bl	7588 <CLOCK_GetOsc0ErClkUndivFreq>
    78cc:	60f8      	str	r0, [r7, #12]
            break;
    78ce:	e019      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_McgFixedFreqClk:
            freq = CLOCK_GetFixedFreqClkFreq();
    78d0:	f000 f97a 	bl	7bc8 <CLOCK_GetFixedFreqClkFreq>
    78d4:	60f8      	str	r0, [r7, #12]
            break;
    78d6:	e015      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_McgInternalRefClk:
            freq = CLOCK_GetInternalRefClkFreq();
    78d8:	f000 f95e 	bl	7b98 <CLOCK_GetInternalRefClkFreq>
    78dc:	60f8      	str	r0, [r7, #12]
            break;
    78de:	e011      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_McgFllClk:
            freq = CLOCK_GetFllFreq();
    78e0:	f000 f918 	bl	7b14 <CLOCK_GetFllFreq>
    78e4:	60f8      	str	r0, [r7, #12]
            break;
    78e6:	e00d      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_McgPll0Clk:
            freq = CLOCK_GetPll0Freq();
    78e8:	f000 f988 	bl	7bfc <CLOCK_GetPll0Freq>
    78ec:	60f8      	str	r0, [r7, #12]
            break;
    78ee:	e009      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_McgIrc48MClk:
            freq = MCG_INTERNAL_IRC_48M;
    78f0:	4b08      	ldr	r3, [pc, #32]	; (7914 <CLOCK_GetFreq+0x144>)
    78f2:	60fb      	str	r3, [r7, #12]
            break;
    78f4:	e006      	b.n	7904 <CLOCK_GetFreq+0x134>
        case kCLOCK_LpoClk:
            freq = LPO_CLK_FREQ;
    78f6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    78fa:	60fb      	str	r3, [r7, #12]
            break;
    78fc:	e002      	b.n	7904 <CLOCK_GetFreq+0x134>
        default:
            freq = 0U;
    78fe:	2300      	movs	r3, #0
    7900:	60fb      	str	r3, [r7, #12]
            break;
    7902:	bf00      	nop
    }

    return freq;
    7904:	68fb      	ldr	r3, [r7, #12]
}
    7906:	4618      	mov	r0, r3
    7908:	3710      	adds	r7, #16
    790a:	46bd      	mov	sp, r7
    790c:	bd80      	pop	{r7, pc}
    790e:	bf00      	nop
    7910:	40047000 	.word	0x40047000
    7914:	02dc6c00 	.word	0x02dc6c00

00007918 <CLOCK_SetSimConfig>:
 * This function sets system layer clock settings in SIM module.
 *
 * param config Pointer to the configure structure.
 */
void CLOCK_SetSimConfig(sim_clock_config_t const *config)
{
    7918:	b580      	push	{r7, lr}
    791a:	b082      	sub	sp, #8
    791c:	af00      	add	r7, sp, #0
    791e:	6078      	str	r0, [r7, #4]
    SIM->CLKDIV1 = config->clkdiv1;
    7920:	4a0c      	ldr	r2, [pc, #48]	; (7954 <CLOCK_SetSimConfig+0x3c>)
    7922:	687b      	ldr	r3, [r7, #4]
    7924:	685b      	ldr	r3, [r3, #4]
    7926:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    792a:	6453      	str	r3, [r2, #68]	; 0x44
    CLOCK_SetPllFllSelClock(config->pllFllSel, config->pllFllDiv, config->pllFllFrac);
    792c:	687b      	ldr	r3, [r7, #4]
    792e:	781b      	ldrb	r3, [r3, #0]
    7930:	4618      	mov	r0, r3
    7932:	687b      	ldr	r3, [r7, #4]
    7934:	785b      	ldrb	r3, [r3, #1]
    7936:	4619      	mov	r1, r3
    7938:	687b      	ldr	r3, [r7, #4]
    793a:	789b      	ldrb	r3, [r3, #2]
    793c:	461a      	mov	r2, r3
    793e:	f7ff fca5 	bl	728c <CLOCK_SetPllFllSelClock>
    CLOCK_SetEr32kClock(config->er32kSrc);
    7942:	687b      	ldr	r3, [r7, #4]
    7944:	78db      	ldrb	r3, [r3, #3]
    7946:	4618      	mov	r0, r3
    7948:	f7ff fc88 	bl	725c <CLOCK_SetEr32kClock>
}
    794c:	bf00      	nop
    794e:	3708      	adds	r7, #8
    7950:	46bd      	mov	sp, r7
    7952:	bd80      	pop	{r7, pc}
    7954:	40047000 	.word	0x40047000

00007958 <CLOCK_EnableUsbfs0Clock>:
 * param freq The frequency specified by src.
 * retval true The clock is set successfully.
 * retval false The clock source is invalid to get proper USB FS clock.
 */
bool CLOCK_EnableUsbfs0Clock(clock_usb_src_t src, uint32_t freq)
{
    7958:	b580      	push	{r7, lr}
    795a:	b084      	sub	sp, #16
    795c:	af00      	add	r7, sp, #0
    795e:	6078      	str	r0, [r7, #4]
    7960:	6039      	str	r1, [r7, #0]
    /* In current implementation, USBPFDCLK is not used for USB FS. */
    assert(kCLOCK_UsbSrcUsbPfd != src);
    7962:	687b      	ldr	r3, [r7, #4]
    7964:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
    7968:	d106      	bne.n	7978 <CLOCK_EnableUsbfs0Clock+0x20>
    796a:	4b3c      	ldr	r3, [pc, #240]	; (7a5c <CLOCK_EnableUsbfs0Clock+0x104>)
    796c:	4a3c      	ldr	r2, [pc, #240]	; (7a60 <CLOCK_EnableUsbfs0Clock+0x108>)
    796e:	f44f 7118 	mov.w	r1, #608	; 0x260
    7972:	483c      	ldr	r0, [pc, #240]	; (7a64 <CLOCK_EnableUsbfs0Clock+0x10c>)
    7974:	f7ff fc32 	bl	71dc <__assert_func>

    bool ret = true;
    7978:	2301      	movs	r3, #1
    797a:	73fb      	strb	r3, [r7, #15]

    CLOCK_DisableClock(kCLOCK_Usbfs0);
    797c:	483a      	ldr	r0, [pc, #232]	; (7a68 <CLOCK_EnableUsbfs0Clock+0x110>)
    797e:	f7ff fc50 	bl	7222 <CLOCK_DisableClock>

    if (kCLOCK_UsbSrcExt == src)
    7982:	687b      	ldr	r3, [r7, #4]
    7984:	2b00      	cmp	r3, #0
    7986:	d10a      	bne.n	799e <CLOCK_EnableUsbfs0Clock+0x46>
    {
        SIM->SOPT2 &= ~SIM_SOPT2_USBSRC_MASK;
    7988:	4b38      	ldr	r3, [pc, #224]	; (7a6c <CLOCK_EnableUsbfs0Clock+0x114>)
    798a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    798e:	685b      	ldr	r3, [r3, #4]
    7990:	4a36      	ldr	r2, [pc, #216]	; (7a6c <CLOCK_EnableUsbfs0Clock+0x114>)
    7992:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
    7996:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    799a:	6053      	str	r3, [r2, #4]
    799c:	e043      	b.n	7a26 <CLOCK_EnableUsbfs0Clock+0xce>
    }
    else
    {
        switch (freq)
    799e:	683b      	ldr	r3, [r7, #0]
    79a0:	4a33      	ldr	r2, [pc, #204]	; (7a70 <CLOCK_EnableUsbfs0Clock+0x118>)
    79a2:	4293      	cmp	r3, r2
    79a4:	d014      	beq.n	79d0 <CLOCK_EnableUsbfs0Clock+0x78>
    79a6:	683b      	ldr	r3, [r7, #0]
    79a8:	4a31      	ldr	r2, [pc, #196]	; (7a70 <CLOCK_EnableUsbfs0Clock+0x118>)
    79aa:	4293      	cmp	r3, r2
    79ac:	d82c      	bhi.n	7a08 <CLOCK_EnableUsbfs0Clock+0xb0>
    79ae:	683b      	ldr	r3, [r7, #0]
    79b0:	4a30      	ldr	r2, [pc, #192]	; (7a74 <CLOCK_EnableUsbfs0Clock+0x11c>)
    79b2:	4293      	cmp	r3, r2
    79b4:	d013      	beq.n	79de <CLOCK_EnableUsbfs0Clock+0x86>
    79b6:	683b      	ldr	r3, [r7, #0]
    79b8:	4a2e      	ldr	r2, [pc, #184]	; (7a74 <CLOCK_EnableUsbfs0Clock+0x11c>)
    79ba:	4293      	cmp	r3, r2
    79bc:	d824      	bhi.n	7a08 <CLOCK_EnableUsbfs0Clock+0xb0>
    79be:	683b      	ldr	r3, [r7, #0]
    79c0:	4a2d      	ldr	r2, [pc, #180]	; (7a78 <CLOCK_EnableUsbfs0Clock+0x120>)
    79c2:	4293      	cmp	r3, r2
    79c4:	d019      	beq.n	79fa <CLOCK_EnableUsbfs0Clock+0xa2>
    79c6:	683b      	ldr	r3, [r7, #0]
    79c8:	4a2c      	ldr	r2, [pc, #176]	; (7a7c <CLOCK_EnableUsbfs0Clock+0x124>)
    79ca:	4293      	cmp	r3, r2
    79cc:	d00e      	beq.n	79ec <CLOCK_EnableUsbfs0Clock+0x94>
    79ce:	e01b      	b.n	7a08 <CLOCK_EnableUsbfs0Clock+0xb0>
        {
            case 120000000U:
                SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC(1);
    79d0:	4b26      	ldr	r3, [pc, #152]	; (7a6c <CLOCK_EnableUsbfs0Clock+0x114>)
    79d2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    79d6:	461a      	mov	r2, r3
    79d8:	2309      	movs	r3, #9
    79da:	6493      	str	r3, [r2, #72]	; 0x48
                break;
    79dc:	e017      	b.n	7a0e <CLOCK_EnableUsbfs0Clock+0xb6>
            case 96000000U:
                SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(1) | SIM_CLKDIV2_USBFRAC(0);
    79de:	4b23      	ldr	r3, [pc, #140]	; (7a6c <CLOCK_EnableUsbfs0Clock+0x114>)
    79e0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    79e4:	461a      	mov	r2, r3
    79e6:	2302      	movs	r3, #2
    79e8:	6493      	str	r3, [r2, #72]	; 0x48
                break;
    79ea:	e010      	b.n	7a0e <CLOCK_EnableUsbfs0Clock+0xb6>
            case 72000000U:
                SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(2) | SIM_CLKDIV2_USBFRAC(1);
    79ec:	4b1f      	ldr	r3, [pc, #124]	; (7a6c <CLOCK_EnableUsbfs0Clock+0x114>)
    79ee:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    79f2:	461a      	mov	r2, r3
    79f4:	2305      	movs	r3, #5
    79f6:	6493      	str	r3, [r2, #72]	; 0x48
                break;
    79f8:	e009      	b.n	7a0e <CLOCK_EnableUsbfs0Clock+0xb6>
            case 48000000U:
                SIM->CLKDIV2 = SIM_CLKDIV2_USBDIV(0) | SIM_CLKDIV2_USBFRAC(0);
    79fa:	4b1c      	ldr	r3, [pc, #112]	; (7a6c <CLOCK_EnableUsbfs0Clock+0x114>)
    79fc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    7a00:	461a      	mov	r2, r3
    7a02:	2300      	movs	r3, #0
    7a04:	6493      	str	r3, [r2, #72]	; 0x48
                break;
    7a06:	e002      	b.n	7a0e <CLOCK_EnableUsbfs0Clock+0xb6>
            default:
                ret = false;
    7a08:	2300      	movs	r3, #0
    7a0a:	73fb      	strb	r3, [r7, #15]
                break;
    7a0c:	bf00      	nop
        }

        SIM->SOPT2 = ((SIM->SOPT2 & ~(SIM_SOPT2_PLLFLLSEL_MASK | SIM_SOPT2_USBSRC_MASK)) | (uint32_t)src);
    7a0e:	4b17      	ldr	r3, [pc, #92]	; (7a6c <CLOCK_EnableUsbfs0Clock+0x114>)
    7a10:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    7a14:	685b      	ldr	r3, [r3, #4]
    7a16:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
    7a1a:	687b      	ldr	r3, [r7, #4]
    7a1c:	4913      	ldr	r1, [pc, #76]	; (7a6c <CLOCK_EnableUsbfs0Clock+0x114>)
    7a1e:	4313      	orrs	r3, r2
    7a20:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    7a24:	6053      	str	r3, [r2, #4]
    }

    CLOCK_EnableClock(kCLOCK_Usbfs0);
    7a26:	4810      	ldr	r0, [pc, #64]	; (7a68 <CLOCK_EnableUsbfs0Clock+0x110>)
    7a28:	f7ff fbe1 	bl	71ee <CLOCK_EnableClock>

    if (kCLOCK_UsbSrcIrc48M == src)
    7a2c:	687b      	ldr	r3, [r7, #4]
    7a2e:	f5b3 2fe0 	cmp.w	r3, #458752	; 0x70000
    7a32:	d10d      	bne.n	7a50 <CLOCK_EnableUsbfs0Clock+0xf8>
    {
        USB0->CLK_RECOVER_IRC_EN = 0x03U;
    7a34:	4b12      	ldr	r3, [pc, #72]	; (7a80 <CLOCK_EnableUsbfs0Clock+0x128>)
    7a36:	2203      	movs	r2, #3
    7a38:	f883 2144 	strb.w	r2, [r3, #324]	; 0x144
        USB0->CLK_RECOVER_CTRL |= USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK;
    7a3c:	4b10      	ldr	r3, [pc, #64]	; (7a80 <CLOCK_EnableUsbfs0Clock+0x128>)
    7a3e:	f893 3140 	ldrb.w	r3, [r3, #320]	; 0x140
    7a42:	b2db      	uxtb	r3, r3
    7a44:	4a0e      	ldr	r2, [pc, #56]	; (7a80 <CLOCK_EnableUsbfs0Clock+0x128>)
    7a46:	f063 037f 	orn	r3, r3, #127	; 0x7f
    7a4a:	b2db      	uxtb	r3, r3
    7a4c:	f882 3140 	strb.w	r3, [r2, #320]	; 0x140
    }
    return ret;
    7a50:	7bfb      	ldrb	r3, [r7, #15]
}
    7a52:	4618      	mov	r0, r3
    7a54:	3710      	adds	r7, #16
    7a56:	46bd      	mov	sp, r7
    7a58:	bd80      	pop	{r7, pc}
    7a5a:	bf00      	nop
    7a5c:	0000f700 	.word	0x0000f700
    7a60:	0000f864 	.word	0x0000f864
    7a64:	0000f674 	.word	0x0000f674
    7a68:	10340012 	.word	0x10340012
    7a6c:	40047000 	.word	0x40047000
    7a70:	07270e00 	.word	0x07270e00
    7a74:	05b8d800 	.word	0x05b8d800
    7a78:	02dc6c00 	.word	0x02dc6c00
    7a7c:	044aa200 	.word	0x044aa200
    7a80:	40072000 	.word	0x40072000

00007a84 <CLOCK_GetOutClkFreq>:
 * register value.
 *
 * return The frequency of MCGOUTCLK.
 */
uint32_t CLOCK_GetOutClkFreq(void)
{
    7a84:	b580      	push	{r7, lr}
    7a86:	b084      	sub	sp, #16
    7a88:	af00      	add	r7, sp, #0
    uint32_t mcgoutclk;
    uint32_t clkst  = (uint32_t)MCG_S_CLKST_VAL;
    7a8a:	4b21      	ldr	r3, [pc, #132]	; (7b10 <CLOCK_GetOutClkFreq+0x8c>)
    7a8c:	799b      	ldrb	r3, [r3, #6]
    7a8e:	b2db      	uxtb	r3, r3
    7a90:	089b      	lsrs	r3, r3, #2
    7a92:	f003 0303 	and.w	r3, r3, #3
    7a96:	60bb      	str	r3, [r7, #8]
    uint32_t pllcst = MCG_S2_PLLCST_VAL;
    7a98:	4b1d      	ldr	r3, [pc, #116]	; (7b10 <CLOCK_GetOutClkFreq+0x8c>)
    7a9a:	7c9b      	ldrb	r3, [r3, #18]
    7a9c:	b2db      	uxtb	r3, r3
    7a9e:	091b      	lsrs	r3, r3, #4
    7aa0:	f003 0301 	and.w	r3, r3, #1
    7aa4:	607b      	str	r3, [r7, #4]

    switch (clkst)
    7aa6:	68bb      	ldr	r3, [r7, #8]
    7aa8:	2b03      	cmp	r3, #3
    7aaa:	d829      	bhi.n	7b00 <CLOCK_GetOutClkFreq+0x7c>
    7aac:	a201      	add	r2, pc, #4	; (adr r2, 7ab4 <CLOCK_GetOutClkFreq+0x30>)
    7aae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    7ab2:	bf00      	nop
    7ab4:	00007ae9 	.word	0x00007ae9
    7ab8:	00007af1 	.word	0x00007af1
    7abc:	00007af9 	.word	0x00007af9
    7ac0:	00007ac5 	.word	0x00007ac5
    7ac4:	687b      	ldr	r3, [r7, #4]
    7ac6:	2b00      	cmp	r3, #0
    7ac8:	d006      	beq.n	7ad8 <CLOCK_GetOutClkFreq+0x54>
    7aca:	687b      	ldr	r3, [r7, #4]
    7acc:	2b01      	cmp	r3, #1
    7ace:	d107      	bne.n	7ae0 <CLOCK_GetOutClkFreq+0x5c>
    {
        case (uint32_t)kMCG_ClkOutStatPll:
            switch (pllcst)
            {
                case (uint32_t)kMCG_PllClkSelExtPll:
                    mcgoutclk = CLOCK_GetExtPllFreq();
    7ad0:	f000 f8da 	bl	7c88 <CLOCK_GetExtPllFreq>
    7ad4:	60f8      	str	r0, [r7, #12]
                    break;
    7ad6:	e006      	b.n	7ae6 <CLOCK_GetOutClkFreq+0x62>
                case (uint32_t)kMCG_PllClkSelPll0:
                    mcgoutclk = CLOCK_GetPll0Freq();
    7ad8:	f000 f890 	bl	7bfc <CLOCK_GetPll0Freq>
    7adc:	60f8      	str	r0, [r7, #12]
                    break;
    7ade:	e002      	b.n	7ae6 <CLOCK_GetOutClkFreq+0x62>
                default:
                    mcgoutclk = 0U;
    7ae0:	2300      	movs	r3, #0
    7ae2:	60fb      	str	r3, [r7, #12]
                    break;
    7ae4:	bf00      	nop
            }
            break;
    7ae6:	e00e      	b.n	7b06 <CLOCK_GetOutClkFreq+0x82>
        case (uint32_t)kMCG_ClkOutStatFll:
            mcgoutclk = CLOCK_GetFllFreq();
    7ae8:	f000 f814 	bl	7b14 <CLOCK_GetFllFreq>
    7aec:	60f8      	str	r0, [r7, #12]
            break;
    7aee:	e00a      	b.n	7b06 <CLOCK_GetOutClkFreq+0x82>
        case (uint32_t)kMCG_ClkOutStatInt:
            mcgoutclk = CLOCK_GetInternalRefClkSelectFreq();
    7af0:	f7ff fce4 	bl	74bc <CLOCK_GetInternalRefClkSelectFreq>
    7af4:	60f8      	str	r0, [r7, #12]
            break;
    7af6:	e006      	b.n	7b06 <CLOCK_GetOutClkFreq+0x82>
        case (uint32_t)kMCG_ClkOutStatExt:
            mcgoutclk = CLOCK_GetMcgExtClkFreq();
    7af8:	f7ff fc40 	bl	737c <CLOCK_GetMcgExtClkFreq>
    7afc:	60f8      	str	r0, [r7, #12]
            break;
    7afe:	e002      	b.n	7b06 <CLOCK_GetOutClkFreq+0x82>
        default:
            mcgoutclk = 0U;
    7b00:	2300      	movs	r3, #0
    7b02:	60fb      	str	r3, [r7, #12]
            break;
    7b04:	bf00      	nop
    }

    return mcgoutclk;
    7b06:	68fb      	ldr	r3, [r7, #12]
}
    7b08:	4618      	mov	r0, r3
    7b0a:	3710      	adds	r7, #16
    7b0c:	46bd      	mov	sp, r7
    7b0e:	bd80      	pop	{r7, pc}
    7b10:	40064000 	.word	0x40064000

00007b14 <CLOCK_GetFllFreq>:
 * disabled in low power state in other modes.
 *
 * return The frequency of MCGFLLCLK.
 */
uint32_t CLOCK_GetFllFreq(void)
{
    7b14:	b580      	push	{r7, lr}
    7b16:	b084      	sub	sp, #16
    7b18:	af00      	add	r7, sp, #0
    uint8_t drs, dmx32;
    uint32_t freq;
    uint32_t ret;

    /* If FLL is not enabled currently, then return 0U. */
    if ((((MCG->C2 & MCG_C2_LP_MASK) != 0U) || ((MCG->S & MCG_S_PLLST_MASK) != 0U)))
    7b1a:	4b1d      	ldr	r3, [pc, #116]	; (7b90 <CLOCK_GetFllFreq+0x7c>)
    7b1c:	785b      	ldrb	r3, [r3, #1]
    7b1e:	b2db      	uxtb	r3, r3
    7b20:	f003 0302 	and.w	r3, r3, #2
    7b24:	2b00      	cmp	r3, #0
    7b26:	d106      	bne.n	7b36 <CLOCK_GetFllFreq+0x22>
    7b28:	4b19      	ldr	r3, [pc, #100]	; (7b90 <CLOCK_GetFllFreq+0x7c>)
    7b2a:	799b      	ldrb	r3, [r3, #6]
    7b2c:	b2db      	uxtb	r3, r3
    7b2e:	f003 0320 	and.w	r3, r3, #32
    7b32:	2b00      	cmp	r3, #0
    7b34:	d002      	beq.n	7b3c <CLOCK_GetFllFreq+0x28>
    {
        ret = 0U;
    7b36:	2300      	movs	r3, #0
    7b38:	60fb      	str	r3, [r7, #12]
    7b3a:	e024      	b.n	7b86 <CLOCK_GetFllFreq+0x72>
    }
    else
    {
        /* Get FLL reference clock frequency. */
        freq = CLOCK_GetFllRefClkFreq();
    7b3c:	f7ff fce4 	bl	7508 <CLOCK_GetFllRefClkFreq>
    7b40:	60b8      	str	r0, [r7, #8]
        if (0U == freq)
    7b42:	68bb      	ldr	r3, [r7, #8]
    7b44:	2b00      	cmp	r3, #0
    7b46:	d102      	bne.n	7b4e <CLOCK_GetFllFreq+0x3a>
        {
            ret = freq;
    7b48:	68bb      	ldr	r3, [r7, #8]
    7b4a:	60fb      	str	r3, [r7, #12]
    7b4c:	e01b      	b.n	7b86 <CLOCK_GetFllFreq+0x72>
        }
        else
        {
            drs   = MCG_C4_DRST_DRS_VAL;
    7b4e:	4b10      	ldr	r3, [pc, #64]	; (7b90 <CLOCK_GetFllFreq+0x7c>)
    7b50:	78db      	ldrb	r3, [r3, #3]
    7b52:	b2db      	uxtb	r3, r3
    7b54:	095b      	lsrs	r3, r3, #5
    7b56:	b2db      	uxtb	r3, r3
    7b58:	f003 0303 	and.w	r3, r3, #3
    7b5c:	71fb      	strb	r3, [r7, #7]
            dmx32 = MCG_C4_DMX32_VAL;
    7b5e:	4b0c      	ldr	r3, [pc, #48]	; (7b90 <CLOCK_GetFllFreq+0x7c>)
    7b60:	78db      	ldrb	r3, [r3, #3]
    7b62:	b2db      	uxtb	r3, r3
    7b64:	09db      	lsrs	r3, r3, #7
    7b66:	b2db      	uxtb	r3, r3
    7b68:	f003 0301 	and.w	r3, r3, #1
    7b6c:	71bb      	strb	r3, [r7, #6]
            ret   = freq * fllFactorTable[drs][dmx32];
    7b6e:	79fa      	ldrb	r2, [r7, #7]
    7b70:	79bb      	ldrb	r3, [r7, #6]
    7b72:	4908      	ldr	r1, [pc, #32]	; (7b94 <CLOCK_GetFllFreq+0x80>)
    7b74:	0052      	lsls	r2, r2, #1
    7b76:	4413      	add	r3, r2
    7b78:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    7b7c:	461a      	mov	r2, r3
    7b7e:	68bb      	ldr	r3, [r7, #8]
    7b80:	fb02 f303 	mul.w	r3, r2, r3
    7b84:	60fb      	str	r3, [r7, #12]
        }
    }

    return ret;
    7b86:	68fb      	ldr	r3, [r7, #12]
}
    7b88:	4618      	mov	r0, r3
    7b8a:	3710      	adds	r7, #16
    7b8c:	46bd      	mov	sp, r7
    7b8e:	bd80      	pop	{r7, pc}
    7b90:	40064000 	.word	0x40064000
    7b94:	0000f87c 	.word	0x0000f87c

00007b98 <CLOCK_GetInternalRefClkFreq>:
 * on the current MCG register value.
 *
 * return The frequency of MCGIRCLK.
 */
uint32_t CLOCK_GetInternalRefClkFreq(void)
{
    7b98:	b580      	push	{r7, lr}
    7b9a:	b082      	sub	sp, #8
    7b9c:	af00      	add	r7, sp, #0
    uint32_t freq;

    /* If MCGIRCLK is gated. */
    if (0U == (MCG->C1 & MCG_C1_IRCLKEN_MASK))
    7b9e:	4b09      	ldr	r3, [pc, #36]	; (7bc4 <CLOCK_GetInternalRefClkFreq+0x2c>)
    7ba0:	781b      	ldrb	r3, [r3, #0]
    7ba2:	b2db      	uxtb	r3, r3
    7ba4:	f003 0302 	and.w	r3, r3, #2
    7ba8:	2b00      	cmp	r3, #0
    7baa:	d102      	bne.n	7bb2 <CLOCK_GetInternalRefClkFreq+0x1a>
    {
        freq = 0U;
    7bac:	2300      	movs	r3, #0
    7bae:	607b      	str	r3, [r7, #4]
    7bb0:	e002      	b.n	7bb8 <CLOCK_GetInternalRefClkFreq+0x20>
    }
    else
    {
        freq = CLOCK_GetInternalRefClkSelectFreq();
    7bb2:	f7ff fc83 	bl	74bc <CLOCK_GetInternalRefClkSelectFreq>
    7bb6:	6078      	str	r0, [r7, #4]
    }

    return freq;
    7bb8:	687b      	ldr	r3, [r7, #4]
}
    7bba:	4618      	mov	r0, r3
    7bbc:	3708      	adds	r7, #8
    7bbe:	46bd      	mov	sp, r7
    7bc0:	bd80      	pop	{r7, pc}
    7bc2:	bf00      	nop
    7bc4:	40064000 	.word	0x40064000

00007bc8 <CLOCK_GetFixedFreqClkFreq>:
 * on the current MCG register value.
 *
 * return The frequency of MCGFFCLK.
 */
uint32_t CLOCK_GetFixedFreqClkFreq(void)
{
    7bc8:	b580      	push	{r7, lr}
    7bca:	b082      	sub	sp, #8
    7bcc:	af00      	add	r7, sp, #0
    uint32_t freq = CLOCK_GetFllRefClkFreq();
    7bce:	f7ff fc9b 	bl	7508 <CLOCK_GetFllRefClkFreq>
    7bd2:	6038      	str	r0, [r7, #0]
    uint32_t ret;

    /* MCGFFCLK must be no more than MCGOUTCLK/8. */
    if ((freq <= (CLOCK_GetOutClkFreq() / 8U)) && (0U != freq))
    7bd4:	f7ff ff56 	bl	7a84 <CLOCK_GetOutClkFreq>
    7bd8:	4603      	mov	r3, r0
    7bda:	08db      	lsrs	r3, r3, #3
    7bdc:	683a      	ldr	r2, [r7, #0]
    7bde:	429a      	cmp	r2, r3
    7be0:	d805      	bhi.n	7bee <CLOCK_GetFixedFreqClkFreq+0x26>
    7be2:	683b      	ldr	r3, [r7, #0]
    7be4:	2b00      	cmp	r3, #0
    7be6:	d002      	beq.n	7bee <CLOCK_GetFixedFreqClkFreq+0x26>
    {
        ret = freq;
    7be8:	683b      	ldr	r3, [r7, #0]
    7bea:	607b      	str	r3, [r7, #4]
    7bec:	e001      	b.n	7bf2 <CLOCK_GetFixedFreqClkFreq+0x2a>
    }
    else
    {
        ret = 0U;
    7bee:	2300      	movs	r3, #0
    7bf0:	607b      	str	r3, [r7, #4]
    }

    return ret;
    7bf2:	687b      	ldr	r3, [r7, #4]
}
    7bf4:	4618      	mov	r0, r3
    7bf6:	3708      	adds	r7, #8
    7bf8:	46bd      	mov	sp, r7
    7bfa:	bd80      	pop	{r7, pc}

00007bfc <CLOCK_GetPll0Freq>:
 * register value.
 *
 * return The frequency of MCGPLL0CLK.
 */
uint32_t CLOCK_GetPll0Freq(void)
{
    7bfc:	b580      	push	{r7, lr}
    7bfe:	b084      	sub	sp, #16
    7c00:	af00      	add	r7, sp, #0
    uint32_t freq;

    uint8_t mcgpll0prdiv;
    uint8_t mcgpll0vdiv;
    /* If PLL0 is not enabled, return 0. */
    if (((MCG->S & MCG_S_LOCK0_MASK)) == 0U)
    7c02:	4b1d      	ldr	r3, [pc, #116]	; (7c78 <CLOCK_GetPll0Freq+0x7c>)
    7c04:	799b      	ldrb	r3, [r3, #6]
    7c06:	b2db      	uxtb	r3, r3
    7c08:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7c0c:	2b00      	cmp	r3, #0
    7c0e:	d102      	bne.n	7c16 <CLOCK_GetPll0Freq+0x1a>
    {
        freq = 0U;
    7c10:	2300      	movs	r3, #0
    7c12:	60fb      	str	r3, [r7, #12]
    7c14:	e02b      	b.n	7c6e <CLOCK_GetPll0Freq+0x72>
    }
    else
    {
        mcgpll0clk = CLOCK_GetPll0RefFreq();
    7c16:	f7ff fc91 	bl	753c <CLOCK_GetPll0RefFreq>
    7c1a:	60b8      	str	r0, [r7, #8]

        /*
         * Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock.
         * Please call CLOCK_SetXtal1Freq base on board setting before using OSC1 clock.
         */
        assert(mcgpll0clk);
    7c1c:	68bb      	ldr	r3, [r7, #8]
    7c1e:	2b00      	cmp	r3, #0
    7c20:	d106      	bne.n	7c30 <CLOCK_GetPll0Freq+0x34>
    7c22:	4b16      	ldr	r3, [pc, #88]	; (7c7c <CLOCK_GetPll0Freq+0x80>)
    7c24:	4a16      	ldr	r2, [pc, #88]	; (7c80 <CLOCK_GetPll0Freq+0x84>)
    7c26:	f240 31df 	movw	r1, #991	; 0x3df
    7c2a:	4816      	ldr	r0, [pc, #88]	; (7c84 <CLOCK_GetPll0Freq+0x88>)
    7c2c:	f7ff fad6 	bl	71dc <__assert_func>

        mcgpll0prdiv = ((uint8_t)FSL_FEATURE_MCG_PLL_PRDIV_BASE + MCG_C5_PRDIV0_VAL);
    7c30:	4b11      	ldr	r3, [pc, #68]	; (7c78 <CLOCK_GetPll0Freq+0x7c>)
    7c32:	791b      	ldrb	r3, [r3, #4]
    7c34:	b2db      	uxtb	r3, r3
    7c36:	f003 0307 	and.w	r3, r3, #7
    7c3a:	b2db      	uxtb	r3, r3
    7c3c:	3301      	adds	r3, #1
    7c3e:	71fb      	strb	r3, [r7, #7]
        mcgpll0clk /= (uint32_t)mcgpll0prdiv;
    7c40:	79fb      	ldrb	r3, [r7, #7]
    7c42:	68ba      	ldr	r2, [r7, #8]
    7c44:	fbb2 f3f3 	udiv	r3, r2, r3
    7c48:	60bb      	str	r3, [r7, #8]
        mcgpll0vdiv = ((uint8_t)FSL_FEATURE_MCG_PLL_VDIV_BASE + MCG_C6_VDIV0_VAL);
    7c4a:	4b0b      	ldr	r3, [pc, #44]	; (7c78 <CLOCK_GetPll0Freq+0x7c>)
    7c4c:	795b      	ldrb	r3, [r3, #5]
    7c4e:	b2db      	uxtb	r3, r3
    7c50:	f003 031f 	and.w	r3, r3, #31
    7c54:	b2db      	uxtb	r3, r3
    7c56:	3310      	adds	r3, #16
    7c58:	71bb      	strb	r3, [r7, #6]
        mcgpll0clk *= (uint32_t)mcgpll0vdiv;
    7c5a:	79ba      	ldrb	r2, [r7, #6]
    7c5c:	68bb      	ldr	r3, [r7, #8]
    7c5e:	fb02 f303 	mul.w	r3, r2, r3
    7c62:	60bb      	str	r3, [r7, #8]

        mcgpll0clk >>= 1UL;
    7c64:	68bb      	ldr	r3, [r7, #8]
    7c66:	085b      	lsrs	r3, r3, #1
    7c68:	60bb      	str	r3, [r7, #8]
        freq = mcgpll0clk;
    7c6a:	68bb      	ldr	r3, [r7, #8]
    7c6c:	60fb      	str	r3, [r7, #12]
    }

    return freq;
    7c6e:	68fb      	ldr	r3, [r7, #12]
}
    7c70:	4618      	mov	r0, r3
    7c72:	3710      	adds	r7, #16
    7c74:	46bd      	mov	sp, r7
    7c76:	bd80      	pop	{r7, pc}
    7c78:	40064000 	.word	0x40064000
    7c7c:	0000f7a0 	.word	0x0000f7a0
    7c80:	0000f88c 	.word	0x0000f88c
    7c84:	0000f674 	.word	0x0000f674

00007c88 <CLOCK_GetExtPllFreq>:
 * This function gets the MCG external PLL frequency in Hz.
 *
 * return The frequency of the MCG external PLL.
 */
uint32_t CLOCK_GetExtPllFreq(void)
{
    7c88:	b480      	push	{r7}
    7c8a:	af00      	add	r7, sp, #0
    return s_extPllFreq;
    7c8c:	4b03      	ldr	r3, [pc, #12]	; (7c9c <CLOCK_GetExtPllFreq+0x14>)
    7c8e:	681b      	ldr	r3, [r3, #0]
}
    7c90:	4618      	mov	r0, r3
    7c92:	46bd      	mov	sp, r7
    7c94:	f85d 7b04 	ldr.w	r7, [sp], #4
    7c98:	4770      	bx	lr
    7c9a:	bf00      	nop
    7c9c:	1fff1430 	.word	0x1fff1430

00007ca0 <CLOCK_SetExternalRefClkConfig>:
 * retval kStatus_MCG_SourceUsed Because the external reference clock is used as a clock source,
 * the configuration should not be changed. Otherwise, a glitch occurs.
 * retval kStatus_Success External reference clock set successfully.
 */
status_t CLOCK_SetExternalRefClkConfig(mcg_oscsel_t oscsel)
{
    7ca0:	b480      	push	{r7}
    7ca2:	b085      	sub	sp, #20
    7ca4:	af00      	add	r7, sp, #0
    7ca6:	4603      	mov	r3, r0
    7ca8:	71fb      	strb	r3, [r7, #7]
    {
        return kStatus_MCG_SourceUsed;
    }
#endif /* MCG_CONFIG_CHECK_PARAM */

    if (MCG_C7_OSCSEL_VAL != (uint8_t)oscsel)
    7caa:	4b17      	ldr	r3, [pc, #92]	; (7d08 <CLOCK_SetExternalRefClkConfig+0x68>)
    7cac:	7b1b      	ldrb	r3, [r3, #12]
    7cae:	b2db      	uxtb	r3, r3
    7cb0:	f003 0203 	and.w	r2, r3, #3
    7cb4:	79fb      	ldrb	r3, [r7, #7]
    7cb6:	429a      	cmp	r2, r3
    7cb8:	d002      	beq.n	7cc0 <CLOCK_SetExternalRefClkConfig+0x20>
    {
        /* If change OSCSEL, need to delay, ERR009878. */
        needDelay = true;
    7cba:	2301      	movs	r3, #1
    7cbc:	73fb      	strb	r3, [r7, #15]
    7cbe:	e001      	b.n	7cc4 <CLOCK_SetExternalRefClkConfig+0x24>
    }
    else
    {
        needDelay = false;
    7cc0:	2300      	movs	r3, #0
    7cc2:	73fb      	strb	r3, [r7, #15]
    }

    MCG->C7 = (uint8_t)(MCG->C7 & ~MCG_C7_OSCSEL_MASK) | MCG_C7_OSCSEL(oscsel);
    7cc4:	4b10      	ldr	r3, [pc, #64]	; (7d08 <CLOCK_SetExternalRefClkConfig+0x68>)
    7cc6:	7b1b      	ldrb	r3, [r3, #12]
    7cc8:	b2db      	uxtb	r3, r3
    7cca:	f023 0303 	bic.w	r3, r3, #3
    7cce:	b2da      	uxtb	r2, r3
    7cd0:	79fb      	ldrb	r3, [r7, #7]
    7cd2:	f003 0303 	and.w	r3, r3, #3
    7cd6:	b2db      	uxtb	r3, r3
    7cd8:	490b      	ldr	r1, [pc, #44]	; (7d08 <CLOCK_SetExternalRefClkConfig+0x68>)
    7cda:	4313      	orrs	r3, r2
    7cdc:	b2db      	uxtb	r3, r3
    7cde:	730b      	strb	r3, [r1, #12]
    if (needDelay)
    7ce0:	7bfb      	ldrb	r3, [r7, #15]
    7ce2:	2b00      	cmp	r3, #0
    7ce4:	d009      	beq.n	7cfa <CLOCK_SetExternalRefClkConfig+0x5a>
    {
        /* ERR009878 Delay at least 50 micro-seconds for external clock change valid. */
        i = 1500U;
    7ce6:	f240 53dc 	movw	r3, #1500	; 0x5dc
    7cea:	60bb      	str	r3, [r7, #8]
        while (0U != (i--))
    7cec:	e000      	b.n	7cf0 <CLOCK_SetExternalRefClkConfig+0x50>
        {
            __NOP();
    7cee:	bf00      	nop
        while (0U != (i--))
    7cf0:	68bb      	ldr	r3, [r7, #8]
    7cf2:	1e5a      	subs	r2, r3, #1
    7cf4:	60ba      	str	r2, [r7, #8]
    7cf6:	2b00      	cmp	r3, #0
    7cf8:	d1f9      	bne.n	7cee <CLOCK_SetExternalRefClkConfig+0x4e>
        }
    }

    return kStatus_Success;
    7cfa:	2300      	movs	r3, #0
}
    7cfc:	4618      	mov	r0, r3
    7cfe:	3714      	adds	r7, #20
    7d00:	46bd      	mov	sp, r7
    7d02:	f85d 7b04 	ldr.w	r7, [sp], #4
    7d06:	4770      	bx	lr
    7d08:	40064000 	.word	0x40064000

00007d0c <CLOCK_SetInternalRefClkConfig>:
 * retval kStatus_MCG_SourceUsed Because the internal reference clock is used as a clock source,
 * the configuration should not be changed. Otherwise, a glitch occurs.
 * retval kStatus_Success MCGIRCLK configuration finished successfully.
 */
status_t CLOCK_SetInternalRefClkConfig(uint8_t enableMode, mcg_irc_mode_t ircs, uint8_t fcrdiv)
{
    7d0c:	b480      	push	{r7}
    7d0e:	b085      	sub	sp, #20
    7d10:	af00      	add	r7, sp, #0
    7d12:	4603      	mov	r3, r0
    7d14:	71fb      	strb	r3, [r7, #7]
    7d16:	460b      	mov	r3, r1
    7d18:	71bb      	strb	r3, [r7, #6]
    7d1a:	4613      	mov	r3, r2
    7d1c:	717b      	strb	r3, [r7, #5]
    uint32_t mcgOutClkState = (uint32_t)MCG_S_CLKST_VAL;
    7d1e:	4b3b      	ldr	r3, [pc, #236]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7d20:	799b      	ldrb	r3, [r3, #6]
    7d22:	b2db      	uxtb	r3, r3
    7d24:	089b      	lsrs	r3, r3, #2
    7d26:	f003 0303 	and.w	r3, r3, #3
    7d2a:	60fb      	str	r3, [r7, #12]
    mcg_irc_mode_t curIrcs  = (mcg_irc_mode_t)((uint32_t)MCG_S_IRCST_VAL);
    7d2c:	4b37      	ldr	r3, [pc, #220]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7d2e:	799b      	ldrb	r3, [r3, #6]
    7d30:	b2db      	uxtb	r3, r3
    7d32:	f003 0301 	and.w	r3, r3, #1
    7d36:	72fb      	strb	r3, [r7, #11]
    uint8_t curFcrdiv       = MCG_SC_FCRDIV_VAL;
    7d38:	4b34      	ldr	r3, [pc, #208]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7d3a:	7a1b      	ldrb	r3, [r3, #8]
    7d3c:	b2db      	uxtb	r3, r3
    7d3e:	085b      	lsrs	r3, r3, #1
    7d40:	b2db      	uxtb	r3, r3
    7d42:	f003 0307 	and.w	r3, r3, #7
    7d46:	72bb      	strb	r3, [r7, #10]
        }
    }
#endif

    /* If need to update the FCRDIV. */
    if (fcrdiv != curFcrdiv)
    7d48:	797a      	ldrb	r2, [r7, #5]
    7d4a:	7abb      	ldrb	r3, [r7, #10]
    7d4c:	429a      	cmp	r2, r3
    7d4e:	d02c      	beq.n	7daa <CLOCK_SetInternalRefClkConfig+0x9e>
    {
        /* If fast IRC is in use currently, change to slow IRC. */
        if (((0U != (MCG->C1 & MCG_C1_IRCLKEN_MASK)) || (mcgOutClkState == (uint32_t)kMCG_ClkOutStatInt)) &&
    7d50:	4b2e      	ldr	r3, [pc, #184]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7d52:	781b      	ldrb	r3, [r3, #0]
    7d54:	b2db      	uxtb	r3, r3
    7d56:	f003 0302 	and.w	r3, r3, #2
    7d5a:	2b00      	cmp	r3, #0
    7d5c:	d102      	bne.n	7d64 <CLOCK_SetInternalRefClkConfig+0x58>
    7d5e:	68fb      	ldr	r3, [r7, #12]
    7d60:	2b01      	cmp	r3, #1
    7d62:	d112      	bne.n	7d8a <CLOCK_SetInternalRefClkConfig+0x7e>
    7d64:	7afb      	ldrb	r3, [r7, #11]
    7d66:	2b01      	cmp	r3, #1
    7d68:	d10f      	bne.n	7d8a <CLOCK_SetInternalRefClkConfig+0x7e>
            (kMCG_IrcFast == curIrcs))
        {
            MCG->C2 = (uint8_t)((MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(kMCG_IrcSlow)));
    7d6a:	4b28      	ldr	r3, [pc, #160]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7d6c:	785b      	ldrb	r3, [r3, #1]
    7d6e:	b2db      	uxtb	r3, r3
    7d70:	4a26      	ldr	r2, [pc, #152]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7d72:	f023 0301 	bic.w	r3, r3, #1
    7d76:	b2db      	uxtb	r3, r3
    7d78:	7053      	strb	r3, [r2, #1]
            while (MCG_S_IRCST_VAL != (uint8_t)kMCG_IrcSlow)
    7d7a:	bf00      	nop
    7d7c:	4b23      	ldr	r3, [pc, #140]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7d7e:	799b      	ldrb	r3, [r3, #6]
    7d80:	b2db      	uxtb	r3, r3
    7d82:	f003 0301 	and.w	r3, r3, #1
    7d86:	2b00      	cmp	r3, #0
    7d88:	d1f8      	bne.n	7d7c <CLOCK_SetInternalRefClkConfig+0x70>
            {
            }
        }
        /* Update FCRDIV. */
        MCG->SC =
            (uint8_t)(MCG->SC & ~(MCG_SC_FCRDIV_MASK | MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK)) | MCG_SC_FCRDIV(fcrdiv);
    7d8a:	4b20      	ldr	r3, [pc, #128]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7d8c:	7a1b      	ldrb	r3, [r3, #8]
    7d8e:	b2db      	uxtb	r3, r3
    7d90:	f023 032f 	bic.w	r3, r3, #47	; 0x2f
    7d94:	b2da      	uxtb	r2, r3
    7d96:	797b      	ldrb	r3, [r7, #5]
    7d98:	005b      	lsls	r3, r3, #1
    7d9a:	b2db      	uxtb	r3, r3
    7d9c:	f003 030e 	and.w	r3, r3, #14
    7da0:	b2db      	uxtb	r3, r3
        MCG->SC =
    7da2:	491a      	ldr	r1, [pc, #104]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
            (uint8_t)(MCG->SC & ~(MCG_SC_FCRDIV_MASK | MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK)) | MCG_SC_FCRDIV(fcrdiv);
    7da4:	4313      	orrs	r3, r2
    7da6:	b2db      	uxtb	r3, r3
        MCG->SC =
    7da8:	720b      	strb	r3, [r1, #8]
    }

    /* Set internal reference clock selection. */
    MCG->C2 = (uint8_t)((MCG->C2 & ~MCG_C2_IRCS_MASK) | (MCG_C2_IRCS(ircs)));
    7daa:	4b18      	ldr	r3, [pc, #96]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7dac:	785b      	ldrb	r3, [r3, #1]
    7dae:	b2db      	uxtb	r3, r3
    7db0:	f023 0301 	bic.w	r3, r3, #1
    7db4:	b2da      	uxtb	r2, r3
    7db6:	79bb      	ldrb	r3, [r7, #6]
    7db8:	f003 0301 	and.w	r3, r3, #1
    7dbc:	b2db      	uxtb	r3, r3
    7dbe:	4913      	ldr	r1, [pc, #76]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7dc0:	4313      	orrs	r3, r2
    7dc2:	b2db      	uxtb	r3, r3
    7dc4:	704b      	strb	r3, [r1, #1]
    MCG->C1 = (uint8_t)((MCG->C1 & ~(MCG_C1_IRCLKEN_MASK | MCG_C1_IREFSTEN_MASK)) | (uint8_t)enableMode);
    7dc6:	4b11      	ldr	r3, [pc, #68]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7dc8:	781b      	ldrb	r3, [r3, #0]
    7dca:	b2db      	uxtb	r3, r3
    7dcc:	f023 0303 	bic.w	r3, r3, #3
    7dd0:	b2da      	uxtb	r2, r3
    7dd2:	490e      	ldr	r1, [pc, #56]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7dd4:	79fb      	ldrb	r3, [r7, #7]
    7dd6:	4313      	orrs	r3, r2
    7dd8:	b2db      	uxtb	r3, r3
    7dda:	700b      	strb	r3, [r1, #0]

    /* If MCGIRCLK is used, need to wait for MCG_S_IRCST. */
    if ((mcgOutClkState == (uint32_t)kMCG_ClkOutStatInt) || (0U != (enableMode & (uint32_t)kMCG_IrclkEnable)))
    7ddc:	68fb      	ldr	r3, [r7, #12]
    7dde:	2b01      	cmp	r3, #1
    7de0:	d004      	beq.n	7dec <CLOCK_SetInternalRefClkConfig+0xe0>
    7de2:	79fb      	ldrb	r3, [r7, #7]
    7de4:	f003 0302 	and.w	r3, r3, #2
    7de8:	2b00      	cmp	r3, #0
    7dea:	d008      	beq.n	7dfe <CLOCK_SetInternalRefClkConfig+0xf2>
    {
        while (MCG_S_IRCST_VAL != (uint8_t)ircs)
    7dec:	bf00      	nop
    7dee:	4b07      	ldr	r3, [pc, #28]	; (7e0c <CLOCK_SetInternalRefClkConfig+0x100>)
    7df0:	799b      	ldrb	r3, [r3, #6]
    7df2:	b2db      	uxtb	r3, r3
    7df4:	f003 0201 	and.w	r2, r3, #1
    7df8:	79bb      	ldrb	r3, [r7, #6]
    7dfa:	429a      	cmp	r2, r3
    7dfc:	d1f7      	bne.n	7dee <CLOCK_SetInternalRefClkConfig+0xe2>
        {
        }
    }

    return kStatus_Success;
    7dfe:	2300      	movs	r3, #0
}
    7e00:	4618      	mov	r0, r3
    7e02:	3714      	adds	r7, #20
    7e04:	46bd      	mov	sp, r7
    7e06:	f85d 7b04 	ldr.w	r7, [sp], #4
    7e0a:	4770      	bx	lr
    7e0c:	40064000 	.word	0x40064000

00007e10 <CLOCK_EnablePll0>:
 * divider values.
 *
 * param config Pointer to the configuration structure.
 */
void CLOCK_EnablePll0(mcg_pll_config_t const *config)
{
    7e10:	b580      	push	{r7, lr}
    7e12:	b084      	sub	sp, #16
    7e14:	af00      	add	r7, sp, #0
    7e16:	6078      	str	r0, [r7, #4]
    assert(config);
    7e18:	687b      	ldr	r3, [r7, #4]
    7e1a:	2b00      	cmp	r3, #0
    7e1c:	d106      	bne.n	7e2c <CLOCK_EnablePll0+0x1c>
    7e1e:	4b1e      	ldr	r3, [pc, #120]	; (7e98 <CLOCK_EnablePll0+0x88>)
    7e20:	4a1e      	ldr	r2, [pc, #120]	; (7e9c <CLOCK_EnablePll0+0x8c>)
    7e22:	f240 41fd 	movw	r1, #1277	; 0x4fd
    7e26:	481e      	ldr	r0, [pc, #120]	; (7ea0 <CLOCK_EnablePll0+0x90>)
    7e28:	f7ff f9d8 	bl	71dc <__assert_func>

    uint8_t mcg_c5 = 0U;
    7e2c:	2300      	movs	r3, #0
    7e2e:	73fb      	strb	r3, [r7, #15]

    mcg_c5 |= MCG_C5_PRDIV0(config->prdiv);
    7e30:	687b      	ldr	r3, [r7, #4]
    7e32:	785b      	ldrb	r3, [r3, #1]
    7e34:	f003 0307 	and.w	r3, r3, #7
    7e38:	b2da      	uxtb	r2, r3
    7e3a:	7bfb      	ldrb	r3, [r7, #15]
    7e3c:	4313      	orrs	r3, r2
    7e3e:	73fb      	strb	r3, [r7, #15]
    MCG->C5 = mcg_c5; /* Disable the PLL first. */
    7e40:	4a18      	ldr	r2, [pc, #96]	; (7ea4 <CLOCK_EnablePll0+0x94>)
    7e42:	7bfb      	ldrb	r3, [r7, #15]
    7e44:	7113      	strb	r3, [r2, #4]

    MCG->C6 = (uint8_t)((MCG->C6 & ~MCG_C6_VDIV0_MASK) | MCG_C6_VDIV0(config->vdiv));
    7e46:	4b17      	ldr	r3, [pc, #92]	; (7ea4 <CLOCK_EnablePll0+0x94>)
    7e48:	795b      	ldrb	r3, [r3, #5]
    7e4a:	b2db      	uxtb	r3, r3
    7e4c:	f023 031f 	bic.w	r3, r3, #31
    7e50:	b2da      	uxtb	r2, r3
    7e52:	687b      	ldr	r3, [r7, #4]
    7e54:	789b      	ldrb	r3, [r3, #2]
    7e56:	f003 031f 	and.w	r3, r3, #31
    7e5a:	b2db      	uxtb	r3, r3
    7e5c:	4911      	ldr	r1, [pc, #68]	; (7ea4 <CLOCK_EnablePll0+0x94>)
    7e5e:	4313      	orrs	r3, r2
    7e60:	b2db      	uxtb	r3, r3
    7e62:	714b      	strb	r3, [r1, #5]

    /* Set enable mode. */
    MCG->C5 |= ((uint8_t)kMCG_PllEnableIndependent | (uint8_t)config->enableMode);
    7e64:	4b0f      	ldr	r3, [pc, #60]	; (7ea4 <CLOCK_EnablePll0+0x94>)
    7e66:	791b      	ldrb	r3, [r3, #4]
    7e68:	b2da      	uxtb	r2, r3
    7e6a:	687b      	ldr	r3, [r7, #4]
    7e6c:	781b      	ldrb	r3, [r3, #0]
    7e6e:	4313      	orrs	r3, r2
    7e70:	b2db      	uxtb	r3, r3
    7e72:	4a0c      	ldr	r2, [pc, #48]	; (7ea4 <CLOCK_EnablePll0+0x94>)
    7e74:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    7e78:	b2db      	uxtb	r3, r3
    7e7a:	7113      	strb	r3, [r2, #4]

    /* Wait for PLL lock. */
    while (((MCG->S & MCG_S_LOCK0_MASK)) == 0U)
    7e7c:	bf00      	nop
    7e7e:	4b09      	ldr	r3, [pc, #36]	; (7ea4 <CLOCK_EnablePll0+0x94>)
    7e80:	799b      	ldrb	r3, [r3, #6]
    7e82:	b2db      	uxtb	r3, r3
    7e84:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7e88:	2b00      	cmp	r3, #0
    7e8a:	d0f8      	beq.n	7e7e <CLOCK_EnablePll0+0x6e>
    {
    }
}
    7e8c:	bf00      	nop
    7e8e:	bf00      	nop
    7e90:	3710      	adds	r7, #16
    7e92:	46bd      	mov	sp, r7
    7e94:	bd80      	pop	{r7, pc}
    7e96:	bf00      	nop
    7e98:	0000f7ac 	.word	0x0000f7ac
    7e9c:	0000f8a0 	.word	0x0000f8a0
    7ea0:	0000f674 	.word	0x0000f674
    7ea4:	40064000 	.word	0x40064000

00007ea8 <CLOCK_InitOsc0>:
 * This function initializes the OSC0 according to the board configuration.
 *
 * param  config Pointer to the OSC0 configuration structure.
 */
void CLOCK_InitOsc0(osc_config_t const *config)
{
    7ea8:	b580      	push	{r7, lr}
    7eaa:	b084      	sub	sp, #16
    7eac:	af00      	add	r7, sp, #0
    7eae:	6078      	str	r0, [r7, #4]
    uint8_t range = CLOCK_GetOscRangeFromFreq(config->freq);
    7eb0:	687b      	ldr	r3, [r7, #4]
    7eb2:	681b      	ldr	r3, [r3, #0]
    7eb4:	4618      	mov	r0, r3
    7eb6:	f7ff fb49 	bl	754c <CLOCK_GetOscRangeFromFreq>
    7eba:	4603      	mov	r3, r0
    7ebc:	73fb      	strb	r3, [r7, #15]

    OSC_SetCapLoad(OSC0, config->capLoad);
    7ebe:	687b      	ldr	r3, [r7, #4]
    7ec0:	791b      	ldrb	r3, [r3, #4]
    7ec2:	4619      	mov	r1, r3
    7ec4:	4819      	ldr	r0, [pc, #100]	; (7f2c <CLOCK_InitOsc0+0x84>)
    7ec6:	f7ff fa2b 	bl	7320 <OSC_SetCapLoad>

    MCG->C2 = (uint8_t)((MCG->C2 & ~OSC_MODE_MASK) | MCG_C2_RANGE(range) | (uint8_t)config->workMode);
    7eca:	4b19      	ldr	r3, [pc, #100]	; (7f30 <CLOCK_InitOsc0+0x88>)
    7ecc:	785b      	ldrb	r3, [r3, #1]
    7ece:	b2db      	uxtb	r3, r3
    7ed0:	f023 033c 	bic.w	r3, r3, #60	; 0x3c
    7ed4:	b2da      	uxtb	r2, r3
    7ed6:	7bfb      	ldrb	r3, [r7, #15]
    7ed8:	011b      	lsls	r3, r3, #4
    7eda:	b2db      	uxtb	r3, r3
    7edc:	f003 0330 	and.w	r3, r3, #48	; 0x30
    7ee0:	b2db      	uxtb	r3, r3
    7ee2:	4313      	orrs	r3, r2
    7ee4:	b2da      	uxtb	r2, r3
    7ee6:	687b      	ldr	r3, [r7, #4]
    7ee8:	795b      	ldrb	r3, [r3, #5]
    7eea:	4911      	ldr	r1, [pc, #68]	; (7f30 <CLOCK_InitOsc0+0x88>)
    7eec:	4313      	orrs	r3, r2
    7eee:	b2db      	uxtb	r3, r3
    7ef0:	704b      	strb	r3, [r1, #1]
    OSC_SetExtRefClkConfig(OSC0, &config->oscerConfig);
    7ef2:	687b      	ldr	r3, [r7, #4]
    7ef4:	3306      	adds	r3, #6
    7ef6:	4619      	mov	r1, r3
    7ef8:	480c      	ldr	r0, [pc, #48]	; (7f2c <CLOCK_InitOsc0+0x84>)
    7efa:	f7ff f9f1 	bl	72e0 <OSC_SetExtRefClkConfig>

    if ((kOSC_ModeExt != config->workMode) && ((OSC0->CR & OSC_CR_ERCLKEN_MASK) != 0U))
    7efe:	687b      	ldr	r3, [r7, #4]
    7f00:	795b      	ldrb	r3, [r3, #5]
    7f02:	2b00      	cmp	r3, #0
    7f04:	d00d      	beq.n	7f22 <CLOCK_InitOsc0+0x7a>
    7f06:	4b09      	ldr	r3, [pc, #36]	; (7f2c <CLOCK_InitOsc0+0x84>)
    7f08:	781b      	ldrb	r3, [r3, #0]
    7f0a:	b2db      	uxtb	r3, r3
    7f0c:	b25b      	sxtb	r3, r3
    7f0e:	2b00      	cmp	r3, #0
    7f10:	da07      	bge.n	7f22 <CLOCK_InitOsc0+0x7a>
    {
        /* Wait for stable. */
        while (0U == (MCG->S & MCG_S_OSCINIT0_MASK))
    7f12:	bf00      	nop
    7f14:	4b06      	ldr	r3, [pc, #24]	; (7f30 <CLOCK_InitOsc0+0x88>)
    7f16:	799b      	ldrb	r3, [r3, #6]
    7f18:	b2db      	uxtb	r3, r3
    7f1a:	f003 0302 	and.w	r3, r3, #2
    7f1e:	2b00      	cmp	r3, #0
    7f20:	d0f8      	beq.n	7f14 <CLOCK_InitOsc0+0x6c>
        {
        }
    }
}
    7f22:	bf00      	nop
    7f24:	3710      	adds	r7, #16
    7f26:	46bd      	mov	sp, r7
    7f28:	bd80      	pop	{r7, pc}
    7f2a:	bf00      	nop
    7f2c:	40065000 	.word	0x40065000
    7f30:	40064000 	.word	0x40064000

00007f34 <CLOCK_GetMode>:
 * This function checks the MCG registers and determines the current MCG mode.
 *
 * return Current MCG mode or error code; See ref mcg_mode_t.
 */
mcg_mode_t CLOCK_GetMode(void)
{
    7f34:	b480      	push	{r7}
    7f36:	b087      	sub	sp, #28
    7f38:	af00      	add	r7, sp, #0
    mcg_mode_t mode = kMCG_ModeError;
    7f3a:	2308      	movs	r3, #8
    7f3c:	75fb      	strb	r3, [r7, #23]
    uint32_t clkst  = (uint32_t)MCG_S_CLKST_VAL;
    7f3e:	4b29      	ldr	r3, [pc, #164]	; (7fe4 <CLOCK_GetMode+0xb0>)
    7f40:	799b      	ldrb	r3, [r3, #6]
    7f42:	b2db      	uxtb	r3, r3
    7f44:	089b      	lsrs	r3, r3, #2
    7f46:	f003 0303 	and.w	r3, r3, #3
    7f4a:	613b      	str	r3, [r7, #16]
    uint32_t irefst = (uint32_t)MCG_S_IREFST_VAL;
    7f4c:	4b25      	ldr	r3, [pc, #148]	; (7fe4 <CLOCK_GetMode+0xb0>)
    7f4e:	799b      	ldrb	r3, [r3, #6]
    7f50:	b2db      	uxtb	r3, r3
    7f52:	091b      	lsrs	r3, r3, #4
    7f54:	f003 0301 	and.w	r3, r3, #1
    7f58:	60fb      	str	r3, [r7, #12]
    uint32_t lp     = (uint32_t)MCG_C2_LP_VAL;
    7f5a:	4b22      	ldr	r3, [pc, #136]	; (7fe4 <CLOCK_GetMode+0xb0>)
    7f5c:	785b      	ldrb	r3, [r3, #1]
    7f5e:	b2db      	uxtb	r3, r3
    7f60:	085b      	lsrs	r3, r3, #1
    7f62:	f003 0301 	and.w	r3, r3, #1
    7f66:	60bb      	str	r3, [r7, #8]
    uint32_t pllst  = MCG_S_PLLST_VAL;
    7f68:	4b1e      	ldr	r3, [pc, #120]	; (7fe4 <CLOCK_GetMode+0xb0>)
    7f6a:	799b      	ldrb	r3, [r3, #6]
    7f6c:	b2db      	uxtb	r3, r3
    7f6e:	095b      	lsrs	r3, r3, #5
    7f70:	f003 0301 	and.w	r3, r3, #1
    7f74:	607b      	str	r3, [r7, #4]
      PEI    |  11(PLL)   |   1(INT)   |   1(PLL)  |      X
    ____________________________________________________________________

    ----------------------------------------------------------------------*/

    if (clkst == (uint32_t)kMCG_ClkOutStatFll)
    7f76:	693b      	ldr	r3, [r7, #16]
    7f78:	2b00      	cmp	r3, #0
    7f7a:	d108      	bne.n	7f8e <CLOCK_GetMode+0x5a>
    {
        if ((uint32_t)kMCG_FllSrcExternal == irefst)
    7f7c:	68fb      	ldr	r3, [r7, #12]
    7f7e:	2b00      	cmp	r3, #0
    7f80:	d102      	bne.n	7f88 <CLOCK_GetMode+0x54>
        {
            mode = kMCG_ModeFEE;
    7f82:	2303      	movs	r3, #3
    7f84:	75fb      	strb	r3, [r7, #23]
    7f86:	e025      	b.n	7fd4 <CLOCK_GetMode+0xa0>
        }
        else
        {
            mode = kMCG_ModeFEI;
    7f88:	2300      	movs	r3, #0
    7f8a:	75fb      	strb	r3, [r7, #23]
    7f8c:	e022      	b.n	7fd4 <CLOCK_GetMode+0xa0>
        }
    }
    else if (clkst == (uint32_t)kMCG_ClkOutStatInt)
    7f8e:	693b      	ldr	r3, [r7, #16]
    7f90:	2b01      	cmp	r3, #1
    7f92:	d108      	bne.n	7fa6 <CLOCK_GetMode+0x72>
    {
        if (0U != lp)
    7f94:	68bb      	ldr	r3, [r7, #8]
    7f96:	2b00      	cmp	r3, #0
    7f98:	d002      	beq.n	7fa0 <CLOCK_GetMode+0x6c>
        {
            mode = kMCG_ModeBLPI;
    7f9a:	2302      	movs	r3, #2
    7f9c:	75fb      	strb	r3, [r7, #23]
    7f9e:	e019      	b.n	7fd4 <CLOCK_GetMode+0xa0>
        }
        else
        {
            {
                mode = kMCG_ModeFBI;
    7fa0:	2301      	movs	r3, #1
    7fa2:	75fb      	strb	r3, [r7, #23]
    7fa4:	e016      	b.n	7fd4 <CLOCK_GetMode+0xa0>
            }
        }
    }
    else if (clkst == (uint32_t)kMCG_ClkOutStatExt)
    7fa6:	693b      	ldr	r3, [r7, #16]
    7fa8:	2b02      	cmp	r3, #2
    7faa:	d10e      	bne.n	7fca <CLOCK_GetMode+0x96>
    {
        if (0U != lp)
    7fac:	68bb      	ldr	r3, [r7, #8]
    7fae:	2b00      	cmp	r3, #0
    7fb0:	d002      	beq.n	7fb8 <CLOCK_GetMode+0x84>
        {
            mode = kMCG_ModeBLPE;
    7fb2:	2305      	movs	r3, #5
    7fb4:	75fb      	strb	r3, [r7, #23]
    7fb6:	e00d      	b.n	7fd4 <CLOCK_GetMode+0xa0>
        }
        else
        {
            if ((uint32_t)kMCG_PllstPll == pllst)
    7fb8:	687b      	ldr	r3, [r7, #4]
    7fba:	2b01      	cmp	r3, #1
    7fbc:	d102      	bne.n	7fc4 <CLOCK_GetMode+0x90>
            {
                mode = kMCG_ModePBE;
    7fbe:	2306      	movs	r3, #6
    7fc0:	75fb      	strb	r3, [r7, #23]
    7fc2:	e007      	b.n	7fd4 <CLOCK_GetMode+0xa0>
            }
            else
            {
                mode = kMCG_ModeFBE;
    7fc4:	2304      	movs	r3, #4
    7fc6:	75fb      	strb	r3, [r7, #23]
    7fc8:	e004      	b.n	7fd4 <CLOCK_GetMode+0xa0>
            }
        }
    }
    else if (clkst == (uint32_t)kMCG_ClkOutStatPll)
    7fca:	693b      	ldr	r3, [r7, #16]
    7fcc:	2b03      	cmp	r3, #3
    7fce:	d101      	bne.n	7fd4 <CLOCK_GetMode+0xa0>
    {
        {
            mode = kMCG_ModePEE;
    7fd0:	2307      	movs	r3, #7
    7fd2:	75fb      	strb	r3, [r7, #23]
    else
    {
        /*do nothing*/
    }

    return mode;
    7fd4:	7dfb      	ldrb	r3, [r7, #23]
}
    7fd6:	4618      	mov	r0, r3
    7fd8:	371c      	adds	r7, #28
    7fda:	46bd      	mov	sp, r7
    7fdc:	f85d 7b04 	ldr.w	r7, [sp], #4
    7fe0:	4770      	bx	lr
    7fe2:	bf00      	nop
    7fe4:	40064000 	.word	0x40064000

00007fe8 <CLOCK_SetFeiMode>:
 * retval kStatus_Success Switched to the target mode successfully.
 * note If p dmx32 is set to kMCG_Dmx32Fine, the slow IRC must not be trimmed
 * to a frequency above 32768 Hz.
 */
status_t CLOCK_SetFeiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
{
    7fe8:	b580      	push	{r7, lr}
    7fea:	b084      	sub	sp, #16
    7fec:	af00      	add	r7, sp, #0
    7fee:	4603      	mov	r3, r0
    7ff0:	603a      	str	r2, [r7, #0]
    7ff2:	71fb      	strb	r3, [r7, #7]
    7ff4:	460b      	mov	r3, r1
    7ff6:	71bb      	strb	r3, [r7, #6]
    uint8_t mcg_c4;
    bool change_drs = false;
    7ff8:	2300      	movs	r3, #0
    7ffa:	73fb      	strb	r3, [r7, #15]
    if (!((kMCG_ModeFEI == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeFEE == mode)))
    {
        return kStatus_MCG_ModeUnreachable;
    }
#endif
    mcg_c4 = MCG->C4;
    7ffc:	4b29      	ldr	r3, [pc, #164]	; (80a4 <CLOCK_SetFeiMode+0xbc>)
    7ffe:	78db      	ldrb	r3, [r3, #3]
    8000:	73bb      	strb	r3, [r7, #14]
       Errata: ERR007993
       Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
       reference clock source changes, then reset to previous value after
       reference clock changes.
     */
    if ((uint8_t)kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
    8002:	4b28      	ldr	r3, [pc, #160]	; (80a4 <CLOCK_SetFeiMode+0xbc>)
    8004:	799b      	ldrb	r3, [r3, #6]
    8006:	b2db      	uxtb	r3, r3
    8008:	f003 0310 	and.w	r3, r3, #16
    800c:	2b00      	cmp	r3, #0
    800e:	d109      	bne.n	8024 <CLOCK_SetFeiMode+0x3c>
    {
        change_drs = true;
    8010:	2301      	movs	r3, #1
    8012:	73fb      	strb	r3, [r7, #15]
        /* Change the LSB of DRST_DRS. */
        MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
    8014:	4b23      	ldr	r3, [pc, #140]	; (80a4 <CLOCK_SetFeiMode+0xbc>)
    8016:	78db      	ldrb	r3, [r3, #3]
    8018:	b2db      	uxtb	r3, r3
    801a:	4a22      	ldr	r2, [pc, #136]	; (80a4 <CLOCK_SetFeiMode+0xbc>)
    801c:	f083 0320 	eor.w	r3, r3, #32
    8020:	b2db      	uxtb	r3, r3
    8022:	70d3      	strb	r3, [r2, #3]
    }

    /* Set CLKS and IREFS. */
    MCG->C1 = (uint8_t)(((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK))) |
    8024:	4b1f      	ldr	r3, [pc, #124]	; (80a4 <CLOCK_SetFeiMode+0xbc>)
    8026:	781b      	ldrb	r3, [r3, #0]
    8028:	b2db      	uxtb	r3, r3
    802a:	f003 033b 	and.w	r3, r3, #59	; 0x3b
    802e:	b2db      	uxtb	r3, r3
    8030:	4a1c      	ldr	r2, [pc, #112]	; (80a4 <CLOCK_SetFeiMode+0xbc>)
    8032:	f043 0304 	orr.w	r3, r3, #4
    8036:	b2db      	uxtb	r3, r3
    8038:	7013      	strb	r3, [r2, #0]
                        (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
                         | MCG_C1_IREFS(kMCG_FllSrcInternal))); /* IREFS = 1 */

    /* Wait and check status. */
    while ((uint8_t)kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
    803a:	bf00      	nop
    803c:	4b19      	ldr	r3, [pc, #100]	; (80a4 <CLOCK_SetFeiMode+0xbc>)
    803e:	799b      	ldrb	r3, [r3, #6]
    8040:	b2db      	uxtb	r3, r3
    8042:	091b      	lsrs	r3, r3, #4
    8044:	f003 0301 	and.w	r3, r3, #1
    8048:	2b01      	cmp	r3, #1
    804a:	d1f7      	bne.n	803c <CLOCK_SetFeiMode+0x54>
    {
    }

    /* Errata: ERR007993 */
    if (change_drs)
    804c:	7bfb      	ldrb	r3, [r7, #15]
    804e:	2b00      	cmp	r3, #0
    8050:	d002      	beq.n	8058 <CLOCK_SetFeiMode+0x70>
    {
        MCG->C4 = mcg_c4;
    8052:	4a14      	ldr	r2, [pc, #80]	; (80a4 <CLOCK_SetFeiMode+0xbc>)
    8054:	7bbb      	ldrb	r3, [r7, #14]
    8056:	70d3      	strb	r3, [r2, #3]
    }

    /* In FEI mode, the MCG_C4[DMX32] is set to 0U. */
    MCG->C4 = (uint8_t)((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) |
    8058:	7bbb      	ldrb	r3, [r7, #14]
    805a:	f003 031f 	and.w	r3, r3, #31
    805e:	b2da      	uxtb	r2, r3
                        (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs)));
    8060:	79fb      	ldrb	r3, [r7, #7]
    8062:	01db      	lsls	r3, r3, #7
    8064:	b2d9      	uxtb	r1, r3
    8066:	79bb      	ldrb	r3, [r7, #6]
    8068:	015b      	lsls	r3, r3, #5
    806a:	b2db      	uxtb	r3, r3
    806c:	f003 0360 	and.w	r3, r3, #96	; 0x60
    8070:	b2db      	uxtb	r3, r3
    8072:	430b      	orrs	r3, r1
    8074:	b2db      	uxtb	r3, r3
    MCG->C4 = (uint8_t)((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) |
    8076:	490b      	ldr	r1, [pc, #44]	; (80a4 <CLOCK_SetFeiMode+0xbc>)
    8078:	4313      	orrs	r3, r2
    807a:	b2db      	uxtb	r3, r3
    807c:	70cb      	strb	r3, [r1, #3]

    /* Check MCG_S[CLKST] */
    while ((uint8_t)kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
    807e:	bf00      	nop
    8080:	4b08      	ldr	r3, [pc, #32]	; (80a4 <CLOCK_SetFeiMode+0xbc>)
    8082:	799b      	ldrb	r3, [r3, #6]
    8084:	b2db      	uxtb	r3, r3
    8086:	089b      	lsrs	r3, r3, #2
    8088:	f003 0303 	and.w	r3, r3, #3
    808c:	2b00      	cmp	r3, #0
    808e:	d1f7      	bne.n	8080 <CLOCK_SetFeiMode+0x98>
    {
    }

    /* Wait for FLL stable time. */
    if (NULL != fllStableDelay)
    8090:	683b      	ldr	r3, [r7, #0]
    8092:	2b00      	cmp	r3, #0
    8094:	d001      	beq.n	809a <CLOCK_SetFeiMode+0xb2>
    {
        fllStableDelay();
    8096:	683b      	ldr	r3, [r7, #0]
    8098:	4798      	blx	r3
    }

    return kStatus_Success;
    809a:	2300      	movs	r3, #0
}
    809c:	4618      	mov	r0, r3
    809e:	3710      	adds	r7, #16
    80a0:	46bd      	mov	sp, r7
    80a2:	bd80      	pop	{r7, pc}
    80a4:	40064000 	.word	0x40064000

000080a8 <CLOCK_SetFeeMode>:
 *
 * retval kStatus_MCG_ModeUnreachable Could not switch to the target mode.
 * retval kStatus_Success Switched to the target mode successfully.
 */
status_t CLOCK_SetFeeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
{
    80a8:	b580      	push	{r7, lr}
    80aa:	b084      	sub	sp, #16
    80ac:	af00      	add	r7, sp, #0
    80ae:	603b      	str	r3, [r7, #0]
    80b0:	4603      	mov	r3, r0
    80b2:	71fb      	strb	r3, [r7, #7]
    80b4:	460b      	mov	r3, r1
    80b6:	71bb      	strb	r3, [r7, #6]
    80b8:	4613      	mov	r3, r2
    80ba:	717b      	strb	r3, [r7, #5]
    uint8_t mcg_c4;
    bool change_drs = false;
    80bc:	2300      	movs	r3, #0
    80be:	73fb      	strb	r3, [r7, #15]
    if (!((kMCG_ModeFEE == mode) || (kMCG_ModeFBI == mode) || (kMCG_ModeFBE == mode) || (kMCG_ModeFEI == mode)))
    {
        return kStatus_MCG_ModeUnreachable;
    }
#endif
    mcg_c4 = MCG->C4;
    80c0:	4b3b      	ldr	r3, [pc, #236]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    80c2:	78db      	ldrb	r3, [r3, #3]
    80c4:	73bb      	strb	r3, [r7, #14]
       Errata: ERR007993
       Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
       reference clock source changes, then reset to previous value after
       reference clock changes.
     */
    if ((uint8_t)kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
    80c6:	4b3a      	ldr	r3, [pc, #232]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    80c8:	799b      	ldrb	r3, [r3, #6]
    80ca:	b2db      	uxtb	r3, r3
    80cc:	091b      	lsrs	r3, r3, #4
    80ce:	f003 0301 	and.w	r3, r3, #1
    80d2:	2b01      	cmp	r3, #1
    80d4:	d109      	bne.n	80ea <CLOCK_SetFeeMode+0x42>
    {
        change_drs = true;
    80d6:	2301      	movs	r3, #1
    80d8:	73fb      	strb	r3, [r7, #15]
        /* Change the LSB of DRST_DRS. */
        MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
    80da:	4b35      	ldr	r3, [pc, #212]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    80dc:	78db      	ldrb	r3, [r3, #3]
    80de:	b2db      	uxtb	r3, r3
    80e0:	4a33      	ldr	r2, [pc, #204]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    80e2:	f083 0320 	eor.w	r3, r3, #32
    80e6:	b2db      	uxtb	r3, r3
    80e8:	70d3      	strb	r3, [r2, #3]
    }

    /* Set CLKS and IREFS. */
    MCG->C1 = (uint8_t)((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
    80ea:	4b31      	ldr	r3, [pc, #196]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    80ec:	781b      	ldrb	r3, [r3, #0]
    80ee:	b2db      	uxtb	r3, r3
    80f0:	f003 0303 	and.w	r3, r3, #3
    80f4:	b2da      	uxtb	r2, r3
                        (MCG_C1_CLKS(kMCG_ClkOutSrcOut)         /* CLKS = 0 */
                         | MCG_C1_FRDIV(frdiv)                  /* FRDIV */
    80f6:	79fb      	ldrb	r3, [r7, #7]
    80f8:	00db      	lsls	r3, r3, #3
    80fa:	b2db      	uxtb	r3, r3
    80fc:	f003 0338 	and.w	r3, r3, #56	; 0x38
    8100:	b2db      	uxtb	r3, r3
    MCG->C1 = (uint8_t)((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
    8102:	492b      	ldr	r1, [pc, #172]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    8104:	4313      	orrs	r3, r2
    8106:	b2db      	uxtb	r3, r3
    8108:	700b      	strb	r3, [r1, #0]
                         | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */

    /* If use external crystal as clock source, wait for it stable. */
    if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
    810a:	4b29      	ldr	r3, [pc, #164]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    810c:	7b1b      	ldrb	r3, [r3, #12]
    810e:	b2db      	uxtb	r3, r3
    8110:	f003 0303 	and.w	r3, r3, #3
    8114:	2b00      	cmp	r3, #0
    8116:	d10e      	bne.n	8136 <CLOCK_SetFeeMode+0x8e>
    {
        if (0U != (MCG->C2 & MCG_C2_EREFS_MASK))
    8118:	4b25      	ldr	r3, [pc, #148]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    811a:	785b      	ldrb	r3, [r3, #1]
    811c:	b2db      	uxtb	r3, r3
    811e:	f003 0304 	and.w	r3, r3, #4
    8122:	2b00      	cmp	r3, #0
    8124:	d007      	beq.n	8136 <CLOCK_SetFeeMode+0x8e>
        {
            while (0U == (MCG->S & MCG_S_OSCINIT0_MASK))
    8126:	bf00      	nop
    8128:	4b21      	ldr	r3, [pc, #132]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    812a:	799b      	ldrb	r3, [r3, #6]
    812c:	b2db      	uxtb	r3, r3
    812e:	f003 0302 	and.w	r3, r3, #2
    8132:	2b00      	cmp	r3, #0
    8134:	d0f8      	beq.n	8128 <CLOCK_SetFeeMode+0x80>
            }
        }
    }

    /* Wait and check status. */
    while ((uint8_t)kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
    8136:	bf00      	nop
    8138:	4b1d      	ldr	r3, [pc, #116]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    813a:	799b      	ldrb	r3, [r3, #6]
    813c:	b2db      	uxtb	r3, r3
    813e:	f003 0310 	and.w	r3, r3, #16
    8142:	2b00      	cmp	r3, #0
    8144:	d1f8      	bne.n	8138 <CLOCK_SetFeeMode+0x90>
    {
    }

    /* Errata: ERR007993 */
    if (change_drs)
    8146:	7bfb      	ldrb	r3, [r7, #15]
    8148:	2b00      	cmp	r3, #0
    814a:	d002      	beq.n	8152 <CLOCK_SetFeeMode+0xaa>
    {
        MCG->C4 = mcg_c4;
    814c:	4a18      	ldr	r2, [pc, #96]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    814e:	7bbb      	ldrb	r3, [r7, #14]
    8150:	70d3      	strb	r3, [r2, #3]
    }

    /* Set DRS and DMX32. */
    mcg_c4  = (uint8_t)((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) |
    8152:	7bbb      	ldrb	r3, [r7, #14]
    8154:	f003 031f 	and.w	r3, r3, #31
    8158:	b2da      	uxtb	r2, r3
                       (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs)));
    815a:	79bb      	ldrb	r3, [r7, #6]
    815c:	01db      	lsls	r3, r3, #7
    815e:	b2d9      	uxtb	r1, r3
    8160:	797b      	ldrb	r3, [r7, #5]
    8162:	015b      	lsls	r3, r3, #5
    8164:	b2db      	uxtb	r3, r3
    8166:	f003 0360 	and.w	r3, r3, #96	; 0x60
    816a:	b2db      	uxtb	r3, r3
    816c:	430b      	orrs	r3, r1
    816e:	b2db      	uxtb	r3, r3
    mcg_c4  = (uint8_t)((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) |
    8170:	4313      	orrs	r3, r2
    8172:	73bb      	strb	r3, [r7, #14]
    MCG->C4 = mcg_c4;
    8174:	4a0e      	ldr	r2, [pc, #56]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    8176:	7bbb      	ldrb	r3, [r7, #14]
    8178:	70d3      	strb	r3, [r2, #3]

    /* Wait for DRST_DRS update. */
    while (MCG->C4 != mcg_c4)
    817a:	bf00      	nop
    817c:	4b0c      	ldr	r3, [pc, #48]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    817e:	78db      	ldrb	r3, [r3, #3]
    8180:	b2db      	uxtb	r3, r3
    8182:	7bba      	ldrb	r2, [r7, #14]
    8184:	429a      	cmp	r2, r3
    8186:	d1f9      	bne.n	817c <CLOCK_SetFeeMode+0xd4>
    {
    }

    /* Check MCG_S[CLKST] */
    while ((uint8_t)kMCG_ClkOutStatFll != MCG_S_CLKST_VAL)
    8188:	bf00      	nop
    818a:	4b09      	ldr	r3, [pc, #36]	; (81b0 <CLOCK_SetFeeMode+0x108>)
    818c:	799b      	ldrb	r3, [r3, #6]
    818e:	b2db      	uxtb	r3, r3
    8190:	089b      	lsrs	r3, r3, #2
    8192:	f003 0303 	and.w	r3, r3, #3
    8196:	2b00      	cmp	r3, #0
    8198:	d1f7      	bne.n	818a <CLOCK_SetFeeMode+0xe2>
    {
    }

    /* Wait for FLL stable time. */
    if (NULL != fllStableDelay)
    819a:	683b      	ldr	r3, [r7, #0]
    819c:	2b00      	cmp	r3, #0
    819e:	d001      	beq.n	81a4 <CLOCK_SetFeeMode+0xfc>
    {
        fllStableDelay();
    81a0:	683b      	ldr	r3, [r7, #0]
    81a2:	4798      	blx	r3
    }

    return kStatus_Success;
    81a4:	2300      	movs	r3, #0
}
    81a6:	4618      	mov	r0, r3
    81a8:	3710      	adds	r7, #16
    81aa:	46bd      	mov	sp, r7
    81ac:	bd80      	pop	{r7, pc}
    81ae:	bf00      	nop
    81b0:	40064000 	.word	0x40064000

000081b4 <CLOCK_SetFbiMode>:
 * retval kStatus_Success Switched to the target mode successfully.
 * note If p dmx32 is set to kMCG_Dmx32Fine, the slow IRC must not be trimmed
 * to frequency above 32768 Hz.
 */
status_t CLOCK_SetFbiMode(mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
{
    81b4:	b580      	push	{r7, lr}
    81b6:	b084      	sub	sp, #16
    81b8:	af00      	add	r7, sp, #0
    81ba:	4603      	mov	r3, r0
    81bc:	603a      	str	r2, [r7, #0]
    81be:	71fb      	strb	r3, [r7, #7]
    81c0:	460b      	mov	r3, r1
    81c2:	71bb      	strb	r3, [r7, #6]
    uint8_t mcg_c4;
    bool change_drs = false;
    81c4:	2300      	movs	r3, #0
    81c6:	73fb      	strb	r3, [r7, #15]
    {
        return kStatus_MCG_ModeUnreachable;
    }
#endif

    mcg_c4 = MCG->C4;
    81c8:	4b2d      	ldr	r3, [pc, #180]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    81ca:	78db      	ldrb	r3, [r3, #3]
    81cc:	73bb      	strb	r3, [r7, #14]

    MCG->C2 &= ~(uint8_t)MCG_C2_LP_MASK; /* Disable lowpower. */
    81ce:	4b2c      	ldr	r3, [pc, #176]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    81d0:	785b      	ldrb	r3, [r3, #1]
    81d2:	b2db      	uxtb	r3, r3
    81d4:	4a2a      	ldr	r2, [pc, #168]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    81d6:	f023 0302 	bic.w	r3, r3, #2
    81da:	b2db      	uxtb	r3, r3
    81dc:	7053      	strb	r3, [r2, #1]
       Errata: ERR007993
       Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
       reference clock source changes, then reset to previous value after
       reference clock changes.
     */
    if ((uint8_t)kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
    81de:	4b28      	ldr	r3, [pc, #160]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    81e0:	799b      	ldrb	r3, [r3, #6]
    81e2:	b2db      	uxtb	r3, r3
    81e4:	f003 0310 	and.w	r3, r3, #16
    81e8:	2b00      	cmp	r3, #0
    81ea:	d109      	bne.n	8200 <CLOCK_SetFbiMode+0x4c>
    {
        change_drs = true;
    81ec:	2301      	movs	r3, #1
    81ee:	73fb      	strb	r3, [r7, #15]
        /* Change the LSB of DRST_DRS. */
        MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
    81f0:	4b23      	ldr	r3, [pc, #140]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    81f2:	78db      	ldrb	r3, [r3, #3]
    81f4:	b2db      	uxtb	r3, r3
    81f6:	4a22      	ldr	r2, [pc, #136]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    81f8:	f083 0320 	eor.w	r3, r3, #32
    81fc:	b2db      	uxtb	r3, r3
    81fe:	70d3      	strb	r3, [r2, #3]
    }

    /* Set CLKS and IREFS. */
    MCG->C1 = (uint8_t)((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) |
    8200:	4b1f      	ldr	r3, [pc, #124]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    8202:	781b      	ldrb	r3, [r3, #0]
    8204:	b2db      	uxtb	r3, r3
    8206:	f003 033b 	and.w	r3, r3, #59	; 0x3b
    820a:	b2db      	uxtb	r3, r3
    820c:	4a1c      	ldr	r2, [pc, #112]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    820e:	f043 0344 	orr.w	r3, r3, #68	; 0x44
    8212:	b2db      	uxtb	r3, r3
    8214:	7013      	strb	r3, [r2, #0]
                        (MCG_C1_CLKS(kMCG_ClkOutSrcInternal)    /* CLKS = 1 */
                         | MCG_C1_IREFS(kMCG_FllSrcInternal))); /* IREFS = 1 */

    /* Wait and check status. */
    while ((uint8_t)kMCG_FllSrcInternal != MCG_S_IREFST_VAL)
    8216:	bf00      	nop
    8218:	4b19      	ldr	r3, [pc, #100]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    821a:	799b      	ldrb	r3, [r3, #6]
    821c:	b2db      	uxtb	r3, r3
    821e:	091b      	lsrs	r3, r3, #4
    8220:	f003 0301 	and.w	r3, r3, #1
    8224:	2b01      	cmp	r3, #1
    8226:	d1f7      	bne.n	8218 <CLOCK_SetFbiMode+0x64>
    {
    }

    /* Errata: ERR007993 */
    if (change_drs)
    8228:	7bfb      	ldrb	r3, [r7, #15]
    822a:	2b00      	cmp	r3, #0
    822c:	d002      	beq.n	8234 <CLOCK_SetFbiMode+0x80>
    {
        MCG->C4 = mcg_c4;
    822e:	4a14      	ldr	r2, [pc, #80]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    8230:	7bbb      	ldrb	r3, [r7, #14]
    8232:	70d3      	strb	r3, [r2, #3]
    }

    while ((uint8_t)kMCG_ClkOutStatInt != MCG_S_CLKST_VAL)
    8234:	bf00      	nop
    8236:	4b12      	ldr	r3, [pc, #72]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    8238:	799b      	ldrb	r3, [r3, #6]
    823a:	b2db      	uxtb	r3, r3
    823c:	089b      	lsrs	r3, r3, #2
    823e:	f003 0303 	and.w	r3, r3, #3
    8242:	2b01      	cmp	r3, #1
    8244:	d1f7      	bne.n	8236 <CLOCK_SetFbiMode+0x82>
    {
    }

    MCG->C4 = (uint8_t)((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) |
    8246:	7bbb      	ldrb	r3, [r7, #14]
    8248:	f003 031f 	and.w	r3, r3, #31
    824c:	b2da      	uxtb	r2, r3
                        (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs)));
    824e:	79fb      	ldrb	r3, [r7, #7]
    8250:	01db      	lsls	r3, r3, #7
    8252:	b2d9      	uxtb	r1, r3
    8254:	79bb      	ldrb	r3, [r7, #6]
    8256:	015b      	lsls	r3, r3, #5
    8258:	b2db      	uxtb	r3, r3
    825a:	f003 0360 	and.w	r3, r3, #96	; 0x60
    825e:	b2db      	uxtb	r3, r3
    8260:	430b      	orrs	r3, r1
    8262:	b2db      	uxtb	r3, r3
    MCG->C4 = (uint8_t)((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) |
    8264:	4906      	ldr	r1, [pc, #24]	; (8280 <CLOCK_SetFbiMode+0xcc>)
    8266:	4313      	orrs	r3, r2
    8268:	b2db      	uxtb	r3, r3
    826a:	70cb      	strb	r3, [r1, #3]

    /* Wait for FLL stable time. */
    if (NULL != fllStableDelay)
    826c:	683b      	ldr	r3, [r7, #0]
    826e:	2b00      	cmp	r3, #0
    8270:	d001      	beq.n	8276 <CLOCK_SetFbiMode+0xc2>
    {
        fllStableDelay();
    8272:	683b      	ldr	r3, [r7, #0]
    8274:	4798      	blx	r3
    }

    return kStatus_Success;
    8276:	2300      	movs	r3, #0
}
    8278:	4618      	mov	r0, r3
    827a:	3710      	adds	r7, #16
    827c:	46bd      	mov	sp, r7
    827e:	bd80      	pop	{r7, pc}
    8280:	40064000 	.word	0x40064000

00008284 <CLOCK_SetFbeMode>:
 *          does not cause a delay.
 * retval kStatus_MCG_ModeUnreachable Could not switch to the target mode.
 * retval kStatus_Success Switched to the target mode successfully.
 */
status_t CLOCK_SetFbeMode(uint8_t frdiv, mcg_dmx32_t dmx32, mcg_drs_t drs, void (*fllStableDelay)(void))
{
    8284:	b580      	push	{r7, lr}
    8286:	b084      	sub	sp, #16
    8288:	af00      	add	r7, sp, #0
    828a:	603b      	str	r3, [r7, #0]
    828c:	4603      	mov	r3, r0
    828e:	71fb      	strb	r3, [r7, #7]
    8290:	460b      	mov	r3, r1
    8292:	71bb      	strb	r3, [r7, #6]
    8294:	4613      	mov	r3, r2
    8296:	717b      	strb	r3, [r7, #5]
    uint8_t mcg_c4;
    bool change_drs = false;
    8298:	2300      	movs	r3, #0
    829a:	73fb      	strb	r3, [r7, #15]
        return kStatus_MCG_ModeUnreachable;
    }
#endif

    /* Change to FLL mode. */
    MCG->C6 &= ~(uint8_t)MCG_C6_PLLS_MASK;
    829c:	4b43      	ldr	r3, [pc, #268]	; (83ac <CLOCK_SetFbeMode+0x128>)
    829e:	795b      	ldrb	r3, [r3, #5]
    82a0:	b2db      	uxtb	r3, r3
    82a2:	4a42      	ldr	r2, [pc, #264]	; (83ac <CLOCK_SetFbeMode+0x128>)
    82a4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    82a8:	b2db      	uxtb	r3, r3
    82aa:	7153      	strb	r3, [r2, #5]
    while ((MCG->S & MCG_S_PLLST_MASK) != 0U)
    82ac:	bf00      	nop
    82ae:	4b3f      	ldr	r3, [pc, #252]	; (83ac <CLOCK_SetFbeMode+0x128>)
    82b0:	799b      	ldrb	r3, [r3, #6]
    82b2:	b2db      	uxtb	r3, r3
    82b4:	f003 0320 	and.w	r3, r3, #32
    82b8:	2b00      	cmp	r3, #0
    82ba:	d1f8      	bne.n	82ae <CLOCK_SetFbeMode+0x2a>
    {
    }

    /* Set LP bit to enable the FLL */
    MCG->C2 &= ~(uint8_t)MCG_C2_LP_MASK;
    82bc:	4b3b      	ldr	r3, [pc, #236]	; (83ac <CLOCK_SetFbeMode+0x128>)
    82be:	785b      	ldrb	r3, [r3, #1]
    82c0:	b2db      	uxtb	r3, r3
    82c2:	4a3a      	ldr	r2, [pc, #232]	; (83ac <CLOCK_SetFbeMode+0x128>)
    82c4:	f023 0302 	bic.w	r3, r3, #2
    82c8:	b2db      	uxtb	r3, r3
    82ca:	7053      	strb	r3, [r2, #1]

    mcg_c4 = MCG->C4;
    82cc:	4b37      	ldr	r3, [pc, #220]	; (83ac <CLOCK_SetFbeMode+0x128>)
    82ce:	78db      	ldrb	r3, [r3, #3]
    82d0:	73bb      	strb	r3, [r7, #14]
       Errata: ERR007993
       Workaround: Invert MCG_C4[DMX32] or change MCG_C4[DRST_DRS] before
       reference clock source changes, then reset to previous value after
       reference clock changes.
     */
    if ((uint8_t)kMCG_FllSrcInternal == MCG_S_IREFST_VAL)
    82d2:	4b36      	ldr	r3, [pc, #216]	; (83ac <CLOCK_SetFbeMode+0x128>)
    82d4:	799b      	ldrb	r3, [r3, #6]
    82d6:	b2db      	uxtb	r3, r3
    82d8:	091b      	lsrs	r3, r3, #4
    82da:	f003 0301 	and.w	r3, r3, #1
    82de:	2b01      	cmp	r3, #1
    82e0:	d109      	bne.n	82f6 <CLOCK_SetFbeMode+0x72>
    {
        change_drs = true;
    82e2:	2301      	movs	r3, #1
    82e4:	73fb      	strb	r3, [r7, #15]
        /* Change the LSB of DRST_DRS. */
        MCG->C4 ^= (1U << MCG_C4_DRST_DRS_SHIFT);
    82e6:	4b31      	ldr	r3, [pc, #196]	; (83ac <CLOCK_SetFbeMode+0x128>)
    82e8:	78db      	ldrb	r3, [r3, #3]
    82ea:	b2db      	uxtb	r3, r3
    82ec:	4a2f      	ldr	r2, [pc, #188]	; (83ac <CLOCK_SetFbeMode+0x128>)
    82ee:	f083 0320 	eor.w	r3, r3, #32
    82f2:	b2db      	uxtb	r3, r3
    82f4:	70d3      	strb	r3, [r2, #3]
    }

    /* Set CLKS and IREFS. */
    MCG->C1 = (uint8_t)((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
    82f6:	4b2d      	ldr	r3, [pc, #180]	; (83ac <CLOCK_SetFbeMode+0x128>)
    82f8:	781b      	ldrb	r3, [r3, #0]
    82fa:	b2db      	uxtb	r3, r3
    82fc:	f003 0303 	and.w	r3, r3, #3
    8300:	b2da      	uxtb	r2, r3
                        (MCG_C1_CLKS(kMCG_ClkOutSrcExternal)    /* CLKS = 2 */
                         | MCG_C1_FRDIV(frdiv)                  /* FRDIV = frdiv */
    8302:	79fb      	ldrb	r3, [r7, #7]
    8304:	00db      	lsls	r3, r3, #3
    8306:	b2db      	uxtb	r3, r3
    8308:	f003 0338 	and.w	r3, r3, #56	; 0x38
    830c:	b2db      	uxtb	r3, r3
    MCG->C1 = (uint8_t)((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK)) |
    830e:	4313      	orrs	r3, r2
    8310:	b2db      	uxtb	r3, r3
    8312:	4a26      	ldr	r2, [pc, #152]	; (83ac <CLOCK_SetFbeMode+0x128>)
    8314:	f063 037f 	orn	r3, r3, #127	; 0x7f
    8318:	b2db      	uxtb	r3, r3
    831a:	7013      	strb	r3, [r2, #0]
                         | MCG_C1_IREFS(kMCG_FllSrcExternal))); /* IREFS = 0 */

    /* If use external crystal as clock source, wait for it stable. */
    if (MCG_C7_OSCSEL(kMCG_OscselOsc) == (MCG->C7 & MCG_C7_OSCSEL_MASK))
    831c:	4b23      	ldr	r3, [pc, #140]	; (83ac <CLOCK_SetFbeMode+0x128>)
    831e:	7b1b      	ldrb	r3, [r3, #12]
    8320:	b2db      	uxtb	r3, r3
    8322:	f003 0303 	and.w	r3, r3, #3
    8326:	2b00      	cmp	r3, #0
    8328:	d10e      	bne.n	8348 <CLOCK_SetFbeMode+0xc4>
    {
        if (0U != (MCG->C2 & MCG_C2_EREFS_MASK))
    832a:	4b20      	ldr	r3, [pc, #128]	; (83ac <CLOCK_SetFbeMode+0x128>)
    832c:	785b      	ldrb	r3, [r3, #1]
    832e:	b2db      	uxtb	r3, r3
    8330:	f003 0304 	and.w	r3, r3, #4
    8334:	2b00      	cmp	r3, #0
    8336:	d007      	beq.n	8348 <CLOCK_SetFbeMode+0xc4>
        {
            while (0U == (MCG->S & MCG_S_OSCINIT0_MASK))
    8338:	bf00      	nop
    833a:	4b1c      	ldr	r3, [pc, #112]	; (83ac <CLOCK_SetFbeMode+0x128>)
    833c:	799b      	ldrb	r3, [r3, #6]
    833e:	b2db      	uxtb	r3, r3
    8340:	f003 0302 	and.w	r3, r3, #2
    8344:	2b00      	cmp	r3, #0
    8346:	d0f8      	beq.n	833a <CLOCK_SetFbeMode+0xb6>
            }
        }
    }

    /* Wait for Reference clock Status bit to clear */
    while ((uint8_t)kMCG_FllSrcExternal != MCG_S_IREFST_VAL)
    8348:	bf00      	nop
    834a:	4b18      	ldr	r3, [pc, #96]	; (83ac <CLOCK_SetFbeMode+0x128>)
    834c:	799b      	ldrb	r3, [r3, #6]
    834e:	b2db      	uxtb	r3, r3
    8350:	f003 0310 	and.w	r3, r3, #16
    8354:	2b00      	cmp	r3, #0
    8356:	d1f8      	bne.n	834a <CLOCK_SetFbeMode+0xc6>
    {
    }

    /* Errata: ERR007993 */
    if (change_drs)
    8358:	7bfb      	ldrb	r3, [r7, #15]
    835a:	2b00      	cmp	r3, #0
    835c:	d002      	beq.n	8364 <CLOCK_SetFbeMode+0xe0>
    {
        MCG->C4 = mcg_c4;
    835e:	4a13      	ldr	r2, [pc, #76]	; (83ac <CLOCK_SetFbeMode+0x128>)
    8360:	7bbb      	ldrb	r3, [r7, #14]
    8362:	70d3      	strb	r3, [r2, #3]
    }

    /* Set DRST_DRS and DMX32. */
    mcg_c4 = (uint8_t)((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) |
    8364:	7bbb      	ldrb	r3, [r7, #14]
    8366:	f003 031f 	and.w	r3, r3, #31
    836a:	b2da      	uxtb	r2, r3
                       (MCG_C4_DMX32(dmx32) | MCG_C4_DRST_DRS(drs)));
    836c:	79bb      	ldrb	r3, [r7, #6]
    836e:	01db      	lsls	r3, r3, #7
    8370:	b2d9      	uxtb	r1, r3
    8372:	797b      	ldrb	r3, [r7, #5]
    8374:	015b      	lsls	r3, r3, #5
    8376:	b2db      	uxtb	r3, r3
    8378:	f003 0360 	and.w	r3, r3, #96	; 0x60
    837c:	b2db      	uxtb	r3, r3
    837e:	430b      	orrs	r3, r1
    8380:	b2db      	uxtb	r3, r3
    mcg_c4 = (uint8_t)((mcg_c4 & ~(MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) |
    8382:	4313      	orrs	r3, r2
    8384:	73bb      	strb	r3, [r7, #14]

    /* Wait for clock status bits to show clock source is ext ref clk */
    while ((uint8_t)kMCG_ClkOutStatExt != MCG_S_CLKST_VAL)
    8386:	bf00      	nop
    8388:	4b08      	ldr	r3, [pc, #32]	; (83ac <CLOCK_SetFbeMode+0x128>)
    838a:	799b      	ldrb	r3, [r3, #6]
    838c:	b2db      	uxtb	r3, r3
    838e:	089b      	lsrs	r3, r3, #2
    8390:	f003 0303 	and.w	r3, r3, #3
    8394:	2b02      	cmp	r3, #2
    8396:	d1f7      	bne.n	8388 <CLOCK_SetFbeMode+0x104>
    {
    }

    /* Wait for fll stable time. */
    if (NULL != fllStableDelay)
    8398:	683b      	ldr	r3, [r7, #0]
    839a:	2b00      	cmp	r3, #0
    839c:	d001      	beq.n	83a2 <CLOCK_SetFbeMode+0x11e>
    {
        fllStableDelay();
    839e:	683b      	ldr	r3, [r7, #0]
    83a0:	4798      	blx	r3
    }

    return kStatus_Success;
    83a2:	2300      	movs	r3, #0
}
    83a4:	4618      	mov	r0, r3
    83a6:	3710      	adds	r7, #16
    83a8:	46bd      	mov	sp, r7
    83aa:	bd80      	pop	{r7, pc}
    83ac:	40064000 	.word	0x40064000

000083b0 <CLOCK_SetBlpiMode>:
 *
 * retval kStatus_MCG_ModeUnreachable Could not switch to the target mode.
 * retval kStatus_Success Switched to the target mode successfully.
 */
status_t CLOCK_SetBlpiMode(void)
{
    83b0:	b480      	push	{r7}
    83b2:	af00      	add	r7, sp, #0
        return kStatus_MCG_ModeUnreachable;
    }
#endif /* MCG_CONFIG_CHECK_PARAM */

    /* Set LP. */
    MCG->C2 |= MCG_C2_LP_MASK;
    83b4:	4b06      	ldr	r3, [pc, #24]	; (83d0 <CLOCK_SetBlpiMode+0x20>)
    83b6:	785b      	ldrb	r3, [r3, #1]
    83b8:	b2db      	uxtb	r3, r3
    83ba:	4a05      	ldr	r2, [pc, #20]	; (83d0 <CLOCK_SetBlpiMode+0x20>)
    83bc:	f043 0302 	orr.w	r3, r3, #2
    83c0:	b2db      	uxtb	r3, r3
    83c2:	7053      	strb	r3, [r2, #1]

    return kStatus_Success;
    83c4:	2300      	movs	r3, #0
}
    83c6:	4618      	mov	r0, r3
    83c8:	46bd      	mov	sp, r7
    83ca:	f85d 7b04 	ldr.w	r7, [sp], #4
    83ce:	4770      	bx	lr
    83d0:	40064000 	.word	0x40064000

000083d4 <CLOCK_SetBlpeMode>:
 *
 * retval kStatus_MCG_ModeUnreachable Could not switch to the target mode.
 * retval kStatus_Success Switched to the target mode successfully.
 */
status_t CLOCK_SetBlpeMode(void)
{
    83d4:	b480      	push	{r7}
    83d6:	af00      	add	r7, sp, #0
        return kStatus_MCG_ModeUnreachable;
    }
#endif

    /* Set LP bit to enter BLPE mode. */
    MCG->C2 |= MCG_C2_LP_MASK;
    83d8:	4b06      	ldr	r3, [pc, #24]	; (83f4 <CLOCK_SetBlpeMode+0x20>)
    83da:	785b      	ldrb	r3, [r3, #1]
    83dc:	b2db      	uxtb	r3, r3
    83de:	4a05      	ldr	r2, [pc, #20]	; (83f4 <CLOCK_SetBlpeMode+0x20>)
    83e0:	f043 0302 	orr.w	r3, r3, #2
    83e4:	b2db      	uxtb	r3, r3
    83e6:	7053      	strb	r3, [r2, #1]

    return kStatus_Success;
    83e8:	2300      	movs	r3, #0
}
    83ea:	4618      	mov	r0, r3
    83ec:	46bd      	mov	sp, r7
    83ee:	f85d 7b04 	ldr.w	r7, [sp], #4
    83f2:	4770      	bx	lr
    83f4:	40064000 	.word	0x40064000

000083f8 <CLOCK_SetPbeMode>:
 * platforms,  it is possible to choose the external PLL directly, which renders the
 * configuration structure not necessary. In this case, pass in NULL.
 * For example: CLOCK_SetPbeMode(kMCG_OscselOsc, kMCG_PllClkSelExtPll, NULL);
 */
status_t CLOCK_SetPbeMode(mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
{
    83f8:	b580      	push	{r7, lr}
    83fa:	b082      	sub	sp, #8
    83fc:	af00      	add	r7, sp, #0
    83fe:	4603      	mov	r3, r0
    8400:	6039      	str	r1, [r7, #0]
    8402:	71fb      	strb	r3, [r7, #7]
    /* If external PLL is used, then the config could be NULL. */
    if (kMCG_PllClkSelExtPll != pllcs)
    8404:	79fb      	ldrb	r3, [r7, #7]
    8406:	2b01      	cmp	r3, #1
    8408:	d009      	beq.n	841e <CLOCK_SetPbeMode+0x26>
    {
        assert(config);
    840a:	683b      	ldr	r3, [r7, #0]
    840c:	2b00      	cmp	r3, #0
    840e:	d106      	bne.n	841e <CLOCK_SetPbeMode+0x26>
    8410:	4b33      	ldr	r3, [pc, #204]	; (84e0 <CLOCK_SetPbeMode+0xe8>)
    8412:	4a34      	ldr	r2, [pc, #208]	; (84e4 <CLOCK_SetPbeMode+0xec>)
    8414:	f640 01a2 	movw	r1, #2210	; 0x8a2
    8418:	4833      	ldr	r0, [pc, #204]	; (84e8 <CLOCK_SetPbeMode+0xf0>)
    841a:	f7fe fedf 	bl	71dc <__assert_func>

    /*
       This function is designed to change MCG to PBE mode from PEE/BLPE/FBE,
       but with this workflow, the source mode could be all modes except PEI/PBI.
     */
    MCG->C2 &= (uint8_t)(~MCG_C2_LP_MASK); /* Disable lowpower. */
    841e:	4b33      	ldr	r3, [pc, #204]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    8420:	785b      	ldrb	r3, [r3, #1]
    8422:	b2db      	uxtb	r3, r3
    8424:	4a31      	ldr	r2, [pc, #196]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    8426:	f023 0302 	bic.w	r3, r3, #2
    842a:	b2db      	uxtb	r3, r3
    842c:	7053      	strb	r3, [r2, #1]

    /* Change to use external clock first. */
    MCG->C1 = (uint8_t)((MCG->C1 & ~(MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK)) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
    842e:	4b2f      	ldr	r3, [pc, #188]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    8430:	781b      	ldrb	r3, [r3, #0]
    8432:	b2db      	uxtb	r3, r3
    8434:	f003 033b 	and.w	r3, r3, #59	; 0x3b
    8438:	b2db      	uxtb	r3, r3
    843a:	4a2c      	ldr	r2, [pc, #176]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    843c:	f063 037f 	orn	r3, r3, #127	; 0x7f
    8440:	b2db      	uxtb	r3, r3
    8442:	7013      	strb	r3, [r2, #0]

    /* Wait for CLKST clock status bits to show clock source is ext ref clk */
    while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
    8444:	bf00      	nop
    8446:	4b29      	ldr	r3, [pc, #164]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    8448:	799b      	ldrb	r3, [r3, #6]
    844a:	b2db      	uxtb	r3, r3
    844c:	f003 031c 	and.w	r3, r3, #28
    8450:	2b08      	cmp	r3, #8
    8452:	d1f8      	bne.n	8446 <CLOCK_SetPbeMode+0x4e>
           (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
    {
    }

    /* Disable PLL first, then configure PLL. */
    MCG->C6 &= (uint8_t)(~MCG_C6_PLLS_MASK);
    8454:	4b25      	ldr	r3, [pc, #148]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    8456:	795b      	ldrb	r3, [r3, #5]
    8458:	b2db      	uxtb	r3, r3
    845a:	4a24      	ldr	r2, [pc, #144]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    845c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    8460:	b2db      	uxtb	r3, r3
    8462:	7153      	strb	r3, [r2, #5]
    while ((MCG->S & MCG_S_PLLST_MASK) != 0U)
    8464:	bf00      	nop
    8466:	4b21      	ldr	r3, [pc, #132]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    8468:	799b      	ldrb	r3, [r3, #6]
    846a:	b2db      	uxtb	r3, r3
    846c:	f003 0320 	and.w	r3, r3, #32
    8470:	2b00      	cmp	r3, #0
    8472:	d1f8      	bne.n	8466 <CLOCK_SetPbeMode+0x6e>
    {
    }

    /* Configure the PLL. */
    if (kMCG_PllClkSelPll0 == pllcs)
    8474:	79fb      	ldrb	r3, [r7, #7]
    8476:	2b00      	cmp	r3, #0
    8478:	d102      	bne.n	8480 <CLOCK_SetPbeMode+0x88>
    {
        CLOCK_EnablePll0(config);
    847a:	6838      	ldr	r0, [r7, #0]
    847c:	f7ff fcc8 	bl	7e10 <CLOCK_EnablePll0>
    }

    /* Change to PLL mode. */
    MCG->C6 |= MCG_C6_PLLS_MASK;
    8480:	4b1a      	ldr	r3, [pc, #104]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    8482:	795b      	ldrb	r3, [r3, #5]
    8484:	b2db      	uxtb	r3, r3
    8486:	4a19      	ldr	r2, [pc, #100]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    8488:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    848c:	b2db      	uxtb	r3, r3
    848e:	7153      	strb	r3, [r2, #5]

    MCG->C11 = (uint8_t)(((MCG->C11 & ~MCG_C11_PLLCS_MASK)) | MCG_C11_PLLCS(pllcs));
    8490:	4b16      	ldr	r3, [pc, #88]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    8492:	7c1b      	ldrb	r3, [r3, #16]
    8494:	b2db      	uxtb	r3, r3
    8496:	f023 0310 	bic.w	r3, r3, #16
    849a:	b2da      	uxtb	r2, r3
    849c:	79fb      	ldrb	r3, [r7, #7]
    849e:	011b      	lsls	r3, r3, #4
    84a0:	b2db      	uxtb	r3, r3
    84a2:	f003 0310 	and.w	r3, r3, #16
    84a6:	b2db      	uxtb	r3, r3
    84a8:	4910      	ldr	r1, [pc, #64]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    84aa:	4313      	orrs	r3, r2
    84ac:	b2db      	uxtb	r3, r3
    84ae:	740b      	strb	r3, [r1, #16]
    while ((uint32_t)pllcs != MCG_S2_PLLCST_VAL)
    84b0:	bf00      	nop
    84b2:	79fa      	ldrb	r2, [r7, #7]
    84b4:	4b0d      	ldr	r3, [pc, #52]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    84b6:	7c9b      	ldrb	r3, [r3, #18]
    84b8:	b2db      	uxtb	r3, r3
    84ba:	091b      	lsrs	r3, r3, #4
    84bc:	f003 0301 	and.w	r3, r3, #1
    84c0:	429a      	cmp	r2, r3
    84c2:	d1f6      	bne.n	84b2 <CLOCK_SetPbeMode+0xba>
    {
    }

    /* Wait for PLL mode changed. */
    while (((MCG->S & MCG_S_PLLST_MASK)) == 0U)
    84c4:	bf00      	nop
    84c6:	4b09      	ldr	r3, [pc, #36]	; (84ec <CLOCK_SetPbeMode+0xf4>)
    84c8:	799b      	ldrb	r3, [r3, #6]
    84ca:	b2db      	uxtb	r3, r3
    84cc:	f003 0320 	and.w	r3, r3, #32
    84d0:	2b00      	cmp	r3, #0
    84d2:	d0f8      	beq.n	84c6 <CLOCK_SetPbeMode+0xce>
    {
    }

    return kStatus_Success;
    84d4:	2300      	movs	r3, #0
}
    84d6:	4618      	mov	r0, r3
    84d8:	3708      	adds	r7, #8
    84da:	46bd      	mov	sp, r7
    84dc:	bd80      	pop	{r7, pc}
    84de:	bf00      	nop
    84e0:	0000f7ac 	.word	0x0000f7ac
    84e4:	0000f8b4 	.word	0x0000f8b4
    84e8:	0000f674 	.word	0x0000f674
    84ec:	40064000 	.word	0x40064000

000084f0 <CLOCK_SetPeeMode>:
 * note This function only changes the CLKS to use the PLL/FLL output. If the
 *       PRDIV/VDIV are different than in the PBE mode, set them up
 *       in PBE mode and wait. When the clock is stable, switch to PEE mode.
 */
status_t CLOCK_SetPeeMode(void)
{
    84f0:	b480      	push	{r7}
    84f2:	af00      	add	r7, sp, #0
        return kStatus_MCG_ModeUnreachable;
    }
#endif

    /* Change to use PLL/FLL output clock first. */
    MCG->C1 = (uint8_t)((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcOut));
    84f4:	4b0b      	ldr	r3, [pc, #44]	; (8524 <CLOCK_SetPeeMode+0x34>)
    84f6:	781b      	ldrb	r3, [r3, #0]
    84f8:	b2db      	uxtb	r3, r3
    84fa:	4a0a      	ldr	r2, [pc, #40]	; (8524 <CLOCK_SetPeeMode+0x34>)
    84fc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    8500:	b2db      	uxtb	r3, r3
    8502:	7013      	strb	r3, [r2, #0]

    /* Wait for clock status bits to update */
    while (MCG_S_CLKST_VAL != (uint8_t)kMCG_ClkOutStatPll)
    8504:	bf00      	nop
    8506:	4b07      	ldr	r3, [pc, #28]	; (8524 <CLOCK_SetPeeMode+0x34>)
    8508:	799b      	ldrb	r3, [r3, #6]
    850a:	b2db      	uxtb	r3, r3
    850c:	089b      	lsrs	r3, r3, #2
    850e:	f003 0303 	and.w	r3, r3, #3
    8512:	2b03      	cmp	r3, #3
    8514:	d1f7      	bne.n	8506 <CLOCK_SetPeeMode+0x16>
    {
    }

    return kStatus_Success;
    8516:	2300      	movs	r3, #0
}
    8518:	4618      	mov	r0, r3
    851a:	46bd      	mov	sp, r7
    851c:	f85d 7b04 	ldr.w	r7, [sp], #4
    8520:	4770      	bx	lr
    8522:	bf00      	nop
    8524:	40064000 	.word	0x40064000

00008528 <CLOCK_ExternalModeToFbeModeQuick>:
 *
 * retval kStatus_Success Switched successfully.
 * retval kStatus_MCG_ModeInvalid If the current mode is not an external mode, do not call this function.
 */
status_t CLOCK_ExternalModeToFbeModeQuick(void)
{
    8528:	b480      	push	{r7}
    852a:	af00      	add	r7, sp, #0
        return kStatus_MCG_ModeInvalid;
    }
#endif /* MCG_CONFIG_CHECK_PARAM */

    /* Disable low power */
    MCG->C2 &= (uint8_t)(~MCG_C2_LP_MASK);
    852c:	4b18      	ldr	r3, [pc, #96]	; (8590 <CLOCK_ExternalModeToFbeModeQuick+0x68>)
    852e:	785b      	ldrb	r3, [r3, #1]
    8530:	b2db      	uxtb	r3, r3
    8532:	4a17      	ldr	r2, [pc, #92]	; (8590 <CLOCK_ExternalModeToFbeModeQuick+0x68>)
    8534:	f023 0302 	bic.w	r3, r3, #2
    8538:	b2db      	uxtb	r3, r3
    853a:	7053      	strb	r3, [r2, #1]

    MCG->C1 = (uint8_t)((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
    853c:	4b14      	ldr	r3, [pc, #80]	; (8590 <CLOCK_ExternalModeToFbeModeQuick+0x68>)
    853e:	781b      	ldrb	r3, [r3, #0]
    8540:	b2db      	uxtb	r3, r3
    8542:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    8546:	b2db      	uxtb	r3, r3
    8548:	4a11      	ldr	r2, [pc, #68]	; (8590 <CLOCK_ExternalModeToFbeModeQuick+0x68>)
    854a:	f063 037f 	orn	r3, r3, #127	; 0x7f
    854e:	b2db      	uxtb	r3, r3
    8550:	7013      	strb	r3, [r2, #0]
    while (MCG_S_CLKST_VAL != (uint8_t)kMCG_ClkOutStatExt)
    8552:	bf00      	nop
    8554:	4b0e      	ldr	r3, [pc, #56]	; (8590 <CLOCK_ExternalModeToFbeModeQuick+0x68>)
    8556:	799b      	ldrb	r3, [r3, #6]
    8558:	b2db      	uxtb	r3, r3
    855a:	089b      	lsrs	r3, r3, #2
    855c:	f003 0303 	and.w	r3, r3, #3
    8560:	2b02      	cmp	r3, #2
    8562:	d1f7      	bne.n	8554 <CLOCK_ExternalModeToFbeModeQuick+0x2c>
    {
    }

    /* Disable PLL. */
    MCG->C6 &= ~(uint8_t)MCG_C6_PLLS_MASK;
    8564:	4b0a      	ldr	r3, [pc, #40]	; (8590 <CLOCK_ExternalModeToFbeModeQuick+0x68>)
    8566:	795b      	ldrb	r3, [r3, #5]
    8568:	b2db      	uxtb	r3, r3
    856a:	4a09      	ldr	r2, [pc, #36]	; (8590 <CLOCK_ExternalModeToFbeModeQuick+0x68>)
    856c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    8570:	b2db      	uxtb	r3, r3
    8572:	7153      	strb	r3, [r2, #5]
    while ((MCG->S & MCG_S_PLLST_MASK) != 0U)
    8574:	bf00      	nop
    8576:	4b06      	ldr	r3, [pc, #24]	; (8590 <CLOCK_ExternalModeToFbeModeQuick+0x68>)
    8578:	799b      	ldrb	r3, [r3, #6]
    857a:	b2db      	uxtb	r3, r3
    857c:	f003 0320 	and.w	r3, r3, #32
    8580:	2b00      	cmp	r3, #0
    8582:	d1f8      	bne.n	8576 <CLOCK_ExternalModeToFbeModeQuick+0x4e>
    {
    }

    return kStatus_Success;
    8584:	2300      	movs	r3, #0
}
    8586:	4618      	mov	r0, r3
    8588:	46bd      	mov	sp, r7
    858a:	f85d 7b04 	ldr.w	r7, [sp], #4
    858e:	4770      	bx	lr
    8590:	40064000 	.word	0x40064000

00008594 <CLOCK_SetMcgConfig>:
 * note If the external clock is used in the target mode, ensure that it is
 * enabled. For example, if the OSC0 is used, set up OSC0 correctly before calling this
 * function.
 */
status_t CLOCK_SetMcgConfig(const mcg_config_t *config)
{
    8594:	b580      	push	{r7, lr}
    8596:	b086      	sub	sp, #24
    8598:	af00      	add	r7, sp, #0
    859a:	6078      	str	r0, [r7, #4]
    mcg_mode_t next_mode;
    status_t status = kStatus_Success;
    859c:	2300      	movs	r3, #0
    859e:	613b      	str	r3, [r7, #16]

    mcg_pll_clk_select_t pllcs = config->pllcs;
    85a0:	687b      	ldr	r3, [r7, #4]
    85a2:	7adb      	ldrb	r3, [r3, #11]
    85a4:	73fb      	strb	r3, [r7, #15]

    /* If need to change external clock, MCG_C7[OSCSEL]. */
    if (MCG_C7_OSCSEL_VAL != (uint8_t)(config->oscsel))
    85a6:	4b7f      	ldr	r3, [pc, #508]	; (87a4 <CLOCK_SetMcgConfig+0x210>)
    85a8:	7b1b      	ldrb	r3, [r3, #12]
    85aa:	b2db      	uxtb	r3, r3
    85ac:	f003 0303 	and.w	r3, r3, #3
    85b0:	687a      	ldr	r2, [r7, #4]
    85b2:	79d2      	ldrb	r2, [r2, #7]
    85b4:	4293      	cmp	r3, r2
    85b6:	d015      	beq.n	85e4 <CLOCK_SetMcgConfig+0x50>
    {
        /* If external clock is in use, change to FEI first. */
        if ((uint8_t)kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
    85b8:	4b7a      	ldr	r3, [pc, #488]	; (87a4 <CLOCK_SetMcgConfig+0x210>)
    85ba:	799b      	ldrb	r3, [r3, #6]
    85bc:	b2db      	uxtb	r3, r3
    85be:	f003 0310 	and.w	r3, r3, #16
    85c2:	2b00      	cmp	r3, #0
    85c4:	d109      	bne.n	85da <CLOCK_SetMcgConfig+0x46>
        {
            (void)CLOCK_ExternalModeToFbeModeQuick();
    85c6:	f7ff ffaf 	bl	8528 <CLOCK_ExternalModeToFbeModeQuick>
            (void)CLOCK_SetFeiMode(config->dmx32, config->drs, NULL);
    85ca:	687b      	ldr	r3, [r7, #4]
    85cc:	7998      	ldrb	r0, [r3, #6]
    85ce:	687b      	ldr	r3, [r7, #4]
    85d0:	795b      	ldrb	r3, [r3, #5]
    85d2:	2200      	movs	r2, #0
    85d4:	4619      	mov	r1, r3
    85d6:	f7ff fd07 	bl	7fe8 <CLOCK_SetFeiMode>
        }

        (void)CLOCK_SetExternalRefClkConfig(config->oscsel);
    85da:	687b      	ldr	r3, [r7, #4]
    85dc:	79db      	ldrb	r3, [r3, #7]
    85de:	4618      	mov	r0, r3
    85e0:	f7ff fb5e 	bl	7ca0 <CLOCK_SetExternalRefClkConfig>
    }

    /* Re-configure MCGIRCLK, if MCGIRCLK is used as system clock source, then change to FEI/PEI first. */
    if (MCG_S_CLKST_VAL == (uint8_t)kMCG_ClkOutStatInt)
    85e4:	4b6f      	ldr	r3, [pc, #444]	; (87a4 <CLOCK_SetMcgConfig+0x210>)
    85e6:	799b      	ldrb	r3, [r3, #6]
    85e8:	b2db      	uxtb	r3, r3
    85ea:	089b      	lsrs	r3, r3, #2
    85ec:	f003 0303 	and.w	r3, r3, #3
    85f0:	2b01      	cmp	r3, #1
    85f2:	d10f      	bne.n	8614 <CLOCK_SetMcgConfig+0x80>
    {
        MCG->C2 &= ~(uint8_t)MCG_C2_LP_MASK; /* Disable lowpower. */
    85f4:	4b6b      	ldr	r3, [pc, #428]	; (87a4 <CLOCK_SetMcgConfig+0x210>)
    85f6:	785b      	ldrb	r3, [r3, #1]
    85f8:	b2db      	uxtb	r3, r3
    85fa:	4a6a      	ldr	r2, [pc, #424]	; (87a4 <CLOCK_SetMcgConfig+0x210>)
    85fc:	f023 0302 	bic.w	r3, r3, #2
    8600:	b2db      	uxtb	r3, r3
    8602:	7053      	strb	r3, [r2, #1]

        {
            (void)CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
    8604:	687b      	ldr	r3, [r7, #4]
    8606:	7998      	ldrb	r0, [r3, #6]
    8608:	687b      	ldr	r3, [r7, #4]
    860a:	795b      	ldrb	r3, [r3, #5]
    860c:	4a66      	ldr	r2, [pc, #408]	; (87a8 <CLOCK_SetMcgConfig+0x214>)
    860e:	4619      	mov	r1, r3
    8610:	f7ff fcea 	bl	7fe8 <CLOCK_SetFeiMode>
        }
    }

    /* Configure MCGIRCLK. */
    (void)CLOCK_SetInternalRefClkConfig(config->irclkEnableMode, config->ircs, config->fcrdiv);
    8614:	687b      	ldr	r3, [r7, #4]
    8616:	7858      	ldrb	r0, [r3, #1]
    8618:	687b      	ldr	r3, [r7, #4]
    861a:	7899      	ldrb	r1, [r3, #2]
    861c:	687b      	ldr	r3, [r7, #4]
    861e:	78db      	ldrb	r3, [r3, #3]
    8620:	461a      	mov	r2, r3
    8622:	f7ff fb73 	bl	7d0c <CLOCK_SetInternalRefClkConfig>

    next_mode = CLOCK_GetMode();
    8626:	f7ff fc85 	bl	7f34 <CLOCK_GetMode>
    862a:	4603      	mov	r3, r0
    862c:	75fb      	strb	r3, [r7, #23]

    do
    {
        next_mode = mcgModeMatrix[next_mode][config->mcgMode];
    862e:	7dfb      	ldrb	r3, [r7, #23]
    8630:	687a      	ldr	r2, [r7, #4]
    8632:	7812      	ldrb	r2, [r2, #0]
    8634:	4611      	mov	r1, r2
    8636:	4a5d      	ldr	r2, [pc, #372]	; (87ac <CLOCK_SetMcgConfig+0x218>)
    8638:	00db      	lsls	r3, r3, #3
    863a:	4413      	add	r3, r2
    863c:	440b      	add	r3, r1
    863e:	781b      	ldrb	r3, [r3, #0]
    8640:	75fb      	strb	r3, [r7, #23]

        switch (next_mode)
    8642:	7dfb      	ldrb	r3, [r7, #23]
    8644:	2b07      	cmp	r3, #7
    8646:	d87f      	bhi.n	8748 <CLOCK_SetMcgConfig+0x1b4>
    8648:	a201      	add	r2, pc, #4	; (adr r2, 8650 <CLOCK_SetMcgConfig+0xbc>)
    864a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    864e:	bf00      	nop
    8650:	00008671 	.word	0x00008671
    8654:	0000869b 	.word	0x0000869b
    8658:	000086c5 	.word	0x000086c5
    865c:	00008685 	.word	0x00008685
    8660:	000086af 	.word	0x000086af
    8664:	000086cd 	.word	0x000086cd
    8668:	000086d5 	.word	0x000086d5
    866c:	00008741 	.word	0x00008741
        {
            case kMCG_ModeFEI:
                status = CLOCK_SetFeiMode(config->dmx32, config->drs, CLOCK_FllStableDelay);
    8670:	687b      	ldr	r3, [r7, #4]
    8672:	7998      	ldrb	r0, [r3, #6]
    8674:	687b      	ldr	r3, [r7, #4]
    8676:	795b      	ldrb	r3, [r3, #5]
    8678:	4a4b      	ldr	r2, [pc, #300]	; (87a8 <CLOCK_SetMcgConfig+0x214>)
    867a:	4619      	mov	r1, r3
    867c:	f7ff fcb4 	bl	7fe8 <CLOCK_SetFeiMode>
    8680:	6138      	str	r0, [r7, #16]
                break;
    8682:	e068      	b.n	8756 <CLOCK_SetMcgConfig+0x1c2>
            case kMCG_ModeFEE:
                status = CLOCK_SetFeeMode(config->frdiv, config->dmx32, config->drs, CLOCK_FllStableDelay);
    8684:	687b      	ldr	r3, [r7, #4]
    8686:	7918      	ldrb	r0, [r3, #4]
    8688:	687b      	ldr	r3, [r7, #4]
    868a:	7999      	ldrb	r1, [r3, #6]
    868c:	687b      	ldr	r3, [r7, #4]
    868e:	795a      	ldrb	r2, [r3, #5]
    8690:	4b45      	ldr	r3, [pc, #276]	; (87a8 <CLOCK_SetMcgConfig+0x214>)
    8692:	f7ff fd09 	bl	80a8 <CLOCK_SetFeeMode>
    8696:	6138      	str	r0, [r7, #16]
                break;
    8698:	e05d      	b.n	8756 <CLOCK_SetMcgConfig+0x1c2>
            case kMCG_ModeFBI:
                status = CLOCK_SetFbiMode(config->dmx32, config->drs, NULL);
    869a:	687b      	ldr	r3, [r7, #4]
    869c:	7998      	ldrb	r0, [r3, #6]
    869e:	687b      	ldr	r3, [r7, #4]
    86a0:	795b      	ldrb	r3, [r3, #5]
    86a2:	2200      	movs	r2, #0
    86a4:	4619      	mov	r1, r3
    86a6:	f7ff fd85 	bl	81b4 <CLOCK_SetFbiMode>
    86aa:	6138      	str	r0, [r7, #16]
                break;
    86ac:	e053      	b.n	8756 <CLOCK_SetMcgConfig+0x1c2>
            case kMCG_ModeFBE:
                status = CLOCK_SetFbeMode(config->frdiv, config->dmx32, config->drs, NULL);
    86ae:	687b      	ldr	r3, [r7, #4]
    86b0:	7918      	ldrb	r0, [r3, #4]
    86b2:	687b      	ldr	r3, [r7, #4]
    86b4:	7999      	ldrb	r1, [r3, #6]
    86b6:	687b      	ldr	r3, [r7, #4]
    86b8:	795a      	ldrb	r2, [r3, #5]
    86ba:	2300      	movs	r3, #0
    86bc:	f7ff fde2 	bl	8284 <CLOCK_SetFbeMode>
    86c0:	6138      	str	r0, [r7, #16]
                break;
    86c2:	e048      	b.n	8756 <CLOCK_SetMcgConfig+0x1c2>
            case kMCG_ModeBLPI:
                status = CLOCK_SetBlpiMode();
    86c4:	f7ff fe74 	bl	83b0 <CLOCK_SetBlpiMode>
    86c8:	6138      	str	r0, [r7, #16]
                break;
    86ca:	e044      	b.n	8756 <CLOCK_SetMcgConfig+0x1c2>
            case kMCG_ModeBLPE:
                status = CLOCK_SetBlpeMode();
    86cc:	f7ff fe82 	bl	83d4 <CLOCK_SetBlpeMode>
    86d0:	6138      	str	r0, [r7, #16]
                break;
    86d2:	e040      	b.n	8756 <CLOCK_SetMcgConfig+0x1c2>
            case kMCG_ModePBE:
                /* If target mode is not PBE or PEE, then only need to set CLKS = EXT here. */
                if ((kMCG_ModePEE == config->mcgMode) || (kMCG_ModePBE == config->mcgMode))
    86d4:	687b      	ldr	r3, [r7, #4]
    86d6:	781b      	ldrb	r3, [r3, #0]
    86d8:	2b07      	cmp	r3, #7
    86da:	d003      	beq.n	86e4 <CLOCK_SetMcgConfig+0x150>
    86dc:	687b      	ldr	r3, [r7, #4]
    86de:	781b      	ldrb	r3, [r3, #0]
    86e0:	2b06      	cmp	r3, #6
    86e2:	d116      	bne.n	8712 <CLOCK_SetMcgConfig+0x17e>
                {
                    if (kMCG_PllClkSelPll0 == pllcs)
    86e4:	7bfb      	ldrb	r3, [r7, #15]
    86e6:	2b00      	cmp	r3, #0
    86e8:	d109      	bne.n	86fe <CLOCK_SetMcgConfig+0x16a>
                    {
                        status = CLOCK_SetPbeMode(pllcs, &config->pll0Config);
    86ea:	687b      	ldr	r3, [r7, #4]
    86ec:	f103 0208 	add.w	r2, r3, #8
    86f0:	7bfb      	ldrb	r3, [r7, #15]
    86f2:	4611      	mov	r1, r2
    86f4:	4618      	mov	r0, r3
    86f6:	f7ff fe7f 	bl	83f8 <CLOCK_SetPbeMode>
    86fa:	6138      	str	r0, [r7, #16]
                    if (kMCG_PllClkSelPll0 == pllcs)
    86fc:	e01e      	b.n	873c <CLOCK_SetMcgConfig+0x1a8>
                    }
                    else if (kMCG_PllClkSelExtPll == pllcs)
    86fe:	7bfb      	ldrb	r3, [r7, #15]
    8700:	2b01      	cmp	r3, #1
    8702:	d11b      	bne.n	873c <CLOCK_SetMcgConfig+0x1a8>
                    {
                        status = CLOCK_SetPbeMode(pllcs, NULL);
    8704:	7bfb      	ldrb	r3, [r7, #15]
    8706:	2100      	movs	r1, #0
    8708:	4618      	mov	r0, r3
    870a:	f7ff fe75 	bl	83f8 <CLOCK_SetPbeMode>
    870e:	6138      	str	r0, [r7, #16]
                    if (kMCG_PllClkSelPll0 == pllcs)
    8710:	e014      	b.n	873c <CLOCK_SetMcgConfig+0x1a8>
                        /* Add comment to prevent the case of MISRA C-2012 rule 15.7 */
                    }
                }
                else
                {
                    MCG->C1 = (uint8_t)((MCG->C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
    8712:	4b24      	ldr	r3, [pc, #144]	; (87a4 <CLOCK_SetMcgConfig+0x210>)
    8714:	781b      	ldrb	r3, [r3, #0]
    8716:	b2db      	uxtb	r3, r3
    8718:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    871c:	b2db      	uxtb	r3, r3
    871e:	4a21      	ldr	r2, [pc, #132]	; (87a4 <CLOCK_SetMcgConfig+0x210>)
    8720:	f063 037f 	orn	r3, r3, #127	; 0x7f
    8724:	b2db      	uxtb	r3, r3
    8726:	7013      	strb	r3, [r2, #0]
                    while (MCG_S_CLKST_VAL != (uint8_t)kMCG_ClkOutStatExt)
    8728:	bf00      	nop
    872a:	4b1e      	ldr	r3, [pc, #120]	; (87a4 <CLOCK_SetMcgConfig+0x210>)
    872c:	799b      	ldrb	r3, [r3, #6]
    872e:	b2db      	uxtb	r3, r3
    8730:	089b      	lsrs	r3, r3, #2
    8732:	f003 0303 	and.w	r3, r3, #3
    8736:	2b02      	cmp	r3, #2
    8738:	d1f7      	bne.n	872a <CLOCK_SetMcgConfig+0x196>
                    {
                    }
                }
                break;
    873a:	e00c      	b.n	8756 <CLOCK_SetMcgConfig+0x1c2>
                    if (kMCG_PllClkSelPll0 == pllcs)
    873c:	bf00      	nop
                break;
    873e:	e00a      	b.n	8756 <CLOCK_SetMcgConfig+0x1c2>
            case kMCG_ModePEE:
                status = CLOCK_SetPeeMode();
    8740:	f7ff fed6 	bl	84f0 <CLOCK_SetPeeMode>
    8744:	6138      	str	r0, [r7, #16]
                break;
    8746:	e006      	b.n	8756 <CLOCK_SetMcgConfig+0x1c2>
            default:
                assert(false);
    8748:	4b19      	ldr	r3, [pc, #100]	; (87b0 <CLOCK_SetMcgConfig+0x21c>)
    874a:	4a1a      	ldr	r2, [pc, #104]	; (87b4 <CLOCK_SetMcgConfig+0x220>)
    874c:	f640 2158 	movw	r1, #2648	; 0xa58
    8750:	4819      	ldr	r0, [pc, #100]	; (87b8 <CLOCK_SetMcgConfig+0x224>)
    8752:	f7fe fd43 	bl	71dc <__assert_func>
                break;
        }
        if (kStatus_Success != status)
    8756:	693b      	ldr	r3, [r7, #16]
    8758:	2b00      	cmp	r3, #0
    875a:	d106      	bne.n	876a <CLOCK_SetMcgConfig+0x1d6>
        {
            break;
        }
    } while (next_mode != config->mcgMode);
    875c:	687b      	ldr	r3, [r7, #4]
    875e:	781b      	ldrb	r3, [r3, #0]
    8760:	7dfa      	ldrb	r2, [r7, #23]
    8762:	429a      	cmp	r2, r3
    8764:	f47f af63 	bne.w	862e <CLOCK_SetMcgConfig+0x9a>
    8768:	e000      	b.n	876c <CLOCK_SetMcgConfig+0x1d8>
            break;
    876a:	bf00      	nop

    if (status == kStatus_Success)
    876c:	693b      	ldr	r3, [r7, #16]
    876e:	2b00      	cmp	r3, #0
    8770:	d113      	bne.n	879a <CLOCK_SetMcgConfig+0x206>
    {
        if ((config->pll0Config.enableMode & (uint8_t)kMCG_PllEnableIndependent) != 0U)
    8772:	687b      	ldr	r3, [r7, #4]
    8774:	7a1b      	ldrb	r3, [r3, #8]
    8776:	f003 0340 	and.w	r3, r3, #64	; 0x40
    877a:	2b00      	cmp	r3, #0
    877c:	d005      	beq.n	878a <CLOCK_SetMcgConfig+0x1f6>
        {
            CLOCK_EnablePll0(&config->pll0Config);
    877e:	687b      	ldr	r3, [r7, #4]
    8780:	3308      	adds	r3, #8
    8782:	4618      	mov	r0, r3
    8784:	f7ff fb44 	bl	7e10 <CLOCK_EnablePll0>
    8788:	e007      	b.n	879a <CLOCK_SetMcgConfig+0x206>
        }
        else
        {
            MCG->C5 &= ~(uint8_t)kMCG_PllEnableIndependent;
    878a:	4b06      	ldr	r3, [pc, #24]	; (87a4 <CLOCK_SetMcgConfig+0x210>)
    878c:	791b      	ldrb	r3, [r3, #4]
    878e:	b2db      	uxtb	r3, r3
    8790:	4a04      	ldr	r2, [pc, #16]	; (87a4 <CLOCK_SetMcgConfig+0x210>)
    8792:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    8796:	b2db      	uxtb	r3, r3
    8798:	7113      	strb	r3, [r2, #4]
        }
    }

    return status;
    879a:	693b      	ldr	r3, [r7, #16]
}
    879c:	4618      	mov	r0, r3
    879e:	3718      	adds	r7, #24
    87a0:	46bd      	mov	sp, r7
    87a2:	bd80      	pop	{r7, pc}
    87a4:	40064000 	.word	0x40064000
    87a8:	00007355 	.word	0x00007355
    87ac:	0000f7bc 	.word	0x0000f7bc
    87b0:	0000f7b4 	.word	0x0000f7b4
    87b4:	0000f8c8 	.word	0x0000f8c8
    87b8:	0000f674 	.word	0x0000f674

000087bc <SMC_SetPowerModeHsrun>:
 *
 * param base SMC peripheral base address.
 * return SMC configuration error code.
 */
status_t SMC_SetPowerModeHsrun(SMC_Type *base)
{
    87bc:	b480      	push	{r7}
    87be:	b085      	sub	sp, #20
    87c0:	af00      	add	r7, sp, #0
    87c2:	6078      	str	r0, [r7, #4]
    smc_reg_t reg;

    reg = (base->PMCTRL);
    87c4:	687b      	ldr	r3, [r7, #4]
    87c6:	785b      	ldrb	r3, [r3, #1]
    87c8:	73fb      	strb	r3, [r7, #15]
    /* configure High Speed RUN mode */
    reg &= ~(smc_reg_t)SMC_PMCTRL_RUNM_MASK;
    87ca:	7bfb      	ldrb	r3, [r7, #15]
    87cc:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    87d0:	73fb      	strb	r3, [r7, #15]
    reg |= ((smc_reg_t)kSMC_Hsrun << SMC_PMCTRL_RUNM_SHIFT);
    87d2:	7bfb      	ldrb	r3, [r7, #15]
    87d4:	f043 0360 	orr.w	r3, r3, #96	; 0x60
    87d8:	73fb      	strb	r3, [r7, #15]
    base->PMCTRL = reg;
    87da:	687b      	ldr	r3, [r7, #4]
    87dc:	7bfa      	ldrb	r2, [r7, #15]
    87de:	705a      	strb	r2, [r3, #1]

    return kStatus_Success;
    87e0:	2300      	movs	r3, #0
}
    87e2:	4618      	mov	r0, r3
    87e4:	3714      	adds	r7, #20
    87e6:	46bd      	mov	sp, r7
    87e8:	f85d 7b04 	ldr.w	r7, [sp], #4
    87ec:	4770      	bx	lr

000087ee <CLOCK_EnableClock>:
{
    87ee:	b480      	push	{r7}
    87f0:	b085      	sub	sp, #20
    87f2:	af00      	add	r7, sp, #0
    87f4:	6078      	str	r0, [r7, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    87f6:	687b      	ldr	r3, [r7, #4]
    87f8:	0c1b      	lsrs	r3, r3, #16
    87fa:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    87fe:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    8802:	60fb      	str	r3, [r7, #12]
    (*(volatile uint32_t *)regAddr) |= (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
    8804:	68fb      	ldr	r3, [r7, #12]
    8806:	6819      	ldr	r1, [r3, #0]
    8808:	687b      	ldr	r3, [r7, #4]
    880a:	b29b      	uxth	r3, r3
    880c:	2201      	movs	r2, #1
    880e:	409a      	lsls	r2, r3
    8810:	68fb      	ldr	r3, [r7, #12]
    8812:	430a      	orrs	r2, r1
    8814:	601a      	str	r2, [r3, #0]
}
    8816:	bf00      	nop
    8818:	3714      	adds	r7, #20
    881a:	46bd      	mov	sp, r7
    881c:	f85d 7b04 	ldr.w	r7, [sp], #4
    8820:	4770      	bx	lr
    8822:	Address 0x00008822 is out of bounds.


00008824 <ADC16_GetInstance>:

/*******************************************************************************
 * Code
 ******************************************************************************/
static uint32_t ADC16_GetInstance(ADC_Type *base)
{
    8824:	b580      	push	{r7, lr}
    8826:	b084      	sub	sp, #16
    8828:	af00      	add	r7, sp, #0
    882a:	6078      	str	r0, [r7, #4]
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < ARRAY_SIZE(s_adc16Bases); instance++)
    882c:	2300      	movs	r3, #0
    882e:	60fb      	str	r3, [r7, #12]
    8830:	e009      	b.n	8846 <ADC16_GetInstance+0x22>
    {
        if (s_adc16Bases[instance] == base)
    8832:	4a0e      	ldr	r2, [pc, #56]	; (886c <ADC16_GetInstance+0x48>)
    8834:	68fb      	ldr	r3, [r7, #12]
    8836:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    883a:	687a      	ldr	r2, [r7, #4]
    883c:	429a      	cmp	r2, r3
    883e:	d006      	beq.n	884e <ADC16_GetInstance+0x2a>
    for (instance = 0; instance < ARRAY_SIZE(s_adc16Bases); instance++)
    8840:	68fb      	ldr	r3, [r7, #12]
    8842:	3301      	adds	r3, #1
    8844:	60fb      	str	r3, [r7, #12]
    8846:	68fb      	ldr	r3, [r7, #12]
    8848:	2b01      	cmp	r3, #1
    884a:	d9f2      	bls.n	8832 <ADC16_GetInstance+0xe>
    884c:	e000      	b.n	8850 <ADC16_GetInstance+0x2c>
        {
            break;
    884e:	bf00      	nop
        }
    }

    assert(instance < ARRAY_SIZE(s_adc16Bases));
    8850:	68fb      	ldr	r3, [r7, #12]
    8852:	2b01      	cmp	r3, #1
    8854:	d905      	bls.n	8862 <ADC16_GetInstance+0x3e>
    8856:	4b06      	ldr	r3, [pc, #24]	; (8870 <ADC16_GetInstance+0x4c>)
    8858:	4a06      	ldr	r2, [pc, #24]	; (8874 <ADC16_GetInstance+0x50>)
    885a:	2135      	movs	r1, #53	; 0x35
    885c:	4806      	ldr	r0, [pc, #24]	; (8878 <ADC16_GetInstance+0x54>)
    885e:	f7fe fcbd 	bl	71dc <__assert_func>

    return instance;
    8862:	68fb      	ldr	r3, [r7, #12]
}
    8864:	4618      	mov	r0, r3
    8866:	3710      	adds	r7, #16
    8868:	46bd      	mov	sp, r7
    886a:	bd80      	pop	{r7, pc}
    886c:	0000f8dc 	.word	0x0000f8dc
    8870:	0000f8ec 	.word	0x0000f8ec
    8874:	0000f9a4 	.word	0x0000f9a4
    8878:	0000f910 	.word	0x0000f910

0000887c <ADC16_Init>:
 *
 * param base   ADC16 peripheral base address.
 * param config Pointer to configuration structure. See "adc16_config_t".
 */
void ADC16_Init(ADC_Type *base, const adc16_config_t *config)
{
    887c:	b580      	push	{r7, lr}
    887e:	b084      	sub	sp, #16
    8880:	af00      	add	r7, sp, #0
    8882:	6078      	str	r0, [r7, #4]
    8884:	6039      	str	r1, [r7, #0]
    assert(NULL != config);
    8886:	683b      	ldr	r3, [r7, #0]
    8888:	2b00      	cmp	r3, #0
    888a:	d105      	bne.n	8898 <ADC16_Init+0x1c>
    888c:	4b41      	ldr	r3, [pc, #260]	; (8994 <ADC16_Init+0x118>)
    888e:	4a42      	ldr	r2, [pc, #264]	; (8998 <ADC16_Init+0x11c>)
    8890:	2142      	movs	r1, #66	; 0x42
    8892:	4842      	ldr	r0, [pc, #264]	; (899c <ADC16_Init+0x120>)
    8894:	f7fe fca2 	bl	71dc <__assert_func>

    uint32_t tmp32;

#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    /* Enable the clock. */
    CLOCK_EnableClock(s_adc16Clocks[ADC16_GetInstance(base)]);
    8898:	6878      	ldr	r0, [r7, #4]
    889a:	f7ff ffc3 	bl	8824 <ADC16_GetInstance>
    889e:	4603      	mov	r3, r0
    88a0:	4a3f      	ldr	r2, [pc, #252]	; (89a0 <ADC16_Init+0x124>)
    88a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88a6:	4618      	mov	r0, r3
    88a8:	f7ff ffa1 	bl	87ee <CLOCK_EnableClock>
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

    /* ADCx_CFG1. */
    tmp32 = ADC_CFG1_ADICLK(config->clockSource) | ADC_CFG1_MODE(config->resolution);
    88ac:	683b      	ldr	r3, [r7, #0]
    88ae:	785b      	ldrb	r3, [r3, #1]
    88b0:	f003 0203 	and.w	r2, r3, #3
    88b4:	683b      	ldr	r3, [r7, #0]
    88b6:	791b      	ldrb	r3, [r3, #4]
    88b8:	009b      	lsls	r3, r3, #2
    88ba:	f003 030c 	and.w	r3, r3, #12
    88be:	4313      	orrs	r3, r2
    88c0:	60fb      	str	r3, [r7, #12]
    if (kADC16_LongSampleDisabled != config->longSampleMode)
    88c2:	683b      	ldr	r3, [r7, #0]
    88c4:	795b      	ldrb	r3, [r3, #5]
    88c6:	2b04      	cmp	r3, #4
    88c8:	d003      	beq.n	88d2 <ADC16_Init+0x56>
    {
        tmp32 |= ADC_CFG1_ADLSMP_MASK;
    88ca:	68fb      	ldr	r3, [r7, #12]
    88cc:	f043 0310 	orr.w	r3, r3, #16
    88d0:	60fb      	str	r3, [r7, #12]
    }
    tmp32 |= ADC_CFG1_ADIV(config->clockDivider);
    88d2:	683b      	ldr	r3, [r7, #0]
    88d4:	78db      	ldrb	r3, [r3, #3]
    88d6:	015b      	lsls	r3, r3, #5
    88d8:	f003 0360 	and.w	r3, r3, #96	; 0x60
    88dc:	68fa      	ldr	r2, [r7, #12]
    88de:	4313      	orrs	r3, r2
    88e0:	60fb      	str	r3, [r7, #12]
    if (true == config->enableLowPower)
    88e2:	683b      	ldr	r3, [r7, #0]
    88e4:	79db      	ldrb	r3, [r3, #7]
    88e6:	2b00      	cmp	r3, #0
    88e8:	d003      	beq.n	88f2 <ADC16_Init+0x76>
    {
        tmp32 |= ADC_CFG1_ADLPC_MASK;
    88ea:	68fb      	ldr	r3, [r7, #12]
    88ec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    88f0:	60fb      	str	r3, [r7, #12]
    }
    base->CFG1 = tmp32;
    88f2:	687b      	ldr	r3, [r7, #4]
    88f4:	68fa      	ldr	r2, [r7, #12]
    88f6:	609a      	str	r2, [r3, #8]

    /* ADCx_CFG2. */
    tmp32 = base->CFG2 & ~(ADC_CFG2_ADACKEN_MASK | ADC_CFG2_ADHSC_MASK | ADC_CFG2_ADLSTS_MASK);
    88f8:	687b      	ldr	r3, [r7, #4]
    88fa:	68db      	ldr	r3, [r3, #12]
    88fc:	f023 030f 	bic.w	r3, r3, #15
    8900:	60fb      	str	r3, [r7, #12]
    if (kADC16_LongSampleDisabled != config->longSampleMode)
    8902:	683b      	ldr	r3, [r7, #0]
    8904:	795b      	ldrb	r3, [r3, #5]
    8906:	2b04      	cmp	r3, #4
    8908:	d006      	beq.n	8918 <ADC16_Init+0x9c>
    {
        tmp32 |= ADC_CFG2_ADLSTS(config->longSampleMode);
    890a:	683b      	ldr	r3, [r7, #0]
    890c:	795b      	ldrb	r3, [r3, #5]
    890e:	f003 0303 	and.w	r3, r3, #3
    8912:	68fa      	ldr	r2, [r7, #12]
    8914:	4313      	orrs	r3, r2
    8916:	60fb      	str	r3, [r7, #12]
    }
    if (true == config->enableHighSpeed)
    8918:	683b      	ldr	r3, [r7, #0]
    891a:	799b      	ldrb	r3, [r3, #6]
    891c:	2b00      	cmp	r3, #0
    891e:	d003      	beq.n	8928 <ADC16_Init+0xac>
    {
        tmp32 |= ADC_CFG2_ADHSC_MASK;
    8920:	68fb      	ldr	r3, [r7, #12]
    8922:	f043 0304 	orr.w	r3, r3, #4
    8926:	60fb      	str	r3, [r7, #12]
    }
    if (true == config->enableAsynchronousClock)
    8928:	683b      	ldr	r3, [r7, #0]
    892a:	789b      	ldrb	r3, [r3, #2]
    892c:	2b00      	cmp	r3, #0
    892e:	d003      	beq.n	8938 <ADC16_Init+0xbc>
    {
        tmp32 |= ADC_CFG2_ADACKEN_MASK;
    8930:	68fb      	ldr	r3, [r7, #12]
    8932:	f043 0308 	orr.w	r3, r3, #8
    8936:	60fb      	str	r3, [r7, #12]
    }
    base->CFG2 = tmp32;
    8938:	687b      	ldr	r3, [r7, #4]
    893a:	68fa      	ldr	r2, [r7, #12]
    893c:	60da      	str	r2, [r3, #12]

    /* ADCx_SC2. */
    tmp32 = base->SC2 & ~(ADC_SC2_REFSEL_MASK);
    893e:	687b      	ldr	r3, [r7, #4]
    8940:	6a1b      	ldr	r3, [r3, #32]
    8942:	f023 0303 	bic.w	r3, r3, #3
    8946:	60fb      	str	r3, [r7, #12]
    tmp32 |= ADC_SC2_REFSEL(config->referenceVoltageSource);
    8948:	683b      	ldr	r3, [r7, #0]
    894a:	781b      	ldrb	r3, [r3, #0]
    894c:	f003 0303 	and.w	r3, r3, #3
    8950:	68fa      	ldr	r2, [r7, #12]
    8952:	4313      	orrs	r3, r2
    8954:	60fb      	str	r3, [r7, #12]
    base->SC2 = tmp32;
    8956:	687b      	ldr	r3, [r7, #4]
    8958:	68fa      	ldr	r2, [r7, #12]
    895a:	621a      	str	r2, [r3, #32]

    /* ADCx_SC3. */
    if (true == config->enableContinuousConversion)
    895c:	683b      	ldr	r3, [r7, #0]
    895e:	7a1b      	ldrb	r3, [r3, #8]
    8960:	2b00      	cmp	r3, #0
    8962:	d006      	beq.n	8972 <ADC16_Init+0xf6>
    {
        base->SC3 |= ADC_SC3_ADCO_MASK;
    8964:	687b      	ldr	r3, [r7, #4]
    8966:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8968:	f043 0208 	orr.w	r2, r3, #8
    896c:	687b      	ldr	r3, [r7, #4]
    896e:	625a      	str	r2, [r3, #36]	; 0x24
    8970:	e005      	b.n	897e <ADC16_Init+0x102>
    }
    else
    {
        base->SC3 &= ~ADC_SC3_ADCO_MASK;
    8972:	687b      	ldr	r3, [r7, #4]
    8974:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8976:	f023 0208 	bic.w	r2, r3, #8
    897a:	687b      	ldr	r3, [r7, #4]
    897c:	625a      	str	r2, [r3, #36]	; 0x24
    }

#if defined(FSL_FEATURE_ADC16_HAS_HW_AVERAGE) && FSL_FEATURE_ADC16_HAS_HW_AVERAGE
    ADC16_SetHardwareAverage(base, config->hardwareAverageMode);
    897e:	683b      	ldr	r3, [r7, #0]
    8980:	7a5b      	ldrb	r3, [r3, #9]
    8982:	4619      	mov	r1, r3
    8984:	6878      	ldr	r0, [r7, #4]
    8986:	f000 f8c1 	bl	8b0c <ADC16_SetHardwareAverage>
#endif /* FSL_FEATURE_ADC16_HAS_HW_AVERAGE */
}
    898a:	bf00      	nop
    898c:	3710      	adds	r7, #16
    898e:	46bd      	mov	sp, r7
    8990:	bd80      	pop	{r7, pc}
    8992:	bf00      	nop
    8994:	0000f96c 	.word	0x0000f96c
    8998:	0000f9b8 	.word	0x0000f9b8
    899c:	0000f910 	.word	0x0000f910
    89a0:	0000f8e4 	.word	0x0000f8e4

000089a4 <ADC16_DoAutoCalibration>:
 * return                 Execution status.
 * retval kStatus_Success Calibration is done successfully.
 * retval kStatus_Fail    Calibration has failed.
 */
status_t ADC16_DoAutoCalibration(ADC_Type *base)
{
    89a4:	b580      	push	{r7, lr}
    89a6:	b086      	sub	sp, #24
    89a8:	af00      	add	r7, sp, #0
    89aa:	6078      	str	r0, [r7, #4]
    bool bHWTrigger = false;
    89ac:	2300      	movs	r3, #0
    89ae:	75fb      	strb	r3, [r7, #23]
    uint32_t tmp32;
    status_t status = kStatus_Success;
    89b0:	2300      	movs	r3, #0
    89b2:	613b      	str	r3, [r7, #16]

    /* The calibration would be failed when in hardwar mode.
     * Remember the hardware trigger state here and restore it later if the hardware trigger is enabled.*/
    if (0U != (ADC_SC2_ADTRG_MASK & base->SC2))
    89b4:	687b      	ldr	r3, [r7, #4]
    89b6:	6a1b      	ldr	r3, [r3, #32]
    89b8:	f003 0340 	and.w	r3, r3, #64	; 0x40
    89bc:	2b00      	cmp	r3, #0
    89be:	d007      	beq.n	89d0 <ADC16_DoAutoCalibration+0x2c>
    {
        bHWTrigger = true;
    89c0:	2301      	movs	r3, #1
    89c2:	75fb      	strb	r3, [r7, #23]
        base->SC2 &= ~ADC_SC2_ADTRG_MASK;
    89c4:	687b      	ldr	r3, [r7, #4]
    89c6:	6a1b      	ldr	r3, [r3, #32]
    89c8:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    89cc:	687b      	ldr	r3, [r7, #4]
    89ce:	621a      	str	r2, [r3, #32]
    }

    /* Clear the CALF and launch the calibration. */
    base->SC3 |= ADC_SC3_CAL_MASK | ADC_SC3_CALF_MASK;
    89d0:	687b      	ldr	r3, [r7, #4]
    89d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    89d4:	f043 02c0 	orr.w	r2, r3, #192	; 0xc0
    89d8:	687b      	ldr	r3, [r7, #4]
    89da:	625a      	str	r2, [r3, #36]	; 0x24
    while (0U == ((uint32_t)kADC16_ChannelConversionDoneFlag & ADC16_GetChannelStatusFlags(base, 0U)))
    89dc:	e00a      	b.n	89f4 <ADC16_DoAutoCalibration+0x50>
    {
        /* Check the CALF when the calibration is active. */
        if (0U != ((uint32_t)kADC16_CalibrationFailedFlag & ADC16_GetStatusFlags(base)))
    89de:	6878      	ldr	r0, [r7, #4]
    89e0:	f000 f8b3 	bl	8b4a <ADC16_GetStatusFlags>
    89e4:	4603      	mov	r3, r0
    89e6:	f003 0340 	and.w	r3, r3, #64	; 0x40
    89ea:	2b00      	cmp	r3, #0
    89ec:	d002      	beq.n	89f4 <ADC16_DoAutoCalibration+0x50>
        {
            status = kStatus_Fail;
    89ee:	2301      	movs	r3, #1
    89f0:	613b      	str	r3, [r7, #16]
            break;
    89f2:	e008      	b.n	8a06 <ADC16_DoAutoCalibration+0x62>
    while (0U == ((uint32_t)kADC16_ChannelConversionDoneFlag & ADC16_GetChannelStatusFlags(base, 0U)))
    89f4:	2100      	movs	r1, #0
    89f6:	6878      	ldr	r0, [r7, #4]
    89f8:	f000 f908 	bl	8c0c <ADC16_GetChannelStatusFlags>
    89fc:	4603      	mov	r3, r0
    89fe:	f003 0380 	and.w	r3, r3, #128	; 0x80
    8a02:	2b00      	cmp	r3, #0
    8a04:	d0eb      	beq.n	89de <ADC16_DoAutoCalibration+0x3a>
        }
    }
    (void)base->R[0]; /* Dummy read to clear COCO caused by calibration. */
    8a06:	687b      	ldr	r3, [r7, #4]
    8a08:	691b      	ldr	r3, [r3, #16]

    /* Restore the hardware trigger setting if it was enabled before. */
    if (bHWTrigger)
    8a0a:	7dfb      	ldrb	r3, [r7, #23]
    8a0c:	2b00      	cmp	r3, #0
    8a0e:	d005      	beq.n	8a1c <ADC16_DoAutoCalibration+0x78>
    {
        base->SC2 |= ADC_SC2_ADTRG_MASK;
    8a10:	687b      	ldr	r3, [r7, #4]
    8a12:	6a1b      	ldr	r3, [r3, #32]
    8a14:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    8a18:	687b      	ldr	r3, [r7, #4]
    8a1a:	621a      	str	r2, [r3, #32]
    }
    /* Check the CALF at the end of calibration. */
    if (0U != ((uint32_t)kADC16_CalibrationFailedFlag & ADC16_GetStatusFlags(base)))
    8a1c:	6878      	ldr	r0, [r7, #4]
    8a1e:	f000 f894 	bl	8b4a <ADC16_GetStatusFlags>
    8a22:	4603      	mov	r3, r0
    8a24:	f003 0340 	and.w	r3, r3, #64	; 0x40
    8a28:	2b00      	cmp	r3, #0
    8a2a:	d001      	beq.n	8a30 <ADC16_DoAutoCalibration+0x8c>
    {
        status = kStatus_Fail;
    8a2c:	2301      	movs	r3, #1
    8a2e:	613b      	str	r3, [r7, #16]
    }
    if (kStatus_Success != status) /* Check if the calibration process is succeed. */
    8a30:	693b      	ldr	r3, [r7, #16]
    8a32:	2b00      	cmp	r3, #0
    8a34:	d001      	beq.n	8a3a <ADC16_DoAutoCalibration+0x96>
    {
        return status;
    8a36:	693b      	ldr	r3, [r7, #16]
    8a38:	e048      	b.n	8acc <ADC16_DoAutoCalibration+0x128>
    }

    /* Calculate the calibration values. */
    tmp32 = base->CLP0;
    8a3a:	687b      	ldr	r3, [r7, #4]
    8a3c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    8a3e:	60fb      	str	r3, [r7, #12]
    tmp32 += base->CLP1;
    8a40:	687b      	ldr	r3, [r7, #4]
    8a42:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    8a44:	68fa      	ldr	r2, [r7, #12]
    8a46:	4413      	add	r3, r2
    8a48:	60fb      	str	r3, [r7, #12]
    tmp32 += base->CLP2;
    8a4a:	687b      	ldr	r3, [r7, #4]
    8a4c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    8a4e:	68fa      	ldr	r2, [r7, #12]
    8a50:	4413      	add	r3, r2
    8a52:	60fb      	str	r3, [r7, #12]
    tmp32 += base->CLP3;
    8a54:	687b      	ldr	r3, [r7, #4]
    8a56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    8a58:	68fa      	ldr	r2, [r7, #12]
    8a5a:	4413      	add	r3, r2
    8a5c:	60fb      	str	r3, [r7, #12]
    tmp32 += base->CLP4;
    8a5e:	687b      	ldr	r3, [r7, #4]
    8a60:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    8a62:	68fa      	ldr	r2, [r7, #12]
    8a64:	4413      	add	r3, r2
    8a66:	60fb      	str	r3, [r7, #12]
    tmp32 += base->CLPS;
    8a68:	687b      	ldr	r3, [r7, #4]
    8a6a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    8a6c:	68fa      	ldr	r2, [r7, #12]
    8a6e:	4413      	add	r3, r2
    8a70:	60fb      	str	r3, [r7, #12]
    tmp32    = 0x8000U | (tmp32 >> 1U);
    8a72:	68fb      	ldr	r3, [r7, #12]
    8a74:	085b      	lsrs	r3, r3, #1
    8a76:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    8a7a:	60fb      	str	r3, [r7, #12]
    base->PG = tmp32;
    8a7c:	687b      	ldr	r3, [r7, #4]
    8a7e:	68fa      	ldr	r2, [r7, #12]
    8a80:	62da      	str	r2, [r3, #44]	; 0x2c

#if defined(FSL_FEATURE_ADC16_HAS_DIFF_MODE) && FSL_FEATURE_ADC16_HAS_DIFF_MODE
    tmp32 = base->CLM0;
    8a82:	687b      	ldr	r3, [r7, #4]
    8a84:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    8a86:	60fb      	str	r3, [r7, #12]
    tmp32 += base->CLM1;
    8a88:	687b      	ldr	r3, [r7, #4]
    8a8a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    8a8c:	68fa      	ldr	r2, [r7, #12]
    8a8e:	4413      	add	r3, r2
    8a90:	60fb      	str	r3, [r7, #12]
    tmp32 += base->CLM2;
    8a92:	687b      	ldr	r3, [r7, #4]
    8a94:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    8a96:	68fa      	ldr	r2, [r7, #12]
    8a98:	4413      	add	r3, r2
    8a9a:	60fb      	str	r3, [r7, #12]
    tmp32 += base->CLM3;
    8a9c:	687b      	ldr	r3, [r7, #4]
    8a9e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8aa0:	68fa      	ldr	r2, [r7, #12]
    8aa2:	4413      	add	r3, r2
    8aa4:	60fb      	str	r3, [r7, #12]
    tmp32 += base->CLM4;
    8aa6:	687b      	ldr	r3, [r7, #4]
    8aa8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    8aaa:	68fa      	ldr	r2, [r7, #12]
    8aac:	4413      	add	r3, r2
    8aae:	60fb      	str	r3, [r7, #12]
    tmp32 += base->CLMS;
    8ab0:	687b      	ldr	r3, [r7, #4]
    8ab2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    8ab4:	68fa      	ldr	r2, [r7, #12]
    8ab6:	4413      	add	r3, r2
    8ab8:	60fb      	str	r3, [r7, #12]
    tmp32    = 0x8000U | (tmp32 >> 1U);
    8aba:	68fb      	ldr	r3, [r7, #12]
    8abc:	085b      	lsrs	r3, r3, #1
    8abe:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    8ac2:	60fb      	str	r3, [r7, #12]
    base->MG = tmp32;
    8ac4:	687b      	ldr	r3, [r7, #4]
    8ac6:	68fa      	ldr	r2, [r7, #12]
    8ac8:	631a      	str	r2, [r3, #48]	; 0x30
#endif /* FSL_FEATURE_ADC16_HAS_DIFF_MODE */

    return kStatus_Success;
    8aca:	2300      	movs	r3, #0
}
    8acc:	4618      	mov	r0, r3
    8ace:	3718      	adds	r7, #24
    8ad0:	46bd      	mov	sp, r7
    8ad2:	bd80      	pop	{r7, pc}

00008ad4 <ADC16_SetChannelMuxMode>:
 *
 * param base ADC16 peripheral base address.
 * param mode Setting channel mux mode. See "adc16_channel_mux_mode_t".
 */
void ADC16_SetChannelMuxMode(ADC_Type *base, adc16_channel_mux_mode_t mode)
{
    8ad4:	b480      	push	{r7}
    8ad6:	b083      	sub	sp, #12
    8ad8:	af00      	add	r7, sp, #0
    8ada:	6078      	str	r0, [r7, #4]
    8adc:	460b      	mov	r3, r1
    8ade:	70fb      	strb	r3, [r7, #3]
    if (kADC16_ChannelMuxA == mode)
    8ae0:	78fb      	ldrb	r3, [r7, #3]
    8ae2:	2b00      	cmp	r3, #0
    8ae4:	d106      	bne.n	8af4 <ADC16_SetChannelMuxMode+0x20>
    {
        base->CFG2 &= ~ADC_CFG2_MUXSEL_MASK;
    8ae6:	687b      	ldr	r3, [r7, #4]
    8ae8:	68db      	ldr	r3, [r3, #12]
    8aea:	f023 0210 	bic.w	r2, r3, #16
    8aee:	687b      	ldr	r3, [r7, #4]
    8af0:	60da      	str	r2, [r3, #12]
    }
    else /* kADC16_ChannelMuxB. */
    {
        base->CFG2 |= ADC_CFG2_MUXSEL_MASK;
    }
}
    8af2:	e005      	b.n	8b00 <ADC16_SetChannelMuxMode+0x2c>
        base->CFG2 |= ADC_CFG2_MUXSEL_MASK;
    8af4:	687b      	ldr	r3, [r7, #4]
    8af6:	68db      	ldr	r3, [r3, #12]
    8af8:	f043 0210 	orr.w	r2, r3, #16
    8afc:	687b      	ldr	r3, [r7, #4]
    8afe:	60da      	str	r2, [r3, #12]
}
    8b00:	bf00      	nop
    8b02:	370c      	adds	r7, #12
    8b04:	46bd      	mov	sp, r7
    8b06:	f85d 7b04 	ldr.w	r7, [sp], #4
    8b0a:	4770      	bx	lr

00008b0c <ADC16_SetHardwareAverage>:
 *
 * param base  ADC16 peripheral base address.
 * param mode  Setting the hardware average mode. See "adc16_hardware_average_mode_t".
 */
void ADC16_SetHardwareAverage(ADC_Type *base, adc16_hardware_average_mode_t mode)
{
    8b0c:	b480      	push	{r7}
    8b0e:	b085      	sub	sp, #20
    8b10:	af00      	add	r7, sp, #0
    8b12:	6078      	str	r0, [r7, #4]
    8b14:	460b      	mov	r3, r1
    8b16:	70fb      	strb	r3, [r7, #3]
    uint32_t tmp32 = base->SC3 & ~(ADC_SC3_AVGE_MASK | ADC_SC3_AVGS_MASK);
    8b18:	687b      	ldr	r3, [r7, #4]
    8b1a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8b1c:	f023 0307 	bic.w	r3, r3, #7
    8b20:	60fb      	str	r3, [r7, #12]

    if (kADC16_HardwareAverageDisabled != mode)
    8b22:	78fb      	ldrb	r3, [r7, #3]
    8b24:	2b04      	cmp	r3, #4
    8b26:	d007      	beq.n	8b38 <ADC16_SetHardwareAverage+0x2c>
    {
        tmp32 |= ADC_SC3_AVGE_MASK | ADC_SC3_AVGS(mode);
    8b28:	78fb      	ldrb	r3, [r7, #3]
    8b2a:	f003 0203 	and.w	r2, r3, #3
    8b2e:	68fb      	ldr	r3, [r7, #12]
    8b30:	4313      	orrs	r3, r2
    8b32:	f043 0304 	orr.w	r3, r3, #4
    8b36:	60fb      	str	r3, [r7, #12]
    }
    base->SC3 = tmp32;
    8b38:	687b      	ldr	r3, [r7, #4]
    8b3a:	68fa      	ldr	r2, [r7, #12]
    8b3c:	625a      	str	r2, [r3, #36]	; 0x24
}
    8b3e:	bf00      	nop
    8b40:	3714      	adds	r7, #20
    8b42:	46bd      	mov	sp, r7
    8b44:	f85d 7b04 	ldr.w	r7, [sp], #4
    8b48:	4770      	bx	lr

00008b4a <ADC16_GetStatusFlags>:
 * param  base ADC16 peripheral base address.
 *
 * return      Flags' mask if indicated flags are asserted. See "_adc16_status_flags".
 */
uint32_t ADC16_GetStatusFlags(ADC_Type *base)
{
    8b4a:	b480      	push	{r7}
    8b4c:	b085      	sub	sp, #20
    8b4e:	af00      	add	r7, sp, #0
    8b50:	6078      	str	r0, [r7, #4]
    uint32_t ret = 0;
    8b52:	2300      	movs	r3, #0
    8b54:	60fb      	str	r3, [r7, #12]

    if (0U != (base->SC2 & ADC_SC2_ADACT_MASK))
    8b56:	687b      	ldr	r3, [r7, #4]
    8b58:	6a1b      	ldr	r3, [r3, #32]
    8b5a:	f003 0380 	and.w	r3, r3, #128	; 0x80
    8b5e:	2b00      	cmp	r3, #0
    8b60:	d003      	beq.n	8b6a <ADC16_GetStatusFlags+0x20>
    {
        ret |= (uint32_t)kADC16_ActiveFlag;
    8b62:	68fb      	ldr	r3, [r7, #12]
    8b64:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    8b68:	60fb      	str	r3, [r7, #12]
    }
#if defined(FSL_FEATURE_ADC16_HAS_CALIBRATION) && FSL_FEATURE_ADC16_HAS_CALIBRATION
    if (0U != (base->SC3 & ADC_SC3_CALF_MASK))
    8b6a:	687b      	ldr	r3, [r7, #4]
    8b6c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8b6e:	f003 0340 	and.w	r3, r3, #64	; 0x40
    8b72:	2b00      	cmp	r3, #0
    8b74:	d003      	beq.n	8b7e <ADC16_GetStatusFlags+0x34>
    {
        ret |= (uint32_t)kADC16_CalibrationFailedFlag;
    8b76:	68fb      	ldr	r3, [r7, #12]
    8b78:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    8b7c:	60fb      	str	r3, [r7, #12]
    }
#endif /* FSL_FEATURE_ADC16_HAS_CALIBRATION */
    return ret;
    8b7e:	68fb      	ldr	r3, [r7, #12]
}
    8b80:	4618      	mov	r0, r3
    8b82:	3714      	adds	r7, #20
    8b84:	46bd      	mov	sp, r7
    8b86:	f85d 7b04 	ldr.w	r7, [sp], #4
    8b8a:	4770      	bx	lr

00008b8c <ADC16_SetChannelConfig>:
 * param base          ADC16 peripheral base address.
 * param channelGroup  Channel group index.
 * param config        Pointer to the "adc16_channel_config_t" structure for the conversion channel.
 */
void ADC16_SetChannelConfig(ADC_Type *base, uint32_t channelGroup, const adc16_channel_config_t *config)
{
    8b8c:	b580      	push	{r7, lr}
    8b8e:	b086      	sub	sp, #24
    8b90:	af00      	add	r7, sp, #0
    8b92:	60f8      	str	r0, [r7, #12]
    8b94:	60b9      	str	r1, [r7, #8]
    8b96:	607a      	str	r2, [r7, #4]
    assert(channelGroup < ADC_SC1_COUNT);
    8b98:	68bb      	ldr	r3, [r7, #8]
    8b9a:	2b01      	cmp	r3, #1
    8b9c:	d906      	bls.n	8bac <ADC16_SetChannelConfig+0x20>
    8b9e:	4b17      	ldr	r3, [pc, #92]	; (8bfc <ADC16_SetChannelConfig+0x70>)
    8ba0:	4a17      	ldr	r2, [pc, #92]	; (8c00 <ADC16_SetChannelConfig+0x74>)
    8ba2:	f44f 71e7 	mov.w	r1, #462	; 0x1ce
    8ba6:	4817      	ldr	r0, [pc, #92]	; (8c04 <ADC16_SetChannelConfig+0x78>)
    8ba8:	f7fe fb18 	bl	71dc <__assert_func>
    assert(NULL != config);
    8bac:	687b      	ldr	r3, [r7, #4]
    8bae:	2b00      	cmp	r3, #0
    8bb0:	d106      	bne.n	8bc0 <ADC16_SetChannelConfig+0x34>
    8bb2:	4b15      	ldr	r3, [pc, #84]	; (8c08 <ADC16_SetChannelConfig+0x7c>)
    8bb4:	4a12      	ldr	r2, [pc, #72]	; (8c00 <ADC16_SetChannelConfig+0x74>)
    8bb6:	f240 11cf 	movw	r1, #463	; 0x1cf
    8bba:	4812      	ldr	r0, [pc, #72]	; (8c04 <ADC16_SetChannelConfig+0x78>)
    8bbc:	f7fe fb0e 	bl	71dc <__assert_func>

    uint32_t sc1 = ADC_SC1_ADCH(config->channelNumber); /* Set the channel number. */
    8bc0:	687b      	ldr	r3, [r7, #4]
    8bc2:	681b      	ldr	r3, [r3, #0]
    8bc4:	f003 031f 	and.w	r3, r3, #31
    8bc8:	617b      	str	r3, [r7, #20]

#if defined(FSL_FEATURE_ADC16_HAS_DIFF_MODE) && FSL_FEATURE_ADC16_HAS_DIFF_MODE
    /* Enable the differential conversion. */
    if (true == config->enableDifferentialConversion)
    8bca:	687b      	ldr	r3, [r7, #4]
    8bcc:	795b      	ldrb	r3, [r3, #5]
    8bce:	2b00      	cmp	r3, #0
    8bd0:	d003      	beq.n	8bda <ADC16_SetChannelConfig+0x4e>
    {
        sc1 |= ADC_SC1_DIFF_MASK;
    8bd2:	697b      	ldr	r3, [r7, #20]
    8bd4:	f043 0320 	orr.w	r3, r3, #32
    8bd8:	617b      	str	r3, [r7, #20]
    }
#endif /* FSL_FEATURE_ADC16_HAS_DIFF_MODE */
    /* Enable the interrupt when the conversion is done. */
    if (true == config->enableInterruptOnConversionCompleted)
    8bda:	687b      	ldr	r3, [r7, #4]
    8bdc:	791b      	ldrb	r3, [r3, #4]
    8bde:	2b00      	cmp	r3, #0
    8be0:	d003      	beq.n	8bea <ADC16_SetChannelConfig+0x5e>
    {
        sc1 |= ADC_SC1_AIEN_MASK;
    8be2:	697b      	ldr	r3, [r7, #20]
    8be4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    8be8:	617b      	str	r3, [r7, #20]
    }
    base->SC1[channelGroup] = sc1;
    8bea:	68fb      	ldr	r3, [r7, #12]
    8bec:	68ba      	ldr	r2, [r7, #8]
    8bee:	6979      	ldr	r1, [r7, #20]
    8bf0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    8bf4:	bf00      	nop
    8bf6:	3718      	adds	r7, #24
    8bf8:	46bd      	mov	sp, r7
    8bfa:	bd80      	pop	{r7, pc}
    8bfc:	0000f984 	.word	0x0000f984
    8c00:	0000f9c4 	.word	0x0000f9c4
    8c04:	0000f910 	.word	0x0000f910
    8c08:	0000f96c 	.word	0x0000f96c

00008c0c <ADC16_GetChannelStatusFlags>:
 * param  channelGroup Channel group index.
 *
 * return              Flags' mask if indicated flags are asserted. See "_adc16_channel_status_flags".
 */
uint32_t ADC16_GetChannelStatusFlags(ADC_Type *base, uint32_t channelGroup)
{
    8c0c:	b580      	push	{r7, lr}
    8c0e:	b084      	sub	sp, #16
    8c10:	af00      	add	r7, sp, #0
    8c12:	6078      	str	r0, [r7, #4]
    8c14:	6039      	str	r1, [r7, #0]
    assert(channelGroup < ADC_SC1_COUNT);
    8c16:	683b      	ldr	r3, [r7, #0]
    8c18:	2b01      	cmp	r3, #1
    8c1a:	d906      	bls.n	8c2a <ADC16_GetChannelStatusFlags+0x1e>
    8c1c:	4b0c      	ldr	r3, [pc, #48]	; (8c50 <ADC16_GetChannelStatusFlags+0x44>)
    8c1e:	4a0d      	ldr	r2, [pc, #52]	; (8c54 <ADC16_GetChannelStatusFlags+0x48>)
    8c20:	f44f 71f6 	mov.w	r1, #492	; 0x1ec
    8c24:	480c      	ldr	r0, [pc, #48]	; (8c58 <ADC16_GetChannelStatusFlags+0x4c>)
    8c26:	f7fe fad9 	bl	71dc <__assert_func>

    uint32_t ret = 0U;
    8c2a:	2300      	movs	r3, #0
    8c2c:	60fb      	str	r3, [r7, #12]

    if (0U != (base->SC1[channelGroup] & ADC_SC1_COCO_MASK))
    8c2e:	687b      	ldr	r3, [r7, #4]
    8c30:	683a      	ldr	r2, [r7, #0]
    8c32:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8c36:	f003 0380 	and.w	r3, r3, #128	; 0x80
    8c3a:	2b00      	cmp	r3, #0
    8c3c:	d003      	beq.n	8c46 <ADC16_GetChannelStatusFlags+0x3a>
    {
        ret |= (uint32_t)kADC16_ChannelConversionDoneFlag;
    8c3e:	68fb      	ldr	r3, [r7, #12]
    8c40:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    8c44:	60fb      	str	r3, [r7, #12]
    }
    return ret;
    8c46:	68fb      	ldr	r3, [r7, #12]
}
    8c48:	4618      	mov	r0, r3
    8c4a:	3710      	adds	r7, #16
    8c4c:	46bd      	mov	sp, r7
    8c4e:	bd80      	pop	{r7, pc}
    8c50:	0000f984 	.word	0x0000f984
    8c54:	0000f9dc 	.word	0x0000f9dc
    8c58:	0000f910 	.word	0x0000f910

00008c5c <CLOCK_EnableClock>:
{
    8c5c:	b480      	push	{r7}
    8c5e:	b085      	sub	sp, #20
    8c60:	af00      	add	r7, sp, #0
    8c62:	6078      	str	r0, [r7, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    8c64:	687b      	ldr	r3, [r7, #4]
    8c66:	0c1b      	lsrs	r3, r3, #16
    8c68:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    8c6c:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    8c70:	60fb      	str	r3, [r7, #12]
    (*(volatile uint32_t *)regAddr) |= (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
    8c72:	68fb      	ldr	r3, [r7, #12]
    8c74:	6819      	ldr	r1, [r3, #0]
    8c76:	687b      	ldr	r3, [r7, #4]
    8c78:	b29b      	uxth	r3, r3
    8c7a:	2201      	movs	r2, #1
    8c7c:	409a      	lsls	r2, r3
    8c7e:	68fb      	ldr	r3, [r7, #12]
    8c80:	430a      	orrs	r2, r1
    8c82:	601a      	str	r2, [r3, #0]
}
    8c84:	bf00      	nop
    8c86:	3714      	adds	r7, #20
    8c88:	46bd      	mov	sp, r7
    8c8a:	f85d 7b04 	ldr.w	r7, [sp], #4
    8c8e:	4770      	bx	lr

00008c90 <DMAMUX_GetInstance>:

/*******************************************************************************
 * Code
 ******************************************************************************/
static uint32_t DMAMUX_GetInstance(DMAMUX_Type *base)
{
    8c90:	b580      	push	{r7, lr}
    8c92:	b084      	sub	sp, #16
    8c94:	af00      	add	r7, sp, #0
    8c96:	6078      	str	r0, [r7, #4]
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < ARRAY_SIZE(s_dmamuxBases); instance++)
    8c98:	2300      	movs	r3, #0
    8c9a:	60fb      	str	r3, [r7, #12]
    8c9c:	e006      	b.n	8cac <DMAMUX_GetInstance+0x1c>
    {
        if (s_dmamuxBases[instance] == base)
    8c9e:	4a0d      	ldr	r2, [pc, #52]	; (8cd4 <DMAMUX_GetInstance+0x44>)
    8ca0:	687b      	ldr	r3, [r7, #4]
    8ca2:	4293      	cmp	r3, r2
    8ca4:	d006      	beq.n	8cb4 <DMAMUX_GetInstance+0x24>
    for (instance = 0; instance < ARRAY_SIZE(s_dmamuxBases); instance++)
    8ca6:	68fb      	ldr	r3, [r7, #12]
    8ca8:	3301      	adds	r3, #1
    8caa:	60fb      	str	r3, [r7, #12]
    8cac:	68fb      	ldr	r3, [r7, #12]
    8cae:	2b00      	cmp	r3, #0
    8cb0:	d0f5      	beq.n	8c9e <DMAMUX_GetInstance+0xe>
    8cb2:	e000      	b.n	8cb6 <DMAMUX_GetInstance+0x26>
        {
            break;
    8cb4:	bf00      	nop
        }
    }

    assert(instance < ARRAY_SIZE(s_dmamuxBases));
    8cb6:	68fb      	ldr	r3, [r7, #12]
    8cb8:	2b00      	cmp	r3, #0
    8cba:	d005      	beq.n	8cc8 <DMAMUX_GetInstance+0x38>
    8cbc:	4b06      	ldr	r3, [pc, #24]	; (8cd8 <DMAMUX_GetInstance+0x48>)
    8cbe:	4a07      	ldr	r2, [pc, #28]	; (8cdc <DMAMUX_GetInstance+0x4c>)
    8cc0:	213b      	movs	r1, #59	; 0x3b
    8cc2:	4807      	ldr	r0, [pc, #28]	; (8ce0 <DMAMUX_GetInstance+0x50>)
    8cc4:	f7fe fa8a 	bl	71dc <__assert_func>

    return instance;
    8cc8:	68fb      	ldr	r3, [r7, #12]
}
    8cca:	4618      	mov	r0, r3
    8ccc:	3710      	adds	r7, #16
    8cce:	46bd      	mov	sp, r7
    8cd0:	bd80      	pop	{r7, pc}
    8cd2:	bf00      	nop
    8cd4:	40021000 	.word	0x40021000
    8cd8:	0000f9f8 	.word	0x0000f9f8
    8cdc:	0000fa7c 	.word	0x0000fa7c
    8ce0:	0000fa20 	.word	0x0000fa20

00008ce4 <DMAMUX_Init>:
 *
 * param base DMAMUX peripheral base address.
 *
 */
void DMAMUX_Init(DMAMUX_Type *base)
{
    8ce4:	b580      	push	{r7, lr}
    8ce6:	b082      	sub	sp, #8
    8ce8:	af00      	add	r7, sp, #0
    8cea:	6078      	str	r0, [r7, #4]
#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    CLOCK_EnableClock(s_dmamuxClockName[DMAMUX_GetInstance(base)]);
    8cec:	6878      	ldr	r0, [r7, #4]
    8cee:	f7ff ffcf 	bl	8c90 <DMAMUX_GetInstance>
    8cf2:	4b04      	ldr	r3, [pc, #16]	; (8d04 <DMAMUX_Init+0x20>)
    8cf4:	4618      	mov	r0, r3
    8cf6:	f7ff ffb1 	bl	8c5c <CLOCK_EnableClock>
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
}
    8cfa:	bf00      	nop
    8cfc:	3708      	adds	r7, #8
    8cfe:	46bd      	mov	sp, r7
    8d00:	bd80      	pop	{r7, pc}
    8d02:	bf00      	nop
    8d04:	103c0001 	.word	0x103c0001

00008d08 <__NVIC_EnableIRQ>:
{
    8d08:	b480      	push	{r7}
    8d0a:	b083      	sub	sp, #12
    8d0c:	af00      	add	r7, sp, #0
    8d0e:	4603      	mov	r3, r0
    8d10:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
    8d12:	f997 3007 	ldrsb.w	r3, [r7, #7]
    8d16:	2b00      	cmp	r3, #0
    8d18:	db0b      	blt.n	8d32 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    8d1a:	79fb      	ldrb	r3, [r7, #7]
    8d1c:	f003 021f 	and.w	r2, r3, #31
    8d20:	4907      	ldr	r1, [pc, #28]	; (8d40 <__NVIC_EnableIRQ+0x38>)
    8d22:	f997 3007 	ldrsb.w	r3, [r7, #7]
    8d26:	095b      	lsrs	r3, r3, #5
    8d28:	2001      	movs	r0, #1
    8d2a:	fa00 f202 	lsl.w	r2, r0, r2
    8d2e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8d32:	bf00      	nop
    8d34:	370c      	adds	r7, #12
    8d36:	46bd      	mov	sp, r7
    8d38:	f85d 7b04 	ldr.w	r7, [sp], #4
    8d3c:	4770      	bx	lr
    8d3e:	bf00      	nop
    8d40:	e000e100 	.word	0xe000e100

00008d44 <CLOCK_EnableClock>:
{
    8d44:	b480      	push	{r7}
    8d46:	b085      	sub	sp, #20
    8d48:	af00      	add	r7, sp, #0
    8d4a:	6078      	str	r0, [r7, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    8d4c:	687b      	ldr	r3, [r7, #4]
    8d4e:	0c1b      	lsrs	r3, r3, #16
    8d50:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    8d54:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    8d58:	60fb      	str	r3, [r7, #12]
    (*(volatile uint32_t *)regAddr) |= (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
    8d5a:	68fb      	ldr	r3, [r7, #12]
    8d5c:	6819      	ldr	r1, [r3, #0]
    8d5e:	687b      	ldr	r3, [r7, #4]
    8d60:	b29b      	uxth	r3, r3
    8d62:	2201      	movs	r2, #1
    8d64:	409a      	lsls	r2, r3
    8d66:	68fb      	ldr	r3, [r7, #12]
    8d68:	430a      	orrs	r2, r1
    8d6a:	601a      	str	r2, [r3, #0]
}
    8d6c:	bf00      	nop
    8d6e:	3714      	adds	r7, #20
    8d70:	46bd      	mov	sp, r7
    8d72:	f85d 7b04 	ldr.w	r7, [sp], #4
    8d76:	4770      	bx	lr

00008d78 <EnableIRQ>:
    {
    8d78:	b580      	push	{r7, lr}
    8d7a:	b084      	sub	sp, #16
    8d7c:	af00      	add	r7, sp, #0
    8d7e:	4603      	mov	r3, r0
    8d80:	71fb      	strb	r3, [r7, #7]
        status_t status = kStatus_Success;
    8d82:	2300      	movs	r3, #0
    8d84:	60fb      	str	r3, [r7, #12]
        if (NotAvail_IRQn == interrupt)
    8d86:	f997 3007 	ldrsb.w	r3, [r7, #7]
    8d8a:	f113 0f80 	cmn.w	r3, #128	; 0x80
    8d8e:	d102      	bne.n	8d96 <EnableIRQ+0x1e>
            status = kStatus_Fail;
    8d90:	2301      	movs	r3, #1
    8d92:	60fb      	str	r3, [r7, #12]
    8d94:	e004      	b.n	8da0 <EnableIRQ+0x28>
            NVIC_EnableIRQ(interrupt);
    8d96:	f997 3007 	ldrsb.w	r3, [r7, #7]
    8d9a:	4618      	mov	r0, r3
    8d9c:	f7ff ffb4 	bl	8d08 <__NVIC_EnableIRQ>
        return status;
    8da0:	68fb      	ldr	r3, [r7, #12]
    }
    8da2:	4618      	mov	r0, r3
    8da4:	3710      	adds	r7, #16
    8da6:	46bd      	mov	sp, r7
    8da8:	bd80      	pop	{r7, pc}

00008daa <DisableGlobalIRQ>:
     * register for the EnableGlobalIRQ().
     *
     * @return Current primask value.
     */
    static inline uint32_t DisableGlobalIRQ(void)
    {
    8daa:	b480      	push	{r7}
    8dac:	b083      	sub	sp, #12
    8dae:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    8db0:	f3ef 8310 	mrs	r3, PRIMASK
    8db4:	603b      	str	r3, [r7, #0]
  return(result);
    8db6:	683b      	ldr	r3, [r7, #0]

        __disable_irq();

        return cpsr;
#else
    uint32_t regPrimask = __get_PRIMASK();
    8db8:	607b      	str	r3, [r7, #4]
  __ASM volatile ("cpsid i" : : : "memory");
    8dba:	b672      	cpsid	i
}
    8dbc:	bf00      	nop

    __disable_irq();

    return regPrimask;
    8dbe:	687b      	ldr	r3, [r7, #4]
#endif
#endif
    }
    8dc0:	4618      	mov	r0, r3
    8dc2:	370c      	adds	r7, #12
    8dc4:	46bd      	mov	sp, r7
    8dc6:	f85d 7b04 	ldr.w	r7, [sp], #4
    8dca:	4770      	bx	lr

00008dcc <EnableGlobalIRQ>:
     *
     * @param primask value of primask register to be restored. The primask value is supposed to be provided by the
     * DisableGlobalIRQ().
     */
    static inline void EnableGlobalIRQ(uint32_t primask)
    {
    8dcc:	b480      	push	{r7}
    8dce:	b085      	sub	sp, #20
    8dd0:	af00      	add	r7, sp, #0
    8dd2:	6078      	str	r0, [r7, #4]
    8dd4:	687b      	ldr	r3, [r7, #4]
    8dd6:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    8dd8:	68fb      	ldr	r3, [r7, #12]
    8dda:	f383 8810 	msr	PRIMASK, r3
}
    8dde:	bf00      	nop
        __set_CPSR((__get_CPSR() & ~CPSR_I_Msk) | primask);
#else
    __set_PRIMASK(primask);
#endif
#endif
    }
    8de0:	bf00      	nop
    8de2:	3714      	adds	r7, #20
    8de4:	46bd      	mov	sp, r7
    8de6:	f85d 7b04 	ldr.w	r7, [sp], #4
    8dea:	4770      	bx	lr

00008dec <EDMA_GetInstance>:
/*******************************************************************************
 * Code
 ******************************************************************************/

static uint32_t EDMA_GetInstance(DMA_Type *base)
{
    8dec:	b580      	push	{r7, lr}
    8dee:	b084      	sub	sp, #16
    8df0:	af00      	add	r7, sp, #0
    8df2:	6078      	str	r0, [r7, #4]
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < ARRAY_SIZE(s_edmaBases); instance++)
    8df4:	2300      	movs	r3, #0
    8df6:	60fb      	str	r3, [r7, #12]
    8df8:	e006      	b.n	8e08 <EDMA_GetInstance+0x1c>
    {
        if (s_edmaBases[instance] == base)
    8dfa:	4a0d      	ldr	r2, [pc, #52]	; (8e30 <EDMA_GetInstance+0x44>)
    8dfc:	687b      	ldr	r3, [r7, #4]
    8dfe:	4293      	cmp	r3, r2
    8e00:	d006      	beq.n	8e10 <EDMA_GetInstance+0x24>
    for (instance = 0; instance < ARRAY_SIZE(s_edmaBases); instance++)
    8e02:	68fb      	ldr	r3, [r7, #12]
    8e04:	3301      	adds	r3, #1
    8e06:	60fb      	str	r3, [r7, #12]
    8e08:	68fb      	ldr	r3, [r7, #12]
    8e0a:	2b00      	cmp	r3, #0
    8e0c:	d0f5      	beq.n	8dfa <EDMA_GetInstance+0xe>
    8e0e:	e000      	b.n	8e12 <EDMA_GetInstance+0x26>
        {
            break;
    8e10:	bf00      	nop
        }
    }

    assert(instance < ARRAY_SIZE(s_edmaBases));
    8e12:	68fb      	ldr	r3, [r7, #12]
    8e14:	2b00      	cmp	r3, #0
    8e16:	d005      	beq.n	8e24 <EDMA_GetInstance+0x38>
    8e18:	4b06      	ldr	r3, [pc, #24]	; (8e34 <EDMA_GetInstance+0x48>)
    8e1a:	4a07      	ldr	r2, [pc, #28]	; (8e38 <EDMA_GetInstance+0x4c>)
    8e1c:	214a      	movs	r1, #74	; 0x4a
    8e1e:	4807      	ldr	r0, [pc, #28]	; (8e3c <EDMA_GetInstance+0x50>)
    8e20:	f7fe f9dc 	bl	71dc <__assert_func>

    return instance;
    8e24:	68fb      	ldr	r3, [r7, #12]
}
    8e26:	4618      	mov	r0, r3
    8e28:	3710      	adds	r7, #16
    8e2a:	46bd      	mov	sp, r7
    8e2c:	bd80      	pop	{r7, pc}
    8e2e:	bf00      	nop
    8e30:	40008000 	.word	0x40008000
    8e34:	0000fab0 	.word	0x0000fab0
    8e38:	0000fe48 	.word	0x0000fe48
    8e3c:	0000fad4 	.word	0x0000fad4

00008e40 <EDMA_Init>:
 * param base eDMA peripheral base address.
 * param config A pointer to the configuration structure, see "edma_config_t".
 * note This function enables the minor loop map feature.
 */
void EDMA_Init(DMA_Type *base, const edma_config_t *config)
{
    8e40:	b580      	push	{r7, lr}
    8e42:	b084      	sub	sp, #16
    8e44:	af00      	add	r7, sp, #0
    8e46:	6078      	str	r0, [r7, #4]
    8e48:	6039      	str	r1, [r7, #0]
    assert(config != NULL);
    8e4a:	683b      	ldr	r3, [r7, #0]
    8e4c:	2b00      	cmp	r3, #0
    8e4e:	d105      	bne.n	8e5c <EDMA_Init+0x1c>
    8e50:	4b20      	ldr	r3, [pc, #128]	; (8ed4 <EDMA_Init+0x94>)
    8e52:	4a21      	ldr	r2, [pc, #132]	; (8ed8 <EDMA_Init+0x98>)
    8e54:	2178      	movs	r1, #120	; 0x78
    8e56:	4821      	ldr	r0, [pc, #132]	; (8edc <EDMA_Init+0x9c>)
    8e58:	f7fe f9c0 	bl	71dc <__assert_func>

    uint32_t tmpreg;

#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    /* Ungate EDMA peripheral clock */
    CLOCK_EnableClock(s_edmaClockName[EDMA_GetInstance(base)]);
    8e5c:	6878      	ldr	r0, [r7, #4]
    8e5e:	f7ff ffc5 	bl	8dec <EDMA_GetInstance>
    8e62:	4b1f      	ldr	r3, [pc, #124]	; (8ee0 <EDMA_Init+0xa0>)
    8e64:	4618      	mov	r0, r3
    8e66:	f7ff ff6d 	bl	8d44 <CLOCK_EnableClock>
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

    /* clear all the enabled request, status to make sure EDMA status is in normal condition */
    base->ERQ = 0U;
    8e6a:	687b      	ldr	r3, [r7, #4]
    8e6c:	2200      	movs	r2, #0
    8e6e:	60da      	str	r2, [r3, #12]
    base->INT = 0xFFFFFFFFU;
    8e70:	687b      	ldr	r3, [r7, #4]
    8e72:	f04f 32ff 	mov.w	r2, #4294967295
    8e76:	625a      	str	r2, [r3, #36]	; 0x24
    base->ERR = 0xFFFFFFFFU;
    8e78:	687b      	ldr	r3, [r7, #4]
    8e7a:	f04f 32ff 	mov.w	r2, #4294967295
    8e7e:	62da      	str	r2, [r3, #44]	; 0x2c
    /* Configure EDMA peripheral according to the configuration structure. */
    tmpreg = base->CR;
    8e80:	687b      	ldr	r3, [r7, #4]
    8e82:	681b      	ldr	r3, [r3, #0]
    8e84:	60fb      	str	r3, [r7, #12]
    tmpreg &= ~(DMA_CR_ERCA_MASK | DMA_CR_HOE_MASK | DMA_CR_CLM_MASK | DMA_CR_EDBG_MASK);
    8e86:	68fb      	ldr	r3, [r7, #12]
    8e88:	f023 0356 	bic.w	r3, r3, #86	; 0x56
    8e8c:	60fb      	str	r3, [r7, #12]
    tmpreg |= (DMA_CR_ERCA(config->enableRoundRobinArbitration) | DMA_CR_HOE(config->enableHaltOnError) |
    8e8e:	683b      	ldr	r3, [r7, #0]
    8e90:	789b      	ldrb	r3, [r3, #2]
    8e92:	009b      	lsls	r3, r3, #2
    8e94:	f003 0204 	and.w	r2, r3, #4
    8e98:	683b      	ldr	r3, [r7, #0]
    8e9a:	785b      	ldrb	r3, [r3, #1]
    8e9c:	011b      	lsls	r3, r3, #4
    8e9e:	f003 0310 	and.w	r3, r3, #16
    8ea2:	431a      	orrs	r2, r3
               DMA_CR_CLM(config->enableContinuousLinkMode) | DMA_CR_EDBG(config->enableDebugMode) | DMA_CR_EMLM(1U));
    8ea4:	683b      	ldr	r3, [r7, #0]
    8ea6:	781b      	ldrb	r3, [r3, #0]
    8ea8:	019b      	lsls	r3, r3, #6
    8eaa:	f003 0340 	and.w	r3, r3, #64	; 0x40
    tmpreg |= (DMA_CR_ERCA(config->enableRoundRobinArbitration) | DMA_CR_HOE(config->enableHaltOnError) |
    8eae:	431a      	orrs	r2, r3
               DMA_CR_CLM(config->enableContinuousLinkMode) | DMA_CR_EDBG(config->enableDebugMode) | DMA_CR_EMLM(1U));
    8eb0:	683b      	ldr	r3, [r7, #0]
    8eb2:	78db      	ldrb	r3, [r3, #3]
    8eb4:	005b      	lsls	r3, r3, #1
    8eb6:	f003 0302 	and.w	r3, r3, #2
    8eba:	431a      	orrs	r2, r3
    tmpreg |= (DMA_CR_ERCA(config->enableRoundRobinArbitration) | DMA_CR_HOE(config->enableHaltOnError) |
    8ebc:	68fb      	ldr	r3, [r7, #12]
    8ebe:	4313      	orrs	r3, r2
    8ec0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    8ec4:	60fb      	str	r3, [r7, #12]
    base->CR = tmpreg;
    8ec6:	687b      	ldr	r3, [r7, #4]
    8ec8:	68fa      	ldr	r2, [r7, #12]
    8eca:	601a      	str	r2, [r3, #0]
}
    8ecc:	bf00      	nop
    8ece:	3710      	adds	r7, #16
    8ed0:	46bd      	mov	sp, r7
    8ed2:	bd80      	pop	{r7, pc}
    8ed4:	0000fb8c 	.word	0x0000fb8c
    8ed8:	0000fe5c 	.word	0x0000fe5c
    8edc:	0000fad4 	.word	0x0000fad4
    8ee0:	10400001 	.word	0x10400001

00008ee4 <EDMA_GetDefaultConfig>:
 * endcode
 *
 * param config A pointer to the eDMA configuration structure.
 */
void EDMA_GetDefaultConfig(edma_config_t *config)
{
    8ee4:	b580      	push	{r7, lr}
    8ee6:	b082      	sub	sp, #8
    8ee8:	af00      	add	r7, sp, #0
    8eea:	6078      	str	r0, [r7, #4]
    assert(config != NULL);
    8eec:	687b      	ldr	r3, [r7, #4]
    8eee:	2b00      	cmp	r3, #0
    8ef0:	d105      	bne.n	8efe <EDMA_GetDefaultConfig+0x1a>
    8ef2:	4b0d      	ldr	r3, [pc, #52]	; (8f28 <EDMA_GetDefaultConfig+0x44>)
    8ef4:	4a0d      	ldr	r2, [pc, #52]	; (8f2c <EDMA_GetDefaultConfig+0x48>)
    8ef6:	21ac      	movs	r1, #172	; 0xac
    8ef8:	480d      	ldr	r0, [pc, #52]	; (8f30 <EDMA_GetDefaultConfig+0x4c>)
    8efa:	f7fe f96f 	bl	71dc <__assert_func>

    /* Initializes the configure structure to zero. */
    (void)memset(config, 0, sizeof(*config));
    8efe:	2204      	movs	r2, #4
    8f00:	2100      	movs	r1, #0
    8f02:	6878      	ldr	r0, [r7, #4]
    8f04:	f005 fa68 	bl	e3d8 <memset>

    config->enableRoundRobinArbitration = false;
    8f08:	687b      	ldr	r3, [r7, #4]
    8f0a:	2200      	movs	r2, #0
    8f0c:	709a      	strb	r2, [r3, #2]
    config->enableHaltOnError           = true;
    8f0e:	687b      	ldr	r3, [r7, #4]
    8f10:	2201      	movs	r2, #1
    8f12:	705a      	strb	r2, [r3, #1]
    config->enableContinuousLinkMode    = false;
    8f14:	687b      	ldr	r3, [r7, #4]
    8f16:	2200      	movs	r2, #0
    8f18:	701a      	strb	r2, [r3, #0]
    config->enableDebugMode             = false;
    8f1a:	687b      	ldr	r3, [r7, #4]
    8f1c:	2200      	movs	r2, #0
    8f1e:	70da      	strb	r2, [r3, #3]
}
    8f20:	bf00      	nop
    8f22:	3708      	adds	r7, #8
    8f24:	46bd      	mov	sp, r7
    8f26:	bd80      	pop	{r7, pc}
    8f28:	0000fb8c 	.word	0x0000fb8c
    8f2c:	0000fe68 	.word	0x0000fe68
    8f30:	0000fad4 	.word	0x0000fad4

00008f34 <EDMA_SetTransferConfig>:
 * note If nextTcd is not NULL, it means scatter gather feature is enabled
 *       and DREQ bit is cleared in the previous transfer configuration, which
 *       is set in the eDMA_ResetChannel.
 */
void EDMA_SetTransferConfig(DMA_Type *base, uint32_t channel, const edma_transfer_config_t *config, edma_tcd_t *nextTcd)
{
    8f34:	b580      	push	{r7, lr}
    8f36:	b084      	sub	sp, #16
    8f38:	af00      	add	r7, sp, #0
    8f3a:	60f8      	str	r0, [r7, #12]
    8f3c:	60b9      	str	r1, [r7, #8]
    8f3e:	607a      	str	r2, [r7, #4]
    8f40:	603b      	str	r3, [r7, #0]
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
    8f42:	68bb      	ldr	r3, [r7, #8]
    8f44:	2b1f      	cmp	r3, #31
    8f46:	d905      	bls.n	8f54 <EDMA_SetTransferConfig+0x20>
    8f48:	4b13      	ldr	r3, [pc, #76]	; (8f98 <EDMA_SetTransferConfig+0x64>)
    8f4a:	4a14      	ldr	r2, [pc, #80]	; (8f9c <EDMA_SetTransferConfig+0x68>)
    8f4c:	21e4      	movs	r1, #228	; 0xe4
    8f4e:	4814      	ldr	r0, [pc, #80]	; (8fa0 <EDMA_SetTransferConfig+0x6c>)
    8f50:	f7fe f944 	bl	71dc <__assert_func>
    assert(config != NULL);
    8f54:	687b      	ldr	r3, [r7, #4]
    8f56:	2b00      	cmp	r3, #0
    8f58:	d105      	bne.n	8f66 <EDMA_SetTransferConfig+0x32>
    8f5a:	4b12      	ldr	r3, [pc, #72]	; (8fa4 <EDMA_SetTransferConfig+0x70>)
    8f5c:	4a0f      	ldr	r2, [pc, #60]	; (8f9c <EDMA_SetTransferConfig+0x68>)
    8f5e:	21e5      	movs	r1, #229	; 0xe5
    8f60:	480f      	ldr	r0, [pc, #60]	; (8fa0 <EDMA_SetTransferConfig+0x6c>)
    8f62:	f7fe f93b 	bl	71dc <__assert_func>
    assert(((uint32_t)nextTcd & 0x1FU) == 0U);
    8f66:	683b      	ldr	r3, [r7, #0]
    8f68:	f003 031f 	and.w	r3, r3, #31
    8f6c:	2b00      	cmp	r3, #0
    8f6e:	d005      	beq.n	8f7c <EDMA_SetTransferConfig+0x48>
    8f70:	4b0d      	ldr	r3, [pc, #52]	; (8fa8 <EDMA_SetTransferConfig+0x74>)
    8f72:	4a0a      	ldr	r2, [pc, #40]	; (8f9c <EDMA_SetTransferConfig+0x68>)
    8f74:	21e6      	movs	r1, #230	; 0xe6
    8f76:	480a      	ldr	r0, [pc, #40]	; (8fa0 <EDMA_SetTransferConfig+0x6c>)
    8f78:	f7fe f930 	bl	71dc <__assert_func>

    EDMA_TcdSetTransferConfig((edma_tcd_t *)(uint32_t)&base->TCD[channel], config, nextTcd);
    8f7c:	68bb      	ldr	r3, [r7, #8]
    8f7e:	3380      	adds	r3, #128	; 0x80
    8f80:	015b      	lsls	r3, r3, #5
    8f82:	68fa      	ldr	r2, [r7, #12]
    8f84:	4413      	add	r3, r2
    8f86:	683a      	ldr	r2, [r7, #0]
    8f88:	6879      	ldr	r1, [r7, #4]
    8f8a:	4618      	mov	r0, r3
    8f8c:	f000 f86a 	bl	9064 <EDMA_TcdSetTransferConfig>
}
    8f90:	bf00      	nop
    8f92:	3710      	adds	r7, #16
    8f94:	46bd      	mov	sp, r7
    8f96:	bd80      	pop	{r7, pc}
    8f98:	0000fb2c 	.word	0x0000fb2c
    8f9c:	0000fe80 	.word	0x0000fe80
    8fa0:	0000fad4 	.word	0x0000fad4
    8fa4:	0000fb8c 	.word	0x0000fb8c
    8fa8:	0000fb9c 	.word	0x0000fb9c

00008fac <EDMA_EnableChannelInterrupts>:
 * param channel eDMA channel number.
 * param mask The mask of interrupt source to be set. Users need to use
 *             the defined edma_interrupt_enable_t type.
 */
void EDMA_EnableChannelInterrupts(DMA_Type *base, uint32_t channel, uint32_t mask)
{
    8fac:	b580      	push	{r7, lr}
    8fae:	b084      	sub	sp, #16
    8fb0:	af00      	add	r7, sp, #0
    8fb2:	60f8      	str	r0, [r7, #12]
    8fb4:	60b9      	str	r1, [r7, #8]
    8fb6:	607a      	str	r2, [r7, #4]
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
    8fb8:	68bb      	ldr	r3, [r7, #8]
    8fba:	2b1f      	cmp	r3, #31
    8fbc:	d906      	bls.n	8fcc <EDMA_EnableChannelInterrupts+0x20>
    8fbe:	4b26      	ldr	r3, [pc, #152]	; (9058 <EDMA_EnableChannelInterrupts+0xac>)
    8fc0:	4a26      	ldr	r2, [pc, #152]	; (905c <EDMA_EnableChannelInterrupts+0xb0>)
    8fc2:	f240 117b 	movw	r1, #379	; 0x17b
    8fc6:	4826      	ldr	r0, [pc, #152]	; (9060 <EDMA_EnableChannelInterrupts+0xb4>)
    8fc8:	f7fe f908 	bl	71dc <__assert_func>

    /* Enable error interrupt */
    if (0U != (mask & (uint32_t)kEDMA_ErrorInterruptEnable))
    8fcc:	687b      	ldr	r3, [r7, #4]
    8fce:	f003 0301 	and.w	r3, r3, #1
    8fd2:	2b00      	cmp	r3, #0
    8fd4:	d008      	beq.n	8fe8 <EDMA_EnableChannelInterrupts+0x3c>
    {
        base->EEI |= ((uint32_t)0x1U << channel);
    8fd6:	68fb      	ldr	r3, [r7, #12]
    8fd8:	695a      	ldr	r2, [r3, #20]
    8fda:	2101      	movs	r1, #1
    8fdc:	68bb      	ldr	r3, [r7, #8]
    8fde:	fa01 f303 	lsl.w	r3, r1, r3
    8fe2:	431a      	orrs	r2, r3
    8fe4:	68fb      	ldr	r3, [r7, #12]
    8fe6:	615a      	str	r2, [r3, #20]
    }

    /* Enable Major interrupt */
    if (0U != (mask & (uint32_t)kEDMA_MajorInterruptEnable))
    8fe8:	687b      	ldr	r3, [r7, #4]
    8fea:	f003 0302 	and.w	r3, r3, #2
    8fee:	2b00      	cmp	r3, #0
    8ff0:	d014      	beq.n	901c <EDMA_EnableChannelInterrupts+0x70>
    {
        base->TCD[channel].CSR |= DMA_CSR_INTMAJOR_MASK;
    8ff2:	68fa      	ldr	r2, [r7, #12]
    8ff4:	68bb      	ldr	r3, [r7, #8]
    8ff6:	015b      	lsls	r3, r3, #5
    8ff8:	4413      	add	r3, r2
    8ffa:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    8ffe:	331c      	adds	r3, #28
    9000:	881b      	ldrh	r3, [r3, #0]
    9002:	b29b      	uxth	r3, r3
    9004:	f043 0302 	orr.w	r3, r3, #2
    9008:	b299      	uxth	r1, r3
    900a:	68fa      	ldr	r2, [r7, #12]
    900c:	68bb      	ldr	r3, [r7, #8]
    900e:	015b      	lsls	r3, r3, #5
    9010:	4413      	add	r3, r2
    9012:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    9016:	331c      	adds	r3, #28
    9018:	460a      	mov	r2, r1
    901a:	801a      	strh	r2, [r3, #0]
    }

    /* Enable Half major interrupt */
    if (0U != (mask & (uint32_t)kEDMA_HalfInterruptEnable))
    901c:	687b      	ldr	r3, [r7, #4]
    901e:	f003 0304 	and.w	r3, r3, #4
    9022:	2b00      	cmp	r3, #0
    9024:	d014      	beq.n	9050 <EDMA_EnableChannelInterrupts+0xa4>
    {
        base->TCD[channel].CSR |= DMA_CSR_INTHALF_MASK;
    9026:	68fa      	ldr	r2, [r7, #12]
    9028:	68bb      	ldr	r3, [r7, #8]
    902a:	015b      	lsls	r3, r3, #5
    902c:	4413      	add	r3, r2
    902e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    9032:	331c      	adds	r3, #28
    9034:	881b      	ldrh	r3, [r3, #0]
    9036:	b29b      	uxth	r3, r3
    9038:	f043 0304 	orr.w	r3, r3, #4
    903c:	b299      	uxth	r1, r3
    903e:	68fa      	ldr	r2, [r7, #12]
    9040:	68bb      	ldr	r3, [r7, #8]
    9042:	015b      	lsls	r3, r3, #5
    9044:	4413      	add	r3, r2
    9046:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    904a:	331c      	adds	r3, #28
    904c:	460a      	mov	r2, r1
    904e:	801a      	strh	r2, [r3, #0]
    }
}
    9050:	bf00      	nop
    9052:	3710      	adds	r7, #16
    9054:	46bd      	mov	sp, r7
    9056:	bd80      	pop	{r7, pc}
    9058:	0000fb2c 	.word	0x0000fb2c
    905c:	0000fe98 	.word	0x0000fe98
    9060:	0000fad4 	.word	0x0000fad4

00009064 <EDMA_TcdSetTransferConfig>:
 * note If the nextTcd is not NULL, the scatter gather feature is enabled
 *       and DREQ bit is cleared in the previous transfer configuration, which
 *       is set in the EDMA_TcdReset.
 */
void EDMA_TcdSetTransferConfig(edma_tcd_t *tcd, const edma_transfer_config_t *config, edma_tcd_t *nextTcd)
{
    9064:	b580      	push	{r7, lr}
    9066:	b084      	sub	sp, #16
    9068:	af00      	add	r7, sp, #0
    906a:	60f8      	str	r0, [r7, #12]
    906c:	60b9      	str	r1, [r7, #8]
    906e:	607a      	str	r2, [r7, #4]
    assert(tcd != NULL);
    9070:	68fb      	ldr	r3, [r7, #12]
    9072:	2b00      	cmp	r3, #0
    9074:	d106      	bne.n	9084 <EDMA_TcdSetTransferConfig+0x20>
    9076:	4b4c      	ldr	r3, [pc, #304]	; (91a8 <EDMA_TcdSetTransferConfig+0x144>)
    9078:	4a4c      	ldr	r2, [pc, #304]	; (91ac <EDMA_TcdSetTransferConfig+0x148>)
    907a:	f44f 71f4 	mov.w	r1, #488	; 0x1e8
    907e:	484c      	ldr	r0, [pc, #304]	; (91b0 <EDMA_TcdSetTransferConfig+0x14c>)
    9080:	f7fe f8ac 	bl	71dc <__assert_func>
    assert(((uint32_t)tcd & 0x1FU) == 0U);
    9084:	68fb      	ldr	r3, [r7, #12]
    9086:	f003 031f 	and.w	r3, r3, #31
    908a:	2b00      	cmp	r3, #0
    908c:	d006      	beq.n	909c <EDMA_TcdSetTransferConfig+0x38>
    908e:	4b49      	ldr	r3, [pc, #292]	; (91b4 <EDMA_TcdSetTransferConfig+0x150>)
    9090:	4a46      	ldr	r2, [pc, #280]	; (91ac <EDMA_TcdSetTransferConfig+0x148>)
    9092:	f240 11e9 	movw	r1, #489	; 0x1e9
    9096:	4846      	ldr	r0, [pc, #280]	; (91b0 <EDMA_TcdSetTransferConfig+0x14c>)
    9098:	f7fe f8a0 	bl	71dc <__assert_func>
    assert(config != NULL);
    909c:	68bb      	ldr	r3, [r7, #8]
    909e:	2b00      	cmp	r3, #0
    90a0:	d106      	bne.n	90b0 <EDMA_TcdSetTransferConfig+0x4c>
    90a2:	4b45      	ldr	r3, [pc, #276]	; (91b8 <EDMA_TcdSetTransferConfig+0x154>)
    90a4:	4a41      	ldr	r2, [pc, #260]	; (91ac <EDMA_TcdSetTransferConfig+0x148>)
    90a6:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
    90aa:	4841      	ldr	r0, [pc, #260]	; (91b0 <EDMA_TcdSetTransferConfig+0x14c>)
    90ac:	f7fe f896 	bl	71dc <__assert_func>
    assert(((uint32_t)nextTcd & 0x1FU) == 0U);
    90b0:	687b      	ldr	r3, [r7, #4]
    90b2:	f003 031f 	and.w	r3, r3, #31
    90b6:	2b00      	cmp	r3, #0
    90b8:	d006      	beq.n	90c8 <EDMA_TcdSetTransferConfig+0x64>
    90ba:	4b40      	ldr	r3, [pc, #256]	; (91bc <EDMA_TcdSetTransferConfig+0x158>)
    90bc:	4a3b      	ldr	r2, [pc, #236]	; (91ac <EDMA_TcdSetTransferConfig+0x148>)
    90be:	f240 11eb 	movw	r1, #491	; 0x1eb
    90c2:	483b      	ldr	r0, [pc, #236]	; (91b0 <EDMA_TcdSetTransferConfig+0x14c>)
    90c4:	f7fe f88a 	bl	71dc <__assert_func>
    assert((config->srcAddr % (1UL << (uint32_t)config->srcTransferSize)) == 0U);
    90c8:	68bb      	ldr	r3, [r7, #8]
    90ca:	681a      	ldr	r2, [r3, #0]
    90cc:	68bb      	ldr	r3, [r7, #8]
    90ce:	7a1b      	ldrb	r3, [r3, #8]
    90d0:	4619      	mov	r1, r3
    90d2:	f04f 33ff 	mov.w	r3, #4294967295
    90d6:	408b      	lsls	r3, r1
    90d8:	43db      	mvns	r3, r3
    90da:	4013      	ands	r3, r2
    90dc:	2b00      	cmp	r3, #0
    90de:	d006      	beq.n	90ee <EDMA_TcdSetTransferConfig+0x8a>
    90e0:	4b37      	ldr	r3, [pc, #220]	; (91c0 <EDMA_TcdSetTransferConfig+0x15c>)
    90e2:	4a32      	ldr	r2, [pc, #200]	; (91ac <EDMA_TcdSetTransferConfig+0x148>)
    90e4:	f44f 71f6 	mov.w	r1, #492	; 0x1ec
    90e8:	4831      	ldr	r0, [pc, #196]	; (91b0 <EDMA_TcdSetTransferConfig+0x14c>)
    90ea:	f7fe f877 	bl	71dc <__assert_func>
    assert((config->destAddr % (1UL << (uint32_t)config->destTransferSize)) == 0U);
    90ee:	68bb      	ldr	r3, [r7, #8]
    90f0:	685a      	ldr	r2, [r3, #4]
    90f2:	68bb      	ldr	r3, [r7, #8]
    90f4:	7a5b      	ldrb	r3, [r3, #9]
    90f6:	4619      	mov	r1, r3
    90f8:	f04f 33ff 	mov.w	r3, #4294967295
    90fc:	408b      	lsls	r3, r1
    90fe:	43db      	mvns	r3, r3
    9100:	4013      	ands	r3, r2
    9102:	2b00      	cmp	r3, #0
    9104:	d006      	beq.n	9114 <EDMA_TcdSetTransferConfig+0xb0>
    9106:	4b2f      	ldr	r3, [pc, #188]	; (91c4 <EDMA_TcdSetTransferConfig+0x160>)
    9108:	4a28      	ldr	r2, [pc, #160]	; (91ac <EDMA_TcdSetTransferConfig+0x148>)
    910a:	f240 11ed 	movw	r1, #493	; 0x1ed
    910e:	4828      	ldr	r0, [pc, #160]	; (91b0 <EDMA_TcdSetTransferConfig+0x14c>)
    9110:	f7fe f864 	bl	71dc <__assert_func>

    /* source address */
    tcd->SADDR = config->srcAddr;
    9114:	68bb      	ldr	r3, [r7, #8]
    9116:	681a      	ldr	r2, [r3, #0]
    9118:	68fb      	ldr	r3, [r7, #12]
    911a:	601a      	str	r2, [r3, #0]
    /* destination address */
    tcd->DADDR = config->destAddr;
    911c:	68bb      	ldr	r3, [r7, #8]
    911e:	685a      	ldr	r2, [r3, #4]
    9120:	68fb      	ldr	r3, [r7, #12]
    9122:	611a      	str	r2, [r3, #16]
    /* Source data and destination data transfer size */
    tcd->ATTR = DMA_ATTR_SSIZE(config->srcTransferSize) | DMA_ATTR_DSIZE(config->destTransferSize);
    9124:	68bb      	ldr	r3, [r7, #8]
    9126:	7a1b      	ldrb	r3, [r3, #8]
    9128:	b29b      	uxth	r3, r3
    912a:	021b      	lsls	r3, r3, #8
    912c:	b29b      	uxth	r3, r3
    912e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    9132:	b29a      	uxth	r2, r3
    9134:	68bb      	ldr	r3, [r7, #8]
    9136:	7a5b      	ldrb	r3, [r3, #9]
    9138:	b29b      	uxth	r3, r3
    913a:	f003 0307 	and.w	r3, r3, #7
    913e:	b29b      	uxth	r3, r3
    9140:	4313      	orrs	r3, r2
    9142:	b29a      	uxth	r2, r3
    9144:	68fb      	ldr	r3, [r7, #12]
    9146:	80da      	strh	r2, [r3, #6]
    /* Source address signed offset */
    tcd->SOFF = (uint16_t)config->srcOffset;
    9148:	68bb      	ldr	r3, [r7, #8]
    914a:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
    914e:	b29a      	uxth	r2, r3
    9150:	68fb      	ldr	r3, [r7, #12]
    9152:	809a      	strh	r2, [r3, #4]
    /* Destination address signed offset */
    tcd->DOFF = (uint16_t)config->destOffset;
    9154:	68bb      	ldr	r3, [r7, #8]
    9156:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
    915a:	b29a      	uxth	r2, r3
    915c:	68fb      	ldr	r3, [r7, #12]
    915e:	829a      	strh	r2, [r3, #20]
    /* Minor byte transfer count */
    tcd->NBYTES = config->minorLoopBytes;
    9160:	68bb      	ldr	r3, [r7, #8]
    9162:	691a      	ldr	r2, [r3, #16]
    9164:	68fb      	ldr	r3, [r7, #12]
    9166:	609a      	str	r2, [r3, #8]
    /* Current major iteration count */
    tcd->CITER = (uint16_t)config->majorLoopCounts;
    9168:	68bb      	ldr	r3, [r7, #8]
    916a:	695b      	ldr	r3, [r3, #20]
    916c:	b29a      	uxth	r2, r3
    916e:	68fb      	ldr	r3, [r7, #12]
    9170:	82da      	strh	r2, [r3, #22]
    /* Starting major iteration count */
    tcd->BITER = (uint16_t)config->majorLoopCounts;
    9172:	68bb      	ldr	r3, [r7, #8]
    9174:	695b      	ldr	r3, [r3, #20]
    9176:	b29a      	uxth	r2, r3
    9178:	68fb      	ldr	r3, [r7, #12]
    917a:	83da      	strh	r2, [r3, #30]
    /* Enable scatter/gather processing */
    if (nextTcd != NULL)
    917c:	687b      	ldr	r3, [r7, #4]
    917e:	2b00      	cmp	r3, #0
    9180:	d00d      	beq.n	919e <EDMA_TcdSetTransferConfig+0x13a>
    {
        tcd->DLAST_SGA = (uint32_t)nextTcd;
    9182:	687a      	ldr	r2, [r7, #4]
    9184:	68fb      	ldr	r3, [r7, #12]
    9186:	619a      	str	r2, [r3, #24]

            Clear the DREQ bit because scatter gather has been enabled, so the
            previous transfer is not the last transfer, and channel request should
            be enabled at the next transfer(the next TCD).
        */
        tcd->CSR = (tcd->CSR | (uint16_t)DMA_CSR_ESG_MASK) & ~(uint16_t)DMA_CSR_DREQ_MASK;
    9188:	68fb      	ldr	r3, [r7, #12]
    918a:	8b9b      	ldrh	r3, [r3, #28]
    918c:	b29b      	uxth	r3, r3
    918e:	f043 0310 	orr.w	r3, r3, #16
    9192:	b29b      	uxth	r3, r3
    9194:	f023 0308 	bic.w	r3, r3, #8
    9198:	b29a      	uxth	r2, r3
    919a:	68fb      	ldr	r3, [r7, #12]
    919c:	839a      	strh	r2, [r3, #28]
    }
}
    919e:	bf00      	nop
    91a0:	3710      	adds	r7, #16
    91a2:	46bd      	mov	sp, r7
    91a4:	bd80      	pop	{r7, pc}
    91a6:	bf00      	nop
    91a8:	0000fb60 	.word	0x0000fb60
    91ac:	0000feb8 	.word	0x0000feb8
    91b0:	0000fad4 	.word	0x0000fad4
    91b4:	0000fb6c 	.word	0x0000fb6c
    91b8:	0000fb8c 	.word	0x0000fb8c
    91bc:	0000fb9c 	.word	0x0000fb9c
    91c0:	0000fbfc 	.word	0x0000fbfc
    91c4:	0000fc44 	.word	0x0000fc44

000091c8 <EDMA_GetChannelStatusFlags>:
 * param channel eDMA channel number.
 * return The mask of channel status flags. Users need to use the
 *         _edma_channel_status_flags type to decode the return variables.
 */
uint32_t EDMA_GetChannelStatusFlags(DMA_Type *base, uint32_t channel)
{
    91c8:	b580      	push	{r7, lr}
    91ca:	b084      	sub	sp, #16
    91cc:	af00      	add	r7, sp, #0
    91ce:	6078      	str	r0, [r7, #4]
    91d0:	6039      	str	r1, [r7, #0]
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
    91d2:	683b      	ldr	r3, [r7, #0]
    91d4:	2b1f      	cmp	r3, #31
    91d6:	d906      	bls.n	91e6 <EDMA_GetChannelStatusFlags+0x1e>
    91d8:	4b19      	ldr	r3, [pc, #100]	; (9240 <EDMA_GetChannelStatusFlags+0x78>)
    91da:	4a1a      	ldr	r2, [pc, #104]	; (9244 <EDMA_GetChannelStatusFlags+0x7c>)
    91dc:	f240 21f1 	movw	r1, #753	; 0x2f1
    91e0:	4819      	ldr	r0, [pc, #100]	; (9248 <EDMA_GetChannelStatusFlags+0x80>)
    91e2:	f7fd fffb 	bl	71dc <__assert_func>

    uint32_t retval = 0;
    91e6:	2300      	movs	r3, #0
    91e8:	60fb      	str	r3, [r7, #12]

    /* Get DONE bit flag */
    retval |= (((uint32_t)base->TCD[channel].CSR & DMA_CSR_DONE_MASK) >> DMA_CSR_DONE_SHIFT);
    91ea:	687a      	ldr	r2, [r7, #4]
    91ec:	683b      	ldr	r3, [r7, #0]
    91ee:	015b      	lsls	r3, r3, #5
    91f0:	4413      	add	r3, r2
    91f2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    91f6:	331c      	adds	r3, #28
    91f8:	881b      	ldrh	r3, [r3, #0]
    91fa:	b29b      	uxth	r3, r3
    91fc:	09db      	lsrs	r3, r3, #7
    91fe:	f003 0301 	and.w	r3, r3, #1
    9202:	68fa      	ldr	r2, [r7, #12]
    9204:	4313      	orrs	r3, r2
    9206:	60fb      	str	r3, [r7, #12]
    /* Get ERROR bit flag */
    retval |= ((((uint32_t)base->ERR >> channel) & 0x1U) << 1U);
    9208:	687b      	ldr	r3, [r7, #4]
    920a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    920c:	683b      	ldr	r3, [r7, #0]
    920e:	fa22 f303 	lsr.w	r3, r2, r3
    9212:	005b      	lsls	r3, r3, #1
    9214:	f003 0302 	and.w	r3, r3, #2
    9218:	68fa      	ldr	r2, [r7, #12]
    921a:	4313      	orrs	r3, r2
    921c:	60fb      	str	r3, [r7, #12]
    /* Get INT bit flag */
    retval |= ((((uint32_t)base->INT >> channel) & 0x1U) << 2U);
    921e:	687b      	ldr	r3, [r7, #4]
    9220:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    9222:	683b      	ldr	r3, [r7, #0]
    9224:	fa22 f303 	lsr.w	r3, r2, r3
    9228:	009b      	lsls	r3, r3, #2
    922a:	f003 0304 	and.w	r3, r3, #4
    922e:	68fa      	ldr	r2, [r7, #12]
    9230:	4313      	orrs	r3, r2
    9232:	60fb      	str	r3, [r7, #12]

    return retval;
    9234:	68fb      	ldr	r3, [r7, #12]
}
    9236:	4618      	mov	r0, r3
    9238:	3710      	adds	r7, #16
    923a:	46bd      	mov	sp, r7
    923c:	bd80      	pop	{r7, pc}
    923e:	bf00      	nop
    9240:	0000fb2c 	.word	0x0000fb2c
    9244:	0000fed4 	.word	0x0000fed4
    9248:	0000fad4 	.word	0x0000fad4

0000924c <EDMA_ClearChannelStatusFlags>:
 * param channel eDMA channel number.
 * param mask The mask of channel status to be cleared. Users need to use
 *             the defined _edma_channel_status_flags type.
 */
void EDMA_ClearChannelStatusFlags(DMA_Type *base, uint32_t channel, uint32_t mask)
{
    924c:	b580      	push	{r7, lr}
    924e:	b084      	sub	sp, #16
    9250:	af00      	add	r7, sp, #0
    9252:	60f8      	str	r0, [r7, #12]
    9254:	60b9      	str	r1, [r7, #8]
    9256:	607a      	str	r2, [r7, #4]
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
    9258:	68bb      	ldr	r3, [r7, #8]
    925a:	2b1f      	cmp	r3, #31
    925c:	d906      	bls.n	926c <EDMA_ClearChannelStatusFlags+0x20>
    925e:	4b13      	ldr	r3, [pc, #76]	; (92ac <EDMA_ClearChannelStatusFlags+0x60>)
    9260:	4a13      	ldr	r2, [pc, #76]	; (92b0 <EDMA_ClearChannelStatusFlags+0x64>)
    9262:	f240 3109 	movw	r1, #777	; 0x309
    9266:	4813      	ldr	r0, [pc, #76]	; (92b4 <EDMA_ClearChannelStatusFlags+0x68>)
    9268:	f7fd ffb8 	bl	71dc <__assert_func>

    /* Clear DONE bit flag */
    if (0U != (mask & (uint32_t)kEDMA_DoneFlag))
    926c:	687b      	ldr	r3, [r7, #4]
    926e:	f003 0301 	and.w	r3, r3, #1
    9272:	2b00      	cmp	r3, #0
    9274:	d003      	beq.n	927e <EDMA_ClearChannelStatusFlags+0x32>
    {
        base->CDNE = (uint8_t)channel;
    9276:	68bb      	ldr	r3, [r7, #8]
    9278:	b2da      	uxtb	r2, r3
    927a:	68fb      	ldr	r3, [r7, #12]
    927c:	771a      	strb	r2, [r3, #28]
    }
    /* Clear ERROR bit flag */
    if (0U != (mask & (uint32_t)kEDMA_ErrorFlag))
    927e:	687b      	ldr	r3, [r7, #4]
    9280:	f003 0302 	and.w	r3, r3, #2
    9284:	2b00      	cmp	r3, #0
    9286:	d003      	beq.n	9290 <EDMA_ClearChannelStatusFlags+0x44>
    {
        base->CERR = (uint8_t)channel;
    9288:	68bb      	ldr	r3, [r7, #8]
    928a:	b2da      	uxtb	r2, r3
    928c:	68fb      	ldr	r3, [r7, #12]
    928e:	779a      	strb	r2, [r3, #30]
    }
    /* Clear INT bit flag */
    if (0U != (mask & (uint32_t)kEDMA_InterruptFlag))
    9290:	687b      	ldr	r3, [r7, #4]
    9292:	f003 0304 	and.w	r3, r3, #4
    9296:	2b00      	cmp	r3, #0
    9298:	d003      	beq.n	92a2 <EDMA_ClearChannelStatusFlags+0x56>
    {
        base->CINT = (uint8_t)channel;
    929a:	68bb      	ldr	r3, [r7, #8]
    929c:	b2da      	uxtb	r2, r3
    929e:	68fb      	ldr	r3, [r7, #12]
    92a0:	77da      	strb	r2, [r3, #31]
    }
}
    92a2:	bf00      	nop
    92a4:	3710      	adds	r7, #16
    92a6:	46bd      	mov	sp, r7
    92a8:	bd80      	pop	{r7, pc}
    92aa:	bf00      	nop
    92ac:	0000fb2c 	.word	0x0000fb2c
    92b0:	0000fef0 	.word	0x0000fef0
    92b4:	0000fad4 	.word	0x0000fad4

000092b8 <EDMA_GetInstanceOffset>:

static uint32_t EDMA_GetInstanceOffset(uint32_t instance)
{
    92b8:	b580      	push	{r7, lr}
    92ba:	b082      	sub	sp, #8
    92bc:	af00      	add	r7, sp, #0
    92be:	6078      	str	r0, [r7, #4]
    static uint8_t startInstanceNum;

#if defined(DMA0)
    startInstanceNum = (uint8_t)EDMA_GetInstance(DMA0);
    92c0:	480e      	ldr	r0, [pc, #56]	; (92fc <EDMA_GetInstanceOffset+0x44>)
    92c2:	f7ff fd93 	bl	8dec <EDMA_GetInstance>
    92c6:	4603      	mov	r3, r0
    92c8:	b2da      	uxtb	r2, r3
    92ca:	4b0d      	ldr	r3, [pc, #52]	; (9300 <EDMA_GetInstanceOffset+0x48>)
    92cc:	701a      	strb	r2, [r3, #0]
    startInstanceNum = (uint8_t)EDMA_GetInstance(DMA2);
#elif defined(DMA3)
    startInstanceNum = (uint8_t)EDMA_GetInstance(DMA3);
#endif

    assert(startInstanceNum <= instance);
    92ce:	4b0c      	ldr	r3, [pc, #48]	; (9300 <EDMA_GetInstanceOffset+0x48>)
    92d0:	781b      	ldrb	r3, [r3, #0]
    92d2:	461a      	mov	r2, r3
    92d4:	687b      	ldr	r3, [r7, #4]
    92d6:	4293      	cmp	r3, r2
    92d8:	d206      	bcs.n	92e8 <EDMA_GetInstanceOffset+0x30>
    92da:	4b0a      	ldr	r3, [pc, #40]	; (9304 <EDMA_GetInstanceOffset+0x4c>)
    92dc:	4a0a      	ldr	r2, [pc, #40]	; (9308 <EDMA_GetInstanceOffset+0x50>)
    92de:	f240 312a 	movw	r1, #810	; 0x32a
    92e2:	480a      	ldr	r0, [pc, #40]	; (930c <EDMA_GetInstanceOffset+0x54>)
    92e4:	f7fd ff7a 	bl	71dc <__assert_func>

    return instance - startInstanceNum;
    92e8:	4b05      	ldr	r3, [pc, #20]	; (9300 <EDMA_GetInstanceOffset+0x48>)
    92ea:	781b      	ldrb	r3, [r3, #0]
    92ec:	461a      	mov	r2, r3
    92ee:	687b      	ldr	r3, [r7, #4]
    92f0:	1a9b      	subs	r3, r3, r2
}
    92f2:	4618      	mov	r0, r3
    92f4:	3708      	adds	r7, #8
    92f6:	46bd      	mov	sp, r7
    92f8:	bd80      	pop	{r7, pc}
    92fa:	bf00      	nop
    92fc:	40008000 	.word	0x40008000
    9300:	1fff14bc 	.word	0x1fff14bc
    9304:	0000fc8c 	.word	0x0000fc8c
    9308:	0000ff10 	.word	0x0000ff10
    930c:	0000fad4 	.word	0x0000fad4

00009310 <EDMA_CreateHandle>:
 *               parameters.
 * param base eDMA peripheral base address.
 * param channel eDMA channel number.
 */
void EDMA_CreateHandle(edma_handle_t *handle, DMA_Type *base, uint32_t channel)
{
    9310:	b580      	push	{r7, lr}
    9312:	b088      	sub	sp, #32
    9314:	af00      	add	r7, sp, #0
    9316:	60f8      	str	r0, [r7, #12]
    9318:	60b9      	str	r1, [r7, #8]
    931a:	607a      	str	r2, [r7, #4]
    assert(handle != NULL);
    931c:	68fb      	ldr	r3, [r7, #12]
    931e:	2b00      	cmp	r3, #0
    9320:	d106      	bne.n	9330 <EDMA_CreateHandle+0x20>
    9322:	4b33      	ldr	r3, [pc, #204]	; (93f0 <EDMA_CreateHandle+0xe0>)
    9324:	4a33      	ldr	r2, [pc, #204]	; (93f4 <EDMA_CreateHandle+0xe4>)
    9326:	f44f 714f 	mov.w	r1, #828	; 0x33c
    932a:	4833      	ldr	r0, [pc, #204]	; (93f8 <EDMA_CreateHandle+0xe8>)
    932c:	f7fd ff56 	bl	71dc <__assert_func>
    assert(channel < (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL);
    9330:	687b      	ldr	r3, [r7, #4]
    9332:	2b1f      	cmp	r3, #31
    9334:	d906      	bls.n	9344 <EDMA_CreateHandle+0x34>
    9336:	4b31      	ldr	r3, [pc, #196]	; (93fc <EDMA_CreateHandle+0xec>)
    9338:	4a2e      	ldr	r2, [pc, #184]	; (93f4 <EDMA_CreateHandle+0xe4>)
    933a:	f240 313d 	movw	r1, #829	; 0x33d
    933e:	482e      	ldr	r0, [pc, #184]	; (93f8 <EDMA_CreateHandle+0xe8>)
    9340:	f7fd ff4c 	bl	71dc <__assert_func>
    uint32_t edmaInstance;
    uint32_t channelIndex;
    edma_tcd_t *tcdRegs;

    /* Zero the handle */
    (void)memset(handle, 0, sizeof(*handle));
    9344:	2218      	movs	r2, #24
    9346:	2100      	movs	r1, #0
    9348:	68f8      	ldr	r0, [r7, #12]
    934a:	f005 f845 	bl	e3d8 <memset>

    handle->base    = base;
    934e:	68fb      	ldr	r3, [r7, #12]
    9350:	68ba      	ldr	r2, [r7, #8]
    9352:	609a      	str	r2, [r3, #8]
    handle->channel = (uint8_t)channel;
    9354:	687b      	ldr	r3, [r7, #4]
    9356:	b2da      	uxtb	r2, r3
    9358:	68fb      	ldr	r3, [r7, #12]
    935a:	741a      	strb	r2, [r3, #16]
    /* Get the DMA instance number */
    edmaInstance = EDMA_GetInstance(base);
    935c:	68b8      	ldr	r0, [r7, #8]
    935e:	f7ff fd45 	bl	8dec <EDMA_GetInstance>
    9362:	61f8      	str	r0, [r7, #28]
    channelIndex = (EDMA_GetInstanceOffset(edmaInstance) * (uint32_t)FSL_FEATURE_EDMA_MODULE_CHANNEL) + channel;
    9364:	69f8      	ldr	r0, [r7, #28]
    9366:	f7ff ffa7 	bl	92b8 <EDMA_GetInstanceOffset>
    936a:	4603      	mov	r3, r0
    936c:	015b      	lsls	r3, r3, #5
    936e:	687a      	ldr	r2, [r7, #4]
    9370:	4413      	add	r3, r2
    9372:	61bb      	str	r3, [r7, #24]
    s_EDMAHandle[channelIndex] = handle;
    9374:	4922      	ldr	r1, [pc, #136]	; (9400 <EDMA_CreateHandle+0xf0>)
    9376:	69bb      	ldr	r3, [r7, #24]
    9378:	68fa      	ldr	r2, [r7, #12]
    937a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

    /* Enable NVIC interrupt */
    (void)EnableIRQ(s_edmaIRQNumber[edmaInstance][channel]);
    937e:	4a21      	ldr	r2, [pc, #132]	; (9404 <EDMA_CreateHandle+0xf4>)
    9380:	69fb      	ldr	r3, [r7, #28]
    9382:	015b      	lsls	r3, r3, #5
    9384:	441a      	add	r2, r3
    9386:	687b      	ldr	r3, [r7, #4]
    9388:	4413      	add	r3, r2
    938a:	f993 3000 	ldrsb.w	r3, [r3]
    938e:	4618      	mov	r0, r3
    9390:	f7ff fcf2 	bl	8d78 <EnableIRQ>
    /*
       Reset TCD registers to zero. Unlike the EDMA_TcdReset(DREQ will be set),
       CSR will be 0. Because in order to suit EDMA busy check mechanism in
       EDMA_SubmitTransfer, CSR must be set 0.
    */
    tcdRegs            = (edma_tcd_t *)(uint32_t)&handle->base->TCD[handle->channel];
    9394:	68fb      	ldr	r3, [r7, #12]
    9396:	689a      	ldr	r2, [r3, #8]
    9398:	68fb      	ldr	r3, [r7, #12]
    939a:	7c1b      	ldrb	r3, [r3, #16]
    939c:	3380      	adds	r3, #128	; 0x80
    939e:	015b      	lsls	r3, r3, #5
    93a0:	4413      	add	r3, r2
    93a2:	617b      	str	r3, [r7, #20]
    tcdRegs->SADDR     = 0;
    93a4:	697b      	ldr	r3, [r7, #20]
    93a6:	2200      	movs	r2, #0
    93a8:	601a      	str	r2, [r3, #0]
    tcdRegs->SOFF      = 0;
    93aa:	697b      	ldr	r3, [r7, #20]
    93ac:	2200      	movs	r2, #0
    93ae:	809a      	strh	r2, [r3, #4]
    tcdRegs->ATTR      = 0;
    93b0:	697b      	ldr	r3, [r7, #20]
    93b2:	2200      	movs	r2, #0
    93b4:	80da      	strh	r2, [r3, #6]
    tcdRegs->NBYTES    = 0;
    93b6:	697b      	ldr	r3, [r7, #20]
    93b8:	2200      	movs	r2, #0
    93ba:	609a      	str	r2, [r3, #8]
    tcdRegs->SLAST     = 0;
    93bc:	697b      	ldr	r3, [r7, #20]
    93be:	2200      	movs	r2, #0
    93c0:	60da      	str	r2, [r3, #12]
    tcdRegs->DADDR     = 0;
    93c2:	697b      	ldr	r3, [r7, #20]
    93c4:	2200      	movs	r2, #0
    93c6:	611a      	str	r2, [r3, #16]
    tcdRegs->DOFF      = 0;
    93c8:	697b      	ldr	r3, [r7, #20]
    93ca:	2200      	movs	r2, #0
    93cc:	829a      	strh	r2, [r3, #20]
    tcdRegs->CITER     = 0;
    93ce:	697b      	ldr	r3, [r7, #20]
    93d0:	2200      	movs	r2, #0
    93d2:	82da      	strh	r2, [r3, #22]
    tcdRegs->DLAST_SGA = 0;
    93d4:	697b      	ldr	r3, [r7, #20]
    93d6:	2200      	movs	r2, #0
    93d8:	619a      	str	r2, [r3, #24]
    tcdRegs->CSR       = 0;
    93da:	697b      	ldr	r3, [r7, #20]
    93dc:	2200      	movs	r2, #0
    93de:	839a      	strh	r2, [r3, #28]
    tcdRegs->BITER     = 0;
    93e0:	697b      	ldr	r3, [r7, #20]
    93e2:	2200      	movs	r2, #0
    93e4:	83da      	strh	r2, [r3, #30]
}
    93e6:	bf00      	nop
    93e8:	3720      	adds	r7, #32
    93ea:	46bd      	mov	sp, r7
    93ec:	bd80      	pop	{r7, pc}
    93ee:	bf00      	nop
    93f0:	0000fcac 	.word	0x0000fcac
    93f4:	0000ff28 	.word	0x0000ff28
    93f8:	0000fad4 	.word	0x0000fad4
    93fc:	0000fb2c 	.word	0x0000fb2c
    9400:	1fff143c 	.word	0x1fff143c
    9404:	0000fa90 	.word	0x0000fa90

00009408 <EDMA_SetCallback>:
 * param handle eDMA handle pointer.
 * param callback eDMA callback function pointer.
 * param userData A parameter for the callback function.
 */
void EDMA_SetCallback(edma_handle_t *handle, edma_callback callback, void *userData)
{
    9408:	b580      	push	{r7, lr}
    940a:	b084      	sub	sp, #16
    940c:	af00      	add	r7, sp, #0
    940e:	60f8      	str	r0, [r7, #12]
    9410:	60b9      	str	r1, [r7, #8]
    9412:	607a      	str	r2, [r7, #4]
    assert(handle != NULL);
    9414:	68fb      	ldr	r3, [r7, #12]
    9416:	2b00      	cmp	r3, #0
    9418:	d106      	bne.n	9428 <EDMA_SetCallback+0x20>
    941a:	4b08      	ldr	r3, [pc, #32]	; (943c <EDMA_SetCallback+0x34>)
    941c:	4a08      	ldr	r2, [pc, #32]	; (9440 <EDMA_SetCallback+0x38>)
    941e:	f240 3189 	movw	r1, #905	; 0x389
    9422:	4808      	ldr	r0, [pc, #32]	; (9444 <EDMA_SetCallback+0x3c>)
    9424:	f7fd feda 	bl	71dc <__assert_func>

    handle->callback = callback;
    9428:	68fb      	ldr	r3, [r7, #12]
    942a:	68ba      	ldr	r2, [r7, #8]
    942c:	601a      	str	r2, [r3, #0]
    handle->userData = userData;
    942e:	68fb      	ldr	r3, [r7, #12]
    9430:	687a      	ldr	r2, [r7, #4]
    9432:	605a      	str	r2, [r3, #4]
}
    9434:	bf00      	nop
    9436:	3710      	adds	r7, #16
    9438:	46bd      	mov	sp, r7
    943a:	bd80      	pop	{r7, pc}
    943c:	0000fcac 	.word	0x0000fcac
    9440:	0000ff3c 	.word	0x0000ff3c
    9444:	0000fad4 	.word	0x0000fad4

00009448 <EDMA_TransferWidthMapping>:

static edma_transfer_size_t EDMA_TransferWidthMapping(uint32_t width)
{
    9448:	b580      	push	{r7, lr}
    944a:	b084      	sub	sp, #16
    944c:	af00      	add	r7, sp, #0
    944e:	6078      	str	r0, [r7, #4]
    edma_transfer_size_t transferSize = kEDMA_TransferSize1Bytes;
    9450:	2300      	movs	r3, #0
    9452:	73fb      	strb	r3, [r7, #15]

    /* map width to register value */
    switch (width)
    9454:	687b      	ldr	r3, [r7, #4]
    9456:	3b01      	subs	r3, #1
    9458:	2b1f      	cmp	r3, #31
    945a:	d852      	bhi.n	9502 <EDMA_TransferWidthMapping+0xba>
    945c:	a201      	add	r2, pc, #4	; (adr r2, 9464 <EDMA_TransferWidthMapping+0x1c>)
    945e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    9462:	bf00      	nop
    9464:	000094e5 	.word	0x000094e5
    9468:	000094eb 	.word	0x000094eb
    946c:	00009503 	.word	0x00009503
    9470:	000094f1 	.word	0x000094f1
    9474:	00009503 	.word	0x00009503
    9478:	00009503 	.word	0x00009503
    947c:	00009503 	.word	0x00009503
    9480:	00009503 	.word	0x00009503
    9484:	00009503 	.word	0x00009503
    9488:	00009503 	.word	0x00009503
    948c:	00009503 	.word	0x00009503
    9490:	00009503 	.word	0x00009503
    9494:	00009503 	.word	0x00009503
    9498:	00009503 	.word	0x00009503
    949c:	00009503 	.word	0x00009503
    94a0:	000094f7 	.word	0x000094f7
    94a4:	00009503 	.word	0x00009503
    94a8:	00009503 	.word	0x00009503
    94ac:	00009503 	.word	0x00009503
    94b0:	00009503 	.word	0x00009503
    94b4:	00009503 	.word	0x00009503
    94b8:	00009503 	.word	0x00009503
    94bc:	00009503 	.word	0x00009503
    94c0:	00009503 	.word	0x00009503
    94c4:	00009503 	.word	0x00009503
    94c8:	00009503 	.word	0x00009503
    94cc:	00009503 	.word	0x00009503
    94d0:	00009503 	.word	0x00009503
    94d4:	00009503 	.word	0x00009503
    94d8:	00009503 	.word	0x00009503
    94dc:	00009503 	.word	0x00009503
    94e0:	000094fd 	.word	0x000094fd
    {
        /* width 8bit */
        case 1U:
            transferSize = kEDMA_TransferSize1Bytes;
    94e4:	2300      	movs	r3, #0
    94e6:	73fb      	strb	r3, [r7, #15]
            break;
    94e8:	e012      	b.n	9510 <EDMA_TransferWidthMapping+0xc8>
        /* width 16bit */
        case 2U:
            transferSize = kEDMA_TransferSize2Bytes;
    94ea:	2301      	movs	r3, #1
    94ec:	73fb      	strb	r3, [r7, #15]
            break;
    94ee:	e00f      	b.n	9510 <EDMA_TransferWidthMapping+0xc8>
        /* width 32bit */
        case 4U:
            transferSize = kEDMA_TransferSize4Bytes;
    94f0:	2302      	movs	r3, #2
    94f2:	73fb      	strb	r3, [r7, #15]
            break;
    94f4:	e00c      	b.n	9510 <EDMA_TransferWidthMapping+0xc8>
            break;
#endif
#if (defined(FSL_FEATURE_EDMA_SUPPORT_16_BYTES_TRANSFER) && FSL_FEATURE_EDMA_SUPPORT_16_BYTES_TRANSFER)
        /* width 128bit */
        case 16U:
            transferSize = kEDMA_TransferSize16Bytes;
    94f6:	2304      	movs	r3, #4
    94f8:	73fb      	strb	r3, [r7, #15]
            break;
    94fa:	e009      	b.n	9510 <EDMA_TransferWidthMapping+0xc8>
#endif
        /* width 256bit */
        case 32U:
            transferSize = kEDMA_TransferSize32Bytes;
    94fc:	2305      	movs	r3, #5
    94fe:	73fb      	strb	r3, [r7, #15]
            break;
    9500:	e006      	b.n	9510 <EDMA_TransferWidthMapping+0xc8>
        default:
            /* All the cases have been listed above, the default clause should not be reached. */
            assert(false);
    9502:	4b06      	ldr	r3, [pc, #24]	; (951c <EDMA_TransferWidthMapping+0xd4>)
    9504:	4a06      	ldr	r2, [pc, #24]	; (9520 <EDMA_TransferWidthMapping+0xd8>)
    9506:	f44f 716d 	mov.w	r1, #948	; 0x3b4
    950a:	4806      	ldr	r0, [pc, #24]	; (9524 <EDMA_TransferWidthMapping+0xdc>)
    950c:	f7fd fe66 	bl	71dc <__assert_func>
            break;
    }

    return transferSize;
    9510:	7bfb      	ldrb	r3, [r7, #15]
}
    9512:	4618      	mov	r0, r3
    9514:	3710      	adds	r7, #16
    9516:	46bd      	mov	sp, r7
    9518:	bd80      	pop	{r7, pc}
    951a:	bf00      	nop
    951c:	0000fce0 	.word	0x0000fce0
    9520:	0000ff50 	.word	0x0000ff50
    9524:	0000fad4 	.word	0x0000fad4

00009528 <EDMA_PrepareTransferConfig>:
                                void *destAddr,
                                uint32_t destWidth,
                                int16_t destOffset,
                                uint32_t bytesEachRequest,
                                uint32_t transferBytes)
{
    9528:	b580      	push	{r7, lr}
    952a:	b084      	sub	sp, #16
    952c:	af00      	add	r7, sp, #0
    952e:	60f8      	str	r0, [r7, #12]
    9530:	60b9      	str	r1, [r7, #8]
    9532:	607a      	str	r2, [r7, #4]
    9534:	807b      	strh	r3, [r7, #2]
    assert(config != NULL);
    9536:	68fb      	ldr	r3, [r7, #12]
    9538:	2b00      	cmp	r3, #0
    953a:	d106      	bne.n	954a <EDMA_PrepareTransferConfig+0x22>
    953c:	4b4f      	ldr	r3, [pc, #316]	; (967c <EDMA_PrepareTransferConfig+0x154>)
    953e:	4a50      	ldr	r2, [pc, #320]	; (9680 <EDMA_PrepareTransferConfig+0x158>)
    9540:	f240 31d7 	movw	r1, #983	; 0x3d7
    9544:	484f      	ldr	r0, [pc, #316]	; (9684 <EDMA_PrepareTransferConfig+0x15c>)
    9546:	f7fd fe49 	bl	71dc <__assert_func>
    assert(srcAddr != NULL);
    954a:	68bb      	ldr	r3, [r7, #8]
    954c:	2b00      	cmp	r3, #0
    954e:	d106      	bne.n	955e <EDMA_PrepareTransferConfig+0x36>
    9550:	4b4d      	ldr	r3, [pc, #308]	; (9688 <EDMA_PrepareTransferConfig+0x160>)
    9552:	4a4b      	ldr	r2, [pc, #300]	; (9680 <EDMA_PrepareTransferConfig+0x158>)
    9554:	f44f 7176 	mov.w	r1, #984	; 0x3d8
    9558:	484a      	ldr	r0, [pc, #296]	; (9684 <EDMA_PrepareTransferConfig+0x15c>)
    955a:	f7fd fe3f 	bl	71dc <__assert_func>
    assert(destAddr != NULL);
    955e:	69bb      	ldr	r3, [r7, #24]
    9560:	2b00      	cmp	r3, #0
    9562:	d106      	bne.n	9572 <EDMA_PrepareTransferConfig+0x4a>
    9564:	4b49      	ldr	r3, [pc, #292]	; (968c <EDMA_PrepareTransferConfig+0x164>)
    9566:	4a46      	ldr	r2, [pc, #280]	; (9680 <EDMA_PrepareTransferConfig+0x158>)
    9568:	f240 31d9 	movw	r1, #985	; 0x3d9
    956c:	4845      	ldr	r0, [pc, #276]	; (9684 <EDMA_PrepareTransferConfig+0x15c>)
    956e:	f7fd fe35 	bl	71dc <__assert_func>
    assert((srcWidth != 0U) && (srcWidth <= 32U) && ((srcWidth & (srcWidth - 1U)) == 0U));
    9572:	687b      	ldr	r3, [r7, #4]
    9574:	2b00      	cmp	r3, #0
    9576:	d008      	beq.n	958a <EDMA_PrepareTransferConfig+0x62>
    9578:	687b      	ldr	r3, [r7, #4]
    957a:	2b20      	cmp	r3, #32
    957c:	d805      	bhi.n	958a <EDMA_PrepareTransferConfig+0x62>
    957e:	687b      	ldr	r3, [r7, #4]
    9580:	1e5a      	subs	r2, r3, #1
    9582:	687b      	ldr	r3, [r7, #4]
    9584:	4013      	ands	r3, r2
    9586:	2b00      	cmp	r3, #0
    9588:	d006      	beq.n	9598 <EDMA_PrepareTransferConfig+0x70>
    958a:	4b41      	ldr	r3, [pc, #260]	; (9690 <EDMA_PrepareTransferConfig+0x168>)
    958c:	4a3c      	ldr	r2, [pc, #240]	; (9680 <EDMA_PrepareTransferConfig+0x158>)
    958e:	f240 31da 	movw	r1, #986	; 0x3da
    9592:	483c      	ldr	r0, [pc, #240]	; (9684 <EDMA_PrepareTransferConfig+0x15c>)
    9594:	f7fd fe22 	bl	71dc <__assert_func>
    assert((destWidth != 0U) && (destWidth <= 32U) && ((destWidth & (destWidth - 1U)) == 0U));
    9598:	69fb      	ldr	r3, [r7, #28]
    959a:	2b00      	cmp	r3, #0
    959c:	d008      	beq.n	95b0 <EDMA_PrepareTransferConfig+0x88>
    959e:	69fb      	ldr	r3, [r7, #28]
    95a0:	2b20      	cmp	r3, #32
    95a2:	d805      	bhi.n	95b0 <EDMA_PrepareTransferConfig+0x88>
    95a4:	69fb      	ldr	r3, [r7, #28]
    95a6:	1e5a      	subs	r2, r3, #1
    95a8:	69fb      	ldr	r3, [r7, #28]
    95aa:	4013      	ands	r3, r2
    95ac:	2b00      	cmp	r3, #0
    95ae:	d006      	beq.n	95be <EDMA_PrepareTransferConfig+0x96>
    95b0:	4b38      	ldr	r3, [pc, #224]	; (9694 <EDMA_PrepareTransferConfig+0x16c>)
    95b2:	4a33      	ldr	r2, [pc, #204]	; (9680 <EDMA_PrepareTransferConfig+0x158>)
    95b4:	f240 31db 	movw	r1, #987	; 0x3db
    95b8:	4832      	ldr	r0, [pc, #200]	; (9684 <EDMA_PrepareTransferConfig+0x15c>)
    95ba:	f7fd fe0f 	bl	71dc <__assert_func>
    assert((transferBytes % bytesEachRequest) == 0U);
    95be:	6abb      	ldr	r3, [r7, #40]	; 0x28
    95c0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    95c2:	fbb3 f2f2 	udiv	r2, r3, r2
    95c6:	6a79      	ldr	r1, [r7, #36]	; 0x24
    95c8:	fb01 f202 	mul.w	r2, r1, r2
    95cc:	1a9b      	subs	r3, r3, r2
    95ce:	2b00      	cmp	r3, #0
    95d0:	d006      	beq.n	95e0 <EDMA_PrepareTransferConfig+0xb8>
    95d2:	4b31      	ldr	r3, [pc, #196]	; (9698 <EDMA_PrepareTransferConfig+0x170>)
    95d4:	4a2a      	ldr	r2, [pc, #168]	; (9680 <EDMA_PrepareTransferConfig+0x158>)
    95d6:	f44f 7177 	mov.w	r1, #988	; 0x3dc
    95da:	482a      	ldr	r0, [pc, #168]	; (9684 <EDMA_PrepareTransferConfig+0x15c>)
    95dc:	f7fd fdfe 	bl	71dc <__assert_func>
    assert((((uint32_t)(uint32_t *)srcAddr) % srcWidth) == 0U);
    95e0:	68bb      	ldr	r3, [r7, #8]
    95e2:	687a      	ldr	r2, [r7, #4]
    95e4:	fbb3 f2f2 	udiv	r2, r3, r2
    95e8:	6879      	ldr	r1, [r7, #4]
    95ea:	fb01 f202 	mul.w	r2, r1, r2
    95ee:	1a9b      	subs	r3, r3, r2
    95f0:	2b00      	cmp	r3, #0
    95f2:	d006      	beq.n	9602 <EDMA_PrepareTransferConfig+0xda>
    95f4:	4b29      	ldr	r3, [pc, #164]	; (969c <EDMA_PrepareTransferConfig+0x174>)
    95f6:	4a22      	ldr	r2, [pc, #136]	; (9680 <EDMA_PrepareTransferConfig+0x158>)
    95f8:	f240 31dd 	movw	r1, #989	; 0x3dd
    95fc:	4821      	ldr	r0, [pc, #132]	; (9684 <EDMA_PrepareTransferConfig+0x15c>)
    95fe:	f7fd fded 	bl	71dc <__assert_func>
    assert((((uint32_t)(uint32_t *)destAddr) % destWidth) == 0U);
    9602:	69bb      	ldr	r3, [r7, #24]
    9604:	69fa      	ldr	r2, [r7, #28]
    9606:	fbb3 f2f2 	udiv	r2, r3, r2
    960a:	69f9      	ldr	r1, [r7, #28]
    960c:	fb01 f202 	mul.w	r2, r1, r2
    9610:	1a9b      	subs	r3, r3, r2
    9612:	2b00      	cmp	r3, #0
    9614:	d006      	beq.n	9624 <EDMA_PrepareTransferConfig+0xfc>
    9616:	4b22      	ldr	r3, [pc, #136]	; (96a0 <EDMA_PrepareTransferConfig+0x178>)
    9618:	4a19      	ldr	r2, [pc, #100]	; (9680 <EDMA_PrepareTransferConfig+0x158>)
    961a:	f240 31de 	movw	r1, #990	; 0x3de
    961e:	4819      	ldr	r0, [pc, #100]	; (9684 <EDMA_PrepareTransferConfig+0x15c>)
    9620:	f7fd fddc 	bl	71dc <__assert_func>

    /* Initializes the configure structure to zero. */
    (void)memset(config, 0, sizeof(*config));
    9624:	2218      	movs	r2, #24
    9626:	2100      	movs	r1, #0
    9628:	68f8      	ldr	r0, [r7, #12]
    962a:	f004 fed5 	bl	e3d8 <memset>

    config->destAddr         = (uint32_t)(uint32_t *)destAddr;
    962e:	69ba      	ldr	r2, [r7, #24]
    9630:	68fb      	ldr	r3, [r7, #12]
    9632:	605a      	str	r2, [r3, #4]
    config->srcAddr          = (uint32_t)(uint32_t *)srcAddr;
    9634:	68ba      	ldr	r2, [r7, #8]
    9636:	68fb      	ldr	r3, [r7, #12]
    9638:	601a      	str	r2, [r3, #0]
    config->minorLoopBytes   = bytesEachRequest;
    963a:	68fb      	ldr	r3, [r7, #12]
    963c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    963e:	611a      	str	r2, [r3, #16]
    config->majorLoopCounts  = transferBytes / bytesEachRequest;
    9640:	6aba      	ldr	r2, [r7, #40]	; 0x28
    9642:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    9644:	fbb2 f2f3 	udiv	r2, r2, r3
    9648:	68fb      	ldr	r3, [r7, #12]
    964a:	615a      	str	r2, [r3, #20]
    config->srcTransferSize  = EDMA_TransferWidthMapping(srcWidth);
    964c:	6878      	ldr	r0, [r7, #4]
    964e:	f7ff fefb 	bl	9448 <EDMA_TransferWidthMapping>
    9652:	4603      	mov	r3, r0
    9654:	461a      	mov	r2, r3
    9656:	68fb      	ldr	r3, [r7, #12]
    9658:	721a      	strb	r2, [r3, #8]
    config->destTransferSize = EDMA_TransferWidthMapping(destWidth);
    965a:	69f8      	ldr	r0, [r7, #28]
    965c:	f7ff fef4 	bl	9448 <EDMA_TransferWidthMapping>
    9660:	4603      	mov	r3, r0
    9662:	461a      	mov	r2, r3
    9664:	68fb      	ldr	r3, [r7, #12]
    9666:	725a      	strb	r2, [r3, #9]
    config->destOffset       = destOffset;
    9668:	68fb      	ldr	r3, [r7, #12]
    966a:	8c3a      	ldrh	r2, [r7, #32]
    966c:	819a      	strh	r2, [r3, #12]
    config->srcOffset        = srcOffset;
    966e:	68fb      	ldr	r3, [r7, #12]
    9670:	887a      	ldrh	r2, [r7, #2]
    9672:	815a      	strh	r2, [r3, #10]
}
    9674:	bf00      	nop
    9676:	3710      	adds	r7, #16
    9678:	46bd      	mov	sp, r7
    967a:	bd80      	pop	{r7, pc}
    967c:	0000fb8c 	.word	0x0000fb8c
    9680:	0000ff6c 	.word	0x0000ff6c
    9684:	0000fad4 	.word	0x0000fad4
    9688:	0000fce8 	.word	0x0000fce8
    968c:	0000fcf8 	.word	0x0000fcf8
    9690:	0000fd0c 	.word	0x0000fd0c
    9694:	0000fd5c 	.word	0x0000fd5c
    9698:	0000fdb0 	.word	0x0000fdb0
    969c:	0000fddc 	.word	0x0000fddc
    96a0:	0000fe10 	.word	0x0000fe10

000096a4 <EDMA_PrepareTransfer>:
                          void *destAddr,
                          uint32_t destWidth,
                          uint32_t bytesEachRequest,
                          uint32_t transferBytes,
                          edma_transfer_type_t type)
{
    96a4:	b580      	push	{r7, lr}
    96a6:	b08c      	sub	sp, #48	; 0x30
    96a8:	af06      	add	r7, sp, #24
    96aa:	60f8      	str	r0, [r7, #12]
    96ac:	60b9      	str	r1, [r7, #8]
    96ae:	607a      	str	r2, [r7, #4]
    96b0:	603b      	str	r3, [r7, #0]
    assert(config != NULL);
    96b2:	68fb      	ldr	r3, [r7, #12]
    96b4:	2b00      	cmp	r3, #0
    96b6:	d106      	bne.n	96c6 <EDMA_PrepareTransfer+0x22>
    96b8:	4b25      	ldr	r3, [pc, #148]	; (9750 <EDMA_PrepareTransfer+0xac>)
    96ba:	4a26      	ldr	r2, [pc, #152]	; (9754 <EDMA_PrepareTransfer+0xb0>)
    96bc:	f240 4107 	movw	r1, #1031	; 0x407
    96c0:	4825      	ldr	r0, [pc, #148]	; (9758 <EDMA_PrepareTransfer+0xb4>)
    96c2:	f7fd fd8b 	bl	71dc <__assert_func>

    int16_t srcOffset = 0, destOffset = 0;
    96c6:	2300      	movs	r3, #0
    96c8:	82fb      	strh	r3, [r7, #22]
    96ca:	2300      	movs	r3, #0
    96cc:	82bb      	strh	r3, [r7, #20]

    switch (type)
    96ce:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    96d2:	2b03      	cmp	r3, #3
    96d4:	d81e      	bhi.n	9714 <EDMA_PrepareTransfer+0x70>
    96d6:	a201      	add	r2, pc, #4	; (adr r2, 96dc <EDMA_PrepareTransfer+0x38>)
    96d8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    96dc:	000096ed 	.word	0x000096ed
    96e0:	00009701 	.word	0x00009701
    96e4:	000096f7 	.word	0x000096f7
    96e8:	0000970b 	.word	0x0000970b
    {
        case kEDMA_MemoryToMemory:
            destOffset = (int16_t)destWidth;
    96ec:	6a3b      	ldr	r3, [r7, #32]
    96ee:	82bb      	strh	r3, [r7, #20]
            srcOffset  = (int16_t)srcWidth;
    96f0:	687b      	ldr	r3, [r7, #4]
    96f2:	82fb      	strh	r3, [r7, #22]
            break;
    96f4:	e015      	b.n	9722 <EDMA_PrepareTransfer+0x7e>
        case kEDMA_MemoryToPeripheral:
            destOffset = 0;
    96f6:	2300      	movs	r3, #0
    96f8:	82bb      	strh	r3, [r7, #20]
            srcOffset  = (int16_t)srcWidth;
    96fa:	687b      	ldr	r3, [r7, #4]
    96fc:	82fb      	strh	r3, [r7, #22]
            break;
    96fe:	e010      	b.n	9722 <EDMA_PrepareTransfer+0x7e>
        case kEDMA_PeripheralToMemory:
            destOffset = (int16_t)destWidth;
    9700:	6a3b      	ldr	r3, [r7, #32]
    9702:	82bb      	strh	r3, [r7, #20]
            srcOffset  = 0;
    9704:	2300      	movs	r3, #0
    9706:	82fb      	strh	r3, [r7, #22]
            break;
    9708:	e00b      	b.n	9722 <EDMA_PrepareTransfer+0x7e>
        case kEDMA_PeripheralToPeripheral:
            destOffset = 0;
    970a:	2300      	movs	r3, #0
    970c:	82bb      	strh	r3, [r7, #20]
            srcOffset  = 0;
    970e:	2300      	movs	r3, #0
    9710:	82fb      	strh	r3, [r7, #22]
            break;
    9712:	e006      	b.n	9722 <EDMA_PrepareTransfer+0x7e>
        default:
            /* All the cases have been listed above, the default clause should not be reached. */
            assert(false);
    9714:	4b11      	ldr	r3, [pc, #68]	; (975c <EDMA_PrepareTransfer+0xb8>)
    9716:	4a0f      	ldr	r2, [pc, #60]	; (9754 <EDMA_PrepareTransfer+0xb0>)
    9718:	f240 411f 	movw	r1, #1055	; 0x41f
    971c:	480e      	ldr	r0, [pc, #56]	; (9758 <EDMA_PrepareTransfer+0xb4>)
    971e:	f7fd fd5d 	bl	71dc <__assert_func>
            break;
    }

    EDMA_PrepareTransferConfig(config, srcAddr, srcWidth, srcOffset, destAddr, destWidth, destOffset, bytesEachRequest,
    9722:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
    9726:	6abb      	ldr	r3, [r7, #40]	; 0x28
    9728:	9304      	str	r3, [sp, #16]
    972a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    972c:	9303      	str	r3, [sp, #12]
    972e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
    9732:	9302      	str	r3, [sp, #8]
    9734:	6a3b      	ldr	r3, [r7, #32]
    9736:	9301      	str	r3, [sp, #4]
    9738:	683b      	ldr	r3, [r7, #0]
    973a:	9300      	str	r3, [sp, #0]
    973c:	4613      	mov	r3, r2
    973e:	687a      	ldr	r2, [r7, #4]
    9740:	68b9      	ldr	r1, [r7, #8]
    9742:	68f8      	ldr	r0, [r7, #12]
    9744:	f7ff fef0 	bl	9528 <EDMA_PrepareTransferConfig>
                               transferBytes);
}
    9748:	bf00      	nop
    974a:	3718      	adds	r7, #24
    974c:	46bd      	mov	sp, r7
    974e:	bd80      	pop	{r7, pc}
    9750:	0000fb8c 	.word	0x0000fb8c
    9754:	0000ff88 	.word	0x0000ff88
    9758:	0000fad4 	.word	0x0000fad4
    975c:	0000fce0 	.word	0x0000fce0

00009760 <EDMA_StartTransfer>:
 * or before submitting the transfer request.
 *
 * param handle eDMA handle pointer.
 */
void EDMA_StartTransfer(edma_handle_t *handle)
{
    9760:	b580      	push	{r7, lr}
    9762:	b086      	sub	sp, #24
    9764:	af00      	add	r7, sp, #0
    9766:	6078      	str	r0, [r7, #4]
    assert(handle != NULL);
    9768:	687b      	ldr	r3, [r7, #4]
    976a:	2b00      	cmp	r3, #0
    976c:	d106      	bne.n	977c <EDMA_StartTransfer+0x1c>
    976e:	4b29      	ldr	r3, [pc, #164]	; (9814 <EDMA_StartTransfer+0xb4>)
    9770:	4a29      	ldr	r2, [pc, #164]	; (9818 <EDMA_StartTransfer+0xb8>)
    9772:	f240 41d7 	movw	r1, #1239	; 0x4d7
    9776:	4829      	ldr	r0, [pc, #164]	; (981c <EDMA_StartTransfer+0xbc>)
    9778:	f7fd fd30 	bl	71dc <__assert_func>
    uint32_t tmpCSR = 0;
    977c:	2300      	movs	r3, #0
    977e:	617b      	str	r3, [r7, #20]

    if (handle->tcdPool == NULL)
    9780:	687b      	ldr	r3, [r7, #4]
    9782:	68db      	ldr	r3, [r3, #12]
    9784:	2b00      	cmp	r3, #0
    9786:	d108      	bne.n	979a <EDMA_StartTransfer+0x3a>
    {
        handle->base->SERQ = DMA_SERQ_SERQ(handle->channel);
    9788:	687b      	ldr	r3, [r7, #4]
    978a:	7c1a      	ldrb	r2, [r3, #16]
    978c:	687b      	ldr	r3, [r7, #4]
    978e:	689b      	ldr	r3, [r3, #8]
    9790:	f002 021f 	and.w	r2, r2, #31
    9794:	b2d2      	uxtb	r2, r2
    9796:	76da      	strb	r2, [r3, #27]
                }
            }
            EnableGlobalIRQ(primask);
        }
    }
}
    9798:	e038      	b.n	980c <EDMA_StartTransfer+0xac>
        edma_tcd_t *tcdRegs = (edma_tcd_t *)(uint32_t)&handle->base->TCD[handle->channel];
    979a:	687b      	ldr	r3, [r7, #4]
    979c:	689a      	ldr	r2, [r3, #8]
    979e:	687b      	ldr	r3, [r7, #4]
    97a0:	7c1b      	ldrb	r3, [r3, #16]
    97a2:	3380      	adds	r3, #128	; 0x80
    97a4:	015b      	lsls	r3, r3, #5
    97a6:	4413      	add	r3, r2
    97a8:	613b      	str	r3, [r7, #16]
        handle->flags |= EDMA_TRANSFER_ENABLED_MASK;
    97aa:	687b      	ldr	r3, [r7, #4]
    97ac:	7d5b      	ldrb	r3, [r3, #21]
    97ae:	f063 037f 	orn	r3, r3, #127	; 0x7f
    97b2:	b2da      	uxtb	r2, r3
    97b4:	687b      	ldr	r3, [r7, #4]
    97b6:	755a      	strb	r2, [r3, #21]
        if (tcdRegs->DLAST_SGA != 0U)
    97b8:	693b      	ldr	r3, [r7, #16]
    97ba:	699b      	ldr	r3, [r3, #24]
    97bc:	2b00      	cmp	r3, #0
    97be:	d025      	beq.n	980c <EDMA_StartTransfer+0xac>
            primask = DisableGlobalIRQ();
    97c0:	f7ff faf3 	bl	8daa <DisableGlobalIRQ>
    97c4:	60f8      	str	r0, [r7, #12]
            if ((handle->base->ERQ & ((uint32_t)1U << handle->channel)) == 0U)
    97c6:	687b      	ldr	r3, [r7, #4]
    97c8:	689b      	ldr	r3, [r3, #8]
    97ca:	68db      	ldr	r3, [r3, #12]
    97cc:	687a      	ldr	r2, [r7, #4]
    97ce:	7c12      	ldrb	r2, [r2, #16]
    97d0:	40d3      	lsrs	r3, r2
    97d2:	f003 0301 	and.w	r3, r3, #1
    97d6:	2b00      	cmp	r3, #0
    97d8:	d115      	bne.n	9806 <EDMA_StartTransfer+0xa6>
                tmpCSR = tcdRegs->CSR;
    97da:	693b      	ldr	r3, [r7, #16]
    97dc:	8b9b      	ldrh	r3, [r3, #28]
    97de:	b29b      	uxth	r3, r3
    97e0:	617b      	str	r3, [r7, #20]
                if ((0U == (tmpCSR & DMA_CSR_DONE_MASK)) || (0U != (tmpCSR & DMA_CSR_ESG_MASK)))
    97e2:	697b      	ldr	r3, [r7, #20]
    97e4:	f003 0380 	and.w	r3, r3, #128	; 0x80
    97e8:	2b00      	cmp	r3, #0
    97ea:	d004      	beq.n	97f6 <EDMA_StartTransfer+0x96>
    97ec:	697b      	ldr	r3, [r7, #20]
    97ee:	f003 0310 	and.w	r3, r3, #16
    97f2:	2b00      	cmp	r3, #0
    97f4:	d007      	beq.n	9806 <EDMA_StartTransfer+0xa6>
                    handle->base->SERQ = DMA_SERQ_SERQ(handle->channel);
    97f6:	687b      	ldr	r3, [r7, #4]
    97f8:	7c1a      	ldrb	r2, [r3, #16]
    97fa:	687b      	ldr	r3, [r7, #4]
    97fc:	689b      	ldr	r3, [r3, #8]
    97fe:	f002 021f 	and.w	r2, r2, #31
    9802:	b2d2      	uxtb	r2, r2
    9804:	76da      	strb	r2, [r3, #27]
            EnableGlobalIRQ(primask);
    9806:	68f8      	ldr	r0, [r7, #12]
    9808:	f7ff fae0 	bl	8dcc <EnableGlobalIRQ>
}
    980c:	bf00      	nop
    980e:	3718      	adds	r7, #24
    9810:	46bd      	mov	sp, r7
    9812:	bd80      	pop	{r7, pc}
    9814:	0000fcac 	.word	0x0000fcac
    9818:	0000ffa0 	.word	0x0000ffa0
    981c:	0000fad4 	.word	0x0000fad4

00009820 <EDMA_HandleIRQ>:
 * further details.
 *
 * param handle eDMA handle pointer.
 */
void EDMA_HandleIRQ(edma_handle_t *handle)
{
    9820:	b590      	push	{r4, r7, lr}
    9822:	b089      	sub	sp, #36	; 0x24
    9824:	af00      	add	r7, sp, #0
    9826:	6078      	str	r0, [r7, #4]
    assert(handle != NULL);
    9828:	687b      	ldr	r3, [r7, #4]
    982a:	2b00      	cmp	r3, #0
    982c:	d106      	bne.n	983c <EDMA_HandleIRQ+0x1c>
    982e:	4b5d      	ldr	r3, [pc, #372]	; (99a4 <EDMA_HandleIRQ+0x184>)
    9830:	4a5d      	ldr	r2, [pc, #372]	; (99a8 <EDMA_HandleIRQ+0x188>)
    9832:	f240 514b 	movw	r1, #1355	; 0x54b
    9836:	485d      	ldr	r0, [pc, #372]	; (99ac <EDMA_HandleIRQ+0x18c>)
    9838:	f7fd fcd0 	bl	71dc <__assert_func>

    bool transfer_done;

    /* Clear EDMA interrupt flag */
    handle->base->CINT = handle->channel;
    983c:	687b      	ldr	r3, [r7, #4]
    983e:	689b      	ldr	r3, [r3, #8]
    9840:	687a      	ldr	r2, [r7, #4]
    9842:	7c12      	ldrb	r2, [r2, #16]
    9844:	77da      	strb	r2, [r3, #31]
    /* Check if transfer is already finished. */
    transfer_done = ((handle->base->TCD[handle->channel].CSR & DMA_CSR_DONE_MASK) != 0U);
    9846:	687b      	ldr	r3, [r7, #4]
    9848:	689a      	ldr	r2, [r3, #8]
    984a:	687b      	ldr	r3, [r7, #4]
    984c:	7c1b      	ldrb	r3, [r3, #16]
    984e:	015b      	lsls	r3, r3, #5
    9850:	4413      	add	r3, r2
    9852:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    9856:	331c      	adds	r3, #28
    9858:	881b      	ldrh	r3, [r3, #0]
    985a:	b29b      	uxth	r3, r3
    985c:	f003 0380 	and.w	r3, r3, #128	; 0x80
    9860:	2b00      	cmp	r3, #0
    9862:	bf14      	ite	ne
    9864:	2301      	movne	r3, #1
    9866:	2300      	moveq	r3, #0
    9868:	76bb      	strb	r3, [r7, #26]

    if (handle->tcdPool == NULL)
    986a:	687b      	ldr	r3, [r7, #4]
    986c:	68db      	ldr	r3, [r3, #12]
    986e:	2b00      	cmp	r3, #0
    9870:	d10d      	bne.n	988e <EDMA_HandleIRQ+0x6e>
    {
        if (handle->callback != NULL)
    9872:	687b      	ldr	r3, [r7, #4]
    9874:	681b      	ldr	r3, [r3, #0]
    9876:	2b00      	cmp	r3, #0
    9878:	f000 808f 	beq.w	999a <EDMA_HandleIRQ+0x17a>
        {
            (handle->callback)(handle, handle->userData, transfer_done, 0);
    987c:	687b      	ldr	r3, [r7, #4]
    987e:	681c      	ldr	r4, [r3, #0]
    9880:	687b      	ldr	r3, [r7, #4]
    9882:	6859      	ldr	r1, [r3, #4]
    9884:	7eba      	ldrb	r2, [r7, #26]
    9886:	2300      	movs	r3, #0
    9888:	6878      	ldr	r0, [r7, #4]
    988a:	47a0      	blx	r4
            {
                handle->base->CDNE = handle->channel;
            }
        }
    }
}
    988c:	e085      	b.n	999a <EDMA_HandleIRQ+0x17a>
        uint32_t sga = handle->base->TCD[handle->channel].DLAST_SGA;
    988e:	687b      	ldr	r3, [r7, #4]
    9890:	689a      	ldr	r2, [r3, #8]
    9892:	687b      	ldr	r3, [r7, #4]
    9894:	7c1b      	ldrb	r3, [r3, #16]
    9896:	015b      	lsls	r3, r3, #5
    9898:	4413      	add	r3, r2
    989a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    989e:	3318      	adds	r3, #24
    98a0:	681b      	ldr	r3, [r3, #0]
    98a2:	617b      	str	r3, [r7, #20]
        sga -= (uint32_t)handle->tcdPool;
    98a4:	687b      	ldr	r3, [r7, #4]
    98a6:	68db      	ldr	r3, [r3, #12]
    98a8:	461a      	mov	r2, r3
    98aa:	697b      	ldr	r3, [r7, #20]
    98ac:	1a9b      	subs	r3, r3, r2
    98ae:	617b      	str	r3, [r7, #20]
        sga_index = sga / sizeof(edma_tcd_t);
    98b0:	697b      	ldr	r3, [r7, #20]
    98b2:	095b      	lsrs	r3, r3, #5
    98b4:	613b      	str	r3, [r7, #16]
        if (transfer_done)
    98b6:	7ebb      	ldrb	r3, [r7, #26]
    98b8:	2b00      	cmp	r3, #0
    98ba:	d002      	beq.n	98c2 <EDMA_HandleIRQ+0xa2>
            new_header = (uint8_t)sga_index;
    98bc:	693b      	ldr	r3, [r7, #16]
    98be:	76fb      	strb	r3, [r7, #27]
    98c0:	e00e      	b.n	98e0 <EDMA_HandleIRQ+0xc0>
            new_header = sga_index != 0U ? (uint8_t)sga_index - 1U : (uint8_t)handle->tcdSize - 1U;
    98c2:	693b      	ldr	r3, [r7, #16]
    98c4:	2b00      	cmp	r3, #0
    98c6:	d004      	beq.n	98d2 <EDMA_HandleIRQ+0xb2>
    98c8:	693b      	ldr	r3, [r7, #16]
    98ca:	b2db      	uxtb	r3, r3
    98cc:	3b01      	subs	r3, #1
    98ce:	b2db      	uxtb	r3, r3
    98d0:	e005      	b.n	98de <EDMA_HandleIRQ+0xbe>
    98d2:	687b      	ldr	r3, [r7, #4]
    98d4:	7d1b      	ldrb	r3, [r3, #20]
    98d6:	b25b      	sxtb	r3, r3
    98d8:	b2db      	uxtb	r3, r3
    98da:	3b01      	subs	r3, #1
    98dc:	b2db      	uxtb	r3, r3
    98de:	76fb      	strb	r3, [r7, #27]
        if (new_header == (uint8_t)handle->header)
    98e0:	687b      	ldr	r3, [r7, #4]
    98e2:	7c5b      	ldrb	r3, [r3, #17]
    98e4:	b25a      	sxtb	r2, r3
    98e6:	f997 301b 	ldrsb.w	r3, [r7, #27]
    98ea:	429a      	cmp	r2, r3
    98ec:	d113      	bne.n	9916 <EDMA_HandleIRQ+0xf6>
            int8_t tmpTcdUsed = handle->tcdUsed;
    98ee:	687b      	ldr	r3, [r7, #4]
    98f0:	7cdb      	ldrb	r3, [r3, #19]
    98f2:	73fb      	strb	r3, [r7, #15]
            int8_t tmpTcdSize = handle->tcdSize;
    98f4:	687b      	ldr	r3, [r7, #4]
    98f6:	7d1b      	ldrb	r3, [r3, #20]
    98f8:	73bb      	strb	r3, [r7, #14]
            if (tmpTcdUsed == tmpTcdSize)
    98fa:	f997 200f 	ldrsb.w	r2, [r7, #15]
    98fe:	f997 300e 	ldrsb.w	r3, [r7, #14]
    9902:	429a      	cmp	r2, r3
    9904:	d104      	bne.n	9910 <EDMA_HandleIRQ+0xf0>
                tcds_done = handle->tcdUsed;
    9906:	687b      	ldr	r3, [r7, #4]
    9908:	7cdb      	ldrb	r3, [r3, #19]
    990a:	b25b      	sxtb	r3, r3
    990c:	61fb      	str	r3, [r7, #28]
    990e:	e012      	b.n	9936 <EDMA_HandleIRQ+0x116>
                tcds_done = 0;
    9910:	2300      	movs	r3, #0
    9912:	61fb      	str	r3, [r7, #28]
    9914:	e00f      	b.n	9936 <EDMA_HandleIRQ+0x116>
            tcds_done = (int32_t)new_header - (int32_t)handle->header;
    9916:	7efb      	ldrb	r3, [r7, #27]
    9918:	687a      	ldr	r2, [r7, #4]
    991a:	7c52      	ldrb	r2, [r2, #17]
    991c:	b252      	sxtb	r2, r2
    991e:	1a9b      	subs	r3, r3, r2
    9920:	61fb      	str	r3, [r7, #28]
            if (tcds_done < 0)
    9922:	69fb      	ldr	r3, [r7, #28]
    9924:	2b00      	cmp	r3, #0
    9926:	da06      	bge.n	9936 <EDMA_HandleIRQ+0x116>
                tcds_done += handle->tcdSize;
    9928:	687b      	ldr	r3, [r7, #4]
    992a:	7d1b      	ldrb	r3, [r3, #20]
    992c:	b25b      	sxtb	r3, r3
    992e:	461a      	mov	r2, r3
    9930:	69fb      	ldr	r3, [r7, #28]
    9932:	4413      	add	r3, r2
    9934:	61fb      	str	r3, [r7, #28]
        handle->header = (int8_t)new_header;
    9936:	f997 201b 	ldrsb.w	r2, [r7, #27]
    993a:	687b      	ldr	r3, [r7, #4]
    993c:	745a      	strb	r2, [r3, #17]
        handle->tcdUsed -= (int8_t)tcds_done;
    993e:	687b      	ldr	r3, [r7, #4]
    9940:	7cdb      	ldrb	r3, [r3, #19]
    9942:	b25b      	sxtb	r3, r3
    9944:	b2da      	uxtb	r2, r3
    9946:	69fb      	ldr	r3, [r7, #28]
    9948:	b2db      	uxtb	r3, r3
    994a:	1ad3      	subs	r3, r2, r3
    994c:	b2db      	uxtb	r3, r3
    994e:	b25a      	sxtb	r2, r3
    9950:	687b      	ldr	r3, [r7, #4]
    9952:	74da      	strb	r2, [r3, #19]
        if (NULL != handle->callback)
    9954:	687b      	ldr	r3, [r7, #4]
    9956:	681b      	ldr	r3, [r3, #0]
    9958:	2b00      	cmp	r3, #0
    995a:	d007      	beq.n	996c <EDMA_HandleIRQ+0x14c>
            (handle->callback)(handle, handle->userData, transfer_done, tcds_done);
    995c:	687b      	ldr	r3, [r7, #4]
    995e:	681c      	ldr	r4, [r3, #0]
    9960:	687b      	ldr	r3, [r7, #4]
    9962:	6859      	ldr	r1, [r3, #4]
    9964:	69fb      	ldr	r3, [r7, #28]
    9966:	7eba      	ldrb	r2, [r7, #26]
    9968:	6878      	ldr	r0, [r7, #4]
    996a:	47a0      	blx	r4
        if (transfer_done)
    996c:	7ebb      	ldrb	r3, [r7, #26]
    996e:	2b00      	cmp	r3, #0
    9970:	d013      	beq.n	999a <EDMA_HandleIRQ+0x17a>
            if ((handle->base->TCD[handle->channel].CSR & DMA_CSR_ESG_MASK) != 0U)
    9972:	687b      	ldr	r3, [r7, #4]
    9974:	689a      	ldr	r2, [r3, #8]
    9976:	687b      	ldr	r3, [r7, #4]
    9978:	7c1b      	ldrb	r3, [r3, #16]
    997a:	015b      	lsls	r3, r3, #5
    997c:	4413      	add	r3, r2
    997e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    9982:	331c      	adds	r3, #28
    9984:	881b      	ldrh	r3, [r3, #0]
    9986:	b29b      	uxth	r3, r3
    9988:	f003 0310 	and.w	r3, r3, #16
    998c:	2b00      	cmp	r3, #0
    998e:	d004      	beq.n	999a <EDMA_HandleIRQ+0x17a>
                handle->base->CDNE = handle->channel;
    9990:	687b      	ldr	r3, [r7, #4]
    9992:	689b      	ldr	r3, [r3, #8]
    9994:	687a      	ldr	r2, [r7, #4]
    9996:	7c12      	ldrb	r2, [r2, #16]
    9998:	771a      	strb	r2, [r3, #28]
}
    999a:	bf00      	nop
    999c:	3724      	adds	r7, #36	; 0x24
    999e:	46bd      	mov	sp, r7
    99a0:	bd90      	pop	{r4, r7, pc}
    99a2:	bf00      	nop
    99a4:	0000fcac 	.word	0x0000fcac
    99a8:	0000ffb4 	.word	0x0000ffb4
    99ac:	0000fad4 	.word	0x0000fad4

000099b0 <DMA0_DMA16_DriverIRQHandler>:
/* 32 channels (Shared): k80 */
#if defined(FSL_FEATURE_EDMA_MODULE_CHANNEL) && FSL_FEATURE_EDMA_MODULE_CHANNEL == 32U
#if defined(DMA0)
void DMA0_DMA16_DriverIRQHandler(void);
void DMA0_DMA16_DriverIRQHandler(void)
{
    99b0:	b580      	push	{r7, lr}
    99b2:	af00      	add	r7, sp, #0
    if ((EDMA_GetChannelStatusFlags(DMA0, 0U) & (uint32_t)kEDMA_InterruptFlag) != 0U)
    99b4:	2100      	movs	r1, #0
    99b6:	4810      	ldr	r0, [pc, #64]	; (99f8 <DMA0_DMA16_DriverIRQHandler+0x48>)
    99b8:	f7ff fc06 	bl	91c8 <EDMA_GetChannelStatusFlags>
    99bc:	4603      	mov	r3, r0
    99be:	f003 0304 	and.w	r3, r3, #4
    99c2:	2b00      	cmp	r3, #0
    99c4:	d004      	beq.n	99d0 <DMA0_DMA16_DriverIRQHandler+0x20>
    {
        EDMA_HandleIRQ(s_EDMAHandle[0]);
    99c6:	4b0d      	ldr	r3, [pc, #52]	; (99fc <DMA0_DMA16_DriverIRQHandler+0x4c>)
    99c8:	681b      	ldr	r3, [r3, #0]
    99ca:	4618      	mov	r0, r3
    99cc:	f7ff ff28 	bl	9820 <EDMA_HandleIRQ>
    }
    if ((EDMA_GetChannelStatusFlags(DMA0, 16U) & (uint32_t)kEDMA_InterruptFlag) != 0U)
    99d0:	2110      	movs	r1, #16
    99d2:	4809      	ldr	r0, [pc, #36]	; (99f8 <DMA0_DMA16_DriverIRQHandler+0x48>)
    99d4:	f7ff fbf8 	bl	91c8 <EDMA_GetChannelStatusFlags>
    99d8:	4603      	mov	r3, r0
    99da:	f003 0304 	and.w	r3, r3, #4
    99de:	2b00      	cmp	r3, #0
    99e0:	d004      	beq.n	99ec <DMA0_DMA16_DriverIRQHandler+0x3c>
    {
        EDMA_HandleIRQ(s_EDMAHandle[16]);
    99e2:	4b06      	ldr	r3, [pc, #24]	; (99fc <DMA0_DMA16_DriverIRQHandler+0x4c>)
    99e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    99e6:	4618      	mov	r0, r3
    99e8:	f7ff ff1a 	bl	9820 <EDMA_HandleIRQ>
  __ASM volatile ("dsb 0xF":::"memory");
    99ec:	f3bf 8f4f 	dsb	sy
}
    99f0:	bf00      	nop
    }
    SDK_ISR_EXIT_BARRIER;
}
    99f2:	bf00      	nop
    99f4:	bd80      	pop	{r7, pc}
    99f6:	bf00      	nop
    99f8:	40008000 	.word	0x40008000
    99fc:	1fff143c 	.word	0x1fff143c

00009a00 <CLOCK_EnableClock>:
{
    9a00:	b480      	push	{r7}
    9a02:	b085      	sub	sp, #20
    9a04:	af00      	add	r7, sp, #0
    9a06:	6078      	str	r0, [r7, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    9a08:	687b      	ldr	r3, [r7, #4]
    9a0a:	0c1b      	lsrs	r3, r3, #16
    9a0c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    9a10:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    9a14:	60fb      	str	r3, [r7, #12]
    (*(volatile uint32_t *)regAddr) |= (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
    9a16:	68fb      	ldr	r3, [r7, #12]
    9a18:	6819      	ldr	r1, [r3, #0]
    9a1a:	687b      	ldr	r3, [r7, #4]
    9a1c:	b29b      	uxth	r3, r3
    9a1e:	2201      	movs	r2, #1
    9a20:	409a      	lsls	r2, r3
    9a22:	68fb      	ldr	r3, [r7, #12]
    9a24:	430a      	orrs	r2, r1
    9a26:	601a      	str	r2, [r3, #0]
}
    9a28:	bf00      	nop
    9a2a:	3714      	adds	r7, #20
    9a2c:	46bd      	mov	sp, r7
    9a2e:	f85d 7b04 	ldr.w	r7, [sp], #4
    9a32:	4770      	bx	lr

00009a34 <PDB_Enable>:
{
    9a34:	b480      	push	{r7}
    9a36:	b083      	sub	sp, #12
    9a38:	af00      	add	r7, sp, #0
    9a3a:	6078      	str	r0, [r7, #4]
    9a3c:	460b      	mov	r3, r1
    9a3e:	70fb      	strb	r3, [r7, #3]
    if (enable)
    9a40:	78fb      	ldrb	r3, [r7, #3]
    9a42:	2b00      	cmp	r3, #0
    9a44:	d006      	beq.n	9a54 <PDB_Enable+0x20>
        base->SC |= PDB_SC_PDBEN_MASK;
    9a46:	687b      	ldr	r3, [r7, #4]
    9a48:	681b      	ldr	r3, [r3, #0]
    9a4a:	f043 0280 	orr.w	r2, r3, #128	; 0x80
    9a4e:	687b      	ldr	r3, [r7, #4]
    9a50:	601a      	str	r2, [r3, #0]
}
    9a52:	e005      	b.n	9a60 <PDB_Enable+0x2c>
        base->SC &= ~PDB_SC_PDBEN_MASK;
    9a54:	687b      	ldr	r3, [r7, #4]
    9a56:	681b      	ldr	r3, [r3, #0]
    9a58:	f023 0280 	bic.w	r2, r3, #128	; 0x80
    9a5c:	687b      	ldr	r3, [r7, #4]
    9a5e:	601a      	str	r2, [r3, #0]
}
    9a60:	bf00      	nop
    9a62:	370c      	adds	r7, #12
    9a64:	46bd      	mov	sp, r7
    9a66:	f85d 7b04 	ldr.w	r7, [sp], #4
    9a6a:	4770      	bx	lr

00009a6c <PDB_GetInstance>:

/*******************************************************************************
 * Codes
 ******************************************************************************/
static uint32_t PDB_GetInstance(PDB_Type *base)
{
    9a6c:	b580      	push	{r7, lr}
    9a6e:	b084      	sub	sp, #16
    9a70:	af00      	add	r7, sp, #0
    9a72:	6078      	str	r0, [r7, #4]
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < ARRAY_SIZE(s_pdbBases); instance++)
    9a74:	2300      	movs	r3, #0
    9a76:	60fb      	str	r3, [r7, #12]
    9a78:	e006      	b.n	9a88 <PDB_GetInstance+0x1c>
    {
        if (s_pdbBases[instance] == base)
    9a7a:	4a0d      	ldr	r2, [pc, #52]	; (9ab0 <PDB_GetInstance+0x44>)
    9a7c:	687b      	ldr	r3, [r7, #4]
    9a7e:	4293      	cmp	r3, r2
    9a80:	d006      	beq.n	9a90 <PDB_GetInstance+0x24>
    for (instance = 0; instance < ARRAY_SIZE(s_pdbBases); instance++)
    9a82:	68fb      	ldr	r3, [r7, #12]
    9a84:	3301      	adds	r3, #1
    9a86:	60fb      	str	r3, [r7, #12]
    9a88:	68fb      	ldr	r3, [r7, #12]
    9a8a:	2b00      	cmp	r3, #0
    9a8c:	d0f5      	beq.n	9a7a <PDB_GetInstance+0xe>
    9a8e:	e000      	b.n	9a92 <PDB_GetInstance+0x26>
        {
            break;
    9a90:	bf00      	nop
        }
    }

    assert(instance < ARRAY_SIZE(s_pdbBases));
    9a92:	68fb      	ldr	r3, [r7, #12]
    9a94:	2b00      	cmp	r3, #0
    9a96:	d005      	beq.n	9aa4 <PDB_GetInstance+0x38>
    9a98:	4b06      	ldr	r3, [pc, #24]	; (9ab4 <PDB_GetInstance+0x48>)
    9a9a:	4a07      	ldr	r2, [pc, #28]	; (9ab8 <PDB_GetInstance+0x4c>)
    9a9c:	2134      	movs	r1, #52	; 0x34
    9a9e:	4807      	ldr	r0, [pc, #28]	; (9abc <PDB_GetInstance+0x50>)
    9aa0:	f7fd fb9c 	bl	71dc <__assert_func>

    return instance;
    9aa4:	68fb      	ldr	r3, [r7, #12]
}
    9aa6:	4618      	mov	r0, r3
    9aa8:	3710      	adds	r7, #16
    9aaa:	46bd      	mov	sp, r7
    9aac:	bd80      	pop	{r7, pc}
    9aae:	bf00      	nop
    9ab0:	40036000 	.word	0x40036000
    9ab4:	0000ffc4 	.word	0x0000ffc4
    9ab8:	00010098 	.word	0x00010098
    9abc:	0000ffe8 	.word	0x0000ffe8

00009ac0 <PDB_Init>:
 *
 * param base PDB peripheral base address.
 * param config Pointer to the configuration structure. See "pdb_config_t".
 */
void PDB_Init(PDB_Type *base, const pdb_config_t *config)
{
    9ac0:	b580      	push	{r7, lr}
    9ac2:	b084      	sub	sp, #16
    9ac4:	af00      	add	r7, sp, #0
    9ac6:	6078      	str	r0, [r7, #4]
    9ac8:	6039      	str	r1, [r7, #0]
    assert(NULL != config);
    9aca:	683b      	ldr	r3, [r7, #0]
    9acc:	2b00      	cmp	r3, #0
    9ace:	d105      	bne.n	9adc <PDB_Init+0x1c>
    9ad0:	4b1f      	ldr	r3, [pc, #124]	; (9b50 <PDB_Init+0x90>)
    9ad2:	4a20      	ldr	r2, [pc, #128]	; (9b54 <PDB_Init+0x94>)
    9ad4:	2146      	movs	r1, #70	; 0x46
    9ad6:	4820      	ldr	r0, [pc, #128]	; (9b58 <PDB_Init+0x98>)
    9ad8:	f7fd fb80 	bl	71dc <__assert_func>

    uint32_t tmp32;

#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    /* Enable the clock. */
    CLOCK_EnableClock(s_pdbClocks[PDB_GetInstance(base)]);
    9adc:	6878      	ldr	r0, [r7, #4]
    9ade:	f7ff ffc5 	bl	9a6c <PDB_GetInstance>
    9ae2:	4b1e      	ldr	r3, [pc, #120]	; (9b5c <PDB_Init+0x9c>)
    9ae4:	4618      	mov	r0, r3
    9ae6:	f7ff ff8b 	bl	9a00 <CLOCK_EnableClock>
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

    /* Configure. */
    /* PDBx_SC. */
    tmp32 = base->SC &
    9aea:	687b      	ldr	r3, [r7, #4]
    9aec:	681a      	ldr	r2, [r3, #0]
    9aee:	4b1c      	ldr	r3, [pc, #112]	; (9b60 <PDB_Init+0xa0>)
    9af0:	4013      	ands	r3, r2
    9af2:	60fb      	str	r3, [r7, #12]
            ~(PDB_SC_LDMOD_MASK | PDB_SC_PRESCALER_MASK | PDB_SC_TRGSEL_MASK | PDB_SC_MULT_MASK | PDB_SC_CONT_MASK);

    tmp32 |= PDB_SC_LDMOD(config->loadValueMode) | PDB_SC_PRESCALER(config->prescalerDivider) |
    9af4:	683b      	ldr	r3, [r7, #0]
    9af6:	781b      	ldrb	r3, [r3, #0]
    9af8:	049b      	lsls	r3, r3, #18
    9afa:	f403 2240 	and.w	r2, r3, #786432	; 0xc0000
    9afe:	683b      	ldr	r3, [r7, #0]
    9b00:	785b      	ldrb	r3, [r3, #1]
    9b02:	031b      	lsls	r3, r3, #12
    9b04:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
    9b08:	431a      	orrs	r2, r3
             PDB_SC_TRGSEL(config->triggerInputSource) | PDB_SC_MULT(config->dividerMultiplicationFactor);
    9b0a:	683b      	ldr	r3, [r7, #0]
    9b0c:	78db      	ldrb	r3, [r3, #3]
    9b0e:	021b      	lsls	r3, r3, #8
    9b10:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
    tmp32 |= PDB_SC_LDMOD(config->loadValueMode) | PDB_SC_PRESCALER(config->prescalerDivider) |
    9b14:	431a      	orrs	r2, r3
             PDB_SC_TRGSEL(config->triggerInputSource) | PDB_SC_MULT(config->dividerMultiplicationFactor);
    9b16:	683b      	ldr	r3, [r7, #0]
    9b18:	789b      	ldrb	r3, [r3, #2]
    9b1a:	009b      	lsls	r3, r3, #2
    9b1c:	f003 030c 	and.w	r3, r3, #12
    9b20:	4313      	orrs	r3, r2
    tmp32 |= PDB_SC_LDMOD(config->loadValueMode) | PDB_SC_PRESCALER(config->prescalerDivider) |
    9b22:	68fa      	ldr	r2, [r7, #12]
    9b24:	4313      	orrs	r3, r2
    9b26:	60fb      	str	r3, [r7, #12]
    if (config->enableContinuousMode)
    9b28:	683b      	ldr	r3, [r7, #0]
    9b2a:	791b      	ldrb	r3, [r3, #4]
    9b2c:	2b00      	cmp	r3, #0
    9b2e:	d003      	beq.n	9b38 <PDB_Init+0x78>
    {
        tmp32 |= PDB_SC_CONT_MASK;
    9b30:	68fb      	ldr	r3, [r7, #12]
    9b32:	f043 0302 	orr.w	r3, r3, #2
    9b36:	60fb      	str	r3, [r7, #12]
    }
    base->SC = tmp32;
    9b38:	687b      	ldr	r3, [r7, #4]
    9b3a:	68fa      	ldr	r2, [r7, #12]
    9b3c:	601a      	str	r2, [r3, #0]

    PDB_Enable(base, true); /* Enable the PDB module. */
    9b3e:	2101      	movs	r1, #1
    9b40:	6878      	ldr	r0, [r7, #4]
    9b42:	f7ff ff77 	bl	9a34 <PDB_Enable>
}
    9b46:	bf00      	nop
    9b48:	3710      	adds	r7, #16
    9b4a:	46bd      	mov	sp, r7
    9b4c:	bd80      	pop	{r7, pc}
    9b4e:	bf00      	nop
    9b50:	00010040 	.word	0x00010040
    9b54:	000100a8 	.word	0x000100a8
    9b58:	0000ffe8 	.word	0x0000ffe8
    9b5c:	103c0016 	.word	0x103c0016
    9b60:	fff380f1 	.word	0xfff380f1

00009b64 <PDB_SetDACTriggerConfig>:
 * param base    PDB peripheral base address.
 * param channel Channel index for DAC instance.
 * param config  Pointer to the configuration structure. See "pdb_dac_trigger_config_t".
 */
void PDB_SetDACTriggerConfig(PDB_Type *base, pdb_dac_trigger_channel_t channel, pdb_dac_trigger_config_t *config)
{
    9b64:	b580      	push	{r7, lr}
    9b66:	b086      	sub	sp, #24
    9b68:	af00      	add	r7, sp, #0
    9b6a:	60f8      	str	r0, [r7, #12]
    9b6c:	460b      	mov	r3, r1
    9b6e:	607a      	str	r2, [r7, #4]
    9b70:	72fb      	strb	r3, [r7, #11]
    assert((uint8_t)channel < (uint8_t)FSL_FEATURE_PDB_DAC_INTERVAL_TRIGGER_COUNT);
    9b72:	7afb      	ldrb	r3, [r7, #11]
    9b74:	2b01      	cmp	r3, #1
    9b76:	d905      	bls.n	9b84 <PDB_SetDACTriggerConfig+0x20>
    9b78:	4b15      	ldr	r3, [pc, #84]	; (9bd0 <PDB_SetDACTriggerConfig+0x6c>)
    9b7a:	4a16      	ldr	r2, [pc, #88]	; (9bd4 <PDB_SetDACTriggerConfig+0x70>)
    9b7c:	2193      	movs	r1, #147	; 0x93
    9b7e:	4816      	ldr	r0, [pc, #88]	; (9bd8 <PDB_SetDACTriggerConfig+0x74>)
    9b80:	f7fd fb2c 	bl	71dc <__assert_func>
    assert(NULL != config);
    9b84:	687b      	ldr	r3, [r7, #4]
    9b86:	2b00      	cmp	r3, #0
    9b88:	d105      	bne.n	9b96 <PDB_SetDACTriggerConfig+0x32>
    9b8a:	4b14      	ldr	r3, [pc, #80]	; (9bdc <PDB_SetDACTriggerConfig+0x78>)
    9b8c:	4a11      	ldr	r2, [pc, #68]	; (9bd4 <PDB_SetDACTriggerConfig+0x70>)
    9b8e:	2194      	movs	r1, #148	; 0x94
    9b90:	4811      	ldr	r0, [pc, #68]	; (9bd8 <PDB_SetDACTriggerConfig+0x74>)
    9b92:	f7fd fb23 	bl	71dc <__assert_func>

    uint32_t tmp32 = 0U;
    9b96:	2300      	movs	r3, #0
    9b98:	617b      	str	r3, [r7, #20]

    /* PDBx_DACINTC. */
    if (config->enableExternalTriggerInput)
    9b9a:	687b      	ldr	r3, [r7, #4]
    9b9c:	781b      	ldrb	r3, [r3, #0]
    9b9e:	2b00      	cmp	r3, #0
    9ba0:	d003      	beq.n	9baa <PDB_SetDACTriggerConfig+0x46>
    {
        tmp32 |= PDB_INTC_EXT_MASK;
    9ba2:	697b      	ldr	r3, [r7, #20]
    9ba4:	f043 0302 	orr.w	r3, r3, #2
    9ba8:	617b      	str	r3, [r7, #20]
    }
    if (config->enableIntervalTrigger)
    9baa:	687b      	ldr	r3, [r7, #4]
    9bac:	785b      	ldrb	r3, [r3, #1]
    9bae:	2b00      	cmp	r3, #0
    9bb0:	d003      	beq.n	9bba <PDB_SetDACTriggerConfig+0x56>
    {
        tmp32 |= PDB_INTC_TOE_MASK;
    9bb2:	697b      	ldr	r3, [r7, #20]
    9bb4:	f043 0301 	orr.w	r3, r3, #1
    9bb8:	617b      	str	r3, [r7, #20]
    }
    base->DAC[channel].INTC = tmp32;
    9bba:	7afa      	ldrb	r2, [r7, #11]
    9bbc:	68fb      	ldr	r3, [r7, #12]
    9bbe:	322a      	adds	r2, #42	; 0x2a
    9bc0:	6979      	ldr	r1, [r7, #20]
    9bc2:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
}
    9bc6:	bf00      	nop
    9bc8:	3718      	adds	r7, #24
    9bca:	46bd      	mov	sp, r7
    9bcc:	bd80      	pop	{r7, pc}
    9bce:	bf00      	nop
    9bd0:	00010050 	.word	0x00010050
    9bd4:	000100b4 	.word	0x000100b4
    9bd8:	0000ffe8 	.word	0x0000ffe8
    9bdc:	00010040 	.word	0x00010040

00009be0 <CLOCK_EnableClock>:
{
    9be0:	b480      	push	{r7}
    9be2:	b085      	sub	sp, #20
    9be4:	af00      	add	r7, sp, #0
    9be6:	6078      	str	r0, [r7, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    9be8:	687b      	ldr	r3, [r7, #4]
    9bea:	0c1b      	lsrs	r3, r3, #16
    9bec:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    9bf0:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    9bf4:	60fb      	str	r3, [r7, #12]
    (*(volatile uint32_t *)regAddr) |= (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
    9bf6:	68fb      	ldr	r3, [r7, #12]
    9bf8:	6819      	ldr	r1, [r3, #0]
    9bfa:	687b      	ldr	r3, [r7, #4]
    9bfc:	b29b      	uxth	r3, r3
    9bfe:	2201      	movs	r2, #1
    9c00:	409a      	lsls	r2, r3
    9c02:	68fb      	ldr	r3, [r7, #12]
    9c04:	430a      	orrs	r2, r1
    9c06:	601a      	str	r2, [r3, #0]
}
    9c08:	bf00      	nop
    9c0a:	3714      	adds	r7, #20
    9c0c:	46bd      	mov	sp, r7
    9c0e:	f85d 7b04 	ldr.w	r7, [sp], #4
    9c12:	4770      	bx	lr

00009c14 <DAC_GetInstance>:

/*******************************************************************************
 * Codes
 ******************************************************************************/
static uint32_t DAC_GetInstance(DAC_Type *base)
{
    9c14:	b580      	push	{r7, lr}
    9c16:	b084      	sub	sp, #16
    9c18:	af00      	add	r7, sp, #0
    9c1a:	6078      	str	r0, [r7, #4]
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < ARRAY_SIZE(s_dacBases); instance++)
    9c1c:	2300      	movs	r3, #0
    9c1e:	60fb      	str	r3, [r7, #12]
    9c20:	e009      	b.n	9c36 <DAC_GetInstance+0x22>
    {
        if (s_dacBases[instance] == base)
    9c22:	4a0e      	ldr	r2, [pc, #56]	; (9c5c <DAC_GetInstance+0x48>)
    9c24:	68fb      	ldr	r3, [r7, #12]
    9c26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c2a:	687a      	ldr	r2, [r7, #4]
    9c2c:	429a      	cmp	r2, r3
    9c2e:	d006      	beq.n	9c3e <DAC_GetInstance+0x2a>
    for (instance = 0; instance < ARRAY_SIZE(s_dacBases); instance++)
    9c30:	68fb      	ldr	r3, [r7, #12]
    9c32:	3301      	adds	r3, #1
    9c34:	60fb      	str	r3, [r7, #12]
    9c36:	68fb      	ldr	r3, [r7, #12]
    9c38:	2b01      	cmp	r3, #1
    9c3a:	d9f2      	bls.n	9c22 <DAC_GetInstance+0xe>
    9c3c:	e000      	b.n	9c40 <DAC_GetInstance+0x2c>
        {
            break;
    9c3e:	bf00      	nop
        }
    }

    assert(instance < ARRAY_SIZE(s_dacBases));
    9c40:	68fb      	ldr	r3, [r7, #12]
    9c42:	2b01      	cmp	r3, #1
    9c44:	d905      	bls.n	9c52 <DAC_GetInstance+0x3e>
    9c46:	4b06      	ldr	r3, [pc, #24]	; (9c60 <DAC_GetInstance+0x4c>)
    9c48:	4a06      	ldr	r2, [pc, #24]	; (9c64 <DAC_GetInstance+0x50>)
    9c4a:	2134      	movs	r1, #52	; 0x34
    9c4c:	4806      	ldr	r0, [pc, #24]	; (9c68 <DAC_GetInstance+0x54>)
    9c4e:	f7fd fac5 	bl	71dc <__assert_func>

    return instance;
    9c52:	68fb      	ldr	r3, [r7, #12]
}
    9c54:	4618      	mov	r0, r3
    9c56:	3710      	adds	r7, #16
    9c58:	46bd      	mov	sp, r7
    9c5a:	bd80      	pop	{r7, pc}
    9c5c:	000100cc 	.word	0x000100cc
    9c60:	000100dc 	.word	0x000100dc
    9c64:	00010180 	.word	0x00010180
    9c68:	00010100 	.word	0x00010100

00009c6c <DAC_Init>:
 *
 * param base DAC peripheral base address.
 * param config Pointer to the configuration structure. See "dac_config_t".
 */
void DAC_Init(DAC_Type *base, const dac_config_t *config)
{
    9c6c:	b580      	push	{r7, lr}
    9c6e:	b084      	sub	sp, #16
    9c70:	af00      	add	r7, sp, #0
    9c72:	6078      	str	r0, [r7, #4]
    9c74:	6039      	str	r1, [r7, #0]
    assert(NULL != config);
    9c76:	683b      	ldr	r3, [r7, #0]
    9c78:	2b00      	cmp	r3, #0
    9c7a:	d105      	bne.n	9c88 <DAC_Init+0x1c>
    9c7c:	4b17      	ldr	r3, [pc, #92]	; (9cdc <DAC_Init+0x70>)
    9c7e:	4a18      	ldr	r2, [pc, #96]	; (9ce0 <DAC_Init+0x74>)
    9c80:	2146      	movs	r1, #70	; 0x46
    9c82:	4818      	ldr	r0, [pc, #96]	; (9ce4 <DAC_Init+0x78>)
    9c84:	f7fd faaa 	bl	71dc <__assert_func>

    uint8_t tmp8;

#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    /* Enable the clock. */
    CLOCK_EnableClock(s_dacClocks[DAC_GetInstance(base)]);
    9c88:	6878      	ldr	r0, [r7, #4]
    9c8a:	f7ff ffc3 	bl	9c14 <DAC_GetInstance>
    9c8e:	4603      	mov	r3, r0
    9c90:	4a15      	ldr	r2, [pc, #84]	; (9ce8 <DAC_Init+0x7c>)
    9c92:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c96:	4618      	mov	r0, r3
    9c98:	f7ff ffa2 	bl	9be0 <CLOCK_EnableClock>
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

    /* Configure. */
    /* DACx_C0. */
    tmp8 = base->C0 & (uint8_t)(~(DAC_C0_DACRFS_MASK | DAC_C0_LPEN_MASK));
    9c9c:	687b      	ldr	r3, [r7, #4]
    9c9e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    9ca2:	b2db      	uxtb	r3, r3
    9ca4:	f023 0348 	bic.w	r3, r3, #72	; 0x48
    9ca8:	73fb      	strb	r3, [r7, #15]
    if (kDAC_ReferenceVoltageSourceVref2 == config->referenceVoltageSource)
    9caa:	683b      	ldr	r3, [r7, #0]
    9cac:	781b      	ldrb	r3, [r3, #0]
    9cae:	2b01      	cmp	r3, #1
    9cb0:	d103      	bne.n	9cba <DAC_Init+0x4e>
    {
        tmp8 |= DAC_C0_DACRFS_MASK;
    9cb2:	7bfb      	ldrb	r3, [r7, #15]
    9cb4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    9cb8:	73fb      	strb	r3, [r7, #15]
    }
    if (config->enableLowPowerMode)
    9cba:	683b      	ldr	r3, [r7, #0]
    9cbc:	785b      	ldrb	r3, [r3, #1]
    9cbe:	2b00      	cmp	r3, #0
    9cc0:	d003      	beq.n	9cca <DAC_Init+0x5e>
    {
        tmp8 |= DAC_C0_LPEN_MASK;
    9cc2:	7bfb      	ldrb	r3, [r7, #15]
    9cc4:	f043 0308 	orr.w	r3, r3, #8
    9cc8:	73fb      	strb	r3, [r7, #15]
    }
    base->C0 = tmp8;
    9cca:	687b      	ldr	r3, [r7, #4]
    9ccc:	7bfa      	ldrb	r2, [r7, #15]
    9cce:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

    /* DAC_Enable(base, true); */
    /* Tip: The DAC output can be enabled till then after user sets their own available data in application. */
}
    9cd2:	bf00      	nop
    9cd4:	3710      	adds	r7, #16
    9cd6:	46bd      	mov	sp, r7
    9cd8:	bd80      	pop	{r7, pc}
    9cda:	bf00      	nop
    9cdc:	00010158 	.word	0x00010158
    9ce0:	00010190 	.word	0x00010190
    9ce4:	00010100 	.word	0x00010100
    9ce8:	000100d4 	.word	0x000100d4

00009cec <DAC_GetDefaultConfig>:
 *   config->enableLowPowerMode = false;
 * endcode
 * param config Pointer to the configuration structure. See "dac_config_t".
 */
void DAC_GetDefaultConfig(dac_config_t *config)
{
    9cec:	b580      	push	{r7, lr}
    9cee:	b082      	sub	sp, #8
    9cf0:	af00      	add	r7, sp, #0
    9cf2:	6078      	str	r0, [r7, #4]
    assert(NULL != config);
    9cf4:	687b      	ldr	r3, [r7, #4]
    9cf6:	2b00      	cmp	r3, #0
    9cf8:	d105      	bne.n	9d06 <DAC_GetDefaultConfig+0x1a>
    9cfa:	4b0a      	ldr	r3, [pc, #40]	; (9d24 <DAC_GetDefaultConfig+0x38>)
    9cfc:	4a0a      	ldr	r2, [pc, #40]	; (9d28 <DAC_GetDefaultConfig+0x3c>)
    9cfe:	217f      	movs	r1, #127	; 0x7f
    9d00:	480a      	ldr	r0, [pc, #40]	; (9d2c <DAC_GetDefaultConfig+0x40>)
    9d02:	f7fd fa6b 	bl	71dc <__assert_func>

    /* Initializes the configure structure to zero. */
    (void)memset(config, 0, sizeof(*config));
    9d06:	2202      	movs	r2, #2
    9d08:	2100      	movs	r1, #0
    9d0a:	6878      	ldr	r0, [r7, #4]
    9d0c:	f004 fb64 	bl	e3d8 <memset>

    config->referenceVoltageSource = kDAC_ReferenceVoltageSourceVref2;
    9d10:	687b      	ldr	r3, [r7, #4]
    9d12:	2201      	movs	r2, #1
    9d14:	701a      	strb	r2, [r3, #0]
    config->enableLowPowerMode     = false;
    9d16:	687b      	ldr	r3, [r7, #4]
    9d18:	2200      	movs	r2, #0
    9d1a:	705a      	strb	r2, [r3, #1]
}
    9d1c:	bf00      	nop
    9d1e:	3708      	adds	r7, #8
    9d20:	46bd      	mov	sp, r7
    9d22:	bd80      	pop	{r7, pc}
    9d24:	00010158 	.word	0x00010158
    9d28:	0001019c 	.word	0x0001019c
    9d2c:	00010100 	.word	0x00010100

00009d30 <DAC_SetBufferConfig>:
 *
 * param base   DAC peripheral base address.
 * param config Pointer to the configuration structure. See "dac_buffer_config_t".
 */
void DAC_SetBufferConfig(DAC_Type *base, const dac_buffer_config_t *config)
{
    9d30:	b580      	push	{r7, lr}
    9d32:	b084      	sub	sp, #16
    9d34:	af00      	add	r7, sp, #0
    9d36:	6078      	str	r0, [r7, #4]
    9d38:	6039      	str	r1, [r7, #0]
    assert(NULL != config);
    9d3a:	683b      	ldr	r3, [r7, #0]
    9d3c:	2b00      	cmp	r3, #0
    9d3e:	d105      	bne.n	9d4c <DAC_SetBufferConfig+0x1c>
    9d40:	4b27      	ldr	r3, [pc, #156]	; (9de0 <DAC_SetBufferConfig+0xb0>)
    9d42:	4a28      	ldr	r2, [pc, #160]	; (9de4 <DAC_SetBufferConfig+0xb4>)
    9d44:	2190      	movs	r1, #144	; 0x90
    9d46:	4828      	ldr	r0, [pc, #160]	; (9de8 <DAC_SetBufferConfig+0xb8>)
    9d48:	f7fd fa48 	bl	71dc <__assert_func>

    uint8_t tmp8;

    /* DACx_C0. */
    tmp8 = base->C0 & (uint8_t)(~DAC_C0_DACTRGSEL_MASK);
    9d4c:	687b      	ldr	r3, [r7, #4]
    9d4e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    9d52:	b2db      	uxtb	r3, r3
    9d54:	f023 0320 	bic.w	r3, r3, #32
    9d58:	73fb      	strb	r3, [r7, #15]
    if (kDAC_BufferTriggerBySoftwareMode == config->triggerMode)
    9d5a:	683b      	ldr	r3, [r7, #0]
    9d5c:	781b      	ldrb	r3, [r3, #0]
    9d5e:	2b01      	cmp	r3, #1
    9d60:	d103      	bne.n	9d6a <DAC_SetBufferConfig+0x3a>
    {
        tmp8 |= DAC_C0_DACTRGSEL_MASK;
    9d62:	7bfb      	ldrb	r3, [r7, #15]
    9d64:	f043 0320 	orr.w	r3, r3, #32
    9d68:	73fb      	strb	r3, [r7, #15]
    }
    base->C0 = tmp8;
    9d6a:	687b      	ldr	r3, [r7, #4]
    9d6c:	7bfa      	ldrb	r2, [r7, #15]
    9d6e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

    /* DACx_C1. */
    tmp8 = base->C1 & (uint8_t)(~(
    9d72:	687b      	ldr	r3, [r7, #4]
    9d74:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    9d78:	b2db      	uxtb	r3, r3
    9d7a:	f023 031e 	bic.w	r3, r3, #30
    9d7e:	73fb      	strb	r3, [r7, #15]
#if defined(FSL_FEATURE_DAC_HAS_WATERMARK_SELECTION) && FSL_FEATURE_DAC_HAS_WATERMARK_SELECTION
                          DAC_C1_DACBFWM_MASK |
#endif /* FSL_FEATURE_DAC_HAS_WATERMARK_SELECTION */
                          DAC_C1_DACBFMD_MASK));
#if defined(FSL_FEATURE_DAC_HAS_WATERMARK_SELECTION) && FSL_FEATURE_DAC_HAS_WATERMARK_SELECTION
    tmp8 |= DAC_C1_DACBFWM(config->watermark);
    9d80:	683b      	ldr	r3, [r7, #0]
    9d82:	785b      	ldrb	r3, [r3, #1]
    9d84:	00db      	lsls	r3, r3, #3
    9d86:	b2db      	uxtb	r3, r3
    9d88:	f003 0318 	and.w	r3, r3, #24
    9d8c:	b2da      	uxtb	r2, r3
    9d8e:	7bfb      	ldrb	r3, [r7, #15]
    9d90:	4313      	orrs	r3, r2
    9d92:	73fb      	strb	r3, [r7, #15]
#endif /* FSL_FEATURE_DAC_HAS_WATERMARK_SELECTION */
    tmp8 |= DAC_C1_DACBFMD(config->workMode);
    9d94:	683b      	ldr	r3, [r7, #0]
    9d96:	789b      	ldrb	r3, [r3, #2]
    9d98:	005b      	lsls	r3, r3, #1
    9d9a:	b2db      	uxtb	r3, r3
    9d9c:	f003 0306 	and.w	r3, r3, #6
    9da0:	b2da      	uxtb	r2, r3
    9da2:	7bfb      	ldrb	r3, [r7, #15]
    9da4:	4313      	orrs	r3, r2
    9da6:	73fb      	strb	r3, [r7, #15]
    base->C1 = tmp8;
    9da8:	687b      	ldr	r3, [r7, #4]
    9daa:	7bfa      	ldrb	r2, [r7, #15]
    9dac:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

    /* DACx_C2. */
    tmp8 = base->C2 & (uint8_t)(~DAC_C2_DACBFUP_MASK);
    9db0:	687b      	ldr	r3, [r7, #4]
    9db2:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    9db6:	b2db      	uxtb	r3, r3
    9db8:	f023 030f 	bic.w	r3, r3, #15
    9dbc:	73fb      	strb	r3, [r7, #15]
    tmp8 |= DAC_C2_DACBFUP(config->upperLimit);
    9dbe:	683b      	ldr	r3, [r7, #0]
    9dc0:	78db      	ldrb	r3, [r3, #3]
    9dc2:	f003 030f 	and.w	r3, r3, #15
    9dc6:	b2da      	uxtb	r2, r3
    9dc8:	7bfb      	ldrb	r3, [r7, #15]
    9dca:	4313      	orrs	r3, r2
    9dcc:	73fb      	strb	r3, [r7, #15]
    base->C2 = tmp8;
    9dce:	687b      	ldr	r3, [r7, #4]
    9dd0:	7bfa      	ldrb	r2, [r7, #15]
    9dd2:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
}
    9dd6:	bf00      	nop
    9dd8:	3710      	adds	r7, #16
    9dda:	46bd      	mov	sp, r7
    9ddc:	bd80      	pop	{r7, pc}
    9dde:	bf00      	nop
    9de0:	00010158 	.word	0x00010158
    9de4:	000101b4 	.word	0x000101b4
    9de8:	00010100 	.word	0x00010100

00009dec <DAC_GetDefaultBufferConfig>:
 *   config->upperLimit  = DAC_DATL_COUNT - 1U;
 * endcode
 * param config Pointer to the configuration structure. See "dac_buffer_config_t".
 */
void DAC_GetDefaultBufferConfig(dac_buffer_config_t *config)
{
    9dec:	b580      	push	{r7, lr}
    9dee:	b082      	sub	sp, #8
    9df0:	af00      	add	r7, sp, #0
    9df2:	6078      	str	r0, [r7, #4]
    assert(NULL != config);
    9df4:	687b      	ldr	r3, [r7, #4]
    9df6:	2b00      	cmp	r3, #0
    9df8:	d105      	bne.n	9e06 <DAC_GetDefaultBufferConfig+0x1a>
    9dfa:	4b0d      	ldr	r3, [pc, #52]	; (9e30 <DAC_GetDefaultBufferConfig+0x44>)
    9dfc:	4a0d      	ldr	r2, [pc, #52]	; (9e34 <DAC_GetDefaultBufferConfig+0x48>)
    9dfe:	21bd      	movs	r1, #189	; 0xbd
    9e00:	480d      	ldr	r0, [pc, #52]	; (9e38 <DAC_GetDefaultBufferConfig+0x4c>)
    9e02:	f7fd f9eb 	bl	71dc <__assert_func>

    /* Initializes the configure structure to zero. */
    (void)memset(config, 0, sizeof(*config));
    9e06:	2204      	movs	r2, #4
    9e08:	2100      	movs	r1, #0
    9e0a:	6878      	ldr	r0, [r7, #4]
    9e0c:	f004 fae4 	bl	e3d8 <memset>

    config->triggerMode = kDAC_BufferTriggerBySoftwareMode;
    9e10:	687b      	ldr	r3, [r7, #4]
    9e12:	2201      	movs	r2, #1
    9e14:	701a      	strb	r2, [r3, #0]
#if defined(FSL_FEATURE_DAC_HAS_WATERMARK_SELECTION) && FSL_FEATURE_DAC_HAS_WATERMARK_SELECTION
    config->watermark = kDAC_BufferWatermark1Word;
    9e16:	687b      	ldr	r3, [r7, #4]
    9e18:	2200      	movs	r2, #0
    9e1a:	705a      	strb	r2, [r3, #1]
#endif /* FSL_FEATURE_DAC_HAS_WATERMARK_SELECTION */
    config->workMode   = kDAC_BufferWorkAsNormalMode;
    9e1c:	687b      	ldr	r3, [r7, #4]
    9e1e:	2200      	movs	r2, #0
    9e20:	709a      	strb	r2, [r3, #2]
    config->upperLimit = DAC_DATL_COUNT - 1U;
    9e22:	687b      	ldr	r3, [r7, #4]
    9e24:	220f      	movs	r2, #15
    9e26:	70da      	strb	r2, [r3, #3]
}
    9e28:	bf00      	nop
    9e2a:	3708      	adds	r7, #8
    9e2c:	46bd      	mov	sp, r7
    9e2e:	bd80      	pop	{r7, pc}
    9e30:	00010158 	.word	0x00010158
    9e34:	000101c8 	.word	0x000101c8
    9e38:	00010100 	.word	0x00010100

00009e3c <DAC_SetBufferValue>:
 * param index Setting the index for items in the buffer. The available index should not exceed the size of the DAC
 * buffer.
 * param value Setting the value for items in the buffer. 12-bits are available.
 */
void DAC_SetBufferValue(DAC_Type *base, uint8_t index, uint16_t value)
{
    9e3c:	b580      	push	{r7, lr}
    9e3e:	b082      	sub	sp, #8
    9e40:	af00      	add	r7, sp, #0
    9e42:	6078      	str	r0, [r7, #4]
    9e44:	460b      	mov	r3, r1
    9e46:	70fb      	strb	r3, [r7, #3]
    9e48:	4613      	mov	r3, r2
    9e4a:	803b      	strh	r3, [r7, #0]
    assert(index < DAC_DATL_COUNT);
    9e4c:	78fb      	ldrb	r3, [r7, #3]
    9e4e:	2b0f      	cmp	r3, #15
    9e50:	d905      	bls.n	9e5e <DAC_SetBufferValue+0x22>
    9e52:	4b0e      	ldr	r3, [pc, #56]	; (9e8c <DAC_SetBufferValue+0x50>)
    9e54:	4a0e      	ldr	r2, [pc, #56]	; (9e90 <DAC_SetBufferValue+0x54>)
    9e56:	21d4      	movs	r1, #212	; 0xd4
    9e58:	480e      	ldr	r0, [pc, #56]	; (9e94 <DAC_SetBufferValue+0x58>)
    9e5a:	f7fd f9bf 	bl	71dc <__assert_func>

    base->DAT[index].DATL = (uint8_t)(0xFFU & value);         /* Low 8-bit. */
    9e5e:	78fa      	ldrb	r2, [r7, #3]
    9e60:	883b      	ldrh	r3, [r7, #0]
    9e62:	b2d9      	uxtb	r1, r3
    9e64:	687b      	ldr	r3, [r7, #4]
    9e66:	f803 1012 	strb.w	r1, [r3, r2, lsl #1]
    base->DAT[index].DATH = (uint8_t)((0xF00U & value) >> 8); /* High 4-bit. */
    9e6a:	883b      	ldrh	r3, [r7, #0]
    9e6c:	0a1b      	lsrs	r3, r3, #8
    9e6e:	b29b      	uxth	r3, r3
    9e70:	b2da      	uxtb	r2, r3
    9e72:	78fb      	ldrb	r3, [r7, #3]
    9e74:	f002 020f 	and.w	r2, r2, #15
    9e78:	b2d1      	uxtb	r1, r2
    9e7a:	687a      	ldr	r2, [r7, #4]
    9e7c:	005b      	lsls	r3, r3, #1
    9e7e:	4413      	add	r3, r2
    9e80:	460a      	mov	r2, r1
    9e82:	705a      	strb	r2, [r3, #1]
}
    9e84:	bf00      	nop
    9e86:	3708      	adds	r7, #8
    9e88:	46bd      	mov	sp, r7
    9e8a:	bd80      	pop	{r7, pc}
    9e8c:	00010168 	.word	0x00010168
    9e90:	000101e4 	.word	0x000101e4
    9e94:	00010100 	.word	0x00010100

00009e98 <DAC_SetBufferReadPointer>:
 *
 * param base  DAC peripheral base address.
 * param index Setting an index value for the pointer.
 */
void DAC_SetBufferReadPointer(DAC_Type *base, uint8_t index)
{
    9e98:	b580      	push	{r7, lr}
    9e9a:	b084      	sub	sp, #16
    9e9c:	af00      	add	r7, sp, #0
    9e9e:	6078      	str	r0, [r7, #4]
    9ea0:	460b      	mov	r3, r1
    9ea2:	70fb      	strb	r3, [r7, #3]
    assert(index < DAC_DATL_COUNT);
    9ea4:	78fb      	ldrb	r3, [r7, #3]
    9ea6:	2b0f      	cmp	r3, #15
    9ea8:	d905      	bls.n	9eb6 <DAC_SetBufferReadPointer+0x1e>
    9eaa:	4b0d      	ldr	r3, [pc, #52]	; (9ee0 <DAC_SetBufferReadPointer+0x48>)
    9eac:	4a0d      	ldr	r2, [pc, #52]	; (9ee4 <DAC_SetBufferReadPointer+0x4c>)
    9eae:	21e6      	movs	r1, #230	; 0xe6
    9eb0:	480d      	ldr	r0, [pc, #52]	; (9ee8 <DAC_SetBufferReadPointer+0x50>)
    9eb2:	f7fd f993 	bl	71dc <__assert_func>

    uint8_t tmp8 = base->C2 & (uint8_t)(~DAC_C2_DACBFRP_MASK);
    9eb6:	687b      	ldr	r3, [r7, #4]
    9eb8:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    9ebc:	b2db      	uxtb	r3, r3
    9ebe:	f003 030f 	and.w	r3, r3, #15
    9ec2:	73fb      	strb	r3, [r7, #15]

    tmp8 |= DAC_C2_DACBFRP(index);
    9ec4:	78fb      	ldrb	r3, [r7, #3]
    9ec6:	011b      	lsls	r3, r3, #4
    9ec8:	b2da      	uxtb	r2, r3
    9eca:	7bfb      	ldrb	r3, [r7, #15]
    9ecc:	4313      	orrs	r3, r2
    9ece:	73fb      	strb	r3, [r7, #15]
    base->C2 = tmp8;
    9ed0:	687b      	ldr	r3, [r7, #4]
    9ed2:	7bfa      	ldrb	r2, [r7, #15]
    9ed4:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
}
    9ed8:	bf00      	nop
    9eda:	3710      	adds	r7, #16
    9edc:	46bd      	mov	sp, r7
    9ede:	bd80      	pop	{r7, pc}
    9ee0:	00010168 	.word	0x00010168
    9ee4:	000101f8 	.word	0x000101f8
    9ee8:	00010100 	.word	0x00010100

00009eec <DAC_EnableBufferInterrupts>:
 *
 * param base DAC peripheral base address.
 * param mask Mask value for interrupts. See "_dac_buffer_interrupt_enable".
 */
void DAC_EnableBufferInterrupts(DAC_Type *base, uint32_t mask)
{
    9eec:	b480      	push	{r7}
    9eee:	b083      	sub	sp, #12
    9ef0:	af00      	add	r7, sp, #0
    9ef2:	6078      	str	r0, [r7, #4]
    9ef4:	6039      	str	r1, [r7, #0]
    mask &= (
    9ef6:	683b      	ldr	r3, [r7, #0]
    9ef8:	f003 0307 	and.w	r3, r3, #7
    9efc:	603b      	str	r3, [r7, #0]
#if defined(FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION) && FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION
        DAC_C0_DACBWIEN_MASK |
#endif /* FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION */
        DAC_C0_DACBTIEN_MASK | DAC_C0_DACBBIEN_MASK);
    base->C0 |= ((uint8_t)mask); /* Write 1 to enable. */
    9efe:	687b      	ldr	r3, [r7, #4]
    9f00:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    9f04:	b2da      	uxtb	r2, r3
    9f06:	683b      	ldr	r3, [r7, #0]
    9f08:	b2db      	uxtb	r3, r3
    9f0a:	4313      	orrs	r3, r2
    9f0c:	b2da      	uxtb	r2, r3
    9f0e:	687b      	ldr	r3, [r7, #4]
    9f10:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
}
    9f14:	bf00      	nop
    9f16:	370c      	adds	r7, #12
    9f18:	46bd      	mov	sp, r7
    9f1a:	f85d 7b04 	ldr.w	r7, [sp], #4
    9f1e:	4770      	bx	lr

00009f20 <DAC_DisableBufferInterrupts>:
 *
 * param base DAC peripheral base address.
 * param mask Mask value for interrupts. See  "_dac_buffer_interrupt_enable".
 */
void DAC_DisableBufferInterrupts(DAC_Type *base, uint32_t mask)
{
    9f20:	b480      	push	{r7}
    9f22:	b083      	sub	sp, #12
    9f24:	af00      	add	r7, sp, #0
    9f26:	6078      	str	r0, [r7, #4]
    9f28:	6039      	str	r1, [r7, #0]
    mask &= (
    9f2a:	683b      	ldr	r3, [r7, #0]
    9f2c:	f003 0307 	and.w	r3, r3, #7
    9f30:	603b      	str	r3, [r7, #0]
#if defined(FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION) && FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION
        DAC_C0_DACBWIEN_MASK |
#endif /* FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION */
        DAC_C0_DACBTIEN_MASK | DAC_C0_DACBBIEN_MASK);
    base->C0 &= (uint8_t)(~((uint8_t)mask)); /* Write 0 to disable. */
    9f32:	687b      	ldr	r3, [r7, #4]
    9f34:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    9f38:	b2da      	uxtb	r2, r3
    9f3a:	683b      	ldr	r3, [r7, #0]
    9f3c:	b2db      	uxtb	r3, r3
    9f3e:	43db      	mvns	r3, r3
    9f40:	b2db      	uxtb	r3, r3
    9f42:	4013      	ands	r3, r2
    9f44:	b2da      	uxtb	r2, r3
    9f46:	687b      	ldr	r3, [r7, #4]
    9f48:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
}
    9f4c:	bf00      	nop
    9f4e:	370c      	adds	r7, #12
    9f50:	46bd      	mov	sp, r7
    9f52:	f85d 7b04 	ldr.w	r7, [sp], #4
    9f56:	4770      	bx	lr

00009f58 <DAC_GetBufferStatusFlags>:
 * param  base DAC peripheral base address.
 *
 * return      Mask value for the asserted flags. See  "_dac_buffer_status_flags".
 */
uint8_t DAC_GetBufferStatusFlags(DAC_Type *base)
{
    9f58:	b480      	push	{r7}
    9f5a:	b083      	sub	sp, #12
    9f5c:	af00      	add	r7, sp, #0
    9f5e:	6078      	str	r0, [r7, #4]
    return base->SR & (
    9f60:	687b      	ldr	r3, [r7, #4]
    9f62:	f893 3020 	ldrb.w	r3, [r3, #32]
    9f66:	b2db      	uxtb	r3, r3
    9f68:	f003 0307 	and.w	r3, r3, #7
    9f6c:	b2db      	uxtb	r3, r3
#if defined(FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION) && FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION
                          DAC_SR_DACBFWMF_MASK |
#endif /* FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION */
                          DAC_SR_DACBFRPTF_MASK | DAC_SR_DACBFRPBF_MASK);
}
    9f6e:	4618      	mov	r0, r3
    9f70:	370c      	adds	r7, #12
    9f72:	46bd      	mov	sp, r7
    9f74:	f85d 7b04 	ldr.w	r7, [sp], #4
    9f78:	4770      	bx	lr

00009f7a <DAC_ClearBufferStatusFlags>:
 *
 * param base DAC peripheral base address.
 * param mask Mask value for flags. See "_dac_buffer_status_flags_t".
 */
void DAC_ClearBufferStatusFlags(DAC_Type *base, uint32_t mask)
{
    9f7a:	b480      	push	{r7}
    9f7c:	b083      	sub	sp, #12
    9f7e:	af00      	add	r7, sp, #0
    9f80:	6078      	str	r0, [r7, #4]
    9f82:	6039      	str	r1, [r7, #0]
    mask &= (
    9f84:	683b      	ldr	r3, [r7, #0]
    9f86:	f003 0307 	and.w	r3, r3, #7
    9f8a:	603b      	str	r3, [r7, #0]
#if defined(FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION) && FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION
        DAC_SR_DACBFWMF_MASK |
#endif /* FSL_FEATURE_DAC_HAS_WATERMARK_DETECTION */
        DAC_SR_DACBFRPTF_MASK | DAC_SR_DACBFRPBF_MASK);
    base->SR &= (uint8_t)(~((uint8_t)mask)); /* Write 0 to clear flags. */
    9f8c:	687b      	ldr	r3, [r7, #4]
    9f8e:	f893 3020 	ldrb.w	r3, [r3, #32]
    9f92:	b2da      	uxtb	r2, r3
    9f94:	683b      	ldr	r3, [r7, #0]
    9f96:	b2db      	uxtb	r3, r3
    9f98:	43db      	mvns	r3, r3
    9f9a:	b2db      	uxtb	r3, r3
    9f9c:	4013      	ands	r3, r2
    9f9e:	b2da      	uxtb	r2, r3
    9fa0:	687b      	ldr	r3, [r7, #4]
    9fa2:	f883 2020 	strb.w	r2, [r3, #32]
}
    9fa6:	bf00      	nop
    9fa8:	370c      	adds	r7, #12
    9faa:	46bd      	mov	sp, r7
    9fac:	f85d 7b04 	ldr.w	r7, [sp], #4
    9fb0:	4770      	bx	lr

00009fb2 <GPIO_PinWrite>:
{
    9fb2:	b480      	push	{r7}
    9fb4:	b087      	sub	sp, #28
    9fb6:	af00      	add	r7, sp, #0
    9fb8:	60f8      	str	r0, [r7, #12]
    9fba:	60b9      	str	r1, [r7, #8]
    9fbc:	4613      	mov	r3, r2
    9fbe:	71fb      	strb	r3, [r7, #7]
    uint32_t u32flag = 1;
    9fc0:	2301      	movs	r3, #1
    9fc2:	617b      	str	r3, [r7, #20]
    if (output == 0U)
    9fc4:	79fb      	ldrb	r3, [r7, #7]
    9fc6:	2b00      	cmp	r3, #0
    9fc8:	d105      	bne.n	9fd6 <GPIO_PinWrite+0x24>
        base->PCOR = GPIO_FIT_REG(u32flag << pin);
    9fca:	697a      	ldr	r2, [r7, #20]
    9fcc:	68bb      	ldr	r3, [r7, #8]
    9fce:	409a      	lsls	r2, r3
    9fd0:	68fb      	ldr	r3, [r7, #12]
    9fd2:	609a      	str	r2, [r3, #8]
}
    9fd4:	e004      	b.n	9fe0 <GPIO_PinWrite+0x2e>
        base->PSOR = GPIO_FIT_REG(u32flag << pin);
    9fd6:	697a      	ldr	r2, [r7, #20]
    9fd8:	68bb      	ldr	r3, [r7, #8]
    9fda:	409a      	lsls	r2, r3
    9fdc:	68fb      	ldr	r3, [r7, #12]
    9fde:	605a      	str	r2, [r3, #4]
}
    9fe0:	bf00      	nop
    9fe2:	371c      	adds	r7, #28
    9fe4:	46bd      	mov	sp, r7
    9fe6:	f85d 7b04 	ldr.w	r7, [sp], #4
    9fea:	4770      	bx	lr

00009fec <PORT_SetPinConfig>:
{
    9fec:	b580      	push	{r7, lr}
    9fee:	b086      	sub	sp, #24
    9ff0:	af00      	add	r7, sp, #0
    9ff2:	60f8      	str	r0, [r7, #12]
    9ff4:	60b9      	str	r1, [r7, #8]
    9ff6:	607a      	str	r2, [r7, #4]
    assert(config);
    9ff8:	687b      	ldr	r3, [r7, #4]
    9ffa:	2b00      	cmp	r3, #0
    9ffc:	d105      	bne.n	a00a <PORT_SetPinConfig+0x1e>
    9ffe:	4b09      	ldr	r3, [pc, #36]	; (a024 <PORT_SetPinConfig+0x38>)
    a000:	4a09      	ldr	r2, [pc, #36]	; (a028 <PORT_SetPinConfig+0x3c>)
    a002:	21f5      	movs	r1, #245	; 0xf5
    a004:	4809      	ldr	r0, [pc, #36]	; (a02c <PORT_SetPinConfig+0x40>)
    a006:	f7fd f8e9 	bl	71dc <__assert_func>
    uint32_t addr                = (uint32_t)&base->PCR[pin];
    a00a:	68bb      	ldr	r3, [r7, #8]
    a00c:	009b      	lsls	r3, r3, #2
    a00e:	68fa      	ldr	r2, [r7, #12]
    a010:	4413      	add	r3, r2
    a012:	617b      	str	r3, [r7, #20]
    *(volatile uint16_t *)(addr) = *((const uint16_t *)(const void *)config);
    a014:	697b      	ldr	r3, [r7, #20]
    a016:	687a      	ldr	r2, [r7, #4]
    a018:	8812      	ldrh	r2, [r2, #0]
    a01a:	801a      	strh	r2, [r3, #0]
}
    a01c:	bf00      	nop
    a01e:	3718      	adds	r7, #24
    a020:	46bd      	mov	sp, r7
    a022:	bd80      	pop	{r7, pc}
    a024:	00010214 	.word	0x00010214
    a028:	0001021c 	.word	0x0001021c
    a02c:	00010264 	.word	0x00010264

0000a030 <_ZN6ADG732C1EP9PORT_TypeP9GPIO_TypemS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_mS1_S3_m>:
#include "ADG732.h"

ADG732::ADG732(PORT_Type* port_a0, GPIO_Type * gpio_a0, uint32_t pin_a0,
    a030:	b480      	push	{r7}
    a032:	b085      	sub	sp, #20
    a034:	af00      	add	r7, sp, #0
    a036:	60f8      	str	r0, [r7, #12]
    a038:	60b9      	str	r1, [r7, #8]
    a03a:	607a      	str	r2, [r7, #4]
    a03c:	603b      	str	r3, [r7, #0]
               PORT_Type* port_a4, GPIO_Type * gpio_a4, uint32_t pin_a4,
               PORT_Type* port_cs, GPIO_Type * gpio_cs, uint32_t pin_cs,
               PORT_Type* port_wr, GPIO_Type * gpio_wr, uint32_t pin_wr,
               PORT_Type* port_en, GPIO_Type * gpio_en, uint32_t pin_en)
    :
    m_pPort_a0( port_a0 ),
    a03e:	68fb      	ldr	r3, [r7, #12]
    a040:	68ba      	ldr	r2, [r7, #8]
    a042:	601a      	str	r2, [r3, #0]
    m_pPort_a1( port_a1 ),
    a044:	68fb      	ldr	r3, [r7, #12]
    a046:	69ba      	ldr	r2, [r7, #24]
    a048:	605a      	str	r2, [r3, #4]
    m_pPort_a2( port_a2 ),
    a04a:	68fb      	ldr	r3, [r7, #12]
    a04c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    a04e:	609a      	str	r2, [r3, #8]
    m_pPort_a3( port_a3 ),
    a050:	68fb      	ldr	r3, [r7, #12]
    a052:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    a054:	60da      	str	r2, [r3, #12]
    m_pPort_a4( port_a4 ),
    a056:	68fb      	ldr	r3, [r7, #12]
    a058:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    a05a:	611a      	str	r2, [r3, #16]
    m_pPort_cs( port_cs ),
    a05c:	68fb      	ldr	r3, [r7, #12]
    a05e:	6cba      	ldr	r2, [r7, #72]	; 0x48
    a060:	615a      	str	r2, [r3, #20]
    m_pPort_wr( port_wr ),
    a062:	68fb      	ldr	r3, [r7, #12]
    a064:	6d7a      	ldr	r2, [r7, #84]	; 0x54
    a066:	619a      	str	r2, [r3, #24]
    m_pPort_en( port_en ),
    a068:	68fb      	ldr	r3, [r7, #12]
    a06a:	6e3a      	ldr	r2, [r7, #96]	; 0x60
    a06c:	61da      	str	r2, [r3, #28]

    m_pGpio_a0( gpio_a0 ),
    a06e:	68fb      	ldr	r3, [r7, #12]
    a070:	687a      	ldr	r2, [r7, #4]
    a072:	621a      	str	r2, [r3, #32]
    m_pGpio_a1( gpio_a1 ),
    a074:	68fb      	ldr	r3, [r7, #12]
    a076:	69fa      	ldr	r2, [r7, #28]
    a078:	625a      	str	r2, [r3, #36]	; 0x24
    m_pGpio_a2( gpio_a2 ),
    a07a:	68fb      	ldr	r3, [r7, #12]
    a07c:	6aba      	ldr	r2, [r7, #40]	; 0x28
    a07e:	629a      	str	r2, [r3, #40]	; 0x28
    m_pGpio_a3( gpio_a3 ),
    a080:	68fb      	ldr	r3, [r7, #12]
    a082:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    a084:	62da      	str	r2, [r3, #44]	; 0x2c
    m_pGpio_a4( gpio_a4 ),
    a086:	68fb      	ldr	r3, [r7, #12]
    a088:	6c3a      	ldr	r2, [r7, #64]	; 0x40
    a08a:	631a      	str	r2, [r3, #48]	; 0x30
    m_pGpio_cs( gpio_cs ),
    a08c:	68fb      	ldr	r3, [r7, #12]
    a08e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
    a090:	635a      	str	r2, [r3, #52]	; 0x34
    m_pGpio_wr( gpio_wr ),
    a092:	68fb      	ldr	r3, [r7, #12]
    a094:	6dba      	ldr	r2, [r7, #88]	; 0x58
    a096:	639a      	str	r2, [r3, #56]	; 0x38
    m_pGpio_en( gpio_en ),
    a098:	68fb      	ldr	r3, [r7, #12]
    a09a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
    a09c:	63da      	str	r2, [r3, #60]	; 0x3c

    m_iPin_a0 ( pin_a0  ),
    a09e:	68fb      	ldr	r3, [r7, #12]
    a0a0:	683a      	ldr	r2, [r7, #0]
    a0a2:	641a      	str	r2, [r3, #64]	; 0x40
    m_iPin_a1 ( pin_a1  ),
    a0a4:	68fb      	ldr	r3, [r7, #12]
    a0a6:	6a3a      	ldr	r2, [r7, #32]
    a0a8:	645a      	str	r2, [r3, #68]	; 0x44
    m_iPin_a2 ( pin_a2  ),
    a0aa:	68fb      	ldr	r3, [r7, #12]
    a0ac:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    a0ae:	649a      	str	r2, [r3, #72]	; 0x48
    m_iPin_a3 ( pin_a3  ),
    a0b0:	68fb      	ldr	r3, [r7, #12]
    a0b2:	6bba      	ldr	r2, [r7, #56]	; 0x38
    a0b4:	64da      	str	r2, [r3, #76]	; 0x4c
    m_iPin_a4 ( pin_a4  ),
    a0b6:	68fb      	ldr	r3, [r7, #12]
    a0b8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
    a0ba:	651a      	str	r2, [r3, #80]	; 0x50
    m_iPin_cs ( pin_cs  ),
    a0bc:	68fb      	ldr	r3, [r7, #12]
    a0be:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    a0c0:	655a      	str	r2, [r3, #84]	; 0x54
    m_iPin_wr ( pin_wr  ),
    a0c2:	68fb      	ldr	r3, [r7, #12]
    a0c4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
    a0c6:	659a      	str	r2, [r3, #88]	; 0x58
    m_iPin_en ( pin_en  )
    a0c8:	68fb      	ldr	r3, [r7, #12]
    a0ca:	6eba      	ldr	r2, [r7, #104]	; 0x68
    a0cc:	65da      	str	r2, [r3, #92]	; 0x5c
{
    
}
    a0ce:	68fb      	ldr	r3, [r7, #12]
    a0d0:	4618      	mov	r0, r3
    a0d2:	3714      	adds	r7, #20
    a0d4:	46bd      	mov	sp, r7
    a0d6:	f85d 7b04 	ldr.w	r7, [sp], #4
    a0da:	4770      	bx	lr

0000a0dc <_ZN6ADG7324initEv>:

void ADG732::init() 
{
    a0dc:	b580      	push	{r7, lr}
    a0de:	b084      	sub	sp, #16
    a0e0:	af00      	add	r7, sp, #0
    a0e2:	6078      	str	r0, [r7, #4]
    #if defined(FSL_FEATURE_PORT_PCR_MUX_WIDTH) && FSL_FEATURE_PORT_PCR_MUX_WIDTH
    port_pin_config_t port_config =
    a0e4:	2300      	movs	r3, #0
    a0e6:	81bb      	strh	r3, [r7, #12]
    a0e8:	7b7b      	ldrb	r3, [r7, #13]
    a0ea:	2201      	movs	r2, #1
    a0ec:	f362 0302 	bfi	r3, r2, #0, #3
    a0f0:	737b      	strb	r3, [r7, #13]
        #endif
        #if defined(FSL_FEATURE_PORT_HAS_PIN_CONTROL_LOCK) && FSL_FEATURE_PORT_HAS_PIN_CONTROL_LOCK
            .lockRegister = kPORT_UnlockRegister,
        #endif /* FSL_FEATURE_PORT_HAS_PIN_CONTROL_LOCK */
    };
    PORT_SetPinConfig(m_pPort_a0,  m_iPin_a0,  &port_config);
    a0f2:	687b      	ldr	r3, [r7, #4]
    a0f4:	6818      	ldr	r0, [r3, #0]
    a0f6:	687b      	ldr	r3, [r7, #4]
    a0f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    a0fa:	f107 020c 	add.w	r2, r7, #12
    a0fe:	4619      	mov	r1, r3
    a100:	f7ff ff74 	bl	9fec <PORT_SetPinConfig>
    PORT_SetPinConfig(m_pPort_a1,  m_iPin_a1,  &port_config);
    a104:	687b      	ldr	r3, [r7, #4]
    a106:	6858      	ldr	r0, [r3, #4]
    a108:	687b      	ldr	r3, [r7, #4]
    a10a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    a10c:	f107 020c 	add.w	r2, r7, #12
    a110:	4619      	mov	r1, r3
    a112:	f7ff ff6b 	bl	9fec <PORT_SetPinConfig>
    PORT_SetPinConfig(m_pPort_a2,  m_iPin_a2,  &port_config);
    a116:	687b      	ldr	r3, [r7, #4]
    a118:	6898      	ldr	r0, [r3, #8]
    a11a:	687b      	ldr	r3, [r7, #4]
    a11c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    a11e:	f107 020c 	add.w	r2, r7, #12
    a122:	4619      	mov	r1, r3
    a124:	f7ff ff62 	bl	9fec <PORT_SetPinConfig>
    PORT_SetPinConfig(m_pPort_a3,  m_iPin_a3,  &port_config);
    a128:	687b      	ldr	r3, [r7, #4]
    a12a:	68d8      	ldr	r0, [r3, #12]
    a12c:	687b      	ldr	r3, [r7, #4]
    a12e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    a130:	f107 020c 	add.w	r2, r7, #12
    a134:	4619      	mov	r1, r3
    a136:	f7ff ff59 	bl	9fec <PORT_SetPinConfig>
    PORT_SetPinConfig(m_pPort_a4,  m_iPin_a4,  &port_config);
    a13a:	687b      	ldr	r3, [r7, #4]
    a13c:	6918      	ldr	r0, [r3, #16]
    a13e:	687b      	ldr	r3, [r7, #4]
    a140:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    a142:	f107 020c 	add.w	r2, r7, #12
    a146:	4619      	mov	r1, r3
    a148:	f7ff ff50 	bl	9fec <PORT_SetPinConfig>
    PORT_SetPinConfig(m_pPort_cs,  m_iPin_cs,  &port_config);
    a14c:	687b      	ldr	r3, [r7, #4]
    a14e:	6958      	ldr	r0, [r3, #20]
    a150:	687b      	ldr	r3, [r7, #4]
    a152:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    a154:	f107 020c 	add.w	r2, r7, #12
    a158:	4619      	mov	r1, r3
    a15a:	f7ff ff47 	bl	9fec <PORT_SetPinConfig>
    PORT_SetPinConfig(m_pPort_wr,  m_iPin_wr,  &port_config);
    a15e:	687b      	ldr	r3, [r7, #4]
    a160:	6998      	ldr	r0, [r3, #24]
    a162:	687b      	ldr	r3, [r7, #4]
    a164:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    a166:	f107 020c 	add.w	r2, r7, #12
    a16a:	4619      	mov	r1, r3
    a16c:	f7ff ff3e 	bl	9fec <PORT_SetPinConfig>
    PORT_SetPinConfig(m_pPort_en , m_iPin_en , &port_config);
    a170:	687b      	ldr	r3, [r7, #4]
    a172:	69d8      	ldr	r0, [r3, #28]
    a174:	687b      	ldr	r3, [r7, #4]
    a176:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    a178:	f107 020c 	add.w	r2, r7, #12
    a17c:	4619      	mov	r1, r3
    a17e:	f7ff ff35 	bl	9fec <PORT_SetPinConfig>

    #endif /* FSL_FEATURE_PORT_PCR_MUX_WIDTH */

    gpio_pin_config_t const gpio_config = 
    a182:	4b2f      	ldr	r3, [pc, #188]	; (a240 <_ZN6ADG7324initEv+0x164>)
    a184:	881b      	ldrh	r3, [r3, #0]
    a186:	813b      	strh	r3, [r7, #8]
    {
        .pinDirection = kGPIO_DigitalOutput, 
        .outputLogic = 1,
    };

    GPIO_PinInit(m_pGpio_en,  m_iPin_en,  &gpio_config);
    a188:	687b      	ldr	r3, [r7, #4]
    a18a:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
    a18c:	687b      	ldr	r3, [r7, #4]
    a18e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    a190:	f107 0208 	add.w	r2, r7, #8
    a194:	4619      	mov	r1, r3
    a196:	f7fc ffe7 	bl	7168 <GPIO_PinInit>
    enable(false);
    a19a:	2100      	movs	r1, #0
    a19c:	6878      	ldr	r0, [r7, #4]
    a19e:	f000 f8ae 	bl	a2fe <_ZN6ADG7326enableEb>
    GPIO_PinInit(m_pGpio_cs,  m_iPin_cs,  &gpio_config);
    a1a2:	687b      	ldr	r3, [r7, #4]
    a1a4:	6b58      	ldr	r0, [r3, #52]	; 0x34
    a1a6:	687b      	ldr	r3, [r7, #4]
    a1a8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    a1aa:	f107 0208 	add.w	r2, r7, #8
    a1ae:	4619      	mov	r1, r3
    a1b0:	f7fc ffda 	bl	7168 <GPIO_PinInit>
    _chipSelect(false);
    a1b4:	2100      	movs	r1, #0
    a1b6:	6878      	ldr	r0, [r7, #4]
    a1b8:	f000 f8b8 	bl	a32c <_ZN6ADG73211_chipSelectEb>
    GPIO_PinInit(m_pGpio_wr,  m_iPin_wr,  &gpio_config);
    a1bc:	687b      	ldr	r3, [r7, #4]
    a1be:	6b98      	ldr	r0, [r3, #56]	; 0x38
    a1c0:	687b      	ldr	r3, [r7, #4]
    a1c2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    a1c4:	f107 0208 	add.w	r2, r7, #8
    a1c8:	4619      	mov	r1, r3
    a1ca:	f7fc ffcd 	bl	7168 <GPIO_PinInit>
    _writeEnable(false);
    a1ce:	2100      	movs	r1, #0
    a1d0:	6878      	ldr	r0, [r7, #4]
    a1d2:	f000 f8c2 	bl	a35a <_ZN6ADG73212_writeEnableEb>

    GPIO_PinInit(m_pGpio_a0,  m_iPin_a0,  &gpio_config);
    a1d6:	687b      	ldr	r3, [r7, #4]
    a1d8:	6a18      	ldr	r0, [r3, #32]
    a1da:	687b      	ldr	r3, [r7, #4]
    a1dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    a1de:	f107 0208 	add.w	r2, r7, #8
    a1e2:	4619      	mov	r1, r3
    a1e4:	f7fc ffc0 	bl	7168 <GPIO_PinInit>
    GPIO_PinInit(m_pGpio_a1,  m_iPin_a1,  &gpio_config);
    a1e8:	687b      	ldr	r3, [r7, #4]
    a1ea:	6a58      	ldr	r0, [r3, #36]	; 0x24
    a1ec:	687b      	ldr	r3, [r7, #4]
    a1ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    a1f0:	f107 0208 	add.w	r2, r7, #8
    a1f4:	4619      	mov	r1, r3
    a1f6:	f7fc ffb7 	bl	7168 <GPIO_PinInit>
    GPIO_PinInit(m_pGpio_a2,  m_iPin_a2,  &gpio_config);
    a1fa:	687b      	ldr	r3, [r7, #4]
    a1fc:	6a98      	ldr	r0, [r3, #40]	; 0x28
    a1fe:	687b      	ldr	r3, [r7, #4]
    a200:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    a202:	f107 0208 	add.w	r2, r7, #8
    a206:	4619      	mov	r1, r3
    a208:	f7fc ffae 	bl	7168 <GPIO_PinInit>
    GPIO_PinInit(m_pGpio_a3,  m_iPin_a3,  &gpio_config);
    a20c:	687b      	ldr	r3, [r7, #4]
    a20e:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    a210:	687b      	ldr	r3, [r7, #4]
    a212:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    a214:	f107 0208 	add.w	r2, r7, #8
    a218:	4619      	mov	r1, r3
    a21a:	f7fc ffa5 	bl	7168 <GPIO_PinInit>
    GPIO_PinInit(m_pGpio_a4,  m_iPin_a4,  &gpio_config);
    a21e:	687b      	ldr	r3, [r7, #4]
    a220:	6b18      	ldr	r0, [r3, #48]	; 0x30
    a222:	687b      	ldr	r3, [r7, #4]
    a224:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    a226:	f107 0208 	add.w	r2, r7, #8
    a22a:	4619      	mov	r1, r3
    a22c:	f7fc ff9c 	bl	7168 <GPIO_PinInit>

    select(ADG732::Channels::_MIN);
    a230:	2100      	movs	r1, #0
    a232:	6878      	ldr	r0, [r7, #4]
    a234:	f000 f806 	bl	a244 <_ZN6ADG7326selectENS_8Channels4TypeE>
}
    a238:	bf00      	nop
    a23a:	3710      	adds	r7, #16
    a23c:	46bd      	mov	sp, r7
    a23e:	bd80      	pop	{r7, pc}
    a240:	000102bc 	.word	0x000102bc

0000a244 <_ZN6ADG7326selectENS_8Channels4TypeE>:

void ADG732::select(ADG732::Channel channel)
{
    a244:	b580      	push	{r7, lr}
    a246:	b082      	sub	sp, #8
    a248:	af00      	add	r7, sp, #0
    a24a:	6078      	str	r0, [r7, #4]
    a24c:	460b      	mov	r3, r1
    a24e:	70fb      	strb	r3, [r7, #3]
    channel = (Channel) ( ( (unsigned int) channel )  & 0b11111 ) ;
    a250:	78fb      	ldrb	r3, [r7, #3]
    a252:	f003 031f 	and.w	r3, r3, #31
    a256:	70fb      	strb	r3, [r7, #3]

    _chipSelect(true);
    a258:	2101      	movs	r1, #1
    a25a:	6878      	ldr	r0, [r7, #4]
    a25c:	f000 f866 	bl	a32c <_ZN6ADG73211_chipSelectEb>
    _writeEnable(true);
    a260:	2101      	movs	r1, #1
    a262:	6878      	ldr	r0, [r7, #4]
    a264:	f000 f879 	bl	a35a <_ZN6ADG73212_writeEnableEb>
    GPIO_PinWrite(m_pGpio_a0, m_iPin_a0, ( ( channel & (1 << 0) ) ? 1 : 0 ) );
    a268:	687b      	ldr	r3, [r7, #4]
    a26a:	6a18      	ldr	r0, [r3, #32]
    a26c:	687b      	ldr	r3, [r7, #4]
    a26e:	6c19      	ldr	r1, [r3, #64]	; 0x40
    a270:	78fb      	ldrb	r3, [r7, #3]
    a272:	f003 0301 	and.w	r3, r3, #1
    a276:	b2db      	uxtb	r3, r3
    a278:	461a      	mov	r2, r3
    a27a:	f7ff fe9a 	bl	9fb2 <GPIO_PinWrite>
    GPIO_PinWrite(m_pGpio_a1, m_iPin_a1, ( ( channel & (1 << 1) ) ? 1 : 0 ) );
    a27e:	687b      	ldr	r3, [r7, #4]
    a280:	6a58      	ldr	r0, [r3, #36]	; 0x24
    a282:	687b      	ldr	r3, [r7, #4]
    a284:	6c59      	ldr	r1, [r3, #68]	; 0x44
    a286:	78fb      	ldrb	r3, [r7, #3]
    a288:	105b      	asrs	r3, r3, #1
    a28a:	b2db      	uxtb	r3, r3
    a28c:	f003 0301 	and.w	r3, r3, #1
    a290:	b2db      	uxtb	r3, r3
    a292:	461a      	mov	r2, r3
    a294:	f7ff fe8d 	bl	9fb2 <GPIO_PinWrite>
    GPIO_PinWrite(m_pGpio_a2, m_iPin_a2, ( ( channel & (1 << 2) ) ? 1 : 0 ) );
    a298:	687b      	ldr	r3, [r7, #4]
    a29a:	6a98      	ldr	r0, [r3, #40]	; 0x28
    a29c:	687b      	ldr	r3, [r7, #4]
    a29e:	6c99      	ldr	r1, [r3, #72]	; 0x48
    a2a0:	78fb      	ldrb	r3, [r7, #3]
    a2a2:	109b      	asrs	r3, r3, #2
    a2a4:	b2db      	uxtb	r3, r3
    a2a6:	f003 0301 	and.w	r3, r3, #1
    a2aa:	b2db      	uxtb	r3, r3
    a2ac:	461a      	mov	r2, r3
    a2ae:	f7ff fe80 	bl	9fb2 <GPIO_PinWrite>
    GPIO_PinWrite(m_pGpio_a3, m_iPin_a3, ( ( channel & (1 << 3) ) ? 1 : 0 ) );
    a2b2:	687b      	ldr	r3, [r7, #4]
    a2b4:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    a2b6:	687b      	ldr	r3, [r7, #4]
    a2b8:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
    a2ba:	78fb      	ldrb	r3, [r7, #3]
    a2bc:	10db      	asrs	r3, r3, #3
    a2be:	b2db      	uxtb	r3, r3
    a2c0:	f003 0301 	and.w	r3, r3, #1
    a2c4:	b2db      	uxtb	r3, r3
    a2c6:	461a      	mov	r2, r3
    a2c8:	f7ff fe73 	bl	9fb2 <GPIO_PinWrite>
    GPIO_PinWrite(m_pGpio_a4, m_iPin_a4, ( ( channel & (1 << 4) ) ? 1 : 0 ) );
    a2cc:	687b      	ldr	r3, [r7, #4]
    a2ce:	6b18      	ldr	r0, [r3, #48]	; 0x30
    a2d0:	687b      	ldr	r3, [r7, #4]
    a2d2:	6d19      	ldr	r1, [r3, #80]	; 0x50
    a2d4:	78fb      	ldrb	r3, [r7, #3]
    a2d6:	111b      	asrs	r3, r3, #4
    a2d8:	b2db      	uxtb	r3, r3
    a2da:	f003 0301 	and.w	r3, r3, #1
    a2de:	b2db      	uxtb	r3, r3
    a2e0:	461a      	mov	r2, r3
    a2e2:	f7ff fe66 	bl	9fb2 <GPIO_PinWrite>
    _writeEnable(false);
    a2e6:	2100      	movs	r1, #0
    a2e8:	6878      	ldr	r0, [r7, #4]
    a2ea:	f000 f836 	bl	a35a <_ZN6ADG73212_writeEnableEb>
    _chipSelect(false);
    a2ee:	2100      	movs	r1, #0
    a2f0:	6878      	ldr	r0, [r7, #4]
    a2f2:	f000 f81b 	bl	a32c <_ZN6ADG73211_chipSelectEb>
}
    a2f6:	bf00      	nop
    a2f8:	3708      	adds	r7, #8
    a2fa:	46bd      	mov	sp, r7
    a2fc:	bd80      	pop	{r7, pc}

0000a2fe <_ZN6ADG7326enableEb>:

void ADG732::enable(bool enable)
{
    a2fe:	b580      	push	{r7, lr}
    a300:	b082      	sub	sp, #8
    a302:	af00      	add	r7, sp, #0
    a304:	6078      	str	r0, [r7, #4]
    a306:	460b      	mov	r3, r1
    a308:	70fb      	strb	r3, [r7, #3]
    GPIO_PinWrite(m_pGpio_en, m_iPin_en, enable ? 0 : 1);
    a30a:	687b      	ldr	r3, [r7, #4]
    a30c:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
    a30e:	687b      	ldr	r3, [r7, #4]
    a310:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
    a312:	78fb      	ldrb	r3, [r7, #3]
    a314:	2b00      	cmp	r3, #0
    a316:	d001      	beq.n	a31c <_ZN6ADG7326enableEb+0x1e>
    a318:	2300      	movs	r3, #0
    a31a:	e000      	b.n	a31e <_ZN6ADG7326enableEb+0x20>
    a31c:	2301      	movs	r3, #1
    a31e:	461a      	mov	r2, r3
    a320:	f7ff fe47 	bl	9fb2 <GPIO_PinWrite>
}
    a324:	bf00      	nop
    a326:	3708      	adds	r7, #8
    a328:	46bd      	mov	sp, r7
    a32a:	bd80      	pop	{r7, pc}

0000a32c <_ZN6ADG73211_chipSelectEb>:

void ADG732::_chipSelect(bool chipSelect)
{
    a32c:	b580      	push	{r7, lr}
    a32e:	b082      	sub	sp, #8
    a330:	af00      	add	r7, sp, #0
    a332:	6078      	str	r0, [r7, #4]
    a334:	460b      	mov	r3, r1
    a336:	70fb      	strb	r3, [r7, #3]
    GPIO_PinWrite(m_pGpio_cs, m_iPin_cs, chipSelect ? 0 : 1);
    a338:	687b      	ldr	r3, [r7, #4]
    a33a:	6b58      	ldr	r0, [r3, #52]	; 0x34
    a33c:	687b      	ldr	r3, [r7, #4]
    a33e:	6d59      	ldr	r1, [r3, #84]	; 0x54
    a340:	78fb      	ldrb	r3, [r7, #3]
    a342:	2b00      	cmp	r3, #0
    a344:	d001      	beq.n	a34a <_ZN6ADG73211_chipSelectEb+0x1e>
    a346:	2300      	movs	r3, #0
    a348:	e000      	b.n	a34c <_ZN6ADG73211_chipSelectEb+0x20>
    a34a:	2301      	movs	r3, #1
    a34c:	461a      	mov	r2, r3
    a34e:	f7ff fe30 	bl	9fb2 <GPIO_PinWrite>
}
    a352:	bf00      	nop
    a354:	3708      	adds	r7, #8
    a356:	46bd      	mov	sp, r7
    a358:	bd80      	pop	{r7, pc}

0000a35a <_ZN6ADG73212_writeEnableEb>:

void ADG732::_writeEnable(bool writeEnable)
{
    a35a:	b580      	push	{r7, lr}
    a35c:	b082      	sub	sp, #8
    a35e:	af00      	add	r7, sp, #0
    a360:	6078      	str	r0, [r7, #4]
    a362:	460b      	mov	r3, r1
    a364:	70fb      	strb	r3, [r7, #3]
    GPIO_PinWrite(m_pGpio_wr, m_iPin_wr, writeEnable ? 0 : 1);
    a366:	687b      	ldr	r3, [r7, #4]
    a368:	6b98      	ldr	r0, [r3, #56]	; 0x38
    a36a:	687b      	ldr	r3, [r7, #4]
    a36c:	6d99      	ldr	r1, [r3, #88]	; 0x58
    a36e:	78fb      	ldrb	r3, [r7, #3]
    a370:	2b00      	cmp	r3, #0
    a372:	d001      	beq.n	a378 <_ZN6ADG73212_writeEnableEb+0x1e>
    a374:	2300      	movs	r3, #0
    a376:	e000      	b.n	a37a <_ZN6ADG73212_writeEnableEb+0x20>
    a378:	2301      	movs	r3, #1
    a37a:	461a      	mov	r2, r3
    a37c:	f7ff fe19 	bl	9fb2 <GPIO_PinWrite>
    a380:	bf00      	nop
    a382:	3708      	adds	r7, #8
    a384:	46bd      	mov	sp, r7
    a386:	bd80      	pop	{r7, pc}

0000a388 <PORT_SetPinMux>:
{
    a388:	b480      	push	{r7}
    a38a:	b085      	sub	sp, #20
    a38c:	af00      	add	r7, sp, #0
    a38e:	60f8      	str	r0, [r7, #12]
    a390:	60b9      	str	r1, [r7, #8]
    a392:	4613      	mov	r3, r2
    a394:	71fb      	strb	r3, [r7, #7]
    base->PCR[pin] = (base->PCR[pin] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(mux);
    a396:	68fb      	ldr	r3, [r7, #12]
    a398:	68ba      	ldr	r2, [r7, #8]
    a39a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    a39e:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
    a3a2:	79fb      	ldrb	r3, [r7, #7]
    a3a4:	021b      	lsls	r3, r3, #8
    a3a6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    a3aa:	ea42 0103 	orr.w	r1, r2, r3
    a3ae:	68fb      	ldr	r3, [r7, #12]
    a3b0:	68ba      	ldr	r2, [r7, #8]
    a3b2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    a3b6:	bf00      	nop
    a3b8:	3714      	adds	r7, #20
    a3ba:	46bd      	mov	sp, r7
    a3bc:	f85d 7b04 	ldr.w	r7, [sp], #4
    a3c0:	4770      	bx	lr

0000a3c2 <DSPI_ClearStatusFlags>:
 *
 * @param base DSPI peripheral address.
 * @param statusFlags The status flag used from the type dspi_flags.
 */
static inline void DSPI_ClearStatusFlags(SPI_Type *base, uint32_t statusFlags)
{
    a3c2:	b480      	push	{r7}
    a3c4:	b083      	sub	sp, #12
    a3c6:	af00      	add	r7, sp, #0
    a3c8:	6078      	str	r0, [r7, #4]
    a3ca:	6039      	str	r1, [r7, #0]
    base->SR = statusFlags; /*!< The status flags are cleared by writing 1 (w1c).*/
    a3cc:	687b      	ldr	r3, [r7, #4]
    a3ce:	683a      	ldr	r2, [r7, #0]
    a3d0:	62da      	str	r2, [r3, #44]	; 0x2c
}
    a3d2:	bf00      	nop
    a3d4:	370c      	adds	r7, #12
    a3d6:	46bd      	mov	sp, r7
    a3d8:	f85d 7b04 	ldr.w	r7, [sp], #4
    a3dc:	4770      	bx	lr

0000a3de <DSPI_StartTransfer>:
 * This function sets the module to start data transfer in either master or slave mode.
 *
 * @param base DSPI peripheral address.
 */
static inline void DSPI_StartTransfer(SPI_Type *base)
{
    a3de:	b480      	push	{r7}
    a3e0:	b083      	sub	sp, #12
    a3e2:	af00      	add	r7, sp, #0
    a3e4:	6078      	str	r0, [r7, #4]
    base->MCR &= ~SPI_MCR_HALT_MASK;
    a3e6:	687b      	ldr	r3, [r7, #4]
    a3e8:	681b      	ldr	r3, [r3, #0]
    a3ea:	f023 0201 	bic.w	r2, r3, #1
    a3ee:	687b      	ldr	r3, [r7, #4]
    a3f0:	601a      	str	r2, [r3, #0]
}
    a3f2:	bf00      	nop
    a3f4:	370c      	adds	r7, #12
    a3f6:	46bd      	mov	sp, r7
    a3f8:	f85d 7b04 	ldr.w	r7, [sp], #4
    a3fc:	4770      	bx	lr

0000a3fe <DSPI_StopTransfer>:
 * This function stops data transfers in either master or slave modes.
 *
 * @param base DSPI peripheral address.
 */
static inline void DSPI_StopTransfer(SPI_Type *base)
{
    a3fe:	b480      	push	{r7}
    a400:	b083      	sub	sp, #12
    a402:	af00      	add	r7, sp, #0
    a404:	6078      	str	r0, [r7, #4]
    base->MCR |= SPI_MCR_HALT_MASK;
    a406:	687b      	ldr	r3, [r7, #4]
    a408:	681b      	ldr	r3, [r3, #0]
    a40a:	f043 0201 	orr.w	r2, r3, #1
    a40e:	687b      	ldr	r3, [r7, #4]
    a410:	601a      	str	r2, [r3, #0]
}
    a412:	bf00      	nop
    a414:	370c      	adds	r7, #12
    a416:	46bd      	mov	sp, r7
    a418:	f85d 7b04 	ldr.w	r7, [sp], #4
    a41c:	4770      	bx	lr

0000a41e <DSPI_FlushFifo>:
 * @param base DSPI peripheral address.
 * @param flushTxFifo Flushes (true) the Tx FIFO; Otherwise, does not flush (false) the Tx FIFO
 * @param flushRxFifo Flushes (true) the Rx FIFO; Otherwise, does not flush (false) the Rx FIFO
 */
static inline void DSPI_FlushFifo(SPI_Type *base, bool flushTxFifo, bool flushRxFifo)
{
    a41e:	b480      	push	{r7}
    a420:	b083      	sub	sp, #12
    a422:	af00      	add	r7, sp, #0
    a424:	6078      	str	r0, [r7, #4]
    a426:	460b      	mov	r3, r1
    a428:	70fb      	strb	r3, [r7, #3]
    a42a:	4613      	mov	r3, r2
    a42c:	70bb      	strb	r3, [r7, #2]
    base->MCR = (base->MCR & (~(SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK))) |
    a42e:	687b      	ldr	r3, [r7, #4]
    a430:	681b      	ldr	r3, [r3, #0]
    a432:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
                SPI_MCR_CLR_TXF((true == flushTxFifo ? 1U : 0U)) | SPI_MCR_CLR_RXF((true == flushRxFifo ? 1U : 0U));
    a436:	78fa      	ldrb	r2, [r7, #3]
    a438:	2a01      	cmp	r2, #1
    a43a:	d102      	bne.n	a442 <DSPI_FlushFifo+0x24>
    a43c:	f44f 6200 	mov.w	r2, #2048	; 0x800
    a440:	e000      	b.n	a444 <DSPI_FlushFifo+0x26>
    a442:	2200      	movs	r2, #0
    base->MCR = (base->MCR & (~(SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK))) |
    a444:	4313      	orrs	r3, r2
                SPI_MCR_CLR_TXF((true == flushTxFifo ? 1U : 0U)) | SPI_MCR_CLR_RXF((true == flushRxFifo ? 1U : 0U));
    a446:	78ba      	ldrb	r2, [r7, #2]
    a448:	2a01      	cmp	r2, #1
    a44a:	d102      	bne.n	a452 <DSPI_FlushFifo+0x34>
    a44c:	f44f 6280 	mov.w	r2, #1024	; 0x400
    a450:	e000      	b.n	a454 <DSPI_FlushFifo+0x36>
    a452:	2200      	movs	r2, #0
    a454:	431a      	orrs	r2, r3
    base->MCR = (base->MCR & (~(SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK))) |
    a456:	687b      	ldr	r3, [r7, #4]
    a458:	601a      	str	r2, [r3, #0]
}
    a45a:	bf00      	nop
    a45c:	370c      	adds	r7, #12
    a45e:	46bd      	mov	sp, r7
    a460:	f85d 7b04 	ldr.w	r7, [sp], #4
    a464:	4770      	bx	lr

0000a466 <_ZN6AD5262C1EP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configP9PORT_Typem9_port_muxS5_mS6_S5_mS6_m>:
#include "AD5262.h"

AD5262::AD5262(SPI_Type *spiBase,
    a466:	b480      	push	{r7}
    a468:	b085      	sub	sp, #20
    a46a:	af00      	add	r7, sp, #0
    a46c:	60f8      	str	r0, [r7, #12]
    a46e:	60b9      	str	r1, [r7, #8]
    a470:	4611      	mov	r1, r2
    a472:	461a      	mov	r2, r3
    a474:	460b      	mov	r3, r1
    a476:	71fb      	strb	r3, [r7, #7]
    a478:	4613      	mov	r3, r2
    a47a:	71bb      	strb	r3, [r7, #6]
               PORT_Type * port_MOSI, uint32_t pin_MOSI, port_mux_t mux_MOSI,
               PORT_Type * port_CLK , uint32_t pin_CLK , port_mux_t mux_CLK ,
               PORT_Type * port_CS  , uint32_t pin_CS  , port_mux_t mux_CS  ,
               uint32_t maxResistance_ohms) 
               :
    m_spiBase (spiBase),
    a47c:	68fb      	ldr	r3, [r7, #12]
    a47e:	68ba      	ldr	r2, [r7, #8]
    a480:	601a      	str	r2, [r3, #0]

    m_whichCTAR ( whichCTAR ),
    a482:	68fb      	ldr	r3, [r7, #12]
    a484:	79fa      	ldrb	r2, [r7, #7]
    a486:	711a      	strb	r2, [r3, #4]
    m_whichPCS  ( whichPCS ),
    a488:	68fb      	ldr	r3, [r7, #12]
    a48a:	79ba      	ldrb	r2, [r7, #6]
    a48c:	715a      	strb	r2, [r3, #5]

    m_pPort_MOSI( port_MOSI ),
    a48e:	68fb      	ldr	r3, [r7, #12]
    a490:	69ba      	ldr	r2, [r7, #24]
    a492:	609a      	str	r2, [r3, #8]
    m_pPort_CLK ( port_CLK  ),
    a494:	68fb      	ldr	r3, [r7, #12]
    a496:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    a498:	60da      	str	r2, [r3, #12]
    m_pPort_CS  ( port_CS   ),
    a49a:	68fb      	ldr	r3, [r7, #12]
    a49c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    a49e:	611a      	str	r2, [r3, #16]

    m_iPin_MOSI ( pin_MOSI  ),
    a4a0:	68fb      	ldr	r3, [r7, #12]
    a4a2:	69fa      	ldr	r2, [r7, #28]
    a4a4:	615a      	str	r2, [r3, #20]
    m_iPin_CLK  ( pin_CLK   ),
    a4a6:	68fb      	ldr	r3, [r7, #12]
    a4a8:	6aba      	ldr	r2, [r7, #40]	; 0x28
    a4aa:	619a      	str	r2, [r3, #24]
    m_iPin_CS   ( pin_CS    ),
    a4ac:	68fb      	ldr	r3, [r7, #12]
    a4ae:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    a4b0:	61da      	str	r2, [r3, #28]

    m_mux_MOSI  ( mux_MOSI  ),
    a4b2:	68fb      	ldr	r3, [r7, #12]
    a4b4:	f897 2020 	ldrb.w	r2, [r7, #32]
    a4b8:	f883 2020 	strb.w	r2, [r3, #32]
    m_mux_CLK   ( mux_CLK   ),
    a4bc:	68fb      	ldr	r3, [r7, #12]
    a4be:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
    a4c2:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    m_mux_CS    ( mux_CS    ),
    a4c6:	68fb      	ldr	r3, [r7, #12]
    a4c8:	f897 2038 	ldrb.w	r2, [r7, #56]	; 0x38
    a4cc:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

    m_iMaxResistance_ohms ( maxResistance_ohms )
    a4d0:	68fb      	ldr	r3, [r7, #12]
    a4d2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    a4d4:	625a      	str	r2, [r3, #36]	; 0x24
{

}
    a4d6:	68fb      	ldr	r3, [r7, #12]
    a4d8:	4618      	mov	r0, r3
    a4da:	3714      	adds	r7, #20
    a4dc:	46bd      	mov	sp, r7
    a4de:	f85d 7b04 	ldr.w	r7, [sp], #4
    a4e2:	4770      	bx	lr

0000a4e4 <_ZN6AD52624initEv>:

void AD5262::init()
{
    a4e4:	b580      	push	{r7, lr}
    a4e6:	b08e      	sub	sp, #56	; 0x38
    a4e8:	af00      	add	r7, sp, #0
    a4ea:	6078      	str	r0, [r7, #4]
    dspi_master_config_t masterConfig;

    const uint32_t transferBaudrate = 500000U ; // Max = 25 MHz
    a4ec:	4b2a      	ldr	r3, [pc, #168]	; (a598 <_ZN6AD52624initEv+0xb4>)
    a4ee:	637b      	str	r3, [r7, #52]	; 0x34

    masterConfig.whichCtar                                = m_whichCTAR;
    a4f0:	687b      	ldr	r3, [r7, #4]
    a4f2:	791b      	ldrb	r3, [r3, #4]
    a4f4:	733b      	strb	r3, [r7, #12]
    masterConfig.ctarConfig.baudRate                      = transferBaudrate;
    a4f6:	4b28      	ldr	r3, [pc, #160]	; (a598 <_ZN6AD52624initEv+0xb4>)
    a4f8:	613b      	str	r3, [r7, #16]
    masterConfig.ctarConfig.bitsPerFrame                  = 9; // Address + Data
    a4fa:	2309      	movs	r3, #9
    a4fc:	617b      	str	r3, [r7, #20]
    masterConfig.ctarConfig.cpol                          = kDSPI_ClockPolarityActiveHigh;
    a4fe:	2300      	movs	r3, #0
    a500:	763b      	strb	r3, [r7, #24]
    masterConfig.ctarConfig.cpha                          = kDSPI_ClockPhaseFirstEdge;
    a502:	2300      	movs	r3, #0
    a504:	767b      	strb	r3, [r7, #25]
    masterConfig.ctarConfig.direction                     = kDSPI_MsbFirst;
    a506:	2300      	movs	r3, #0
    a508:	76bb      	strb	r3, [r7, #26]
    masterConfig.ctarConfig.pcsToSckDelayInNanoSec        = 50;  // datasheet: 5ns ,
    a50a:	2332      	movs	r3, #50	; 0x32
    a50c:	61fb      	str	r3, [r7, #28]
    masterConfig.ctarConfig.lastSckToPcsDelayInNanoSec    = 50;  // datasheet: 0ns ,
    a50e:	2332      	movs	r3, #50	; 0x32
    a510:	623b      	str	r3, [r7, #32]
    masterConfig.ctarConfig.betweenTransferDelayInNanoSec = 50;  // datasheet: 20ns
    a512:	2332      	movs	r3, #50	; 0x32
    a514:	627b      	str	r3, [r7, #36]	; 0x24

    masterConfig.whichPcs                   = m_whichPCS;
    a516:	687b      	ldr	r3, [r7, #4]
    a518:	795b      	ldrb	r3, [r3, #5]
    a51a:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    masterConfig.pcsActiveHighOrLow         = kDSPI_PcsActiveLow;
    a51e:	2301      	movs	r3, #1
    a520:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29

    masterConfig.enableContinuousSCK        = false;
    a524:	2300      	movs	r3, #0
    a526:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
    masterConfig.enableRxFifoOverWrite      = true;
    a52a:	2301      	movs	r3, #1
    a52c:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    masterConfig.enableModifiedTimingFormat = false;
    a530:	2300      	movs	r3, #0
    a532:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    masterConfig.samplePoint                = kDSPI_SckToSin0Clock;
    a536:	2300      	movs	r3, #0
    a538:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    
    uint32_t srcFreq_hz = CLOCK_GetFreq(BUS_CLK);
    a53c:	2002      	movs	r0, #2
    a53e:	f7fd f947 	bl	77d0 <CLOCK_GetFreq>
    a542:	6338      	str	r0, [r7, #48]	; 0x30
    PORT_SetPinMux(m_pPort_MOSI, m_iPin_MOSI, m_mux_MOSI);
    a544:	687b      	ldr	r3, [r7, #4]
    a546:	6898      	ldr	r0, [r3, #8]
    a548:	687b      	ldr	r3, [r7, #4]
    a54a:	6959      	ldr	r1, [r3, #20]
    a54c:	687b      	ldr	r3, [r7, #4]
    a54e:	f893 3020 	ldrb.w	r3, [r3, #32]
    a552:	461a      	mov	r2, r3
    a554:	f7ff ff18 	bl	a388 <PORT_SetPinMux>
    PORT_SetPinMux(m_pPort_CLK , m_iPin_CLK , m_mux_CLK );
    a558:	687b      	ldr	r3, [r7, #4]
    a55a:	68d8      	ldr	r0, [r3, #12]
    a55c:	687b      	ldr	r3, [r7, #4]
    a55e:	6999      	ldr	r1, [r3, #24]
    a560:	687b      	ldr	r3, [r7, #4]
    a562:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    a566:	461a      	mov	r2, r3
    a568:	f7ff ff0e 	bl	a388 <PORT_SetPinMux>
    PORT_SetPinMux(m_pPort_CS  , m_iPin_CS  , m_mux_CS  );
    a56c:	687b      	ldr	r3, [r7, #4]
    a56e:	6918      	ldr	r0, [r3, #16]
    a570:	687b      	ldr	r3, [r7, #4]
    a572:	69d9      	ldr	r1, [r3, #28]
    a574:	687b      	ldr	r3, [r7, #4]
    a576:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    a57a:	461a      	mov	r2, r3
    a57c:	f7ff ff04 	bl	a388 <PORT_SetPinMux>
    DSPI_MasterInit(m_spiBase, &masterConfig, srcFreq_hz);
    a580:	687b      	ldr	r3, [r7, #4]
    a582:	681b      	ldr	r3, [r3, #0]
    a584:	f107 010c 	add.w	r1, r7, #12
    a588:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    a58a:	4618      	mov	r0, r3
    a58c:	f000 fdd4 	bl	b138 <DSPI_MasterInit>

}
    a590:	bf00      	nop
    a592:	3738      	adds	r7, #56	; 0x38
    a594:	46bd      	mov	sp, r7
    a596:	bd80      	pop	{r7, pc}
    a598:	0007a120 	.word	0x0007a120

0000a59c <_ZN6AD526213setResistanceENS_8Channels4TypeEm>:

void AD5262::setResistance(Channel channel, uint32_t resistance_ohms) 
{
    a59c:	b580      	push	{r7, lr}
    a59e:	b088      	sub	sp, #32
    a5a0:	af00      	add	r7, sp, #0
    a5a2:	60f8      	str	r0, [r7, #12]
    a5a4:	460b      	mov	r3, r1
    a5a6:	607a      	str	r2, [r7, #4]
    a5a8:	72fb      	strb	r3, [r7, #11]
    const uint32_t Rw = 60;
    a5aa:	233c      	movs	r3, #60	; 0x3c
    a5ac:	61fb      	str	r3, [r7, #28]
    uint16_t command = ((channel & 1) << 8);
    a5ae:	7afb      	ldrb	r3, [r7, #11]
    a5b0:	021b      	lsls	r3, r3, #8
    a5b2:	b29b      	uxth	r3, r3
    a5b4:	f403 7380 	and.w	r3, r3, #256	; 0x100
    a5b8:	837b      	strh	r3, [r7, #26]
    if ( resistance_ohms > (m_iMaxResistance_ohms + Rw ) )
    a5ba:	68fb      	ldr	r3, [r7, #12]
    a5bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    a5be:	333c      	adds	r3, #60	; 0x3c
    a5c0:	687a      	ldr	r2, [r7, #4]
    a5c2:	429a      	cmp	r2, r3
    a5c4:	d904      	bls.n	a5d0 <_ZN6AD526213setResistanceENS_8Channels4TypeEm+0x34>
    {
        resistance_ohms = (m_iMaxResistance_ohms + Rw );
    a5c6:	68fb      	ldr	r3, [r7, #12]
    a5c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    a5ca:	333c      	adds	r3, #60	; 0x3c
    a5cc:	607b      	str	r3, [r7, #4]
    a5ce:	e004      	b.n	a5da <_ZN6AD526213setResistanceENS_8Channels4TypeEm+0x3e>
    } 
    else if ( resistance_ohms < Rw) 
    a5d0:	687b      	ldr	r3, [r7, #4]
    a5d2:	2b3b      	cmp	r3, #59	; 0x3b
    a5d4:	d801      	bhi.n	a5da <_ZN6AD526213setResistanceENS_8Channels4TypeEm+0x3e>
    {
        resistance_ohms = Rw;
    a5d6:	233c      	movs	r3, #60	; 0x3c
    a5d8:	607b      	str	r3, [r7, #4]
    }
    
    command |= 0xFF & ( ((resistance_ohms - Rw) * 256) / m_iMaxResistance_ohms );
    a5da:	687b      	ldr	r3, [r7, #4]
    a5dc:	3b3c      	subs	r3, #60	; 0x3c
    a5de:	021a      	lsls	r2, r3, #8
    a5e0:	68fb      	ldr	r3, [r7, #12]
    a5e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    a5e4:	fbb2 f3f3 	udiv	r3, r2, r3
    a5e8:	b29b      	uxth	r3, r3
    a5ea:	b2db      	uxtb	r3, r3
    a5ec:	b29a      	uxth	r2, r3
    a5ee:	8b7b      	ldrh	r3, [r7, #26]
    a5f0:	4313      	orrs	r3, r2
    a5f2:	837b      	strh	r3, [r7, #26]
    //DSPI_MasterWriteCommandDataBlocking(m_spiBase, command);

    dspi_command_data_config_t commandConfig;
    commandConfig.isPcsContinuous    = false;
    a5f4:	2300      	movs	r3, #0
    a5f6:	753b      	strb	r3, [r7, #20]
    commandConfig.whichCtar          = m_whichCTAR;
    a5f8:	68fb      	ldr	r3, [r7, #12]
    a5fa:	791b      	ldrb	r3, [r3, #4]
    a5fc:	757b      	strb	r3, [r7, #21]
    commandConfig.whichPcs           = m_whichPCS;
    a5fe:	68fb      	ldr	r3, [r7, #12]
    a600:	795b      	ldrb	r3, [r3, #5]
    a602:	75bb      	strb	r3, [r7, #22]
    commandConfig.clearTransferCount = true;
    a604:	2301      	movs	r3, #1
    a606:	763b      	strb	r3, [r7, #24]
    commandConfig.isEndOfQueue = true;
    a608:	2301      	movs	r3, #1
    a60a:	75fb      	strb	r3, [r7, #23]

    DSPI_StopTransfer(m_spiBase);
    a60c:	68fb      	ldr	r3, [r7, #12]
    a60e:	681b      	ldr	r3, [r3, #0]
    a610:	4618      	mov	r0, r3
    a612:	f7ff fef4 	bl	a3fe <DSPI_StopTransfer>
    DSPI_FlushFifo(m_spiBase, true, true);
    a616:	68fb      	ldr	r3, [r7, #12]
    a618:	681b      	ldr	r3, [r3, #0]
    a61a:	2201      	movs	r2, #1
    a61c:	2101      	movs	r1, #1
    a61e:	4618      	mov	r0, r3
    a620:	f7ff fefd 	bl	a41e <DSPI_FlushFifo>
    DSPI_ClearStatusFlags(m_spiBase, (uint32_t)kDSPI_AllStatusFlag);
    a624:	68fb      	ldr	r3, [r7, #12]
    a626:	681b      	ldr	r3, [r3, #0]
    a628:	490a      	ldr	r1, [pc, #40]	; (a654 <_ZN6AD526213setResistanceENS_8Channels4TypeEm+0xb8>)
    a62a:	4618      	mov	r0, r3
    a62c:	f7ff fec9 	bl	a3c2 <DSPI_ClearStatusFlags>
    DSPI_StartTransfer(m_spiBase);
    a630:	68fb      	ldr	r3, [r7, #12]
    a632:	681b      	ldr	r3, [r3, #0]
    a634:	4618      	mov	r0, r3
    a636:	f7ff fed2 	bl	a3de <DSPI_StartTransfer>
    DSPI_MasterWriteDataBlocking(m_spiBase, &commandConfig, command);
    a63a:	68fb      	ldr	r3, [r7, #12]
    a63c:	681b      	ldr	r3, [r3, #0]
    a63e:	8b7a      	ldrh	r2, [r7, #26]
    a640:	f107 0114 	add.w	r1, r7, #20
    a644:	4618      	mov	r0, r3
    a646:	f001 f809 	bl	b65c <DSPI_MasterWriteDataBlocking>
    a64a:	bf00      	nop
    a64c:	3720      	adds	r7, #32
    a64e:	46bd      	mov	sp, r7
    a650:	bd80      	pop	{r7, pc}
    a652:	bf00      	nop
    a654:	da0a0000 	.word	0xda0a0000

0000a658 <PORT_SetPinMux>:
{
    a658:	b480      	push	{r7}
    a65a:	b085      	sub	sp, #20
    a65c:	af00      	add	r7, sp, #0
    a65e:	60f8      	str	r0, [r7, #12]
    a660:	60b9      	str	r1, [r7, #8]
    a662:	4613      	mov	r3, r2
    a664:	71fb      	strb	r3, [r7, #7]
    base->PCR[pin] = (base->PCR[pin] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(mux);
    a666:	68fb      	ldr	r3, [r7, #12]
    a668:	68ba      	ldr	r2, [r7, #8]
    a66a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    a66e:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
    a672:	79fb      	ldrb	r3, [r7, #7]
    a674:	021b      	lsls	r3, r3, #8
    a676:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    a67a:	ea42 0103 	orr.w	r1, r2, r3
    a67e:	68fb      	ldr	r3, [r7, #12]
    a680:	68ba      	ldr	r2, [r7, #8]
    a682:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    a686:	bf00      	nop
    a688:	3714      	adds	r7, #20
    a68a:	46bd      	mov	sp, r7
    a68c:	f85d 7b04 	ldr.w	r7, [sp], #4
    a690:	4770      	bx	lr

0000a692 <DSPI_ClearStatusFlags>:
{
    a692:	b480      	push	{r7}
    a694:	b083      	sub	sp, #12
    a696:	af00      	add	r7, sp, #0
    a698:	6078      	str	r0, [r7, #4]
    a69a:	6039      	str	r1, [r7, #0]
    base->SR = statusFlags; /*!< The status flags are cleared by writing 1 (w1c).*/
    a69c:	687b      	ldr	r3, [r7, #4]
    a69e:	683a      	ldr	r2, [r7, #0]
    a6a0:	62da      	str	r2, [r3, #44]	; 0x2c
}
    a6a2:	bf00      	nop
    a6a4:	370c      	adds	r7, #12
    a6a6:	46bd      	mov	sp, r7
    a6a8:	f85d 7b04 	ldr.w	r7, [sp], #4
    a6ac:	4770      	bx	lr

0000a6ae <DSPI_StartTransfer>:
{
    a6ae:	b480      	push	{r7}
    a6b0:	b083      	sub	sp, #12
    a6b2:	af00      	add	r7, sp, #0
    a6b4:	6078      	str	r0, [r7, #4]
    base->MCR &= ~SPI_MCR_HALT_MASK;
    a6b6:	687b      	ldr	r3, [r7, #4]
    a6b8:	681b      	ldr	r3, [r3, #0]
    a6ba:	f023 0201 	bic.w	r2, r3, #1
    a6be:	687b      	ldr	r3, [r7, #4]
    a6c0:	601a      	str	r2, [r3, #0]
}
    a6c2:	bf00      	nop
    a6c4:	370c      	adds	r7, #12
    a6c6:	46bd      	mov	sp, r7
    a6c8:	f85d 7b04 	ldr.w	r7, [sp], #4
    a6cc:	4770      	bx	lr

0000a6ce <DSPI_StopTransfer>:
{
    a6ce:	b480      	push	{r7}
    a6d0:	b083      	sub	sp, #12
    a6d2:	af00      	add	r7, sp, #0
    a6d4:	6078      	str	r0, [r7, #4]
    base->MCR |= SPI_MCR_HALT_MASK;
    a6d6:	687b      	ldr	r3, [r7, #4]
    a6d8:	681b      	ldr	r3, [r3, #0]
    a6da:	f043 0201 	orr.w	r2, r3, #1
    a6de:	687b      	ldr	r3, [r7, #4]
    a6e0:	601a      	str	r2, [r3, #0]
}
    a6e2:	bf00      	nop
    a6e4:	370c      	adds	r7, #12
    a6e6:	46bd      	mov	sp, r7
    a6e8:	f85d 7b04 	ldr.w	r7, [sp], #4
    a6ec:	4770      	bx	lr

0000a6ee <DSPI_FlushFifo>:
{
    a6ee:	b480      	push	{r7}
    a6f0:	b083      	sub	sp, #12
    a6f2:	af00      	add	r7, sp, #0
    a6f4:	6078      	str	r0, [r7, #4]
    a6f6:	460b      	mov	r3, r1
    a6f8:	70fb      	strb	r3, [r7, #3]
    a6fa:	4613      	mov	r3, r2
    a6fc:	70bb      	strb	r3, [r7, #2]
    base->MCR = (base->MCR & (~(SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK))) |
    a6fe:	687b      	ldr	r3, [r7, #4]
    a700:	681b      	ldr	r3, [r3, #0]
    a702:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
                SPI_MCR_CLR_TXF((true == flushTxFifo ? 1U : 0U)) | SPI_MCR_CLR_RXF((true == flushRxFifo ? 1U : 0U));
    a706:	78fa      	ldrb	r2, [r7, #3]
    a708:	2a01      	cmp	r2, #1
    a70a:	d102      	bne.n	a712 <DSPI_FlushFifo+0x24>
    a70c:	f44f 6200 	mov.w	r2, #2048	; 0x800
    a710:	e000      	b.n	a714 <DSPI_FlushFifo+0x26>
    a712:	2200      	movs	r2, #0
    base->MCR = (base->MCR & (~(SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK))) |
    a714:	4313      	orrs	r3, r2
                SPI_MCR_CLR_TXF((true == flushTxFifo ? 1U : 0U)) | SPI_MCR_CLR_RXF((true == flushRxFifo ? 1U : 0U));
    a716:	78ba      	ldrb	r2, [r7, #2]
    a718:	2a01      	cmp	r2, #1
    a71a:	d102      	bne.n	a722 <DSPI_FlushFifo+0x34>
    a71c:	f44f 6280 	mov.w	r2, #1024	; 0x400
    a720:	e000      	b.n	a724 <DSPI_FlushFifo+0x36>
    a722:	2200      	movs	r2, #0
    a724:	431a      	orrs	r2, r3
    base->MCR = (base->MCR & (~(SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK))) |
    a726:	687b      	ldr	r3, [r7, #4]
    a728:	601a      	str	r2, [r3, #0]
}
    a72a:	bf00      	nop
    a72c:	370c      	adds	r7, #12
    a72e:	46bd      	mov	sp, r7
    a730:	f85d 7b04 	ldr.w	r7, [sp], #4
    a734:	4770      	bx	lr

0000a736 <_ZN6AD9833C1EP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configP9PORT_Typem9_port_muxS5_mS6_S5_mS6_m>:
    SleepModeValues::DACPowerDown               , // SleepModes::DACPowerDown               
    SleepModeValues::InternalClockDisabled      , // SleepModes::InternalClockDisabled      
    SleepModeValues::DACAndInternalClockDisabled, // SleepModes::DACAndInternalClockDisabled
};

AD9833::AD9833(SPI_Type * spiBase,
    a736:	b480      	push	{r7}
    a738:	b085      	sub	sp, #20
    a73a:	af00      	add	r7, sp, #0
    a73c:	60f8      	str	r0, [r7, #12]
    a73e:	60b9      	str	r1, [r7, #8]
    a740:	4611      	mov	r1, r2
    a742:	461a      	mov	r2, r3
    a744:	460b      	mov	r3, r1
    a746:	71fb      	strb	r3, [r7, #7]
    a748:	4613      	mov	r3, r2
    a74a:	71bb      	strb	r3, [r7, #6]
               PORT_Type * port_MOSI, uint32_t pin_MOSI, port_mux_t mux_MOSI,
               PORT_Type * port_CLK , uint32_t pin_CLK , port_mux_t mux_CLK ,
               PORT_Type * port_CS  , uint32_t pin_CS  , port_mux_t mux_CS,
               uint32_t iMClockFrequency_hertz)
               :
    m_spiBase (spiBase),
    a74c:	68fb      	ldr	r3, [r7, #12]
    a74e:	68ba      	ldr	r2, [r7, #8]
    a750:	601a      	str	r2, [r3, #0]

    m_whichCTAR ( whichCTAR ),
    a752:	68fb      	ldr	r3, [r7, #12]
    a754:	79fa      	ldrb	r2, [r7, #7]
    a756:	711a      	strb	r2, [r3, #4]
    m_whichPCS  ( whichPCS ),
    a758:	68fb      	ldr	r3, [r7, #12]
    a75a:	79ba      	ldrb	r2, [r7, #6]
    a75c:	715a      	strb	r2, [r3, #5]

    m_pPort_MOSI( port_MOSI ),
    a75e:	68fb      	ldr	r3, [r7, #12]
    a760:	69ba      	ldr	r2, [r7, #24]
    a762:	609a      	str	r2, [r3, #8]
    m_pPort_CLK ( port_CLK  ),
    a764:	68fb      	ldr	r3, [r7, #12]
    a766:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    a768:	60da      	str	r2, [r3, #12]
    m_pPort_CS  ( port_CS   ),
    a76a:	68fb      	ldr	r3, [r7, #12]
    a76c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    a76e:	611a      	str	r2, [r3, #16]

    m_iPin_MOSI ( pin_MOSI  ),
    a770:	68fb      	ldr	r3, [r7, #12]
    a772:	69fa      	ldr	r2, [r7, #28]
    a774:	615a      	str	r2, [r3, #20]
    m_iPin_CLK  ( pin_CLK   ),
    a776:	68fb      	ldr	r3, [r7, #12]
    a778:	6aba      	ldr	r2, [r7, #40]	; 0x28
    a77a:	619a      	str	r2, [r3, #24]
    m_iPin_CS   ( pin_CS    ),
    a77c:	68fb      	ldr	r3, [r7, #12]
    a77e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    a780:	61da      	str	r2, [r3, #28]

    m_mux_MOSI  ( mux_MOSI  ),
    a782:	68fb      	ldr	r3, [r7, #12]
    a784:	f897 2020 	ldrb.w	r2, [r7, #32]
    a788:	f883 2020 	strb.w	r2, [r3, #32]
    m_mux_CLK   ( mux_CLK   ),
    a78c:	68fb      	ldr	r3, [r7, #12]
    a78e:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
    a792:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    m_mux_CS    ( mux_CS    ),
    a796:	68fb      	ldr	r3, [r7, #12]
    a798:	f897 2038 	ldrb.w	r2, [r7, #56]	; 0x38
    a79c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

    m_iMClockFrequency_hertz ( iMClockFrequency_hertz ),
    a7a0:	68fb      	ldr	r3, [r7, #12]
    a7a2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    a7a4:	625a      	str	r2, [r3, #36]	; 0x24

    m_sControl(WriteModeValues::FullWord | SleepModeValues::NoPowerDown  | OutputModeValues::Sinusoid )
    a7a6:	68fb      	ldr	r3, [r7, #12]
    a7a8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    a7ac:	851a      	strh	r2, [r3, #40]	; 0x28
{

}
    a7ae:	68fb      	ldr	r3, [r7, #12]
    a7b0:	4618      	mov	r0, r3
    a7b2:	3714      	adds	r7, #20
    a7b4:	46bd      	mov	sp, r7
    a7b6:	f85d 7b04 	ldr.w	r7, [sp], #4
    a7ba:	4770      	bx	lr

0000a7bc <_Z5writeP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configt>:


void write(SPI_Type * spiBase, dspi_ctar_selection_t whichCTAR, dspi_which_pcs_t whichPCS, uint16_t data16)
{
    a7bc:	b580      	push	{r7, lr}
    a7be:	b084      	sub	sp, #16
    a7c0:	af00      	add	r7, sp, #0
    a7c2:	6078      	str	r0, [r7, #4]
    a7c4:	4608      	mov	r0, r1
    a7c6:	4611      	mov	r1, r2
    a7c8:	461a      	mov	r2, r3
    a7ca:	4603      	mov	r3, r0
    a7cc:	70fb      	strb	r3, [r7, #3]
    a7ce:	460b      	mov	r3, r1
    a7d0:	70bb      	strb	r3, [r7, #2]
    a7d2:	4613      	mov	r3, r2
    a7d4:	803b      	strh	r3, [r7, #0]
    dspi_command_data_config_t commandConfig;
    commandConfig.isPcsContinuous    = false;
    a7d6:	2300      	movs	r3, #0
    a7d8:	723b      	strb	r3, [r7, #8]
    commandConfig.whichCtar          = whichCTAR;
    a7da:	78fb      	ldrb	r3, [r7, #3]
    a7dc:	727b      	strb	r3, [r7, #9]
    commandConfig.whichPcs           = whichPCS;
    a7de:	78bb      	ldrb	r3, [r7, #2]
    a7e0:	72bb      	strb	r3, [r7, #10]
    commandConfig.clearTransferCount = true;
    a7e2:	2301      	movs	r3, #1
    a7e4:	733b      	strb	r3, [r7, #12]
    commandConfig.isEndOfQueue = true;
    a7e6:	2301      	movs	r3, #1
    a7e8:	72fb      	strb	r3, [r7, #11]

    DSPI_StopTransfer(spiBase);
    a7ea:	6878      	ldr	r0, [r7, #4]
    a7ec:	f7ff ff6f 	bl	a6ce <DSPI_StopTransfer>
    DSPI_FlushFifo(spiBase, true, true);
    a7f0:	2201      	movs	r2, #1
    a7f2:	2101      	movs	r1, #1
    a7f4:	6878      	ldr	r0, [r7, #4]
    a7f6:	f7ff ff7a 	bl	a6ee <DSPI_FlushFifo>
    DSPI_ClearStatusFlags(spiBase, (uint32_t)kDSPI_AllStatusFlag);
    a7fa:	4909      	ldr	r1, [pc, #36]	; (a820 <_Z5writeP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configt+0x64>)
    a7fc:	6878      	ldr	r0, [r7, #4]
    a7fe:	f7ff ff48 	bl	a692 <DSPI_ClearStatusFlags>
    DSPI_StartTransfer(spiBase);
    a802:	6878      	ldr	r0, [r7, #4]
    a804:	f7ff ff53 	bl	a6ae <DSPI_StartTransfer>
    DSPI_MasterWriteDataBlocking(spiBase, &commandConfig, data16);
    a808:	883a      	ldrh	r2, [r7, #0]
    a80a:	f107 0308 	add.w	r3, r7, #8
    a80e:	4619      	mov	r1, r3
    a810:	6878      	ldr	r0, [r7, #4]
    a812:	f000 ff23 	bl	b65c <DSPI_MasterWriteDataBlocking>
}
    a816:	bf00      	nop
    a818:	3710      	adds	r7, #16
    a81a:	46bd      	mov	sp, r7
    a81c:	bd80      	pop	{r7, pc}
    a81e:	bf00      	nop
    a820:	da0a0000 	.word	0xda0a0000

0000a824 <_ZN6AD98334initEv>:

void AD9833::init()
{
    a824:	b580      	push	{r7, lr}
    a826:	b08e      	sub	sp, #56	; 0x38
    a828:	af00      	add	r7, sp, #0
    a82a:	6078      	str	r0, [r7, #4]
    dspi_master_config_t masterConfig;

    const uint32_t transferBaudrate = 500000U ; // Max = 25 MHz
    a82c:	4b2a      	ldr	r3, [pc, #168]	; (a8d8 <_ZN6AD98334initEv+0xb4>)
    a82e:	637b      	str	r3, [r7, #52]	; 0x34

    masterConfig.whichCtar                                = m_whichCTAR;
    a830:	687b      	ldr	r3, [r7, #4]
    a832:	791b      	ldrb	r3, [r3, #4]
    a834:	733b      	strb	r3, [r7, #12]
    masterConfig.ctarConfig.baudRate                      = transferBaudrate;
    a836:	4b28      	ldr	r3, [pc, #160]	; (a8d8 <_ZN6AD98334initEv+0xb4>)
    a838:	613b      	str	r3, [r7, #16]
    masterConfig.ctarConfig.bitsPerFrame                  = 16;
    a83a:	2310      	movs	r3, #16
    a83c:	617b      	str	r3, [r7, #20]
    masterConfig.ctarConfig.cpol                          = kDSPI_ClockPolarityActiveLow;
    a83e:	2301      	movs	r3, #1
    a840:	763b      	strb	r3, [r7, #24]
    masterConfig.ctarConfig.cpha                          = kDSPI_ClockPhaseFirstEdge;
    a842:	2300      	movs	r3, #0
    a844:	767b      	strb	r3, [r7, #25]
    masterConfig.ctarConfig.direction                     = kDSPI_MsbFirst;
    a846:	2300      	movs	r3, #0
    a848:	76bb      	strb	r3, [r7, #26]
    masterConfig.ctarConfig.pcsToSckDelayInNanoSec        = 50;  // datasheet: 5ns ,
    a84a:	2332      	movs	r3, #50	; 0x32
    a84c:	61fb      	str	r3, [r7, #28]
    masterConfig.ctarConfig.lastSckToPcsDelayInNanoSec    = 50;  // datasheet: 0ns ,
    a84e:	2332      	movs	r3, #50	; 0x32
    a850:	623b      	str	r3, [r7, #32]
    masterConfig.ctarConfig.betweenTransferDelayInNanoSec = 50;  // datasheet: 20ns
    a852:	2332      	movs	r3, #50	; 0x32
    a854:	627b      	str	r3, [r7, #36]	; 0x24

    masterConfig.whichPcs                   = m_whichPCS;
    a856:	687b      	ldr	r3, [r7, #4]
    a858:	795b      	ldrb	r3, [r3, #5]
    a85a:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    masterConfig.pcsActiveHighOrLow         = kDSPI_PcsActiveLow;
    a85e:	2301      	movs	r3, #1
    a860:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29

    masterConfig.enableContinuousSCK        = false;
    a864:	2300      	movs	r3, #0
    a866:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
    masterConfig.enableRxFifoOverWrite      = true;
    a86a:	2301      	movs	r3, #1
    a86c:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    masterConfig.enableModifiedTimingFormat = false;
    a870:	2300      	movs	r3, #0
    a872:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    masterConfig.samplePoint                = kDSPI_SckToSin0Clock;
    a876:	2300      	movs	r3, #0
    a878:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
    
    uint32_t srcFreq_hz = CLOCK_GetFreq(BUS_CLK);
    a87c:	2002      	movs	r0, #2
    a87e:	f7fc ffa7 	bl	77d0 <CLOCK_GetFreq>
    a882:	6338      	str	r0, [r7, #48]	; 0x30

    DSPI_MasterInit(m_spiBase, &masterConfig, srcFreq_hz);
    a884:	687b      	ldr	r3, [r7, #4]
    a886:	681b      	ldr	r3, [r3, #0]
    a888:	f107 010c 	add.w	r1, r7, #12
    a88c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    a88e:	4618      	mov	r0, r3
    a890:	f000 fc52 	bl	b138 <DSPI_MasterInit>

    PORT_SetPinMux(m_pPort_MOSI, m_iPin_MOSI, m_mux_MOSI);
    a894:	687b      	ldr	r3, [r7, #4]
    a896:	6898      	ldr	r0, [r3, #8]
    a898:	687b      	ldr	r3, [r7, #4]
    a89a:	6959      	ldr	r1, [r3, #20]
    a89c:	687b      	ldr	r3, [r7, #4]
    a89e:	f893 3020 	ldrb.w	r3, [r3, #32]
    a8a2:	461a      	mov	r2, r3
    a8a4:	f7ff fed8 	bl	a658 <PORT_SetPinMux>
    PORT_SetPinMux(m_pPort_CLK , m_iPin_CLK , m_mux_CLK );
    a8a8:	687b      	ldr	r3, [r7, #4]
    a8aa:	68d8      	ldr	r0, [r3, #12]
    a8ac:	687b      	ldr	r3, [r7, #4]
    a8ae:	6999      	ldr	r1, [r3, #24]
    a8b0:	687b      	ldr	r3, [r7, #4]
    a8b2:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    a8b6:	461a      	mov	r2, r3
    a8b8:	f7ff fece 	bl	a658 <PORT_SetPinMux>
    PORT_SetPinMux(m_pPort_CS  , m_iPin_CS  , m_mux_CS  );
    a8bc:	687b      	ldr	r3, [r7, #4]
    a8be:	6918      	ldr	r0, [r3, #16]
    a8c0:	687b      	ldr	r3, [r7, #4]
    a8c2:	69d9      	ldr	r1, [r3, #28]
    a8c4:	687b      	ldr	r3, [r7, #4]
    a8c6:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    a8ca:	461a      	mov	r2, r3
    a8cc:	f7ff fec4 	bl	a658 <PORT_SetPinMux>
}
    a8d0:	bf00      	nop
    a8d2:	3738      	adds	r7, #56	; 0x38
    a8d4:	46bd      	mov	sp, r7
    a8d6:	bd80      	pop	{r7, pc}
    a8d8:	0007a120 	.word	0x0007a120
    a8dc:	ffffffff 	.word	0xffffffff

0000a8e0 <_ZN6AD983312setFrequencyENS_18FrequencyRegisters4TypeEd>:

void AD9833::setFrequency(FrequencyRegister eFrequencyRegister, double dFrequency_hertz)
{
    a8e0:	b5b0      	push	{r4, r5, r7, lr}
    a8e2:	b088      	sub	sp, #32
    a8e4:	af00      	add	r7, sp, #0
    a8e6:	60f8      	str	r0, [r7, #12]
    a8e8:	460b      	mov	r3, r1
    a8ea:	ed87 0b00 	vstr	d0, [r7]
    a8ee:	72fb      	strb	r3, [r7, #11]
    eFrequencyRegister = boundEnum<FrequencyRegisters>(eFrequencyRegister);
    a8f0:	7afb      	ldrb	r3, [r7, #11]
    a8f2:	4618      	mov	r0, r3
    a8f4:	f000 f97f 	bl	abf6 <_Z9boundEnumIN6AD983318FrequencyRegistersENS1_4TypeEET0_S3_>
    a8f8:	4603      	mov	r3, r0
    a8fa:	72fb      	strb	r3, [r7, #11]
    dFrequency_hertz = bound<double>(dFrequency_hertz, 0, m_iMClockFrequency_hertz/2);
    a8fc:	68fb      	ldr	r3, [r7, #12]
    a8fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    a900:	085b      	lsrs	r3, r3, #1
    a902:	4618      	mov	r0, r3
    a904:	f003 f804 	bl	d910 <__aeabi_ui2d>
    a908:	4602      	mov	r2, r0
    a90a:	460b      	mov	r3, r1
    a90c:	ec43 2b12 	vmov	d2, r2, r3
    a910:	ed9f 1b35 	vldr	d1, [pc, #212]	; a9e8 <_ZN6AD983312setFrequencyENS_18FrequencyRegisters4TypeEd+0x108>
    a914:	ed97 0b00 	vldr	d0, [r7]
    a918:	f000 f97e 	bl	ac18 <_Z5boundIdET_S0_S0_S0_>
    a91c:	ed87 0b00 	vstr	d0, [r7]

    const Register reg = FrequencyRegisterLUT[(unsigned int) eFrequencyRegister];
    a920:	7afb      	ldrb	r3, [r7, #11]
    a922:	4a33      	ldr	r2, [pc, #204]	; (a9f0 <_ZN6AD983312setFrequencyENS_18FrequencyRegisters4TypeEd+0x110>)
    a924:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
    a928:	83fb      	strh	r3, [r7, #30]

    // FREQREG = (fOut * (2^28)) / fMClk
    uint32_t FREQREG = ( ( dFrequency_hertz * 0x10000000 ) / m_iMClockFrequency_hertz );
    a92a:	f04f 0200 	mov.w	r2, #0
    a92e:	4b31      	ldr	r3, [pc, #196]	; (a9f4 <_ZN6AD983312setFrequencyENS_18FrequencyRegisters4TypeEd+0x114>)
    a930:	e9d7 0100 	ldrd	r0, r1, [r7]
    a934:	f003 f866 	bl	da04 <__aeabi_dmul>
    a938:	4602      	mov	r2, r0
    a93a:	460b      	mov	r3, r1
    a93c:	4614      	mov	r4, r2
    a93e:	461d      	mov	r5, r3
    a940:	68fb      	ldr	r3, [r7, #12]
    a942:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    a944:	4618      	mov	r0, r3
    a946:	f002 ffe3 	bl	d910 <__aeabi_ui2d>
    a94a:	4602      	mov	r2, r0
    a94c:	460b      	mov	r3, r1
    a94e:	4620      	mov	r0, r4
    a950:	4629      	mov	r1, r5
    a952:	f003 f981 	bl	dc58 <__aeabi_ddiv>
    a956:	4602      	mov	r2, r0
    a958:	460b      	mov	r3, r1
    a95a:	4610      	mov	r0, r2
    a95c:	4619      	mov	r1, r3
    a95e:	f003 fb01 	bl	df64 <__aeabi_d2uiz>
    a962:	4603      	mov	r3, r0
    a964:	61bb      	str	r3, [r7, #24]
    FREQREG &= 0xFFFFFFF; // 28 Bits
    a966:	69bb      	ldr	r3, [r7, #24]
    a968:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    a96c:	61bb      	str	r3, [r7, #24]
    
    uint16_t low  = (FREQREG & 0x3FFF); // 14 LSbits
    a96e:	69bb      	ldr	r3, [r7, #24]
    a970:	b29b      	uxth	r3, r3
    a972:	f3c3 030d 	ubfx	r3, r3, #0, #14
    a976:	82fb      	strh	r3, [r7, #22]
    uint16_t high = ((FREQREG >> 14) & 0x3FFF); // 14 MSbits
    a978:	69bb      	ldr	r3, [r7, #24]
    a97a:	0b9b      	lsrs	r3, r3, #14
    a97c:	b29b      	uxth	r3, r3
    a97e:	f3c3 030d 	ubfx	r3, r3, #0, #14
    a982:	82bb      	strh	r3, [r7, #20]
    if ((m_sControl & WriteModeValues::LowOnly  ) || (m_sControl & WriteModeValues::FullWord ) ) write(m_spiBase, m_whichCTAR, m_whichPCS, reg | low  );
    a984:	68fb      	ldr	r3, [r7, #12]
    a986:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    a988:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
    a98c:	2b00      	cmp	r3, #0
    a98e:	d00c      	beq.n	a9aa <_ZN6AD983312setFrequencyENS_18FrequencyRegisters4TypeEd+0xca>
    a990:	68fb      	ldr	r3, [r7, #12]
    a992:	6818      	ldr	r0, [r3, #0]
    a994:	68fb      	ldr	r3, [r7, #12]
    a996:	7919      	ldrb	r1, [r3, #4]
    a998:	68fb      	ldr	r3, [r7, #12]
    a99a:	795c      	ldrb	r4, [r3, #5]
    a99c:	8bfa      	ldrh	r2, [r7, #30]
    a99e:	8afb      	ldrh	r3, [r7, #22]
    a9a0:	4313      	orrs	r3, r2
    a9a2:	b29b      	uxth	r3, r3
    a9a4:	4622      	mov	r2, r4
    a9a6:	f7ff ff09 	bl	a7bc <_Z5writeP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configt>
    if ((m_sControl & WriteModeValues::HighOnly ) || (m_sControl & WriteModeValues::FullWord ) ) write(m_spiBase, m_whichCTAR, m_whichPCS, reg | high );
    a9aa:	68fb      	ldr	r3, [r7, #12]
    a9ac:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    a9ae:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    a9b2:	2b00      	cmp	r3, #0
    a9b4:	d105      	bne.n	a9c2 <_ZN6AD983312setFrequencyENS_18FrequencyRegisters4TypeEd+0xe2>
    a9b6:	68fb      	ldr	r3, [r7, #12]
    a9b8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    a9ba:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
    a9be:	2b00      	cmp	r3, #0
    a9c0:	d00c      	beq.n	a9dc <_ZN6AD983312setFrequencyENS_18FrequencyRegisters4TypeEd+0xfc>
    a9c2:	68fb      	ldr	r3, [r7, #12]
    a9c4:	6818      	ldr	r0, [r3, #0]
    a9c6:	68fb      	ldr	r3, [r7, #12]
    a9c8:	7919      	ldrb	r1, [r3, #4]
    a9ca:	68fb      	ldr	r3, [r7, #12]
    a9cc:	795c      	ldrb	r4, [r3, #5]
    a9ce:	8bfa      	ldrh	r2, [r7, #30]
    a9d0:	8abb      	ldrh	r3, [r7, #20]
    a9d2:	4313      	orrs	r3, r2
    a9d4:	b29b      	uxth	r3, r3
    a9d6:	4622      	mov	r2, r4
    a9d8:	f7ff fef0 	bl	a7bc <_Z5writeP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configt>
}
    a9dc:	bf00      	nop
    a9de:	3720      	adds	r7, #32
    a9e0:	46bd      	mov	sp, r7
    a9e2:	bdb0      	pop	{r4, r5, r7, pc}
    a9e4:	f3af 8000 	nop.w
	...
    a9f0:	000102c0 	.word	0x000102c0
    a9f4:	41b00000 	.word	0x41b00000

0000a9f8 <_ZN6AD98338setPhaseENS_14PhaseRegisters4TypeEf>:

void AD9833::setPhase(PhaseRegister ePhaseRegister, float fPhase_radians)
{
    a9f8:	b590      	push	{r4, r7, lr}
    a9fa:	b089      	sub	sp, #36	; 0x24
    a9fc:	af00      	add	r7, sp, #0
    a9fe:	60f8      	str	r0, [r7, #12]
    aa00:	460b      	mov	r3, r1
    aa02:	ed87 0a01 	vstr	s0, [r7, #4]
    aa06:	72fb      	strb	r3, [r7, #11]
    ePhaseRegister = boundEnum<PhaseRegisters>(ePhaseRegister);
    aa08:	7afb      	ldrb	r3, [r7, #11]
    aa0a:	4618      	mov	r0, r3
    aa0c:	f000 f94e 	bl	acac <_Z9boundEnumIN6AD983314PhaseRegistersENS1_4TypeEET0_S3_>
    aa10:	4603      	mov	r3, r0
    aa12:	72fb      	strb	r3, [r7, #11]
    fPhase_radians = bound<float>(fPhase_radians, 0, 2*M_PI);
    aa14:	ed9f 1a2e 	vldr	s2, [pc, #184]	; aad0 <_ZN6AD98338setPhaseENS_14PhaseRegisters4TypeEf+0xd8>
    aa18:	eddf 0a2e 	vldr	s1, [pc, #184]	; aad4 <_ZN6AD98338setPhaseENS_14PhaseRegisters4TypeEf+0xdc>
    aa1c:	ed97 0a01 	vldr	s0, [r7, #4]
    aa20:	f000 f954 	bl	accc <_Z5boundIfET_S0_S0_S0_>
    aa24:	ed87 0a01 	vstr	s0, [r7, #4]

    const Register reg = PhaseRegisterLUT[(unsigned int) ePhaseRegister];
    aa28:	7afb      	ldrb	r3, [r7, #11]
    aa2a:	4a2b      	ldr	r2, [pc, #172]	; (aad8 <_ZN6AD98338setPhaseENS_14PhaseRegisters4TypeEf+0xe0>)
    aa2c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
    aa30:	83fb      	strh	r3, [r7, #30]

    // PHASEREG = (Phase * (2^12) )/ ( 2 * PI )
    uint32_t PHASEREG = ( ( fPhase_radians * (4096) ) / ( 2 * M_PI ) ) ;
    aa32:	edd7 7a01 	vldr	s15, [r7, #4]
    aa36:	ed9f 7a29 	vldr	s14, [pc, #164]	; aadc <_ZN6AD98338setPhaseENS_14PhaseRegisters4TypeEf+0xe4>
    aa3a:	ee27 7a87 	vmul.f32	s14, s15, s14
    aa3e:	eddf 6a24 	vldr	s13, [pc, #144]	; aad0 <_ZN6AD98338setPhaseENS_14PhaseRegisters4TypeEf+0xd8>
    aa42:	eec7 7a26 	vdiv.f32	s15, s14, s13
    aa46:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    aa4a:	ee17 3a90 	vmov	r3, s15
    aa4e:	61bb      	str	r3, [r7, #24]
    PHASEREG &= 0xFFFFFF; // 24 Bits
    aa50:	69bb      	ldr	r3, [r7, #24]
    aa52:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    aa56:	61bb      	str	r3, [r7, #24]
    
    uint16_t low  = (PHASEREG & 0xFFF); // 12 LSbits
    aa58:	69bb      	ldr	r3, [r7, #24]
    aa5a:	b29b      	uxth	r3, r3
    aa5c:	f3c3 030b 	ubfx	r3, r3, #0, #12
    aa60:	82fb      	strh	r3, [r7, #22]
    uint16_t high = ((PHASEREG >> 12) & 0xFFF); // 12 MSbits
    aa62:	69bb      	ldr	r3, [r7, #24]
    aa64:	0b1b      	lsrs	r3, r3, #12
    aa66:	b29b      	uxth	r3, r3
    aa68:	f3c3 030b 	ubfx	r3, r3, #0, #12
    aa6c:	82bb      	strh	r3, [r7, #20]
    if ((m_sControl & WriteModeValues::LowOnly  ) || (m_sControl & WriteModeValues::FullWord ) ) write(m_spiBase, m_whichCTAR, m_whichPCS, reg | low  );
    aa6e:	68fb      	ldr	r3, [r7, #12]
    aa70:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    aa72:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
    aa76:	2b00      	cmp	r3, #0
    aa78:	d00c      	beq.n	aa94 <_ZN6AD98338setPhaseENS_14PhaseRegisters4TypeEf+0x9c>
    aa7a:	68fb      	ldr	r3, [r7, #12]
    aa7c:	6818      	ldr	r0, [r3, #0]
    aa7e:	68fb      	ldr	r3, [r7, #12]
    aa80:	7919      	ldrb	r1, [r3, #4]
    aa82:	68fb      	ldr	r3, [r7, #12]
    aa84:	795c      	ldrb	r4, [r3, #5]
    aa86:	8bfa      	ldrh	r2, [r7, #30]
    aa88:	8afb      	ldrh	r3, [r7, #22]
    aa8a:	4313      	orrs	r3, r2
    aa8c:	b29b      	uxth	r3, r3
    aa8e:	4622      	mov	r2, r4
    aa90:	f7ff fe94 	bl	a7bc <_Z5writeP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configt>
    if ((m_sControl & WriteModeValues::HighOnly ) || (m_sControl & WriteModeValues::FullWord ) ) write(m_spiBase, m_whichCTAR, m_whichPCS, reg | high );
    aa94:	68fb      	ldr	r3, [r7, #12]
    aa96:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    aa98:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    aa9c:	2b00      	cmp	r3, #0
    aa9e:	d105      	bne.n	aaac <_ZN6AD98338setPhaseENS_14PhaseRegisters4TypeEf+0xb4>
    aaa0:	68fb      	ldr	r3, [r7, #12]
    aaa2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    aaa4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
    aaa8:	2b00      	cmp	r3, #0
    aaaa:	d00c      	beq.n	aac6 <_ZN6AD98338setPhaseENS_14PhaseRegisters4TypeEf+0xce>
    aaac:	68fb      	ldr	r3, [r7, #12]
    aaae:	6818      	ldr	r0, [r3, #0]
    aab0:	68fb      	ldr	r3, [r7, #12]
    aab2:	7919      	ldrb	r1, [r3, #4]
    aab4:	68fb      	ldr	r3, [r7, #12]
    aab6:	795c      	ldrb	r4, [r3, #5]
    aab8:	8bfa      	ldrh	r2, [r7, #30]
    aaba:	8abb      	ldrh	r3, [r7, #20]
    aabc:	4313      	orrs	r3, r2
    aabe:	b29b      	uxth	r3, r3
    aac0:	4622      	mov	r2, r4
    aac2:	f7ff fe7b 	bl	a7bc <_Z5writeP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configt>
}
    aac6:	bf00      	nop
    aac8:	3724      	adds	r7, #36	; 0x24
    aaca:	46bd      	mov	sp, r7
    aacc:	bd90      	pop	{r4, r7, pc}
    aace:	bf00      	nop
    aad0:	40c90fdb 	.word	0x40c90fdb
    aad4:	00000000 	.word	0x00000000
    aad8:	000102c4 	.word	0x000102c4
    aadc:	45800000 	.word	0x45800000

0000aae0 <_ZN6AD983310setControlENS_18FrequencyRegisters4TypeENS_14PhaseRegisters4TypeENS_10WriteModes4TypeENS_10SleepModes4TypeENS_11OutputModes4TypeEb>:
                        PhaseRegister ePhaseSelect,
                        WriteMode eWriteMode, 
                        SleepMode eSleepMode,
                        OutputMode eOutputMode,
                        bool bReset)
{
    aae0:	b580      	push	{r7, lr}
    aae2:	b084      	sub	sp, #16
    aae4:	af00      	add	r7, sp, #0
    aae6:	6078      	str	r0, [r7, #4]
    aae8:	4608      	mov	r0, r1
    aaea:	4611      	mov	r1, r2
    aaec:	461a      	mov	r2, r3
    aaee:	4603      	mov	r3, r0
    aaf0:	70fb      	strb	r3, [r7, #3]
    aaf2:	460b      	mov	r3, r1
    aaf4:	70bb      	strb	r3, [r7, #2]
    aaf6:	4613      	mov	r3, r2
    aaf8:	707b      	strb	r3, [r7, #1]
    eFrequencySelect = boundEnum<FrequencyRegisters>(eFrequencySelect);
    aafa:	78fb      	ldrb	r3, [r7, #3]
    aafc:	4618      	mov	r0, r3
    aafe:	f000 f87a 	bl	abf6 <_Z9boundEnumIN6AD983318FrequencyRegistersENS1_4TypeEET0_S3_>
    ab02:	4603      	mov	r3, r0
    ab04:	70fb      	strb	r3, [r7, #3]
    ePhaseSelect = boundEnum<PhaseRegisters>(ePhaseSelect);
    ab06:	78bb      	ldrb	r3, [r7, #2]
    ab08:	4618      	mov	r0, r3
    ab0a:	f000 f8cf 	bl	acac <_Z9boundEnumIN6AD983314PhaseRegistersENS1_4TypeEET0_S3_>
    ab0e:	4603      	mov	r3, r0
    ab10:	70bb      	strb	r3, [r7, #2]
    eWriteMode = boundEnum<WriteModes>(eWriteMode);
    ab12:	787b      	ldrb	r3, [r7, #1]
    ab14:	4618      	mov	r0, r3
    ab16:	f000 f91f 	bl	ad58 <_Z9boundEnumIN6AD983310WriteModesENS1_4TypeEET0_S3_>
    ab1a:	4603      	mov	r3, r0
    ab1c:	707b      	strb	r3, [r7, #1]
    eSleepMode = boundEnum<SleepModes>(eSleepMode);
    ab1e:	7e3b      	ldrb	r3, [r7, #24]
    ab20:	4618      	mov	r0, r3
    ab22:	f000 f929 	bl	ad78 <_Z9boundEnumIN6AD983310SleepModesENS1_4TypeEET0_S3_>
    ab26:	4603      	mov	r3, r0
    ab28:	763b      	strb	r3, [r7, #24]
    eOutputMode = boundEnum<OutputModes>(eOutputMode);
    ab2a:	7f3b      	ldrb	r3, [r7, #28]
    ab2c:	4618      	mov	r0, r3
    ab2e:	f000 f933 	bl	ad98 <_Z9boundEnumIN6AD983311OutputModesENS1_4TypeEET0_S3_>
    ab32:	4603      	mov	r3, r0
    ab34:	773b      	strb	r3, [r7, #28]


    uint16_t control = 0
        | WriteModeLUT[(unsigned int)eWriteMode]
    ab36:	787b      	ldrb	r3, [r7, #1]
    ab38:	4a1f      	ldr	r2, [pc, #124]	; (abb8 <_ZN6AD983310setControlENS_18FrequencyRegisters4TypeENS_14PhaseRegisters4TypeENS_10WriteModes4TypeENS_10SleepModes4TypeENS_11OutputModes4TypeEb+0xd8>)
    ab3a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
    ab3e:	b21a      	sxth	r2, r3
        | ( ( (eFrequencySelect == FrequencyRegisters::FREQ0 ) ? 0 : 1 ) << 11 )
    ab40:	78fb      	ldrb	r3, [r7, #3]
    ab42:	2b00      	cmp	r3, #0
    ab44:	bf14      	ite	ne
    ab46:	2301      	movne	r3, #1
    ab48:	2300      	moveq	r3, #0
    ab4a:	b2db      	uxtb	r3, r3
    ab4c:	02db      	lsls	r3, r3, #11
    ab4e:	b21b      	sxth	r3, r3
    ab50:	4313      	orrs	r3, r2
    ab52:	b21a      	sxth	r2, r3
        | ( ( (ePhaseSelect     == PhaseRegisters::PHASE0    ) ? 0 : 1 ) << 10 )
    ab54:	78bb      	ldrb	r3, [r7, #2]
    ab56:	2b00      	cmp	r3, #0
    ab58:	bf14      	ite	ne
    ab5a:	2301      	movne	r3, #1
    ab5c:	2300      	moveq	r3, #0
    ab5e:	b2db      	uxtb	r3, r3
    ab60:	029b      	lsls	r3, r3, #10
    ab62:	b21b      	sxth	r3, r3
    ab64:	4313      	orrs	r3, r2
    ab66:	b21b      	sxth	r3, r3
        | ( ( bReset ? 1 : 0) << 8 )
    ab68:	f897 2020 	ldrb.w	r2, [r7, #32]
    ab6c:	2a00      	cmp	r2, #0
    ab6e:	d002      	beq.n	ab76 <_ZN6AD983310setControlENS_18FrequencyRegisters4TypeENS_14PhaseRegisters4TypeENS_10WriteModes4TypeENS_10SleepModes4TypeENS_11OutputModes4TypeEb+0x96>
    ab70:	f44f 7280 	mov.w	r2, #256	; 0x100
    ab74:	e000      	b.n	ab78 <_ZN6AD983310setControlENS_18FrequencyRegisters4TypeENS_14PhaseRegisters4TypeENS_10WriteModes4TypeENS_10SleepModes4TypeENS_11OutputModes4TypeEb+0x98>
    ab76:	2200      	movs	r2, #0
    ab78:	4313      	orrs	r3, r2
    ab7a:	b21a      	sxth	r2, r3
        | SleepModeLUT[(unsigned int)eSleepMode]
    ab7c:	7e3b      	ldrb	r3, [r7, #24]
    ab7e:	490f      	ldr	r1, [pc, #60]	; (abbc <_ZN6AD983310setControlENS_18FrequencyRegisters4TypeENS_14PhaseRegisters4TypeENS_10WriteModes4TypeENS_10SleepModes4TypeENS_11OutputModes4TypeEb+0xdc>)
    ab80:	5ccb      	ldrb	r3, [r1, r3]
    ab82:	b21b      	sxth	r3, r3
    ab84:	4313      	orrs	r3, r2
    ab86:	b21a      	sxth	r2, r3
        | OutputModeLUT[(unsigned int)eOutputMode];
    ab88:	7f3b      	ldrb	r3, [r7, #28]
    ab8a:	490d      	ldr	r1, [pc, #52]	; (abc0 <_ZN6AD983310setControlENS_18FrequencyRegisters4TypeENS_14PhaseRegisters4TypeENS_10WriteModes4TypeENS_10SleepModes4TypeENS_11OutputModes4TypeEb+0xe0>)
    ab8c:	5ccb      	ldrb	r3, [r1, r3]
    ab8e:	b21b      	sxth	r3, r3
    ab90:	4313      	orrs	r3, r2
    ab92:	b21b      	sxth	r3, r3
    uint16_t control = 0
    ab94:	81fb      	strh	r3, [r7, #14]
    
    write(m_spiBase, m_whichCTAR, m_whichPCS, control );
    ab96:	687b      	ldr	r3, [r7, #4]
    ab98:	6818      	ldr	r0, [r3, #0]
    ab9a:	687b      	ldr	r3, [r7, #4]
    ab9c:	7919      	ldrb	r1, [r3, #4]
    ab9e:	687b      	ldr	r3, [r7, #4]
    aba0:	795a      	ldrb	r2, [r3, #5]
    aba2:	89fb      	ldrh	r3, [r7, #14]
    aba4:	f7ff fe0a 	bl	a7bc <_Z5writeP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configt>
    
    m_sControl = control;
    aba8:	687b      	ldr	r3, [r7, #4]
    abaa:	89fa      	ldrh	r2, [r7, #14]
    abac:	851a      	strh	r2, [r3, #40]	; 0x28
}
    abae:	bf00      	nop
    abb0:	3710      	adds	r7, #16
    abb2:	46bd      	mov	sp, r7
    abb4:	bd80      	pop	{r7, pc}
    abb6:	bf00      	nop
    abb8:	000102c8 	.word	0x000102c8
    abbc:	000102d4 	.word	0x000102d4
    abc0:	000102d0 	.word	0x000102d0

0000abc4 <_ZN6AD98338setResetEv>:

void AD9833::setReset()
{
    abc4:	b580      	push	{r7, lr}
    abc6:	b084      	sub	sp, #16
    abc8:	af00      	add	r7, sp, #0
    abca:	6078      	str	r0, [r7, #4]
    uint16_t control = ( 1 << 8 ) | ( m_sControl & (~(1 << 8)) );
    abcc:	687b      	ldr	r3, [r7, #4]
    abce:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    abd0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    abd4:	81fb      	strh	r3, [r7, #14]
    write(m_spiBase, m_whichCTAR, m_whichPCS, control );
    abd6:	687b      	ldr	r3, [r7, #4]
    abd8:	6818      	ldr	r0, [r3, #0]
    abda:	687b      	ldr	r3, [r7, #4]
    abdc:	7919      	ldrb	r1, [r3, #4]
    abde:	687b      	ldr	r3, [r7, #4]
    abe0:	795a      	ldrb	r2, [r3, #5]
    abe2:	89fb      	ldrh	r3, [r7, #14]
    abe4:	f7ff fdea 	bl	a7bc <_Z5writeP8SPI_Type20_dspi_ctar_selection22_dspi_which_pcs_configt>
    m_sControl = control;
    abe8:	687b      	ldr	r3, [r7, #4]
    abea:	89fa      	ldrh	r2, [r7, #14]
    abec:	851a      	strh	r2, [r3, #40]	; 0x28
    abee:	bf00      	nop
    abf0:	3710      	adds	r7, #16
    abf2:	46bd      	mov	sp, r7
    abf4:	bd80      	pop	{r7, pc}

0000abf6 <_Z9boundEnumIN6AD983318FrequencyRegistersENS1_4TypeEET0_S3_>:
Type boundEnum(Type value) {
    abf6:	b580      	push	{r7, lr}
    abf8:	b082      	sub	sp, #8
    abfa:	af00      	add	r7, sp, #0
    abfc:	4603      	mov	r3, r0
    abfe:	71fb      	strb	r3, [r7, #7]
    return bound<Type>(value, Enum::_MIN, Enum::_MAX);
    ac00:	79fb      	ldrb	r3, [r7, #7]
    ac02:	2201      	movs	r2, #1
    ac04:	2100      	movs	r1, #0
    ac06:	4618      	mov	r0, r3
    ac08:	f000 f8d6 	bl	adb8 <_Z5boundIN6AD983318FrequencyRegisters4TypeEET_S3_S3_S3_>
    ac0c:	4603      	mov	r3, r0
}
    ac0e:	4618      	mov	r0, r3
    ac10:	3708      	adds	r7, #8
    ac12:	46bd      	mov	sp, r7
    ac14:	bd80      	pop	{r7, pc}
    ac16:	Address 0x0000ac16 is out of bounds.


0000ac18 <_Z5boundIdET_S0_S0_S0_>:
T bound(T value, T min, T max) 
    ac18:	b580      	push	{r7, lr}
    ac1a:	b086      	sub	sp, #24
    ac1c:	af00      	add	r7, sp, #0
    ac1e:	ed87 0b04 	vstr	d0, [r7, #16]
    ac22:	ed87 1b02 	vstr	d1, [r7, #8]
    ac26:	ed87 2b00 	vstr	d2, [r7]
    assert(( max >= value) && ( min <= value));
    ac2a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    ac2e:	e9d7 0100 	ldrd	r0, r1, [r7]
    ac32:	f003 f96d 	bl	df10 <__aeabi_dcmpge>
    ac36:	4603      	mov	r3, r0
    ac38:	2b00      	cmp	r3, #0
    ac3a:	d008      	beq.n	ac4e <_Z5boundIdET_S0_S0_S0_+0x36>
    ac3c:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    ac40:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
    ac44:	f003 f95a 	bl	defc <__aeabi_dcmple>
    ac48:	4603      	mov	r3, r0
    ac4a:	2b00      	cmp	r3, #0
    ac4c:	d105      	bne.n	ac5a <_Z5boundIdET_S0_S0_S0_+0x42>
    ac4e:	4b14      	ldr	r3, [pc, #80]	; (aca0 <_Z5boundIdET_S0_S0_S0_+0x88>)
    ac50:	4a14      	ldr	r2, [pc, #80]	; (aca4 <_Z5boundIdET_S0_S0_S0_+0x8c>)
    ac52:	2107      	movs	r1, #7
    ac54:	4814      	ldr	r0, [pc, #80]	; (aca8 <_Z5boundIdET_S0_S0_S0_+0x90>)
    ac56:	f7fc fac1 	bl	71dc <__assert_func>
    if( max < value) return max;
    ac5a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    ac5e:	e9d7 0100 	ldrd	r0, r1, [r7]
    ac62:	f003 f941 	bl	dee8 <__aeabi_dcmplt>
    ac66:	4603      	mov	r3, r0
    ac68:	2b00      	cmp	r3, #0
    ac6a:	d002      	beq.n	ac72 <_Z5boundIdET_S0_S0_S0_+0x5a>
    ac6c:	e9d7 2300 	ldrd	r2, r3, [r7]
    ac70:	e00d      	b.n	ac8e <_Z5boundIdET_S0_S0_S0_+0x76>
    if( min > value) return min;
    ac72:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    ac76:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
    ac7a:	f003 f953 	bl	df24 <__aeabi_dcmpgt>
    ac7e:	4603      	mov	r3, r0
    ac80:	2b00      	cmp	r3, #0
    ac82:	d002      	beq.n	ac8a <_Z5boundIdET_S0_S0_S0_+0x72>
    ac84:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    ac88:	e001      	b.n	ac8e <_Z5boundIdET_S0_S0_S0_+0x76>
    return value;
    ac8a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
}
    ac8e:	ec43 2b17 	vmov	d7, r2, r3
    ac92:	eeb0 0a47 	vmov.f32	s0, s14
    ac96:	eef0 0a67 	vmov.f32	s1, s15
    ac9a:	3718      	adds	r7, #24
    ac9c:	46bd      	mov	sp, r7
    ac9e:	bd80      	pop	{r7, pc}
    aca0:	000102d8 	.word	0x000102d8
    aca4:	000102fc 	.word	0x000102fc
    aca8:	00010320 	.word	0x00010320

0000acac <_Z9boundEnumIN6AD983314PhaseRegistersENS1_4TypeEET0_S3_>:
Type boundEnum(Type value) {
    acac:	b580      	push	{r7, lr}
    acae:	b082      	sub	sp, #8
    acb0:	af00      	add	r7, sp, #0
    acb2:	4603      	mov	r3, r0
    acb4:	71fb      	strb	r3, [r7, #7]
    return bound<Type>(value, Enum::_MIN, Enum::_MAX);
    acb6:	79fb      	ldrb	r3, [r7, #7]
    acb8:	2201      	movs	r2, #1
    acba:	2100      	movs	r1, #0
    acbc:	4618      	mov	r0, r3
    acbe:	f000 f8a9 	bl	ae14 <_Z5boundIN6AD983314PhaseRegisters4TypeEET_S3_S3_S3_>
    acc2:	4603      	mov	r3, r0
}
    acc4:	4618      	mov	r0, r3
    acc6:	3708      	adds	r7, #8
    acc8:	46bd      	mov	sp, r7
    acca:	bd80      	pop	{r7, pc}

0000accc <_Z5boundIfET_S0_S0_S0_>:
T bound(T value, T min, T max) 
    accc:	b580      	push	{r7, lr}
    acce:	b084      	sub	sp, #16
    acd0:	af00      	add	r7, sp, #0
    acd2:	ed87 0a03 	vstr	s0, [r7, #12]
    acd6:	edc7 0a02 	vstr	s1, [r7, #8]
    acda:	ed87 1a01 	vstr	s2, [r7, #4]
    assert(( max >= value) && ( min <= value));
    acde:	ed97 7a01 	vldr	s14, [r7, #4]
    ace2:	edd7 7a03 	vldr	s15, [r7, #12]
    ace6:	eeb4 7ae7 	vcmpe.f32	s14, s15
    acea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    acee:	db08      	blt.n	ad02 <_Z5boundIfET_S0_S0_S0_+0x36>
    acf0:	ed97 7a02 	vldr	s14, [r7, #8]
    acf4:	edd7 7a03 	vldr	s15, [r7, #12]
    acf8:	eeb4 7ae7 	vcmpe.f32	s14, s15
    acfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ad00:	d905      	bls.n	ad0e <_Z5boundIfET_S0_S0_S0_+0x42>
    ad02:	4b12      	ldr	r3, [pc, #72]	; (ad4c <_Z5boundIfET_S0_S0_S0_+0x80>)
    ad04:	4a12      	ldr	r2, [pc, #72]	; (ad50 <_Z5boundIfET_S0_S0_S0_+0x84>)
    ad06:	2107      	movs	r1, #7
    ad08:	4812      	ldr	r0, [pc, #72]	; (ad54 <_Z5boundIfET_S0_S0_S0_+0x88>)
    ad0a:	f7fc fa67 	bl	71dc <__assert_func>
    if( max < value) return max;
    ad0e:	ed97 7a01 	vldr	s14, [r7, #4]
    ad12:	edd7 7a03 	vldr	s15, [r7, #12]
    ad16:	eeb4 7ae7 	vcmpe.f32	s14, s15
    ad1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ad1e:	d501      	bpl.n	ad24 <_Z5boundIfET_S0_S0_S0_+0x58>
    ad20:	687b      	ldr	r3, [r7, #4]
    ad22:	e00b      	b.n	ad3c <_Z5boundIfET_S0_S0_S0_+0x70>
    if( min > value) return min;
    ad24:	ed97 7a02 	vldr	s14, [r7, #8]
    ad28:	edd7 7a03 	vldr	s15, [r7, #12]
    ad2c:	eeb4 7ae7 	vcmpe.f32	s14, s15
    ad30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ad34:	dd01      	ble.n	ad3a <_Z5boundIfET_S0_S0_S0_+0x6e>
    ad36:	68bb      	ldr	r3, [r7, #8]
    ad38:	e000      	b.n	ad3c <_Z5boundIfET_S0_S0_S0_+0x70>
    return value;
    ad3a:	68fb      	ldr	r3, [r7, #12]
}
    ad3c:	ee07 3a90 	vmov	s15, r3
    ad40:	eeb0 0a67 	vmov.f32	s0, s15
    ad44:	3710      	adds	r7, #16
    ad46:	46bd      	mov	sp, r7
    ad48:	bd80      	pop	{r7, pc}
    ad4a:	bf00      	nop
    ad4c:	000102d8 	.word	0x000102d8
    ad50:	00010370 	.word	0x00010370
    ad54:	00010320 	.word	0x00010320

0000ad58 <_Z9boundEnumIN6AD983310WriteModesENS1_4TypeEET0_S3_>:
Type boundEnum(Type value) {
    ad58:	b580      	push	{r7, lr}
    ad5a:	b082      	sub	sp, #8
    ad5c:	af00      	add	r7, sp, #0
    ad5e:	4603      	mov	r3, r0
    ad60:	71fb      	strb	r3, [r7, #7]
    return bound<Type>(value, Enum::_MIN, Enum::_MAX);
    ad62:	79fb      	ldrb	r3, [r7, #7]
    ad64:	2202      	movs	r2, #2
    ad66:	2100      	movs	r1, #0
    ad68:	4618      	mov	r0, r3
    ad6a:	f000 f881 	bl	ae70 <_Z5boundIN6AD983310WriteModes4TypeEET_S3_S3_S3_>
    ad6e:	4603      	mov	r3, r0
}
    ad70:	4618      	mov	r0, r3
    ad72:	3708      	adds	r7, #8
    ad74:	46bd      	mov	sp, r7
    ad76:	bd80      	pop	{r7, pc}

0000ad78 <_Z9boundEnumIN6AD983310SleepModesENS1_4TypeEET0_S3_>:
Type boundEnum(Type value) {
    ad78:	b580      	push	{r7, lr}
    ad7a:	b082      	sub	sp, #8
    ad7c:	af00      	add	r7, sp, #0
    ad7e:	4603      	mov	r3, r0
    ad80:	71fb      	strb	r3, [r7, #7]
    return bound<Type>(value, Enum::_MIN, Enum::_MAX);
    ad82:	79fb      	ldrb	r3, [r7, #7]
    ad84:	2203      	movs	r2, #3
    ad86:	2100      	movs	r1, #0
    ad88:	4618      	mov	r0, r3
    ad8a:	f000 f89f 	bl	aecc <_Z5boundIN6AD983310SleepModes4TypeEET_S3_S3_S3_>
    ad8e:	4603      	mov	r3, r0
}
    ad90:	4618      	mov	r0, r3
    ad92:	3708      	adds	r7, #8
    ad94:	46bd      	mov	sp, r7
    ad96:	bd80      	pop	{r7, pc}

0000ad98 <_Z9boundEnumIN6AD983311OutputModesENS1_4TypeEET0_S3_>:
Type boundEnum(Type value) {
    ad98:	b580      	push	{r7, lr}
    ad9a:	b082      	sub	sp, #8
    ad9c:	af00      	add	r7, sp, #0
    ad9e:	4603      	mov	r3, r0
    ada0:	71fb      	strb	r3, [r7, #7]
    return bound<Type>(value, Enum::_MIN, Enum::_MAX);
    ada2:	79fb      	ldrb	r3, [r7, #7]
    ada4:	2203      	movs	r2, #3
    ada6:	2100      	movs	r1, #0
    ada8:	4618      	mov	r0, r3
    adaa:	f000 f8bd 	bl	af28 <_Z5boundIN6AD983311OutputModes4TypeEET_S3_S3_S3_>
    adae:	4603      	mov	r3, r0
}
    adb0:	4618      	mov	r0, r3
    adb2:	3708      	adds	r7, #8
    adb4:	46bd      	mov	sp, r7
    adb6:	bd80      	pop	{r7, pc}

0000adb8 <_Z5boundIN6AD983318FrequencyRegisters4TypeEET_S3_S3_S3_>:
T bound(T value, T min, T max) 
    adb8:	b580      	push	{r7, lr}
    adba:	b082      	sub	sp, #8
    adbc:	af00      	add	r7, sp, #0
    adbe:	4603      	mov	r3, r0
    adc0:	71fb      	strb	r3, [r7, #7]
    adc2:	460b      	mov	r3, r1
    adc4:	71bb      	strb	r3, [r7, #6]
    adc6:	4613      	mov	r3, r2
    adc8:	717b      	strb	r3, [r7, #5]
    assert(( max >= value) && ( min <= value));
    adca:	797a      	ldrb	r2, [r7, #5]
    adcc:	79fb      	ldrb	r3, [r7, #7]
    adce:	429a      	cmp	r2, r3
    add0:	d303      	bcc.n	adda <_Z5boundIN6AD983318FrequencyRegisters4TypeEET_S3_S3_S3_+0x22>
    add2:	79ba      	ldrb	r2, [r7, #6]
    add4:	79fb      	ldrb	r3, [r7, #7]
    add6:	429a      	cmp	r2, r3
    add8:	d905      	bls.n	ade6 <_Z5boundIN6AD983318FrequencyRegisters4TypeEET_S3_S3_S3_+0x2e>
    adda:	4b0b      	ldr	r3, [pc, #44]	; (ae08 <_Z5boundIN6AD983318FrequencyRegisters4TypeEET_S3_S3_S3_+0x50>)
    addc:	4a0b      	ldr	r2, [pc, #44]	; (ae0c <_Z5boundIN6AD983318FrequencyRegisters4TypeEET_S3_S3_S3_+0x54>)
    adde:	2107      	movs	r1, #7
    ade0:	480b      	ldr	r0, [pc, #44]	; (ae10 <_Z5boundIN6AD983318FrequencyRegisters4TypeEET_S3_S3_S3_+0x58>)
    ade2:	f7fc f9fb 	bl	71dc <__assert_func>
    if( max < value) return max;
    ade6:	797a      	ldrb	r2, [r7, #5]
    ade8:	79fb      	ldrb	r3, [r7, #7]
    adea:	429a      	cmp	r2, r3
    adec:	d201      	bcs.n	adf2 <_Z5boundIN6AD983318FrequencyRegisters4TypeEET_S3_S3_S3_+0x3a>
    adee:	797b      	ldrb	r3, [r7, #5]
    adf0:	e006      	b.n	ae00 <_Z5boundIN6AD983318FrequencyRegisters4TypeEET_S3_S3_S3_+0x48>
    if( min > value) return min;
    adf2:	79ba      	ldrb	r2, [r7, #6]
    adf4:	79fb      	ldrb	r3, [r7, #7]
    adf6:	429a      	cmp	r2, r3
    adf8:	d901      	bls.n	adfe <_Z5boundIN6AD983318FrequencyRegisters4TypeEET_S3_S3_S3_+0x46>
    adfa:	79bb      	ldrb	r3, [r7, #6]
    adfc:	e000      	b.n	ae00 <_Z5boundIN6AD983318FrequencyRegisters4TypeEET_S3_S3_S3_+0x48>
    return value;
    adfe:	79fb      	ldrb	r3, [r7, #7]
}
    ae00:	4618      	mov	r0, r3
    ae02:	3708      	adds	r7, #8
    ae04:	46bd      	mov	sp, r7
    ae06:	bd80      	pop	{r7, pc}
    ae08:	000102d8 	.word	0x000102d8
    ae0c:	00010394 	.word	0x00010394
    ae10:	00010320 	.word	0x00010320

0000ae14 <_Z5boundIN6AD983314PhaseRegisters4TypeEET_S3_S3_S3_>:
T bound(T value, T min, T max) 
    ae14:	b580      	push	{r7, lr}
    ae16:	b082      	sub	sp, #8
    ae18:	af00      	add	r7, sp, #0
    ae1a:	4603      	mov	r3, r0
    ae1c:	71fb      	strb	r3, [r7, #7]
    ae1e:	460b      	mov	r3, r1
    ae20:	71bb      	strb	r3, [r7, #6]
    ae22:	4613      	mov	r3, r2
    ae24:	717b      	strb	r3, [r7, #5]
    assert(( max >= value) && ( min <= value));
    ae26:	797a      	ldrb	r2, [r7, #5]
    ae28:	79fb      	ldrb	r3, [r7, #7]
    ae2a:	429a      	cmp	r2, r3
    ae2c:	d303      	bcc.n	ae36 <_Z5boundIN6AD983314PhaseRegisters4TypeEET_S3_S3_S3_+0x22>
    ae2e:	79ba      	ldrb	r2, [r7, #6]
    ae30:	79fb      	ldrb	r3, [r7, #7]
    ae32:	429a      	cmp	r2, r3
    ae34:	d905      	bls.n	ae42 <_Z5boundIN6AD983314PhaseRegisters4TypeEET_S3_S3_S3_+0x2e>
    ae36:	4b0b      	ldr	r3, [pc, #44]	; (ae64 <_Z5boundIN6AD983314PhaseRegisters4TypeEET_S3_S3_S3_+0x50>)
    ae38:	4a0b      	ldr	r2, [pc, #44]	; (ae68 <_Z5boundIN6AD983314PhaseRegisters4TypeEET_S3_S3_S3_+0x54>)
    ae3a:	2107      	movs	r1, #7
    ae3c:	480b      	ldr	r0, [pc, #44]	; (ae6c <_Z5boundIN6AD983314PhaseRegisters4TypeEET_S3_S3_S3_+0x58>)
    ae3e:	f7fc f9cd 	bl	71dc <__assert_func>
    if( max < value) return max;
    ae42:	797a      	ldrb	r2, [r7, #5]
    ae44:	79fb      	ldrb	r3, [r7, #7]
    ae46:	429a      	cmp	r2, r3
    ae48:	d201      	bcs.n	ae4e <_Z5boundIN6AD983314PhaseRegisters4TypeEET_S3_S3_S3_+0x3a>
    ae4a:	797b      	ldrb	r3, [r7, #5]
    ae4c:	e006      	b.n	ae5c <_Z5boundIN6AD983314PhaseRegisters4TypeEET_S3_S3_S3_+0x48>
    if( min > value) return min;
    ae4e:	79ba      	ldrb	r2, [r7, #6]
    ae50:	79fb      	ldrb	r3, [r7, #7]
    ae52:	429a      	cmp	r2, r3
    ae54:	d901      	bls.n	ae5a <_Z5boundIN6AD983314PhaseRegisters4TypeEET_S3_S3_S3_+0x46>
    ae56:	79bb      	ldrb	r3, [r7, #6]
    ae58:	e000      	b.n	ae5c <_Z5boundIN6AD983314PhaseRegisters4TypeEET_S3_S3_S3_+0x48>
    return value;
    ae5a:	79fb      	ldrb	r3, [r7, #7]
}
    ae5c:	4618      	mov	r0, r3
    ae5e:	3708      	adds	r7, #8
    ae60:	46bd      	mov	sp, r7
    ae62:	bd80      	pop	{r7, pc}
    ae64:	000102d8 	.word	0x000102d8
    ae68:	000103d4 	.word	0x000103d4
    ae6c:	00010320 	.word	0x00010320

0000ae70 <_Z5boundIN6AD983310WriteModes4TypeEET_S3_S3_S3_>:
T bound(T value, T min, T max) 
    ae70:	b580      	push	{r7, lr}
    ae72:	b082      	sub	sp, #8
    ae74:	af00      	add	r7, sp, #0
    ae76:	4603      	mov	r3, r0
    ae78:	71fb      	strb	r3, [r7, #7]
    ae7a:	460b      	mov	r3, r1
    ae7c:	71bb      	strb	r3, [r7, #6]
    ae7e:	4613      	mov	r3, r2
    ae80:	717b      	strb	r3, [r7, #5]
    assert(( max >= value) && ( min <= value));
    ae82:	797a      	ldrb	r2, [r7, #5]
    ae84:	79fb      	ldrb	r3, [r7, #7]
    ae86:	429a      	cmp	r2, r3
    ae88:	d303      	bcc.n	ae92 <_Z5boundIN6AD983310WriteModes4TypeEET_S3_S3_S3_+0x22>
    ae8a:	79ba      	ldrb	r2, [r7, #6]
    ae8c:	79fb      	ldrb	r3, [r7, #7]
    ae8e:	429a      	cmp	r2, r3
    ae90:	d905      	bls.n	ae9e <_Z5boundIN6AD983310WriteModes4TypeEET_S3_S3_S3_+0x2e>
    ae92:	4b0b      	ldr	r3, [pc, #44]	; (aec0 <_Z5boundIN6AD983310WriteModes4TypeEET_S3_S3_S3_+0x50>)
    ae94:	4a0b      	ldr	r2, [pc, #44]	; (aec4 <_Z5boundIN6AD983310WriteModes4TypeEET_S3_S3_S3_+0x54>)
    ae96:	2107      	movs	r1, #7
    ae98:	480b      	ldr	r0, [pc, #44]	; (aec8 <_Z5boundIN6AD983310WriteModes4TypeEET_S3_S3_S3_+0x58>)
    ae9a:	f7fc f99f 	bl	71dc <__assert_func>
    if( max < value) return max;
    ae9e:	797a      	ldrb	r2, [r7, #5]
    aea0:	79fb      	ldrb	r3, [r7, #7]
    aea2:	429a      	cmp	r2, r3
    aea4:	d201      	bcs.n	aeaa <_Z5boundIN6AD983310WriteModes4TypeEET_S3_S3_S3_+0x3a>
    aea6:	797b      	ldrb	r3, [r7, #5]
    aea8:	e006      	b.n	aeb8 <_Z5boundIN6AD983310WriteModes4TypeEET_S3_S3_S3_+0x48>
    if( min > value) return min;
    aeaa:	79ba      	ldrb	r2, [r7, #6]
    aeac:	79fb      	ldrb	r3, [r7, #7]
    aeae:	429a      	cmp	r2, r3
    aeb0:	d901      	bls.n	aeb6 <_Z5boundIN6AD983310WriteModes4TypeEET_S3_S3_S3_+0x46>
    aeb2:	79bb      	ldrb	r3, [r7, #6]
    aeb4:	e000      	b.n	aeb8 <_Z5boundIN6AD983310WriteModes4TypeEET_S3_S3_S3_+0x48>
    return value;
    aeb6:	79fb      	ldrb	r3, [r7, #7]
}
    aeb8:	4618      	mov	r0, r3
    aeba:	3708      	adds	r7, #8
    aebc:	46bd      	mov	sp, r7
    aebe:	bd80      	pop	{r7, pc}
    aec0:	000102d8 	.word	0x000102d8
    aec4:	00010410 	.word	0x00010410
    aec8:	00010320 	.word	0x00010320

0000aecc <_Z5boundIN6AD983310SleepModes4TypeEET_S3_S3_S3_>:
T bound(T value, T min, T max) 
    aecc:	b580      	push	{r7, lr}
    aece:	b082      	sub	sp, #8
    aed0:	af00      	add	r7, sp, #0
    aed2:	4603      	mov	r3, r0
    aed4:	71fb      	strb	r3, [r7, #7]
    aed6:	460b      	mov	r3, r1
    aed8:	71bb      	strb	r3, [r7, #6]
    aeda:	4613      	mov	r3, r2
    aedc:	717b      	strb	r3, [r7, #5]
    assert(( max >= value) && ( min <= value));
    aede:	797a      	ldrb	r2, [r7, #5]
    aee0:	79fb      	ldrb	r3, [r7, #7]
    aee2:	429a      	cmp	r2, r3
    aee4:	d303      	bcc.n	aeee <_Z5boundIN6AD983310SleepModes4TypeEET_S3_S3_S3_+0x22>
    aee6:	79ba      	ldrb	r2, [r7, #6]
    aee8:	79fb      	ldrb	r3, [r7, #7]
    aeea:	429a      	cmp	r2, r3
    aeec:	d905      	bls.n	aefa <_Z5boundIN6AD983310SleepModes4TypeEET_S3_S3_S3_+0x2e>
    aeee:	4b0b      	ldr	r3, [pc, #44]	; (af1c <_Z5boundIN6AD983310SleepModes4TypeEET_S3_S3_S3_+0x50>)
    aef0:	4a0b      	ldr	r2, [pc, #44]	; (af20 <_Z5boundIN6AD983310SleepModes4TypeEET_S3_S3_S3_+0x54>)
    aef2:	2107      	movs	r1, #7
    aef4:	480b      	ldr	r0, [pc, #44]	; (af24 <_Z5boundIN6AD983310SleepModes4TypeEET_S3_S3_S3_+0x58>)
    aef6:	f7fc f971 	bl	71dc <__assert_func>
    if( max < value) return max;
    aefa:	797a      	ldrb	r2, [r7, #5]
    aefc:	79fb      	ldrb	r3, [r7, #7]
    aefe:	429a      	cmp	r2, r3
    af00:	d201      	bcs.n	af06 <_Z5boundIN6AD983310SleepModes4TypeEET_S3_S3_S3_+0x3a>
    af02:	797b      	ldrb	r3, [r7, #5]
    af04:	e006      	b.n	af14 <_Z5boundIN6AD983310SleepModes4TypeEET_S3_S3_S3_+0x48>
    if( min > value) return min;
    af06:	79ba      	ldrb	r2, [r7, #6]
    af08:	79fb      	ldrb	r3, [r7, #7]
    af0a:	429a      	cmp	r2, r3
    af0c:	d901      	bls.n	af12 <_Z5boundIN6AD983310SleepModes4TypeEET_S3_S3_S3_+0x46>
    af0e:	79bb      	ldrb	r3, [r7, #6]
    af10:	e000      	b.n	af14 <_Z5boundIN6AD983310SleepModes4TypeEET_S3_S3_S3_+0x48>
    return value;
    af12:	79fb      	ldrb	r3, [r7, #7]
}
    af14:	4618      	mov	r0, r3
    af16:	3708      	adds	r7, #8
    af18:	46bd      	mov	sp, r7
    af1a:	bd80      	pop	{r7, pc}
    af1c:	000102d8 	.word	0x000102d8
    af20:	00010448 	.word	0x00010448
    af24:	00010320 	.word	0x00010320

0000af28 <_Z5boundIN6AD983311OutputModes4TypeEET_S3_S3_S3_>:
T bound(T value, T min, T max) 
    af28:	b580      	push	{r7, lr}
    af2a:	b082      	sub	sp, #8
    af2c:	af00      	add	r7, sp, #0
    af2e:	4603      	mov	r3, r0
    af30:	71fb      	strb	r3, [r7, #7]
    af32:	460b      	mov	r3, r1
    af34:	71bb      	strb	r3, [r7, #6]
    af36:	4613      	mov	r3, r2
    af38:	717b      	strb	r3, [r7, #5]
    assert(( max >= value) && ( min <= value));
    af3a:	797a      	ldrb	r2, [r7, #5]
    af3c:	79fb      	ldrb	r3, [r7, #7]
    af3e:	429a      	cmp	r2, r3
    af40:	d303      	bcc.n	af4a <_Z5boundIN6AD983311OutputModes4TypeEET_S3_S3_S3_+0x22>
    af42:	79ba      	ldrb	r2, [r7, #6]
    af44:	79fb      	ldrb	r3, [r7, #7]
    af46:	429a      	cmp	r2, r3
    af48:	d905      	bls.n	af56 <_Z5boundIN6AD983311OutputModes4TypeEET_S3_S3_S3_+0x2e>
    af4a:	4b0b      	ldr	r3, [pc, #44]	; (af78 <_Z5boundIN6AD983311OutputModes4TypeEET_S3_S3_S3_+0x50>)
    af4c:	4a0b      	ldr	r2, [pc, #44]	; (af7c <_Z5boundIN6AD983311OutputModes4TypeEET_S3_S3_S3_+0x54>)
    af4e:	2107      	movs	r1, #7
    af50:	480b      	ldr	r0, [pc, #44]	; (af80 <_Z5boundIN6AD983311OutputModes4TypeEET_S3_S3_S3_+0x58>)
    af52:	f7fc f943 	bl	71dc <__assert_func>
    if( max < value) return max;
    af56:	797a      	ldrb	r2, [r7, #5]
    af58:	79fb      	ldrb	r3, [r7, #7]
    af5a:	429a      	cmp	r2, r3
    af5c:	d201      	bcs.n	af62 <_Z5boundIN6AD983311OutputModes4TypeEET_S3_S3_S3_+0x3a>
    af5e:	797b      	ldrb	r3, [r7, #5]
    af60:	e006      	b.n	af70 <_Z5boundIN6AD983311OutputModes4TypeEET_S3_S3_S3_+0x48>
    if( min > value) return min;
    af62:	79ba      	ldrb	r2, [r7, #6]
    af64:	79fb      	ldrb	r3, [r7, #7]
    af66:	429a      	cmp	r2, r3
    af68:	d901      	bls.n	af6e <_Z5boundIN6AD983311OutputModes4TypeEET_S3_S3_S3_+0x46>
    af6a:	79bb      	ldrb	r3, [r7, #6]
    af6c:	e000      	b.n	af70 <_Z5boundIN6AD983311OutputModes4TypeEET_S3_S3_S3_+0x48>
    return value;
    af6e:	79fb      	ldrb	r3, [r7, #7]
}
    af70:	4618      	mov	r0, r3
    af72:	3708      	adds	r7, #8
    af74:	46bd      	mov	sp, r7
    af76:	bd80      	pop	{r7, pc}
    af78:	000102d8 	.word	0x000102d8
    af7c:	00010480 	.word	0x00010480
    af80:	00010320 	.word	0x00010320

0000af84 <CLOCK_EnableClock>:
{
    af84:	b480      	push	{r7}
    af86:	b085      	sub	sp, #20
    af88:	af00      	add	r7, sp, #0
    af8a:	6078      	str	r0, [r7, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    af8c:	687b      	ldr	r3, [r7, #4]
    af8e:	0c1b      	lsrs	r3, r3, #16
    af90:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    af94:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    af98:	60fb      	str	r3, [r7, #12]
    (*(volatile uint32_t *)regAddr) |= (1UL << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name));
    af9a:	68fb      	ldr	r3, [r7, #12]
    af9c:	6819      	ldr	r1, [r3, #0]
    af9e:	687b      	ldr	r3, [r7, #4]
    afa0:	b29b      	uxth	r3, r3
    afa2:	2201      	movs	r2, #1
    afa4:	409a      	lsls	r2, r3
    afa6:	68fb      	ldr	r3, [r7, #12]
    afa8:	430a      	orrs	r2, r1
    afaa:	601a      	str	r2, [r3, #0]
}
    afac:	bf00      	nop
    afae:	3714      	adds	r7, #20
    afb0:	46bd      	mov	sp, r7
    afb2:	f85d 7b04 	ldr.w	r7, [sp], #4
    afb6:	4770      	bx	lr

0000afb8 <DSPI_Enable>:
{
    afb8:	b480      	push	{r7}
    afba:	b083      	sub	sp, #12
    afbc:	af00      	add	r7, sp, #0
    afbe:	6078      	str	r0, [r7, #4]
    afc0:	460b      	mov	r3, r1
    afc2:	70fb      	strb	r3, [r7, #3]
    if (enable)
    afc4:	78fb      	ldrb	r3, [r7, #3]
    afc6:	2b00      	cmp	r3, #0
    afc8:	d006      	beq.n	afd8 <DSPI_Enable+0x20>
        base->MCR &= ~SPI_MCR_MDIS_MASK;
    afca:	687b      	ldr	r3, [r7, #4]
    afcc:	681b      	ldr	r3, [r3, #0]
    afce:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
    afd2:	687b      	ldr	r3, [r7, #4]
    afd4:	601a      	str	r2, [r3, #0]
}
    afd6:	e005      	b.n	afe4 <DSPI_Enable+0x2c>
        base->MCR |= SPI_MCR_MDIS_MASK;
    afd8:	687b      	ldr	r3, [r7, #4]
    afda:	681b      	ldr	r3, [r3, #0]
    afdc:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
    afe0:	687b      	ldr	r3, [r7, #4]
    afe2:	601a      	str	r2, [r3, #0]
}
    afe4:	bf00      	nop
    afe6:	370c      	adds	r7, #12
    afe8:	46bd      	mov	sp, r7
    afea:	f85d 7b04 	ldr.w	r7, [sp], #4
    afee:	4770      	bx	lr

0000aff0 <DSPI_GetStatusFlags>:
{
    aff0:	b480      	push	{r7}
    aff2:	b083      	sub	sp, #12
    aff4:	af00      	add	r7, sp, #0
    aff6:	6078      	str	r0, [r7, #4]
    return (base->SR);
    aff8:	687b      	ldr	r3, [r7, #4]
    affa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
    affc:	4618      	mov	r0, r3
    affe:	370c      	adds	r7, #12
    b000:	46bd      	mov	sp, r7
    b002:	f85d 7b04 	ldr.w	r7, [sp], #4
    b006:	4770      	bx	lr

0000b008 <DSPI_ClearStatusFlags>:
{
    b008:	b480      	push	{r7}
    b00a:	b083      	sub	sp, #12
    b00c:	af00      	add	r7, sp, #0
    b00e:	6078      	str	r0, [r7, #4]
    b010:	6039      	str	r1, [r7, #0]
    base->SR = statusFlags; /*!< The status flags are cleared by writing 1 (w1c).*/
    b012:	687b      	ldr	r3, [r7, #4]
    b014:	683a      	ldr	r2, [r7, #0]
    b016:	62da      	str	r2, [r3, #44]	; 0x2c
}
    b018:	bf00      	nop
    b01a:	370c      	adds	r7, #12
    b01c:	46bd      	mov	sp, r7
    b01e:	f85d 7b04 	ldr.w	r7, [sp], #4
    b022:	4770      	bx	lr

0000b024 <DSPI_SetMasterSlaveMode>:
{
    b024:	b480      	push	{r7}
    b026:	b083      	sub	sp, #12
    b028:	af00      	add	r7, sp, #0
    b02a:	6078      	str	r0, [r7, #4]
    b02c:	460b      	mov	r3, r1
    b02e:	70fb      	strb	r3, [r7, #3]
    base->MCR = (base->MCR & (~SPI_MCR_MSTR_MASK)) | SPI_MCR_MSTR(mode);
    b030:	687b      	ldr	r3, [r7, #4]
    b032:	681b      	ldr	r3, [r3, #0]
    b034:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    b038:	78fb      	ldrb	r3, [r7, #3]
    b03a:	07db      	lsls	r3, r3, #31
    b03c:	431a      	orrs	r2, r3
    b03e:	687b      	ldr	r3, [r7, #4]
    b040:	601a      	str	r2, [r3, #0]
}
    b042:	bf00      	nop
    b044:	370c      	adds	r7, #12
    b046:	46bd      	mov	sp, r7
    b048:	f85d 7b04 	ldr.w	r7, [sp], #4
    b04c:	4770      	bx	lr

0000b04e <DSPI_IsMaster>:
{
    b04e:	b480      	push	{r7}
    b050:	b085      	sub	sp, #20
    b052:	af00      	add	r7, sp, #0
    b054:	6078      	str	r0, [r7, #4]
    bool ismaster = false;
    b056:	2300      	movs	r3, #0
    b058:	73fb      	strb	r3, [r7, #15]
    if (0U != ((base->MCR) & SPI_MCR_MSTR_MASK))
    b05a:	687b      	ldr	r3, [r7, #4]
    b05c:	681b      	ldr	r3, [r3, #0]
    b05e:	2b00      	cmp	r3, #0
    b060:	da01      	bge.n	b066 <DSPI_IsMaster+0x18>
        ismaster = true;
    b062:	2301      	movs	r3, #1
    b064:	73fb      	strb	r3, [r7, #15]
    return ismaster;
    b066:	7bfb      	ldrb	r3, [r7, #15]
}
    b068:	4618      	mov	r0, r3
    b06a:	3714      	adds	r7, #20
    b06c:	46bd      	mov	sp, r7
    b06e:	f85d 7b04 	ldr.w	r7, [sp], #4
    b072:	4770      	bx	lr

0000b074 <DSPI_StartTransfer>:
{
    b074:	b480      	push	{r7}
    b076:	b083      	sub	sp, #12
    b078:	af00      	add	r7, sp, #0
    b07a:	6078      	str	r0, [r7, #4]
    base->MCR &= ~SPI_MCR_HALT_MASK;
    b07c:	687b      	ldr	r3, [r7, #4]
    b07e:	681b      	ldr	r3, [r3, #0]
    b080:	f023 0201 	bic.w	r2, r3, #1
    b084:	687b      	ldr	r3, [r7, #4]
    b086:	601a      	str	r2, [r3, #0]
}
    b088:	bf00      	nop
    b08a:	370c      	adds	r7, #12
    b08c:	46bd      	mov	sp, r7
    b08e:	f85d 7b04 	ldr.w	r7, [sp], #4
    b092:	4770      	bx	lr

0000b094 <DSPI_StopTransfer>:
{
    b094:	b480      	push	{r7}
    b096:	b083      	sub	sp, #12
    b098:	af00      	add	r7, sp, #0
    b09a:	6078      	str	r0, [r7, #4]
    base->MCR |= SPI_MCR_HALT_MASK;
    b09c:	687b      	ldr	r3, [r7, #4]
    b09e:	681b      	ldr	r3, [r3, #0]
    b0a0:	f043 0201 	orr.w	r2, r3, #1
    b0a4:	687b      	ldr	r3, [r7, #4]
    b0a6:	601a      	str	r2, [r3, #0]
}
    b0a8:	bf00      	nop
    b0aa:	370c      	adds	r7, #12
    b0ac:	46bd      	mov	sp, r7
    b0ae:	f85d 7b04 	ldr.w	r7, [sp], #4
    b0b2:	4770      	bx	lr

0000b0b4 <DSPI_GetInstance>:
 * brief Get instance number for DSPI module.
 *
 * param base DSPI peripheral base address.
 */
uint32_t DSPI_GetInstance(SPI_Type *base)
{
    b0b4:	b580      	push	{r7, lr}
    b0b6:	b084      	sub	sp, #16
    b0b8:	af00      	add	r7, sp, #0
    b0ba:	6078      	str	r0, [r7, #4]
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < ARRAY_SIZE(s_dspiBases); instance++)
    b0bc:	2300      	movs	r3, #0
    b0be:	60fb      	str	r3, [r7, #12]
    b0c0:	e009      	b.n	b0d6 <DSPI_GetInstance+0x22>
    {
        if (s_dspiBases[instance] == base)
    b0c2:	4a0e      	ldr	r2, [pc, #56]	; (b0fc <DSPI_GetInstance+0x48>)
    b0c4:	68fb      	ldr	r3, [r7, #12]
    b0c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b0ca:	687a      	ldr	r2, [r7, #4]
    b0cc:	429a      	cmp	r2, r3
    b0ce:	d006      	beq.n	b0de <DSPI_GetInstance+0x2a>
    for (instance = 0; instance < ARRAY_SIZE(s_dspiBases); instance++)
    b0d0:	68fb      	ldr	r3, [r7, #12]
    b0d2:	3301      	adds	r3, #1
    b0d4:	60fb      	str	r3, [r7, #12]
    b0d6:	68fb      	ldr	r3, [r7, #12]
    b0d8:	2b02      	cmp	r3, #2
    b0da:	d9f2      	bls.n	b0c2 <DSPI_GetInstance+0xe>
    b0dc:	e000      	b.n	b0e0 <DSPI_GetInstance+0x2c>
        {
            break;
    b0de:	bf00      	nop
        }
    }

    assert(instance < ARRAY_SIZE(s_dspiBases));
    b0e0:	68fb      	ldr	r3, [r7, #12]
    b0e2:	2b02      	cmp	r3, #2
    b0e4:	d905      	bls.n	b0f2 <DSPI_GetInstance+0x3e>
    b0e6:	4b06      	ldr	r3, [pc, #24]	; (b100 <DSPI_GetInstance+0x4c>)
    b0e8:	4a06      	ldr	r2, [pc, #24]	; (b104 <DSPI_GetInstance+0x50>)
    b0ea:	218c      	movs	r1, #140	; 0x8c
    b0ec:	4806      	ldr	r0, [pc, #24]	; (b108 <DSPI_GetInstance+0x54>)
    b0ee:	f7fc f875 	bl	71dc <__assert_func>

    return instance;
    b0f2:	68fb      	ldr	r3, [r7, #12]
}
    b0f4:	4618      	mov	r0, r3
    b0f6:	3710      	adds	r7, #16
    b0f8:	46bd      	mov	sp, r7
    b0fa:	bd80      	pop	{r7, pc}
    b0fc:	00010558 	.word	0x00010558
    b100:	00010570 	.word	0x00010570
    b104:	000106ac 	.word	0x000106ac
    b108:	00010594 	.word	0x00010594

0000b10c <DSPI_SetDummyData>:
 *
 * param base DSPI peripheral address.
 * param dummyData Data to be transferred when tx buffer is NULL.
 */
void DSPI_SetDummyData(SPI_Type *base, uint8_t dummyData)
{
    b10c:	b580      	push	{r7, lr}
    b10e:	b084      	sub	sp, #16
    b110:	af00      	add	r7, sp, #0
    b112:	6078      	str	r0, [r7, #4]
    b114:	460b      	mov	r3, r1
    b116:	70fb      	strb	r3, [r7, #3]
    uint32_t instance         = DSPI_GetInstance(base);
    b118:	6878      	ldr	r0, [r7, #4]
    b11a:	f7ff ffcb 	bl	b0b4 <DSPI_GetInstance>
    b11e:	60f8      	str	r0, [r7, #12]
    g_dspiDummyData[instance] = dummyData;
    b120:	4a04      	ldr	r2, [pc, #16]	; (b134 <DSPI_SetDummyData+0x28>)
    b122:	68fb      	ldr	r3, [r7, #12]
    b124:	4413      	add	r3, r2
    b126:	78fa      	ldrb	r2, [r7, #3]
    b128:	701a      	strb	r2, [r3, #0]
}
    b12a:	bf00      	nop
    b12c:	3710      	adds	r7, #16
    b12e:	46bd      	mov	sp, r7
    b130:	bd80      	pop	{r7, pc}
    b132:	bf00      	nop
    b134:	1fff14c0 	.word	0x1fff14c0

0000b138 <DSPI_MasterInit>:
 * param base DSPI peripheral address.
 * param masterConfig Pointer to the structure dspi_master_config_t.
 * param srcClock_Hz Module source input clock in Hertz.
 */
void DSPI_MasterInit(SPI_Type *base, const dspi_master_config_t *masterConfig, uint32_t srcClock_Hz)
{
    b138:	b580      	push	{r7, lr}
    b13a:	b088      	sub	sp, #32
    b13c:	af02      	add	r7, sp, #8
    b13e:	60f8      	str	r0, [r7, #12]
    b140:	60b9      	str	r1, [r7, #8]
    b142:	607a      	str	r2, [r7, #4]
    assert(NULL != masterConfig);
    b144:	68bb      	ldr	r3, [r7, #8]
    b146:	2b00      	cmp	r3, #0
    b148:	d105      	bne.n	b156 <DSPI_MasterInit+0x1e>
    b14a:	4b56      	ldr	r3, [pc, #344]	; (b2a4 <DSPI_MasterInit+0x16c>)
    b14c:	4a56      	ldr	r2, [pc, #344]	; (b2a8 <DSPI_MasterInit+0x170>)
    b14e:	21ca      	movs	r1, #202	; 0xca
    b150:	4856      	ldr	r0, [pc, #344]	; (b2ac <DSPI_MasterInit+0x174>)
    b152:	f7fc f843 	bl	71dc <__assert_func>

    uint32_t temp;
#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    /* enable DSPI clock */
    CLOCK_EnableClock(s_dspiClock[DSPI_GetInstance(base)]);
    b156:	68f8      	ldr	r0, [r7, #12]
    b158:	f7ff ffac 	bl	b0b4 <DSPI_GetInstance>
    b15c:	4603      	mov	r3, r0
    b15e:	4a54      	ldr	r2, [pc, #336]	; (b2b0 <DSPI_MasterInit+0x178>)
    b160:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b164:	4618      	mov	r0, r3
    b166:	f7ff ff0d 	bl	af84 <CLOCK_EnableClock>
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

    DSPI_Enable(base, true);
    b16a:	2101      	movs	r1, #1
    b16c:	68f8      	ldr	r0, [r7, #12]
    b16e:	f7ff ff23 	bl	afb8 <DSPI_Enable>
    DSPI_StopTransfer(base);
    b172:	68f8      	ldr	r0, [r7, #12]
    b174:	f7ff ff8e 	bl	b094 <DSPI_StopTransfer>

    DSPI_SetOnePcsPolarity(base, masterConfig->whichPcs, masterConfig->pcsActiveHighOrLow);
    b178:	68bb      	ldr	r3, [r7, #8]
    b17a:	7f19      	ldrb	r1, [r3, #28]
    b17c:	68bb      	ldr	r3, [r7, #8]
    b17e:	7f5b      	ldrb	r3, [r3, #29]
    b180:	461a      	mov	r2, r3
    b182:	68f8      	ldr	r0, [r7, #12]
    b184:	f000 f898 	bl	b2b8 <DSPI_SetOnePcsPolarity>
    DSPI_SetMasterSlaveMode(base, kDSPI_Master);
    b188:	2101      	movs	r1, #1
    b18a:	68f8      	ldr	r0, [r7, #12]
    b18c:	f7ff ff4a 	bl	b024 <DSPI_SetMasterSlaveMode>

    temp = base->MCR & (~(SPI_MCR_CONT_SCKE_MASK | SPI_MCR_MTFE_MASK | SPI_MCR_ROOE_MASK | SPI_MCR_SMPL_PT_MASK |
    b190:	68fb      	ldr	r3, [r7, #12]
    b192:	681b      	ldr	r3, [r3, #0]
    b194:	f023 438a 	bic.w	r3, r3, #1157627904	; 0x45000000
    b198:	f423 534c 	bic.w	r3, r3, #13056	; 0x3300
    b19c:	617b      	str	r3, [r7, #20]
                          SPI_MCR_DIS_TXF_MASK | SPI_MCR_DIS_RXF_MASK));

    base->MCR = temp | SPI_MCR_CONT_SCKE(masterConfig->enableContinuousSCK) |
    b19e:	68bb      	ldr	r3, [r7, #8]
    b1a0:	7f9b      	ldrb	r3, [r3, #30]
    b1a2:	079b      	lsls	r3, r3, #30
    b1a4:	f003 4280 	and.w	r2, r3, #1073741824	; 0x40000000
    b1a8:	697b      	ldr	r3, [r7, #20]
    b1aa:	431a      	orrs	r2, r3
                SPI_MCR_MTFE(masterConfig->enableModifiedTimingFormat) |
    b1ac:	68bb      	ldr	r3, [r7, #8]
    b1ae:	f893 3020 	ldrb.w	r3, [r3, #32]
    b1b2:	069b      	lsls	r3, r3, #26
    b1b4:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
    base->MCR = temp | SPI_MCR_CONT_SCKE(masterConfig->enableContinuousSCK) |
    b1b8:	431a      	orrs	r2, r3
                SPI_MCR_ROOE(masterConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(masterConfig->samplePoint) |
    b1ba:	68bb      	ldr	r3, [r7, #8]
    b1bc:	7fdb      	ldrb	r3, [r3, #31]
    b1be:	061b      	lsls	r3, r3, #24
    b1c0:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
                SPI_MCR_MTFE(masterConfig->enableModifiedTimingFormat) |
    b1c4:	431a      	orrs	r2, r3
                SPI_MCR_ROOE(masterConfig->enableRxFifoOverWrite) | SPI_MCR_SMPL_PT(masterConfig->samplePoint) |
    b1c6:	68bb      	ldr	r3, [r7, #8]
    b1c8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    b1cc:	021b      	lsls	r3, r3, #8
    b1ce:	f403 7340 	and.w	r3, r3, #768	; 0x300
                SPI_MCR_DIS_TXF(0U) | SPI_MCR_DIS_RXF(0U);
    b1d2:	431a      	orrs	r2, r3
    base->MCR = temp | SPI_MCR_CONT_SCKE(masterConfig->enableContinuousSCK) |
    b1d4:	68fb      	ldr	r3, [r7, #12]
    b1d6:	601a      	str	r2, [r3, #0]

    if (0U == DSPI_MasterSetBaudRate(base, masterConfig->whichCtar, masterConfig->ctarConfig.baudRate, srcClock_Hz))
    b1d8:	68bb      	ldr	r3, [r7, #8]
    b1da:	7819      	ldrb	r1, [r3, #0]
    b1dc:	68bb      	ldr	r3, [r7, #8]
    b1de:	685a      	ldr	r2, [r3, #4]
    b1e0:	687b      	ldr	r3, [r7, #4]
    b1e2:	68f8      	ldr	r0, [r7, #12]
    b1e4:	f000 f890 	bl	b308 <DSPI_MasterSetBaudRate>
    b1e8:	4603      	mov	r3, r0
    b1ea:	2b00      	cmp	r3, #0
    b1ec:	d105      	bne.n	b1fa <DSPI_MasterInit+0xc2>
    {
        assert(false);
    b1ee:	4b31      	ldr	r3, [pc, #196]	; (b2b4 <DSPI_MasterInit+0x17c>)
    b1f0:	4a2d      	ldr	r2, [pc, #180]	; (b2a8 <DSPI_MasterInit+0x170>)
    b1f2:	21e2      	movs	r1, #226	; 0xe2
    b1f4:	482d      	ldr	r0, [pc, #180]	; (b2ac <DSPI_MasterInit+0x174>)
    b1f6:	f7fb fff1 	bl	71dc <__assert_func>
    }

    temp = base->CTAR[masterConfig->whichCtar] &
    b1fa:	68bb      	ldr	r3, [r7, #8]
    b1fc:	781b      	ldrb	r3, [r3, #0]
    b1fe:	68fa      	ldr	r2, [r7, #12]
    b200:	3302      	adds	r3, #2
    b202:	009b      	lsls	r3, r3, #2
    b204:	4413      	add	r3, r2
    b206:	685b      	ldr	r3, [r3, #4]
    b208:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
    b20c:	617b      	str	r3, [r7, #20]
           ~(SPI_CTAR_FMSZ_MASK | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK | SPI_CTAR_LSBFE_MASK);

    base->CTAR[masterConfig->whichCtar] = temp | SPI_CTAR_FMSZ(masterConfig->ctarConfig.bitsPerFrame - 1U) |
    b20e:	68bb      	ldr	r3, [r7, #8]
    b210:	689b      	ldr	r3, [r3, #8]
    b212:	3b01      	subs	r3, #1
    b214:	06db      	lsls	r3, r3, #27
    b216:	f003 42f0 	and.w	r2, r3, #2013265920	; 0x78000000
    b21a:	697b      	ldr	r3, [r7, #20]
    b21c:	431a      	orrs	r2, r3
                                          SPI_CTAR_CPOL(masterConfig->ctarConfig.cpol) |
    b21e:	68bb      	ldr	r3, [r7, #8]
    b220:	7b1b      	ldrb	r3, [r3, #12]
    b222:	069b      	lsls	r3, r3, #26
    b224:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
    base->CTAR[masterConfig->whichCtar] = temp | SPI_CTAR_FMSZ(masterConfig->ctarConfig.bitsPerFrame - 1U) |
    b228:	431a      	orrs	r2, r3
                                          SPI_CTAR_CPHA(masterConfig->ctarConfig.cpha) |
    b22a:	68bb      	ldr	r3, [r7, #8]
    b22c:	7b5b      	ldrb	r3, [r3, #13]
    b22e:	065b      	lsls	r3, r3, #25
    b230:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
                                          SPI_CTAR_CPOL(masterConfig->ctarConfig.cpol) |
    b234:	431a      	orrs	r2, r3
                                          SPI_CTAR_LSBFE(masterConfig->ctarConfig.direction);
    b236:	68bb      	ldr	r3, [r7, #8]
    b238:	7b9b      	ldrb	r3, [r3, #14]
    b23a:	061b      	lsls	r3, r3, #24
    b23c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    base->CTAR[masterConfig->whichCtar] = temp | SPI_CTAR_FMSZ(masterConfig->ctarConfig.bitsPerFrame - 1U) |
    b240:	68b9      	ldr	r1, [r7, #8]
    b242:	7809      	ldrb	r1, [r1, #0]
    b244:	4608      	mov	r0, r1
                                          SPI_CTAR_CPHA(masterConfig->ctarConfig.cpha) |
    b246:	431a      	orrs	r2, r3
    base->CTAR[masterConfig->whichCtar] = temp | SPI_CTAR_FMSZ(masterConfig->ctarConfig.bitsPerFrame - 1U) |
    b248:	68f9      	ldr	r1, [r7, #12]
    b24a:	1c83      	adds	r3, r0, #2
    b24c:	009b      	lsls	r3, r3, #2
    b24e:	440b      	add	r3, r1
    b250:	605a      	str	r2, [r3, #4]

    (void)DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_PcsToSck, srcClock_Hz,
    b252:	68bb      	ldr	r3, [r7, #8]
    b254:	7819      	ldrb	r1, [r3, #0]
                                   masterConfig->ctarConfig.pcsToSckDelayInNanoSec);
    b256:	68bb      	ldr	r3, [r7, #8]
    b258:	691b      	ldr	r3, [r3, #16]
    (void)DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_PcsToSck, srcClock_Hz,
    b25a:	9300      	str	r3, [sp, #0]
    b25c:	687b      	ldr	r3, [r7, #4]
    b25e:	2201      	movs	r2, #1
    b260:	68f8      	ldr	r0, [r7, #12]
    b262:	f000 f963 	bl	b52c <DSPI_MasterSetDelayTimes>
    (void)DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_LastSckToPcs, srcClock_Hz,
    b266:	68bb      	ldr	r3, [r7, #8]
    b268:	7819      	ldrb	r1, [r3, #0]
                                   masterConfig->ctarConfig.lastSckToPcsDelayInNanoSec);
    b26a:	68bb      	ldr	r3, [r7, #8]
    b26c:	695b      	ldr	r3, [r3, #20]
    (void)DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_LastSckToPcs, srcClock_Hz,
    b26e:	9300      	str	r3, [sp, #0]
    b270:	687b      	ldr	r3, [r7, #4]
    b272:	2202      	movs	r2, #2
    b274:	68f8      	ldr	r0, [r7, #12]
    b276:	f000 f959 	bl	b52c <DSPI_MasterSetDelayTimes>
    (void)DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_BetweenTransfer, srcClock_Hz,
    b27a:	68bb      	ldr	r3, [r7, #8]
    b27c:	7819      	ldrb	r1, [r3, #0]
                                   masterConfig->ctarConfig.betweenTransferDelayInNanoSec);
    b27e:	68bb      	ldr	r3, [r7, #8]
    b280:	699b      	ldr	r3, [r3, #24]
    (void)DSPI_MasterSetDelayTimes(base, masterConfig->whichCtar, kDSPI_BetweenTransfer, srcClock_Hz,
    b282:	9300      	str	r3, [sp, #0]
    b284:	687b      	ldr	r3, [r7, #4]
    b286:	2203      	movs	r2, #3
    b288:	68f8      	ldr	r0, [r7, #12]
    b28a:	f000 f94f 	bl	b52c <DSPI_MasterSetDelayTimes>

    DSPI_SetDummyData(base, DSPI_DUMMY_DATA);
    b28e:	2100      	movs	r1, #0
    b290:	68f8      	ldr	r0, [r7, #12]
    b292:	f7ff ff3b 	bl	b10c <DSPI_SetDummyData>
    DSPI_StartTransfer(base);
    b296:	68f8      	ldr	r0, [r7, #12]
    b298:	f7ff feec 	bl	b074 <DSPI_StartTransfer>
}
    b29c:	bf00      	nop
    b29e:	3718      	adds	r7, #24
    b2a0:	46bd      	mov	sp, r7
    b2a2:	bd80      	pop	{r7, pc}
    b2a4:	000105ec 	.word	0x000105ec
    b2a8:	000106c0 	.word	0x000106c0
    b2ac:	00010594 	.word	0x00010594
    b2b0:	00010564 	.word	0x00010564
    b2b4:	00010604 	.word	0x00010604

0000b2b8 <DSPI_SetOnePcsPolarity>:
    CLOCK_DisableClock(s_dspiClock[DSPI_GetInstance(base)]);
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
}

static void DSPI_SetOnePcsPolarity(SPI_Type *base, dspi_which_pcs_t pcs, dspi_pcs_polarity_config_t activeLowOrHigh)
{
    b2b8:	b480      	push	{r7}
    b2ba:	b085      	sub	sp, #20
    b2bc:	af00      	add	r7, sp, #0
    b2be:	6078      	str	r0, [r7, #4]
    b2c0:	460b      	mov	r3, r1
    b2c2:	70fb      	strb	r3, [r7, #3]
    b2c4:	4613      	mov	r3, r2
    b2c6:	70bb      	strb	r3, [r7, #2]
    uint32_t temp;

    temp = base->MCR;
    b2c8:	687b      	ldr	r3, [r7, #4]
    b2ca:	681b      	ldr	r3, [r3, #0]
    b2cc:	60fb      	str	r3, [r7, #12]

    if (activeLowOrHigh == kDSPI_PcsActiveLow)
    b2ce:	78bb      	ldrb	r3, [r7, #2]
    b2d0:	2b01      	cmp	r3, #1
    b2d2:	d107      	bne.n	b2e4 <DSPI_SetOnePcsPolarity+0x2c>
    {
        temp |= SPI_MCR_PCSIS(pcs);
    b2d4:	78fb      	ldrb	r3, [r7, #3]
    b2d6:	041b      	lsls	r3, r3, #16
    b2d8:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
    b2dc:	68fa      	ldr	r2, [r7, #12]
    b2de:	4313      	orrs	r3, r2
    b2e0:	60fb      	str	r3, [r7, #12]
    b2e2:	e007      	b.n	b2f4 <DSPI_SetOnePcsPolarity+0x3c>
    }
    else
    {
        temp &= ~SPI_MCR_PCSIS(pcs);
    b2e4:	78fb      	ldrb	r3, [r7, #3]
    b2e6:	041b      	lsls	r3, r3, #16
    b2e8:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
    b2ec:	43db      	mvns	r3, r3
    b2ee:	68fa      	ldr	r2, [r7, #12]
    b2f0:	4013      	ands	r3, r2
    b2f2:	60fb      	str	r3, [r7, #12]
    }

    base->MCR = temp;
    b2f4:	687b      	ldr	r3, [r7, #4]
    b2f6:	68fa      	ldr	r2, [r7, #12]
    b2f8:	601a      	str	r2, [r3, #0]
}
    b2fa:	bf00      	nop
    b2fc:	3714      	adds	r7, #20
    b2fe:	46bd      	mov	sp, r7
    b300:	f85d 7b04 	ldr.w	r7, [sp], #4
    b304:	4770      	bx	lr
    b306:	Address 0x0000b306 is out of bounds.


0000b308 <DSPI_MasterSetBaudRate>:
 */
uint32_t DSPI_MasterSetBaudRate(SPI_Type *base,
                                dspi_ctar_selection_t whichCtar,
                                uint32_t baudRate_Bps,
                                uint32_t srcClock_Hz)
{
    b308:	b580      	push	{r7, lr}
    b30a:	b090      	sub	sp, #64	; 0x40
    b30c:	af00      	add	r7, sp, #0
    b30e:	60f8      	str	r0, [r7, #12]
    b310:	607a      	str	r2, [r7, #4]
    b312:	603b      	str	r3, [r7, #0]
    b314:	460b      	mov	r3, r1
    b316:	72fb      	strb	r3, [r7, #11]
    /* for master mode configuration, if slave mode detected, return 0*/
    if (!DSPI_IsMaster(base))
    b318:	68f8      	ldr	r0, [r7, #12]
    b31a:	f7ff fe98 	bl	b04e <DSPI_IsMaster>
    b31e:	4603      	mov	r3, r0
    b320:	f083 0301 	eor.w	r3, r3, #1
    b324:	b2db      	uxtb	r3, r3
    b326:	2b00      	cmp	r3, #0
    b328:	d001      	beq.n	b32e <DSPI_MasterSetBaudRate+0x26>
    {
        return 0U;
    b32a:	2300      	movs	r3, #0
    b32c:	e078      	b.n	b420 <DSPI_MasterSetBaudRate+0x118>
    uint32_t prescaler, bestPrescaler;
    uint32_t scaler, bestScaler;
    uint32_t dbr, bestDbr;
    uint32_t realBaudrate, bestBaudrate;
    uint32_t diff, min_diff;
    uint32_t baudrate = baudRate_Bps;
    b32e:	687b      	ldr	r3, [r7, #4]
    b330:	61fb      	str	r3, [r7, #28]

    /* find combination of prescaler and scaler resulting in baudrate closest to the requested value */
    min_diff      = 0xFFFFFFFFU;
    b332:	f04f 33ff 	mov.w	r3, #4294967295
    b336:	623b      	str	r3, [r7, #32]
    bestPrescaler = 0;
    b338:	2300      	movs	r3, #0
    b33a:	63bb      	str	r3, [r7, #56]	; 0x38
    bestScaler    = 0;
    b33c:	2300      	movs	r3, #0
    b33e:	633b      	str	r3, [r7, #48]	; 0x30
    bestDbr       = 1;
    b340:	2301      	movs	r3, #1
    b342:	62bb      	str	r3, [r7, #40]	; 0x28
    bestBaudrate  = 0; /* required to avoid compilation warning */
    b344:	2300      	movs	r3, #0
    b346:	627b      	str	r3, [r7, #36]	; 0x24

    /* In all for loops, if min_diff = 0, the exit for loop*/
    for (prescaler = 0U; prescaler < 4U; prescaler++)
    b348:	2300      	movs	r3, #0
    b34a:	63fb      	str	r3, [r7, #60]	; 0x3c
    b34c:	e048      	b.n	b3e0 <DSPI_MasterSetBaudRate+0xd8>
    {
        for (scaler = 0U; scaler < 16U; scaler++)
    b34e:	2300      	movs	r3, #0
    b350:	637b      	str	r3, [r7, #52]	; 0x34
    b352:	e03a      	b.n	b3ca <DSPI_MasterSetBaudRate+0xc2>
        {
            for (dbr = 1U; dbr < 3U; dbr++)
    b354:	2301      	movs	r3, #1
    b356:	62fb      	str	r3, [r7, #44]	; 0x2c
    b358:	e02c      	b.n	b3b4 <DSPI_MasterSetBaudRate+0xac>
            {
                realBaudrate = ((srcClock_Hz * dbr) / (s_baudratePrescaler[prescaler] * (s_baudrateScaler[scaler])));
    b35a:	683b      	ldr	r3, [r7, #0]
    b35c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    b35e:	fb03 f202 	mul.w	r2, r3, r2
    b362:	4931      	ldr	r1, [pc, #196]	; (b428 <DSPI_MasterSetBaudRate+0x120>)
    b364:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    b366:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    b36a:	4830      	ldr	r0, [pc, #192]	; (b42c <DSPI_MasterSetBaudRate+0x124>)
    b36c:	6b79      	ldr	r1, [r7, #52]	; 0x34
    b36e:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    b372:	fb01 f303 	mul.w	r3, r1, r3
    b376:	fbb2 f3f3 	udiv	r3, r2, r3
    b37a:	61bb      	str	r3, [r7, #24]

                /* calculate the baud rate difference based on the conditional statement that states that the calculated
                 * baud rate must not exceed the desired baud rate.
                 */
                if (baudrate >= realBaudrate)
    b37c:	69fa      	ldr	r2, [r7, #28]
    b37e:	69bb      	ldr	r3, [r7, #24]
    b380:	429a      	cmp	r2, r3
    b382:	d311      	bcc.n	b3a8 <DSPI_MasterSetBaudRate+0xa0>
                {
                    diff = baudrate - realBaudrate;
    b384:	69fa      	ldr	r2, [r7, #28]
    b386:	69bb      	ldr	r3, [r7, #24]
    b388:	1ad3      	subs	r3, r2, r3
    b38a:	617b      	str	r3, [r7, #20]
                    if (min_diff > diff)
    b38c:	6a3a      	ldr	r2, [r7, #32]
    b38e:	697b      	ldr	r3, [r7, #20]
    b390:	429a      	cmp	r2, r3
    b392:	d909      	bls.n	b3a8 <DSPI_MasterSetBaudRate+0xa0>
                    {
                        /* a better match found */
                        min_diff      = diff;
    b394:	697b      	ldr	r3, [r7, #20]
    b396:	623b      	str	r3, [r7, #32]
                        bestPrescaler = prescaler;
    b398:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    b39a:	63bb      	str	r3, [r7, #56]	; 0x38
                        bestScaler    = scaler;
    b39c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    b39e:	633b      	str	r3, [r7, #48]	; 0x30
                        bestBaudrate  = realBaudrate;
    b3a0:	69bb      	ldr	r3, [r7, #24]
    b3a2:	627b      	str	r3, [r7, #36]	; 0x24
                        bestDbr       = dbr;
    b3a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b3a6:	62bb      	str	r3, [r7, #40]	; 0x28
                    }
                }
                if (0U == min_diff)
    b3a8:	6a3b      	ldr	r3, [r7, #32]
    b3aa:	2b00      	cmp	r3, #0
    b3ac:	d006      	beq.n	b3bc <DSPI_MasterSetBaudRate+0xb4>
            for (dbr = 1U; dbr < 3U; dbr++)
    b3ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b3b0:	3301      	adds	r3, #1
    b3b2:	62fb      	str	r3, [r7, #44]	; 0x2c
    b3b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b3b6:	2b02      	cmp	r3, #2
    b3b8:	d9cf      	bls.n	b35a <DSPI_MasterSetBaudRate+0x52>
    b3ba:	e000      	b.n	b3be <DSPI_MasterSetBaudRate+0xb6>
                {
                    break;
    b3bc:	bf00      	nop
                }
            }

            if (0U == min_diff)
    b3be:	6a3b      	ldr	r3, [r7, #32]
    b3c0:	2b00      	cmp	r3, #0
    b3c2:	d006      	beq.n	b3d2 <DSPI_MasterSetBaudRate+0xca>
        for (scaler = 0U; scaler < 16U; scaler++)
    b3c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    b3c6:	3301      	adds	r3, #1
    b3c8:	637b      	str	r3, [r7, #52]	; 0x34
    b3ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    b3cc:	2b0f      	cmp	r3, #15
    b3ce:	d9c1      	bls.n	b354 <DSPI_MasterSetBaudRate+0x4c>
    b3d0:	e000      	b.n	b3d4 <DSPI_MasterSetBaudRate+0xcc>
            {
                break;
    b3d2:	bf00      	nop
            }
        }
        if (0U == min_diff)
    b3d4:	6a3b      	ldr	r3, [r7, #32]
    b3d6:	2b00      	cmp	r3, #0
    b3d8:	d006      	beq.n	b3e8 <DSPI_MasterSetBaudRate+0xe0>
    for (prescaler = 0U; prescaler < 4U; prescaler++)
    b3da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    b3dc:	3301      	adds	r3, #1
    b3de:	63fb      	str	r3, [r7, #60]	; 0x3c
    b3e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    b3e2:	2b03      	cmp	r3, #3
    b3e4:	d9b3      	bls.n	b34e <DSPI_MasterSetBaudRate+0x46>
    b3e6:	e000      	b.n	b3ea <DSPI_MasterSetBaudRate+0xe2>
        {
            break;
    b3e8:	bf00      	nop
        }
    }

    /* write the best dbr, prescalar, and baud rate scalar to the CTAR */
    temp = base->CTAR[whichCtar] & ~(SPI_CTAR_DBR_MASK | SPI_CTAR_PBR_MASK | SPI_CTAR_BR_MASK);
    b3ea:	7afb      	ldrb	r3, [r7, #11]
    b3ec:	68fa      	ldr	r2, [r7, #12]
    b3ee:	3302      	adds	r3, #2
    b3f0:	009b      	lsls	r3, r3, #2
    b3f2:	4413      	add	r3, r2
    b3f4:	685a      	ldr	r2, [r3, #4]
    b3f6:	4b0e      	ldr	r3, [pc, #56]	; (b430 <DSPI_MasterSetBaudRate+0x128>)
    b3f8:	4013      	ands	r3, r2
    b3fa:	613b      	str	r3, [r7, #16]

    base->CTAR[whichCtar] = temp | ((bestDbr - 1U) << SPI_CTAR_DBR_SHIFT) | (bestPrescaler << SPI_CTAR_PBR_SHIFT) |
    b3fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    b3fe:	3b01      	subs	r3, #1
    b400:	07da      	lsls	r2, r3, #31
    b402:	693b      	ldr	r3, [r7, #16]
    b404:	431a      	orrs	r2, r3
    b406:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    b408:	041b      	lsls	r3, r3, #16
    b40a:	ea42 0103 	orr.w	r1, r2, r3
    b40e:	7afb      	ldrb	r3, [r7, #11]
    b410:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    b412:	430a      	orrs	r2, r1
    b414:	68f9      	ldr	r1, [r7, #12]
    b416:	3302      	adds	r3, #2
    b418:	009b      	lsls	r3, r3, #2
    b41a:	440b      	add	r3, r1
    b41c:	605a      	str	r2, [r3, #4]
                            (bestScaler << SPI_CTAR_BR_SHIFT);

    /* return the actual calculated baud rate */
    return bestBaudrate;
    b41e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    b420:	4618      	mov	r0, r3
    b422:	3740      	adds	r7, #64	; 0x40
    b424:	46bd      	mov	sp, r7
    b426:	bd80      	pop	{r7, pc}
    b428:	000104b8 	.word	0x000104b8
    b42c:	000104c8 	.word	0x000104c8
    b430:	7ffcfff0 	.word	0x7ffcfff0

0000b434 <DSPI_MasterSetDelayScaler>:
 * param scaler The scaler delay value (can be any integer between 0 to 15).
 * param whichDelay The desired delay to configure; must be of type dspi_delay_type_t
 */
void DSPI_MasterSetDelayScaler(
    SPI_Type *base, dspi_ctar_selection_t whichCtar, uint32_t prescaler, uint32_t scaler, dspi_delay_type_t whichDelay)
{
    b434:	b580      	push	{r7, lr}
    b436:	b084      	sub	sp, #16
    b438:	af00      	add	r7, sp, #0
    b43a:	60f8      	str	r0, [r7, #12]
    b43c:	607a      	str	r2, [r7, #4]
    b43e:	603b      	str	r3, [r7, #0]
    b440:	460b      	mov	r3, r1
    b442:	72fb      	strb	r3, [r7, #11]
    /* these settings are only relevant in master mode */
    if (DSPI_IsMaster(base))
    b444:	68f8      	ldr	r0, [r7, #12]
    b446:	f7ff fe02 	bl	b04e <DSPI_IsMaster>
    b44a:	4603      	mov	r3, r0
    b44c:	2b00      	cmp	r3, #0
    b44e:	d062      	beq.n	b516 <DSPI_MasterSetDelayScaler+0xe2>
    {
        switch (whichDelay)
    b450:	7e3b      	ldrb	r3, [r7, #24]
    b452:	2b03      	cmp	r3, #3
    b454:	d03d      	beq.n	b4d2 <DSPI_MasterSetDelayScaler+0x9e>
    b456:	2b03      	cmp	r3, #3
    b458:	dc56      	bgt.n	b508 <DSPI_MasterSetDelayScaler+0xd4>
    b45a:	2b01      	cmp	r3, #1
    b45c:	d002      	beq.n	b464 <DSPI_MasterSetDelayScaler+0x30>
    b45e:	2b02      	cmp	r3, #2
    b460:	d01b      	beq.n	b49a <DSPI_MasterSetDelayScaler+0x66>
    b462:	e051      	b.n	b508 <DSPI_MasterSetDelayScaler+0xd4>
        {
            case kDSPI_PcsToSck:
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PCSSCK_MASK) & (~SPI_CTAR_CSSCK_MASK)) |
    b464:	7afb      	ldrb	r3, [r7, #11]
    b466:	68fa      	ldr	r2, [r7, #12]
    b468:	3302      	adds	r3, #2
    b46a:	009b      	lsls	r3, r3, #2
    b46c:	4413      	add	r3, r2
    b46e:	685b      	ldr	r3, [r3, #4]
    b470:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
    b474:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
                                        SPI_CTAR_PCSSCK(prescaler) | SPI_CTAR_CSSCK(scaler);
    b478:	687a      	ldr	r2, [r7, #4]
    b47a:	0592      	lsls	r2, r2, #22
    b47c:	f402 0240 	and.w	r2, r2, #12582912	; 0xc00000
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PCSSCK_MASK) & (~SPI_CTAR_CSSCK_MASK)) |
    b480:	ea43 0102 	orr.w	r1, r3, r2
                                        SPI_CTAR_PCSSCK(prescaler) | SPI_CTAR_CSSCK(scaler);
    b484:	683b      	ldr	r3, [r7, #0]
    b486:	031b      	lsls	r3, r3, #12
    b488:	b29a      	uxth	r2, r3
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PCSSCK_MASK) & (~SPI_CTAR_CSSCK_MASK)) |
    b48a:	7afb      	ldrb	r3, [r7, #11]
                                        SPI_CTAR_PCSSCK(prescaler) | SPI_CTAR_CSSCK(scaler);
    b48c:	430a      	orrs	r2, r1
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PCSSCK_MASK) & (~SPI_CTAR_CSSCK_MASK)) |
    b48e:	68f9      	ldr	r1, [r7, #12]
    b490:	3302      	adds	r3, #2
    b492:	009b      	lsls	r3, r3, #2
    b494:	440b      	add	r3, r1
    b496:	605a      	str	r2, [r3, #4]
                break;
    b498:	e03d      	b.n	b516 <DSPI_MasterSetDelayScaler+0xe2>
            case kDSPI_LastSckToPcs:
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PASC_MASK) & (~SPI_CTAR_ASC_MASK)) |
    b49a:	7afb      	ldrb	r3, [r7, #11]
    b49c:	68fa      	ldr	r2, [r7, #12]
    b49e:	3302      	adds	r3, #2
    b4a0:	009b      	lsls	r3, r3, #2
    b4a2:	4413      	add	r3, r2
    b4a4:	685b      	ldr	r3, [r3, #4]
    b4a6:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
    b4aa:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                                        SPI_CTAR_PASC(prescaler) | SPI_CTAR_ASC(scaler);
    b4ae:	687a      	ldr	r2, [r7, #4]
    b4b0:	0512      	lsls	r2, r2, #20
    b4b2:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PASC_MASK) & (~SPI_CTAR_ASC_MASK)) |
    b4b6:	ea43 0102 	orr.w	r1, r3, r2
                                        SPI_CTAR_PASC(prescaler) | SPI_CTAR_ASC(scaler);
    b4ba:	683b      	ldr	r3, [r7, #0]
    b4bc:	021b      	lsls	r3, r3, #8
    b4be:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PASC_MASK) & (~SPI_CTAR_ASC_MASK)) |
    b4c2:	7afb      	ldrb	r3, [r7, #11]
                                        SPI_CTAR_PASC(prescaler) | SPI_CTAR_ASC(scaler);
    b4c4:	430a      	orrs	r2, r1
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PASC_MASK) & (~SPI_CTAR_ASC_MASK)) |
    b4c6:	68f9      	ldr	r1, [r7, #12]
    b4c8:	3302      	adds	r3, #2
    b4ca:	009b      	lsls	r3, r3, #2
    b4cc:	440b      	add	r3, r1
    b4ce:	605a      	str	r2, [r3, #4]
                break;
    b4d0:	e021      	b.n	b516 <DSPI_MasterSetDelayScaler+0xe2>
            case kDSPI_BetweenTransfer:
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PDT_MASK) & (~SPI_CTAR_DT_MASK)) |
    b4d2:	7afb      	ldrb	r3, [r7, #11]
    b4d4:	68fa      	ldr	r2, [r7, #12]
    b4d6:	3302      	adds	r3, #2
    b4d8:	009b      	lsls	r3, r3, #2
    b4da:	4413      	add	r3, r2
    b4dc:	685b      	ldr	r3, [r3, #4]
    b4de:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
    b4e2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
                                        SPI_CTAR_PDT(prescaler) | SPI_CTAR_DT(scaler);
    b4e6:	687a      	ldr	r2, [r7, #4]
    b4e8:	0492      	lsls	r2, r2, #18
    b4ea:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PDT_MASK) & (~SPI_CTAR_DT_MASK)) |
    b4ee:	ea43 0102 	orr.w	r1, r3, r2
                                        SPI_CTAR_PDT(prescaler) | SPI_CTAR_DT(scaler);
    b4f2:	683b      	ldr	r3, [r7, #0]
    b4f4:	011b      	lsls	r3, r3, #4
    b4f6:	b2da      	uxtb	r2, r3
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PDT_MASK) & (~SPI_CTAR_DT_MASK)) |
    b4f8:	7afb      	ldrb	r3, [r7, #11]
                                        SPI_CTAR_PDT(prescaler) | SPI_CTAR_DT(scaler);
    b4fa:	430a      	orrs	r2, r1
                base->CTAR[whichCtar] = (base->CTAR[whichCtar] & (~SPI_CTAR_PDT_MASK) & (~SPI_CTAR_DT_MASK)) |
    b4fc:	68f9      	ldr	r1, [r7, #12]
    b4fe:	3302      	adds	r3, #2
    b500:	009b      	lsls	r3, r3, #2
    b502:	440b      	add	r3, r1
    b504:	605a      	str	r2, [r3, #4]
                break;
    b506:	e006      	b.n	b516 <DSPI_MasterSetDelayScaler+0xe2>
            default:
                /* All cases have been listed above, the default clause should not be reached. */
                assert(false);
    b508:	4b05      	ldr	r3, [pc, #20]	; (b520 <DSPI_MasterSetDelayScaler+0xec>)
    b50a:	4a06      	ldr	r2, [pc, #24]	; (b524 <DSPI_MasterSetDelayScaler+0xf0>)
    b50c:	f44f 7107 	mov.w	r1, #540	; 0x21c
    b510:	4805      	ldr	r0, [pc, #20]	; (b528 <DSPI_MasterSetDelayScaler+0xf4>)
    b512:	f7fb fe63 	bl	71dc <__assert_func>
                break;
        }
    }
}
    b516:	bf00      	nop
    b518:	3710      	adds	r7, #16
    b51a:	46bd      	mov	sp, r7
    b51c:	bd80      	pop	{r7, pc}
    b51e:	bf00      	nop
    b520:	00010604 	.word	0x00010604
    b524:	000106d0 	.word	0x000106d0
    b528:	00010594 	.word	0x00010594

0000b52c <DSPI_MasterSetDelayTimes>:
uint32_t DSPI_MasterSetDelayTimes(SPI_Type *base,
                                  dspi_ctar_selection_t whichCtar,
                                  dspi_delay_type_t whichDelay,
                                  uint32_t srcClock_Hz,
                                  uint32_t delayTimeInNanoSec)
{
    b52c:	b580      	push	{r7, lr}
    b52e:	b090      	sub	sp, #64	; 0x40
    b530:	af02      	add	r7, sp, #8
    b532:	60f8      	str	r0, [r7, #12]
    b534:	607b      	str	r3, [r7, #4]
    b536:	460b      	mov	r3, r1
    b538:	72fb      	strb	r3, [r7, #11]
    b53a:	4613      	mov	r3, r2
    b53c:	72bb      	strb	r3, [r7, #10]
    /* for master mode configuration, if slave mode detected, return 0 */
    if (!DSPI_IsMaster(base))
    b53e:	68f8      	ldr	r0, [r7, #12]
    b540:	f7ff fd85 	bl	b04e <DSPI_IsMaster>
    b544:	4603      	mov	r3, r0
    b546:	f083 0301 	eor.w	r3, r3, #1
    b54a:	b2db      	uxtb	r3, r3
    b54c:	2b00      	cmp	r3, #0
    b54e:	d001      	beq.n	b554 <DSPI_MasterSetDelayTimes+0x28>
    {
        return 0U;
    b550:	2300      	movs	r3, #0
    b552:	e077      	b.n	b644 <DSPI_MasterSetDelayTimes+0x118>
    uint32_t initialDelayNanoSec;

    /* find combination of prescaler and scaler resulting in the delay closest to the
     * requested value
     */
    min_diff = 0xFFFFFFFFU;
    b554:	f04f 33ff 	mov.w	r3, #4294967295
    b558:	623b      	str	r3, [r7, #32]
    /* Initialize prescaler and scaler to their max values to generate the max delay */
    bestPrescaler = 0x3;
    b55a:	2303      	movs	r3, #3
    b55c:	633b      	str	r3, [r7, #48]	; 0x30
    bestScaler    = 0xF;
    b55e:	230f      	movs	r3, #15
    b560:	62bb      	str	r3, [r7, #40]	; 0x28
    bestDelay = (((1000000000U * 4U) / srcClock_Hz) * s_delayPrescaler[bestPrescaler] * s_delayScaler[bestScaler]) / 4U;
    b562:	4a3a      	ldr	r2, [pc, #232]	; (b64c <DSPI_MasterSetDelayTimes+0x120>)
    b564:	687b      	ldr	r3, [r7, #4]
    b566:	fbb2 f3f3 	udiv	r3, r2, r3
    b56a:	4939      	ldr	r1, [pc, #228]	; (b650 <DSPI_MasterSetDelayTimes+0x124>)
    b56c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    b56e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    b572:	fb02 f303 	mul.w	r3, r2, r3
    b576:	4937      	ldr	r1, [pc, #220]	; (b654 <DSPI_MasterSetDelayTimes+0x128>)
    b578:	6aba      	ldr	r2, [r7, #40]	; 0x28
    b57a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    b57e:	fb02 f303 	mul.w	r3, r2, r3
    b582:	089b      	lsrs	r3, r3, #2
    b584:	627b      	str	r3, [r7, #36]	; 0x24

    /* First calculate the initial, default delay */
    initialDelayNanoSec = 1000000000U / srcClock_Hz * 2U;
    b586:	4a34      	ldr	r2, [pc, #208]	; (b658 <DSPI_MasterSetDelayTimes+0x12c>)
    b588:	687b      	ldr	r3, [r7, #4]
    b58a:	fbb2 f3f3 	udiv	r3, r2, r3
    b58e:	005b      	lsls	r3, r3, #1
    b590:	61fb      	str	r3, [r7, #28]

    /* If the initial, default delay is already greater than the desired delay, then
     * set the delays to their initial value (0) and return the delay. In other words,
     * there is no way to decrease the delay value further.
     */
    if (initialDelayNanoSec >= delayTimeInNanoSec)
    b592:	69fa      	ldr	r2, [r7, #28]
    b594:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    b596:	429a      	cmp	r2, r3
    b598:	d309      	bcc.n	b5ae <DSPI_MasterSetDelayTimes+0x82>
    {
        DSPI_MasterSetDelayScaler(base, whichCtar, 0, 0, whichDelay);
    b59a:	7af9      	ldrb	r1, [r7, #11]
    b59c:	7abb      	ldrb	r3, [r7, #10]
    b59e:	9300      	str	r3, [sp, #0]
    b5a0:	2300      	movs	r3, #0
    b5a2:	2200      	movs	r2, #0
    b5a4:	68f8      	ldr	r0, [r7, #12]
    b5a6:	f7ff ff45 	bl	b434 <DSPI_MasterSetDelayScaler>
        return initialDelayNanoSec;
    b5aa:	69fb      	ldr	r3, [r7, #28]
    b5ac:	e04a      	b.n	b644 <DSPI_MasterSetDelayTimes+0x118>
    }

    /* In all for loops, if min_diff = 0, the exit for loop */
    for (prescaler = 0; prescaler < 4U; prescaler++)
    b5ae:	2300      	movs	r3, #0
    b5b0:	637b      	str	r3, [r7, #52]	; 0x34
    b5b2:	e039      	b.n	b628 <DSPI_MasterSetDelayTimes+0xfc>
    {
        for (scaler = 0; scaler < 16U; scaler++)
    b5b4:	2300      	movs	r3, #0
    b5b6:	62fb      	str	r3, [r7, #44]	; 0x2c
    b5b8:	e02b      	b.n	b612 <DSPI_MasterSetDelayTimes+0xe6>
        {
            realDelay = ((4000000000U / srcClock_Hz) * s_delayPrescaler[prescaler] * s_delayScaler[scaler]) / 4U;
    b5ba:	4a24      	ldr	r2, [pc, #144]	; (b64c <DSPI_MasterSetDelayTimes+0x120>)
    b5bc:	687b      	ldr	r3, [r7, #4]
    b5be:	fbb2 f3f3 	udiv	r3, r2, r3
    b5c2:	4923      	ldr	r1, [pc, #140]	; (b650 <DSPI_MasterSetDelayTimes+0x124>)
    b5c4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    b5c6:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    b5ca:	fb02 f303 	mul.w	r3, r2, r3
    b5ce:	4921      	ldr	r1, [pc, #132]	; (b654 <DSPI_MasterSetDelayTimes+0x128>)
    b5d0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    b5d2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    b5d6:	fb02 f303 	mul.w	r3, r2, r3
    b5da:	089b      	lsrs	r3, r3, #2
    b5dc:	61bb      	str	r3, [r7, #24]

            /* calculate the delay difference based on the conditional statement
             * that states that the calculated delay must not be less then the desired delay
             */
            if (realDelay >= delayTimeInNanoSec)
    b5de:	69ba      	ldr	r2, [r7, #24]
    b5e0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    b5e2:	429a      	cmp	r2, r3
    b5e4:	d30f      	bcc.n	b606 <DSPI_MasterSetDelayTimes+0xda>
            {
                diff = realDelay - delayTimeInNanoSec;
    b5e6:	69ba      	ldr	r2, [r7, #24]
    b5e8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    b5ea:	1ad3      	subs	r3, r2, r3
    b5ec:	617b      	str	r3, [r7, #20]
                if (min_diff > diff)
    b5ee:	6a3a      	ldr	r2, [r7, #32]
    b5f0:	697b      	ldr	r3, [r7, #20]
    b5f2:	429a      	cmp	r2, r3
    b5f4:	d907      	bls.n	b606 <DSPI_MasterSetDelayTimes+0xda>
                {
                    /* a better match found */
                    min_diff      = diff;
    b5f6:	697b      	ldr	r3, [r7, #20]
    b5f8:	623b      	str	r3, [r7, #32]
                    bestPrescaler = prescaler;
    b5fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    b5fc:	633b      	str	r3, [r7, #48]	; 0x30
                    bestScaler    = scaler;
    b5fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b600:	62bb      	str	r3, [r7, #40]	; 0x28
                    bestDelay     = realDelay;
    b602:	69bb      	ldr	r3, [r7, #24]
    b604:	627b      	str	r3, [r7, #36]	; 0x24
                }
            }

            if (0U == min_diff)
    b606:	6a3b      	ldr	r3, [r7, #32]
    b608:	2b00      	cmp	r3, #0
    b60a:	d006      	beq.n	b61a <DSPI_MasterSetDelayTimes+0xee>
        for (scaler = 0; scaler < 16U; scaler++)
    b60c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b60e:	3301      	adds	r3, #1
    b610:	62fb      	str	r3, [r7, #44]	; 0x2c
    b612:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b614:	2b0f      	cmp	r3, #15
    b616:	d9d0      	bls.n	b5ba <DSPI_MasterSetDelayTimes+0x8e>
    b618:	e000      	b.n	b61c <DSPI_MasterSetDelayTimes+0xf0>
            {
                break;
    b61a:	bf00      	nop
            }
        }
        if (0U == min_diff)
    b61c:	6a3b      	ldr	r3, [r7, #32]
    b61e:	2b00      	cmp	r3, #0
    b620:	d006      	beq.n	b630 <DSPI_MasterSetDelayTimes+0x104>
    for (prescaler = 0; prescaler < 4U; prescaler++)
    b622:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    b624:	3301      	adds	r3, #1
    b626:	637b      	str	r3, [r7, #52]	; 0x34
    b628:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    b62a:	2b03      	cmp	r3, #3
    b62c:	d9c2      	bls.n	b5b4 <DSPI_MasterSetDelayTimes+0x88>
    b62e:	e000      	b.n	b632 <DSPI_MasterSetDelayTimes+0x106>
        {
            break;
    b630:	bf00      	nop
        }
    }

    /* write the best dbr, prescalar, and baud rate scalar to the CTAR */
    DSPI_MasterSetDelayScaler(base, whichCtar, bestPrescaler, bestScaler, whichDelay);
    b632:	7af9      	ldrb	r1, [r7, #11]
    b634:	7abb      	ldrb	r3, [r7, #10]
    b636:	9300      	str	r3, [sp, #0]
    b638:	6abb      	ldr	r3, [r7, #40]	; 0x28
    b63a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    b63c:	68f8      	ldr	r0, [r7, #12]
    b63e:	f7ff fef9 	bl	b434 <DSPI_MasterSetDelayScaler>

    /* return the actual calculated baud rate */
    return bestDelay;
    b642:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    b644:	4618      	mov	r0, r3
    b646:	3738      	adds	r7, #56	; 0x38
    b648:	46bd      	mov	sp, r7
    b64a:	bd80      	pop	{r7, pc}
    b64c:	ee6b2800 	.word	0xee6b2800
    b650:	00010508 	.word	0x00010508
    b654:	00010518 	.word	0x00010518
    b658:	3b9aca00 	.word	0x3b9aca00

0000b65c <DSPI_MasterWriteDataBlocking>:
 * param base DSPI peripheral address.
 * param command Pointer to the command structure.
 * param data The data word to be sent.
 */
void DSPI_MasterWriteDataBlocking(SPI_Type *base, dspi_command_data_config_t *command, uint16_t data)
{
    b65c:	b580      	push	{r7, lr}
    b65e:	b084      	sub	sp, #16
    b660:	af00      	add	r7, sp, #0
    b662:	60f8      	str	r0, [r7, #12]
    b664:	60b9      	str	r1, [r7, #8]
    b666:	4613      	mov	r3, r2
    b668:	80fb      	strh	r3, [r7, #6]
    assert(NULL != command);
    b66a:	68bb      	ldr	r3, [r7, #8]
    b66c:	2b00      	cmp	r3, #0
    b66e:	d106      	bne.n	b67e <DSPI_MasterWriteDataBlocking+0x22>
    b670:	4b24      	ldr	r3, [pc, #144]	; (b704 <DSPI_MasterWriteDataBlocking+0xa8>)
    b672:	4a25      	ldr	r2, [pc, #148]	; (b708 <DSPI_MasterWriteDataBlocking+0xac>)
    b674:	f44f 7131 	mov.w	r1, #708	; 0x2c4
    b678:	4824      	ldr	r0, [pc, #144]	; (b70c <DSPI_MasterWriteDataBlocking+0xb0>)
    b67a:	f7fb fdaf 	bl	71dc <__assert_func>

    /* First, clear Transmit Complete Flag (TCF) */
    DSPI_ClearStatusFlags(base, (uint32_t)kDSPI_TxCompleteFlag);
    b67e:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    b682:	68f8      	ldr	r0, [r7, #12]
    b684:	f7ff fcc0 	bl	b008 <DSPI_ClearStatusFlags>

    while (0U == (DSPI_GetStatusFlags(base) & (uint32_t)kDSPI_TxFifoFillRequestFlag))
    b688:	e004      	b.n	b694 <DSPI_MasterWriteDataBlocking+0x38>
    {
        DSPI_ClearStatusFlags(base, (uint32_t)kDSPI_TxFifoFillRequestFlag);
    b68a:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
    b68e:	68f8      	ldr	r0, [r7, #12]
    b690:	f7ff fcba 	bl	b008 <DSPI_ClearStatusFlags>
    while (0U == (DSPI_GetStatusFlags(base) & (uint32_t)kDSPI_TxFifoFillRequestFlag))
    b694:	68f8      	ldr	r0, [r7, #12]
    b696:	f7ff fcab 	bl	aff0 <DSPI_GetStatusFlags>
    b69a:	4603      	mov	r3, r0
    b69c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    b6a0:	2b00      	cmp	r3, #0
    b6a2:	d0f2      	beq.n	b68a <DSPI_MasterWriteDataBlocking+0x2e>
    }

    base->PUSHR = SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar) |
    b6a4:	68bb      	ldr	r3, [r7, #8]
    b6a6:	781b      	ldrb	r3, [r3, #0]
    b6a8:	07da      	lsls	r2, r3, #31
    b6aa:	68bb      	ldr	r3, [r7, #8]
    b6ac:	785b      	ldrb	r3, [r3, #1]
    b6ae:	071b      	lsls	r3, r3, #28
    b6b0:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    b6b4:	431a      	orrs	r2, r3
                  SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
    b6b6:	68bb      	ldr	r3, [r7, #8]
    b6b8:	789b      	ldrb	r3, [r3, #2]
    b6ba:	041b      	lsls	r3, r3, #16
    b6bc:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
    base->PUSHR = SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar) |
    b6c0:	431a      	orrs	r2, r3
                  SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
    b6c2:	68bb      	ldr	r3, [r7, #8]
    b6c4:	78db      	ldrb	r3, [r3, #3]
    b6c6:	06db      	lsls	r3, r3, #27
    b6c8:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
    b6cc:	431a      	orrs	r2, r3
                  SPI_PUSHR_CTCNT(command->clearTransferCount) | SPI_PUSHR_TXDATA(data);
    b6ce:	68bb      	ldr	r3, [r7, #8]
    b6d0:	791b      	ldrb	r3, [r3, #4]
    b6d2:	069b      	lsls	r3, r3, #26
    b6d4:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
                  SPI_PUSHR_PCS(command->whichPcs) | SPI_PUSHR_EOQ(command->isEndOfQueue) |
    b6d8:	431a      	orrs	r2, r3
                  SPI_PUSHR_CTCNT(command->clearTransferCount) | SPI_PUSHR_TXDATA(data);
    b6da:	88fb      	ldrh	r3, [r7, #6]
    b6dc:	431a      	orrs	r2, r3
    base->PUSHR = SPI_PUSHR_CONT(command->isPcsContinuous) | SPI_PUSHR_CTAS(command->whichCtar) |
    b6de:	68fb      	ldr	r3, [r7, #12]
    b6e0:	635a      	str	r2, [r3, #52]	; 0x34
    DSPI_ClearStatusFlags(base, (uint32_t)kDSPI_TxFifoFillRequestFlag);
    b6e2:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
    b6e6:	68f8      	ldr	r0, [r7, #12]
    b6e8:	f7ff fc8e 	bl	b008 <DSPI_ClearStatusFlags>

    /* Wait till TCF sets */
    while (0U == (DSPI_GetStatusFlags(base) & (uint32_t)kDSPI_TxCompleteFlag))
    b6ec:	bf00      	nop
    b6ee:	68f8      	ldr	r0, [r7, #12]
    b6f0:	f7ff fc7e 	bl	aff0 <DSPI_GetStatusFlags>
    b6f4:	4603      	mov	r3, r0
    b6f6:	2b00      	cmp	r3, #0
    b6f8:	daf9      	bge.n	b6ee <DSPI_MasterWriteDataBlocking+0x92>
    {
    }
}
    b6fa:	bf00      	nop
    b6fc:	bf00      	nop
    b6fe:	3710      	adds	r7, #16
    b700:	46bd      	mov	sp, r7
    b702:	bd80      	pop	{r7, pc}
    b704:	00010620 	.word	0x00010620
    b708:	000106ec 	.word	0x000106ec
    b70c:	00010594 	.word	0x00010594

0000b710 <DelayLoop>:
/* clang-format on */
#elif defined(__ARMCC_VERSION) || defined(__ICCARM__) || defined(__GNUC__)
/* Cortex-M0 has a smaller instruction set, SUBS isn't supported in thumb-16 mode reported from __GNUC__ compiler,
 * use SUB and CMP here for compatibility */
static void DelayLoop(uint32_t count)
{
    b710:	b480      	push	{r7}
    b712:	b083      	sub	sp, #12
    b714:	af00      	add	r7, sp, #0
    b716:	6078      	str	r0, [r7, #4]
    __ASM volatile("    MOV    R0, %0" : : "r"(count));
    b718:	687b      	ldr	r3, [r7, #4]
    b71a:	4618      	mov	r0, r3

0000b71c <loop>:
    __ASM volatile(
    b71c:	f1a0 0001 	sub.w	r0, r0, #1
    b720:	2800      	cmp	r0, #0
    b722:	d1fb      	bne.n	b71c <loop>
        "    SUBS   R0, R0, #1          \n"
#endif
        "    CMP    R0, #0              \n"

        "    BNE    loop                \n");
}
    b724:	bf00      	nop
    b726:	370c      	adds	r7, #12
    b728:	46bd      	mov	sp, r7
    b72a:	f85d 7b04 	ldr.w	r7, [sp], #4
    b72e:	4770      	bx	lr

0000b730 <SDK_DelayAtLeastUs>:
 *
 * @param delayTime_us  Delay time in unit of microsecond.
 * @param coreClock_Hz  Core clock frequency with Hz.
 */
void SDK_DelayAtLeastUs(uint32_t delayTime_us, uint32_t coreClock_Hz)
{
    b730:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
    b734:	b084      	sub	sp, #16
    b736:	af00      	add	r7, sp, #0
    b738:	6078      	str	r0, [r7, #4]
    b73a:	6039      	str	r1, [r7, #0]
    assert(0U != delayTime_us);
    b73c:	6879      	ldr	r1, [r7, #4]
    b73e:	2900      	cmp	r1, #0
    b740:	d106      	bne.n	b750 <SDK_DelayAtLeastUs+0x20>
    b742:	4b21      	ldr	r3, [pc, #132]	; (b7c8 <SDK_DelayAtLeastUs+0x98>)
    b744:	4a21      	ldr	r2, [pc, #132]	; (b7cc <SDK_DelayAtLeastUs+0x9c>)
    b746:	f44f 7189 	mov.w	r1, #274	; 0x112
    b74a:	4821      	ldr	r0, [pc, #132]	; (b7d0 <SDK_DelayAtLeastUs+0xa0>)
    b74c:	f7fb fd46 	bl	71dc <__assert_func>
    uint64_t count = USEC_TO_COUNT(delayTime_us, coreClock_Hz);
    b750:	6879      	ldr	r1, [r7, #4]
    b752:	2000      	movs	r0, #0
    b754:	4688      	mov	r8, r1
    b756:	4681      	mov	r9, r0
    b758:	6839      	ldr	r1, [r7, #0]
    b75a:	2000      	movs	r0, #0
    b75c:	460a      	mov	r2, r1
    b75e:	4603      	mov	r3, r0
    b760:	fb02 f009 	mul.w	r0, r2, r9
    b764:	fb08 f103 	mul.w	r1, r8, r3
    b768:	4401      	add	r1, r0
    b76a:	fba8 4502 	umull	r4, r5, r8, r2
    b76e:	194b      	adds	r3, r1, r5
    b770:	461d      	mov	r5, r3
    b772:	4a18      	ldr	r2, [pc, #96]	; (b7d4 <SDK_DelayAtLeastUs+0xa4>)
    b774:	f04f 0300 	mov.w	r3, #0
    b778:	4620      	mov	r0, r4
    b77a:	4629      	mov	r1, r5
    b77c:	f002 fc62 	bl	e044 <__aeabi_uldivmod>
    b780:	4602      	mov	r2, r0
    b782:	460b      	mov	r3, r1
    b784:	e9c7 2302 	strd	r2, r3, [r7, #8]
    assert(count <= UINT32_MAX);
    b788:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
    b78c:	2b01      	cmp	r3, #1
    b78e:	d306      	bcc.n	b79e <SDK_DelayAtLeastUs+0x6e>
    b790:	4b11      	ldr	r3, [pc, #68]	; (b7d8 <SDK_DelayAtLeastUs+0xa8>)
    b792:	4a0e      	ldr	r2, [pc, #56]	; (b7cc <SDK_DelayAtLeastUs+0x9c>)
    b794:	f44f 718a 	mov.w	r1, #276	; 0x114
    b798:	480d      	ldr	r0, [pc, #52]	; (b7d0 <SDK_DelayAtLeastUs+0xa0>)
    b79a:	f7fb fd1f 	bl	71dc <__assert_func>
     * not matter because other instructions outside while loop is enough to fill the time.
     */
#if (__CORTEX_M == 7)
    count = count / 3U * 2U;
#else
    count = count / 4U;
    b79e:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
    b7a2:	f04f 0200 	mov.w	r2, #0
    b7a6:	f04f 0300 	mov.w	r3, #0
    b7aa:	0882      	lsrs	r2, r0, #2
    b7ac:	ea42 7281 	orr.w	r2, r2, r1, lsl #30
    b7b0:	088b      	lsrs	r3, r1, #2
    b7b2:	e9c7 2302 	strd	r2, r3, [r7, #8]
#endif
    DelayLoop((uint32_t)count);
    b7b6:	68bb      	ldr	r3, [r7, #8]
    b7b8:	4618      	mov	r0, r3
    b7ba:	f7ff ffa9 	bl	b710 <DelayLoop>
#endif /* defined(SDK_DELAY_USE_DWT) && defined(DWT) || (defined __XCC__) */
}
    b7be:	bf00      	nop
    b7c0:	3710      	adds	r7, #16
    b7c2:	46bd      	mov	sp, r7
    b7c4:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
    b7c8:	0001070c 	.word	0x0001070c
    b7cc:	00010790 	.word	0x00010790
    b7d0:	00010720 	.word	0x00010720
    b7d4:	000f4240 	.word	0x000f4240
    b7d8:	0001077c 	.word	0x0001077c

0000b7dc <atanf>:
    b7dc:	b538      	push	{r3, r4, r5, lr}
    b7de:	ee10 5a10 	vmov	r5, s0
    b7e2:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
    b7e6:	f1b4 4fa1 	cmp.w	r4, #1350565888	; 0x50800000
    b7ea:	eef0 7a40 	vmov.f32	s15, s0
    b7ee:	db0d      	blt.n	b80c <atanf+0x30>
    b7f0:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
    b7f4:	dc5b      	bgt.n	b8ae <atanf+0xd2>
    b7f6:	eddf 7a53 	vldr	s15, [pc, #332]	; b944 <atanf+0x168>
    b7fa:	ed9f 7a53 	vldr	s14, [pc, #332]	; b948 <atanf+0x16c>
    b7fe:	2d00      	cmp	r5, #0
    b800:	bfd4      	ite	le
    b802:	eeb0 0a47 	vmovle.f32	s0, s14
    b806:	eeb0 0a67 	vmovgt.f32	s0, s15
    b80a:	bd38      	pop	{r3, r4, r5, pc}
    b80c:	4b4f      	ldr	r3, [pc, #316]	; (b94c <atanf+0x170>)
    b80e:	429c      	cmp	r4, r3
    b810:	dc5c      	bgt.n	b8cc <atanf+0xf0>
    b812:	f1b4 5f44 	cmp.w	r4, #822083584	; 0x31000000
    b816:	db4d      	blt.n	b8b4 <atanf+0xd8>
    b818:	f04f 33ff 	mov.w	r3, #4294967295
    b81c:	ee27 6aa7 	vmul.f32	s12, s15, s15
    b820:	eddf 6a4b 	vldr	s13, [pc, #300]	; b950 <atanf+0x174>
    b824:	eddf 5a4b 	vldr	s11, [pc, #300]	; b954 <atanf+0x178>
    b828:	eddf 4a4b 	vldr	s9, [pc, #300]	; b958 <atanf+0x17c>
    b82c:	ed9f 5a4b 	vldr	s10, [pc, #300]	; b95c <atanf+0x180>
    b830:	ed9f 4a4b 	vldr	s8, [pc, #300]	; b960 <atanf+0x184>
    b834:	ee26 7a06 	vmul.f32	s14, s12, s12
    b838:	1c5a      	adds	r2, r3, #1
    b83a:	eee7 5a26 	vfma.f32	s11, s14, s13
    b83e:	eddf 6a49 	vldr	s13, [pc, #292]	; b964 <atanf+0x188>
    b842:	eea5 5a87 	vfma.f32	s10, s11, s14
    b846:	eee7 6a24 	vfma.f32	s13, s14, s9
    b84a:	eddf 5a47 	vldr	s11, [pc, #284]	; b968 <atanf+0x18c>
    b84e:	eddf 4a47 	vldr	s9, [pc, #284]	; b96c <atanf+0x190>
    b852:	eee6 5a87 	vfma.f32	s11, s13, s14
    b856:	eea5 4a07 	vfma.f32	s8, s10, s14
    b85a:	ed9f 5a45 	vldr	s10, [pc, #276]	; b970 <atanf+0x194>
    b85e:	eddf 6a45 	vldr	s13, [pc, #276]	; b974 <atanf+0x198>
    b862:	eea5 5a87 	vfma.f32	s10, s11, s14
    b866:	eee4 4a07 	vfma.f32	s9, s8, s14
    b86a:	eddf 5a43 	vldr	s11, [pc, #268]	; b978 <atanf+0x19c>
    b86e:	eee4 6a87 	vfma.f32	s13, s9, s14
    b872:	eee5 5a07 	vfma.f32	s11, s10, s14
    b876:	ee66 6a86 	vmul.f32	s13, s13, s12
    b87a:	ee65 5a87 	vmul.f32	s11, s11, s14
    b87e:	d03a      	beq.n	b8f6 <atanf+0x11a>
    b880:	4a3e      	ldr	r2, [pc, #248]	; (b97c <atanf+0x1a0>)
    b882:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    b886:	ee76 6aa5 	vadd.f32	s13, s13, s11
    b88a:	ed92 7a00 	vldr	s14, [r2]
    b88e:	4a3c      	ldr	r2, [pc, #240]	; (b980 <atanf+0x1a4>)
    b890:	ee96 7aa7 	vfnms.f32	s14, s13, s15
    b894:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    b898:	2d00      	cmp	r5, #0
    b89a:	edd3 6a00 	vldr	s13, [r3]
    b89e:	ee77 7a67 	vsub.f32	s15, s14, s15
    b8a2:	ee36 0ae7 	vsub.f32	s0, s13, s15
    b8a6:	dab0      	bge.n	b80a <atanf+0x2e>
    b8a8:	eeb1 0a40 	vneg.f32	s0, s0
    b8ac:	bd38      	pop	{r3, r4, r5, pc}
    b8ae:	ee30 0a00 	vadd.f32	s0, s0, s0
    b8b2:	bd38      	pop	{r3, r4, r5, pc}
    b8b4:	ed9f 7a33 	vldr	s14, [pc, #204]	; b984 <atanf+0x1a8>
    b8b8:	ee30 7a07 	vadd.f32	s14, s0, s14
    b8bc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    b8c0:	eeb4 7ae6 	vcmpe.f32	s14, s13
    b8c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    b8c8:	dda6      	ble.n	b818 <atanf+0x3c>
    b8ca:	bd38      	pop	{r3, r4, r5, pc}
    b8cc:	f000 f898 	bl	ba00 <fabsf>
    b8d0:	4b2d      	ldr	r3, [pc, #180]	; (b988 <atanf+0x1ac>)
    b8d2:	429c      	cmp	r4, r3
    b8d4:	dc16      	bgt.n	b904 <atanf+0x128>
    b8d6:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
    b8da:	429c      	cmp	r4, r3
    b8dc:	dc27      	bgt.n	b92e <atanf+0x152>
    b8de:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
    b8e2:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
    b8e6:	eea0 7a27 	vfma.f32	s14, s0, s15
    b8ea:	2300      	movs	r3, #0
    b8ec:	ee30 0a27 	vadd.f32	s0, s0, s15
    b8f0:	eec7 7a00 	vdiv.f32	s15, s14, s0
    b8f4:	e792      	b.n	b81c <atanf+0x40>
    b8f6:	ee76 6aa5 	vadd.f32	s13, s13, s11
    b8fa:	eee6 7ae7 	vfms.f32	s15, s13, s15
    b8fe:	eeb0 0a67 	vmov.f32	s0, s15
    b902:	bd38      	pop	{r3, r4, r5, pc}
    b904:	4b21      	ldr	r3, [pc, #132]	; (b98c <atanf+0x1b0>)
    b906:	429c      	cmp	r4, r3
    b908:	dc0b      	bgt.n	b922 <atanf+0x146>
    b90a:	eef7 7a08 	vmov.f32	s15, #120	; 0x3fc00000  1.5
    b90e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    b912:	eea0 7a27 	vfma.f32	s14, s0, s15
    b916:	2302      	movs	r3, #2
    b918:	ee30 0a67 	vsub.f32	s0, s0, s15
    b91c:	eec0 7a07 	vdiv.f32	s15, s0, s14
    b920:	e77c      	b.n	b81c <atanf+0x40>
    b922:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
    b926:	eec7 7a00 	vdiv.f32	s15, s14, s0
    b92a:	2303      	movs	r3, #3
    b92c:	e776      	b.n	b81c <atanf+0x40>
    b92e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    b932:	ee30 7a67 	vsub.f32	s14, s0, s15
    b936:	ee30 0a27 	vadd.f32	s0, s0, s15
    b93a:	2301      	movs	r3, #1
    b93c:	eec7 7a00 	vdiv.f32	s15, s14, s0
    b940:	e76c      	b.n	b81c <atanf+0x40>
    b942:	bf00      	nop
    b944:	3fc90fdb 	.word	0x3fc90fdb
    b948:	bfc90fdb 	.word	0xbfc90fdb
    b94c:	3edfffff 	.word	0x3edfffff
    b950:	3c8569d7 	.word	0x3c8569d7
    b954:	3d4bda59 	.word	0x3d4bda59
    b958:	bd15a221 	.word	0xbd15a221
    b95c:	3d886b35 	.word	0x3d886b35
    b960:	3dba2e6e 	.word	0x3dba2e6e
    b964:	bd6ef16b 	.word	0xbd6ef16b
    b968:	bd9d8795 	.word	0xbd9d8795
    b96c:	3e124925 	.word	0x3e124925
    b970:	bde38e38 	.word	0xbde38e38
    b974:	3eaaaaab 	.word	0x3eaaaaab
    b978:	be4ccccd 	.word	0xbe4ccccd
    b97c:	000107b4 	.word	0x000107b4
    b980:	000107a4 	.word	0x000107a4
    b984:	7149f2ca 	.word	0x7149f2ca
    b988:	3f97ffff 	.word	0x3f97ffff
    b98c:	401bffff 	.word	0x401bffff

0000b990 <cosf>:
    b990:	ee10 3a10 	vmov	r3, s0
    b994:	4a18      	ldr	r2, [pc, #96]	; (b9f8 <cosf+0x68>)
    b996:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    b99a:	4293      	cmp	r3, r2
    b99c:	dd1b      	ble.n	b9d6 <cosf+0x46>
    b99e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
    b9a2:	db02      	blt.n	b9aa <cosf+0x1a>
    b9a4:	ee30 0a40 	vsub.f32	s0, s0, s0
    b9a8:	4770      	bx	lr
    b9aa:	b500      	push	{lr}
    b9ac:	b083      	sub	sp, #12
    b9ae:	4668      	mov	r0, sp
    b9b0:	f000 f936 	bl	bc20 <__ieee754_rem_pio2f>
    b9b4:	f000 0003 	and.w	r0, r0, #3
    b9b8:	2801      	cmp	r0, #1
    b9ba:	eddd 0a01 	vldr	s1, [sp, #4]
    b9be:	ed9d 0a00 	vldr	s0, [sp]
    b9c2:	d00c      	beq.n	b9de <cosf+0x4e>
    b9c4:	2802      	cmp	r0, #2
    b9c6:	d012      	beq.n	b9ee <cosf+0x5e>
    b9c8:	b170      	cbz	r0, b9e8 <cosf+0x58>
    b9ca:	2001      	movs	r0, #1
    b9cc:	f001 fc90 	bl	d2f0 <__kernel_sinf>
    b9d0:	b003      	add	sp, #12
    b9d2:	f85d fb04 	ldr.w	pc, [sp], #4
    b9d6:	eddf 0a09 	vldr	s1, [pc, #36]	; b9fc <cosf+0x6c>
    b9da:	f001 b8d5 	b.w	cb88 <__kernel_cosf>
    b9de:	f001 fc87 	bl	d2f0 <__kernel_sinf>
    b9e2:	eeb1 0a40 	vneg.f32	s0, s0
    b9e6:	e7f3      	b.n	b9d0 <cosf+0x40>
    b9e8:	f001 f8ce 	bl	cb88 <__kernel_cosf>
    b9ec:	e7f0      	b.n	b9d0 <cosf+0x40>
    b9ee:	f001 f8cb 	bl	cb88 <__kernel_cosf>
    b9f2:	eeb1 0a40 	vneg.f32	s0, s0
    b9f6:	e7eb      	b.n	b9d0 <cosf+0x40>
    b9f8:	3f490fd8 	.word	0x3f490fd8
    b9fc:	00000000 	.word	0x00000000

0000ba00 <fabsf>:
    ba00:	ee10 3a10 	vmov	r3, s0
    ba04:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    ba08:	ee00 3a10 	vmov	s0, r3
    ba0c:	4770      	bx	lr
    ba0e:	bf00      	nop

0000ba10 <sinf>:
    ba10:	ee10 3a10 	vmov	r3, s0
    ba14:	4a19      	ldr	r2, [pc, #100]	; (ba7c <sinf+0x6c>)
    ba16:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    ba1a:	4293      	cmp	r3, r2
    ba1c:	dd1c      	ble.n	ba58 <sinf+0x48>
    ba1e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
    ba22:	db02      	blt.n	ba2a <sinf+0x1a>
    ba24:	ee30 0a40 	vsub.f32	s0, s0, s0
    ba28:	4770      	bx	lr
    ba2a:	b500      	push	{lr}
    ba2c:	b083      	sub	sp, #12
    ba2e:	4668      	mov	r0, sp
    ba30:	f000 f8f6 	bl	bc20 <__ieee754_rem_pio2f>
    ba34:	f000 0003 	and.w	r0, r0, #3
    ba38:	2801      	cmp	r0, #1
    ba3a:	eddd 0a01 	vldr	s1, [sp, #4]
    ba3e:	ed9d 0a00 	vldr	s0, [sp]
    ba42:	d00e      	beq.n	ba62 <sinf+0x52>
    ba44:	2802      	cmp	r0, #2
    ba46:	d013      	beq.n	ba70 <sinf+0x60>
    ba48:	b170      	cbz	r0, ba68 <sinf+0x58>
    ba4a:	f001 f89d 	bl	cb88 <__kernel_cosf>
    ba4e:	eeb1 0a40 	vneg.f32	s0, s0
    ba52:	b003      	add	sp, #12
    ba54:	f85d fb04 	ldr.w	pc, [sp], #4
    ba58:	eddf 0a09 	vldr	s1, [pc, #36]	; ba80 <sinf+0x70>
    ba5c:	2000      	movs	r0, #0
    ba5e:	f001 bc47 	b.w	d2f0 <__kernel_sinf>
    ba62:	f001 f891 	bl	cb88 <__kernel_cosf>
    ba66:	e7f4      	b.n	ba52 <sinf+0x42>
    ba68:	2001      	movs	r0, #1
    ba6a:	f001 fc41 	bl	d2f0 <__kernel_sinf>
    ba6e:	e7f0      	b.n	ba52 <sinf+0x42>
    ba70:	2001      	movs	r0, #1
    ba72:	f001 fc3d 	bl	d2f0 <__kernel_sinf>
    ba76:	eeb1 0a40 	vneg.f32	s0, s0
    ba7a:	e7ea      	b.n	ba52 <sinf+0x42>
    ba7c:	3f490fd8 	.word	0x3f490fd8
    ba80:	00000000 	.word	0x00000000

0000ba84 <sqrtf>:
    ba84:	b508      	push	{r3, lr}
    ba86:	ed2d 8b02 	vpush	{d8}
    ba8a:	eeb0 8a40 	vmov.f32	s16, s0
    ba8e:	f000 f9f7 	bl	be80 <__ieee754_sqrtf>
    ba92:	eeb4 8a48 	vcmp.f32	s16, s16
    ba96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ba9a:	d606      	bvs.n	baaa <sqrtf+0x26>
    ba9c:	eddf 8a09 	vldr	s17, [pc, #36]	; bac4 <sqrtf+0x40>
    baa0:	eeb4 8ae8 	vcmpe.f32	s16, s17
    baa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    baa8:	d402      	bmi.n	bab0 <sqrtf+0x2c>
    baaa:	ecbd 8b02 	vpop	{d8}
    baae:	bd08      	pop	{r3, pc}
    bab0:	f002 fc4a 	bl	e348 <__errno>
    bab4:	ee88 0aa8 	vdiv.f32	s0, s17, s17
    bab8:	ecbd 8b02 	vpop	{d8}
    babc:	2321      	movs	r3, #33	; 0x21
    babe:	6003      	str	r3, [r0, #0]
    bac0:	bd08      	pop	{r3, pc}
    bac2:	bf00      	nop
    bac4:	00000000 	.word	0x00000000

0000bac8 <pow>:
    bac8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    baca:	ed2d 8b02 	vpush	{d8}
    bace:	ec55 4b11 	vmov	r4, r5, d1
    bad2:	ec57 6b10 	vmov	r6, r7, d0
    bad6:	f000 f9d7 	bl	be88 <__ieee754_pow>
    bada:	4622      	mov	r2, r4
    badc:	462b      	mov	r3, r5
    bade:	4620      	mov	r0, r4
    bae0:	4629      	mov	r1, r5
    bae2:	eeb0 8a40 	vmov.f32	s16, s0
    bae6:	eef0 8a60 	vmov.f32	s17, s1
    baea:	f002 fa25 	bl	df38 <__aeabi_dcmpun>
    baee:	b978      	cbnz	r0, bb10 <pow+0x48>
    baf0:	2200      	movs	r2, #0
    baf2:	2300      	movs	r3, #0
    baf4:	4630      	mov	r0, r6
    baf6:	4639      	mov	r1, r7
    baf8:	f002 f9ec 	bl	ded4 <__aeabi_dcmpeq>
    bafc:	b1f0      	cbz	r0, bb3c <pow+0x74>
    bafe:	2200      	movs	r2, #0
    bb00:	2300      	movs	r3, #0
    bb02:	4620      	mov	r0, r4
    bb04:	4629      	mov	r1, r5
    bb06:	f002 f9e5 	bl	ded4 <__aeabi_dcmpeq>
    bb0a:	b140      	cbz	r0, bb1e <pow+0x56>
    bb0c:	ed9f 8b28 	vldr	d8, [pc, #160]	; bbb0 <pow+0xe8>
    bb10:	eeb0 0a48 	vmov.f32	s0, s16
    bb14:	eef0 0a68 	vmov.f32	s1, s17
    bb18:	ecbd 8b02 	vpop	{d8}
    bb1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    bb1e:	ec45 4b10 	vmov	d0, r4, r5
    bb22:	f001 fcb5 	bl	d490 <finite>
    bb26:	2800      	cmp	r0, #0
    bb28:	d0f2      	beq.n	bb10 <pow+0x48>
    bb2a:	4620      	mov	r0, r4
    bb2c:	4629      	mov	r1, r5
    bb2e:	2200      	movs	r2, #0
    bb30:	2300      	movs	r3, #0
    bb32:	f002 f9d9 	bl	dee8 <__aeabi_dcmplt>
    bb36:	2800      	cmp	r0, #0
    bb38:	d0ea      	beq.n	bb10 <pow+0x48>
    bb3a:	e02e      	b.n	bb9a <pow+0xd2>
    bb3c:	eeb0 0a48 	vmov.f32	s0, s16
    bb40:	eef0 0a68 	vmov.f32	s1, s17
    bb44:	f001 fca4 	bl	d490 <finite>
    bb48:	b1a0      	cbz	r0, bb74 <pow+0xac>
    bb4a:	ec51 0b18 	vmov	r0, r1, d8
    bb4e:	2200      	movs	r2, #0
    bb50:	2300      	movs	r3, #0
    bb52:	f002 f9bf 	bl	ded4 <__aeabi_dcmpeq>
    bb56:	2800      	cmp	r0, #0
    bb58:	d0da      	beq.n	bb10 <pow+0x48>
    bb5a:	ec47 6b10 	vmov	d0, r6, r7
    bb5e:	f001 fc97 	bl	d490 <finite>
    bb62:	2800      	cmp	r0, #0
    bb64:	d0d4      	beq.n	bb10 <pow+0x48>
    bb66:	ec45 4b10 	vmov	d0, r4, r5
    bb6a:	f001 fc91 	bl	d490 <finite>
    bb6e:	2800      	cmp	r0, #0
    bb70:	d0ce      	beq.n	bb10 <pow+0x48>
    bb72:	e012      	b.n	bb9a <pow+0xd2>
    bb74:	ec47 6b10 	vmov	d0, r6, r7
    bb78:	f001 fc8a 	bl	d490 <finite>
    bb7c:	2800      	cmp	r0, #0
    bb7e:	d0e4      	beq.n	bb4a <pow+0x82>
    bb80:	ec45 4b10 	vmov	d0, r4, r5
    bb84:	f001 fc84 	bl	d490 <finite>
    bb88:	2800      	cmp	r0, #0
    bb8a:	d0de      	beq.n	bb4a <pow+0x82>
    bb8c:	ec53 2b18 	vmov	r2, r3, d8
    bb90:	ec51 0b18 	vmov	r0, r1, d8
    bb94:	f002 f9d0 	bl	df38 <__aeabi_dcmpun>
    bb98:	b920      	cbnz	r0, bba4 <pow+0xdc>
    bb9a:	f002 fbd5 	bl	e348 <__errno>
    bb9e:	2322      	movs	r3, #34	; 0x22
    bba0:	6003      	str	r3, [r0, #0]
    bba2:	e7b5      	b.n	bb10 <pow+0x48>
    bba4:	f002 fbd0 	bl	e348 <__errno>
    bba8:	2321      	movs	r3, #33	; 0x21
    bbaa:	6003      	str	r3, [r0, #0]
    bbac:	e7b0      	b.n	bb10 <pow+0x48>
    bbae:	bf00      	nop
    bbb0:	00000000 	.word	0x00000000
    bbb4:	3ff00000 	.word	0x3ff00000

0000bbb8 <sqrt>:
    bbb8:	b538      	push	{r3, r4, r5, lr}
    bbba:	ed2d 8b02 	vpush	{d8}
    bbbe:	ec55 4b10 	vmov	r4, r5, d0
    bbc2:	f000 ff17 	bl	c9f4 <__ieee754_sqrt>
    bbc6:	4622      	mov	r2, r4
    bbc8:	462b      	mov	r3, r5
    bbca:	4620      	mov	r0, r4
    bbcc:	4629      	mov	r1, r5
    bbce:	eeb0 8a40 	vmov.f32	s16, s0
    bbd2:	eef0 8a60 	vmov.f32	s17, s1
    bbd6:	f002 f9af 	bl	df38 <__aeabi_dcmpun>
    bbda:	b930      	cbnz	r0, bbea <sqrt+0x32>
    bbdc:	2200      	movs	r2, #0
    bbde:	2300      	movs	r3, #0
    bbe0:	4620      	mov	r0, r4
    bbe2:	4629      	mov	r1, r5
    bbe4:	f002 f980 	bl	dee8 <__aeabi_dcmplt>
    bbe8:	b930      	cbnz	r0, bbf8 <sqrt+0x40>
    bbea:	eeb0 0a48 	vmov.f32	s0, s16
    bbee:	eef0 0a68 	vmov.f32	s1, s17
    bbf2:	ecbd 8b02 	vpop	{d8}
    bbf6:	bd38      	pop	{r3, r4, r5, pc}
    bbf8:	f002 fba6 	bl	e348 <__errno>
    bbfc:	2200      	movs	r2, #0
    bbfe:	2300      	movs	r3, #0
    bc00:	2121      	movs	r1, #33	; 0x21
    bc02:	6001      	str	r1, [r0, #0]
    bc04:	4610      	mov	r0, r2
    bc06:	4619      	mov	r1, r3
    bc08:	f002 f826 	bl	dc58 <__aeabi_ddiv>
    bc0c:	ec41 0b18 	vmov	d8, r0, r1
    bc10:	eeb0 0a48 	vmov.f32	s0, s16
    bc14:	eef0 0a68 	vmov.f32	s1, s17
    bc18:	ecbd 8b02 	vpop	{d8}
    bc1c:	bd38      	pop	{r3, r4, r5, pc}
    bc1e:	bf00      	nop

0000bc20 <__ieee754_rem_pio2f>:
    bc20:	b570      	push	{r4, r5, r6, lr}
    bc22:	ee10 3a10 	vmov	r3, s0
    bc26:	4a88      	ldr	r2, [pc, #544]	; (be48 <__ieee754_rem_pio2f+0x228>)
    bc28:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
    bc2c:	4294      	cmp	r4, r2
    bc2e:	b086      	sub	sp, #24
    bc30:	4605      	mov	r5, r0
    bc32:	dd70      	ble.n	bd16 <__ieee754_rem_pio2f+0xf6>
    bc34:	4a85      	ldr	r2, [pc, #532]	; (be4c <__ieee754_rem_pio2f+0x22c>)
    bc36:	4294      	cmp	r4, r2
    bc38:	ee10 6a10 	vmov	r6, s0
    bc3c:	dc22      	bgt.n	bc84 <__ieee754_rem_pio2f+0x64>
    bc3e:	2b00      	cmp	r3, #0
    bc40:	eddf 7a83 	vldr	s15, [pc, #524]	; be50 <__ieee754_rem_pio2f+0x230>
    bc44:	4a83      	ldr	r2, [pc, #524]	; (be54 <__ieee754_rem_pio2f+0x234>)
    bc46:	f024 040f 	bic.w	r4, r4, #15
    bc4a:	eeb0 7a40 	vmov.f32	s14, s0
    bc4e:	f340 80e2 	ble.w	be16 <__ieee754_rem_pio2f+0x1f6>
    bc52:	4294      	cmp	r4, r2
    bc54:	ee70 7a67 	vsub.f32	s15, s0, s15
    bc58:	bf09      	itett	eq
    bc5a:	eddf 6a7f 	vldreq	s13, [pc, #508]	; be58 <__ieee754_rem_pio2f+0x238>
    bc5e:	ed9f 7a7f 	vldrne	s14, [pc, #508]	; be5c <__ieee754_rem_pio2f+0x23c>
    bc62:	ed9f 7a7f 	vldreq	s14, [pc, #508]	; be60 <__ieee754_rem_pio2f+0x240>
    bc66:	ee77 7ae6 	vsubeq.f32	s15, s15, s13
    bc6a:	2001      	movs	r0, #1
    bc6c:	ee77 6ac7 	vsub.f32	s13, s15, s14
    bc70:	ee77 7ae6 	vsub.f32	s15, s15, s13
    bc74:	edc5 6a00 	vstr	s13, [r5]
    bc78:	ee77 7ac7 	vsub.f32	s15, s15, s14
    bc7c:	edc5 7a01 	vstr	s15, [r5, #4]
    bc80:	b006      	add	sp, #24
    bc82:	bd70      	pop	{r4, r5, r6, pc}
    bc84:	4a77      	ldr	r2, [pc, #476]	; (be64 <__ieee754_rem_pio2f+0x244>)
    bc86:	4294      	cmp	r4, r2
    bc88:	dd54      	ble.n	bd34 <__ieee754_rem_pio2f+0x114>
    bc8a:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
    bc8e:	da49      	bge.n	bd24 <__ieee754_rem_pio2f+0x104>
    bc90:	15e2      	asrs	r2, r4, #23
    bc92:	3a86      	subs	r2, #134	; 0x86
    bc94:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
    bc98:	ee07 3a90 	vmov	s15, r3
    bc9c:	eebd 7ae7 	vcvt.s32.f32	s14, s15
    bca0:	eddf 6a71 	vldr	s13, [pc, #452]	; be68 <__ieee754_rem_pio2f+0x248>
    bca4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    bca8:	ee77 7ac7 	vsub.f32	s15, s15, s14
    bcac:	ed8d 7a03 	vstr	s14, [sp, #12]
    bcb0:	ee67 7aa6 	vmul.f32	s15, s15, s13
    bcb4:	eebd 7ae7 	vcvt.s32.f32	s14, s15
    bcb8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    bcbc:	ee77 7ac7 	vsub.f32	s15, s15, s14
    bcc0:	ed8d 7a04 	vstr	s14, [sp, #16]
    bcc4:	ee67 7aa6 	vmul.f32	s15, s15, s13
    bcc8:	eef5 7a40 	vcmp.f32	s15, #0.0
    bccc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bcd0:	edcd 7a05 	vstr	s15, [sp, #20]
    bcd4:	f040 808e 	bne.w	bdf4 <__ieee754_rem_pio2f+0x1d4>
    bcd8:	eeb5 7a40 	vcmp.f32	s14, #0.0
    bcdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    bce0:	bf14      	ite	ne
    bce2:	2302      	movne	r3, #2
    bce4:	2301      	moveq	r3, #1
    bce6:	4961      	ldr	r1, [pc, #388]	; (be6c <__ieee754_rem_pio2f+0x24c>)
    bce8:	9101      	str	r1, [sp, #4]
    bcea:	2102      	movs	r1, #2
    bcec:	9100      	str	r1, [sp, #0]
    bcee:	a803      	add	r0, sp, #12
    bcf0:	4629      	mov	r1, r5
    bcf2:	f000 ffcb 	bl	cc8c <__kernel_rem_pio2f>
    bcf6:	2e00      	cmp	r6, #0
    bcf8:	dac2      	bge.n	bc80 <__ieee754_rem_pio2f+0x60>
    bcfa:	ed95 7a00 	vldr	s14, [r5]
    bcfe:	edd5 7a01 	vldr	s15, [r5, #4]
    bd02:	eeb1 7a47 	vneg.f32	s14, s14
    bd06:	eef1 7a67 	vneg.f32	s15, s15
    bd0a:	ed85 7a00 	vstr	s14, [r5]
    bd0e:	edc5 7a01 	vstr	s15, [r5, #4]
    bd12:	4240      	negs	r0, r0
    bd14:	e7b4      	b.n	bc80 <__ieee754_rem_pio2f+0x60>
    bd16:	2200      	movs	r2, #0
    bd18:	ed85 0a00 	vstr	s0, [r5]
    bd1c:	6042      	str	r2, [r0, #4]
    bd1e:	2000      	movs	r0, #0
    bd20:	b006      	add	sp, #24
    bd22:	bd70      	pop	{r4, r5, r6, pc}
    bd24:	ee70 7a40 	vsub.f32	s15, s0, s0
    bd28:	2000      	movs	r0, #0
    bd2a:	edc5 7a01 	vstr	s15, [r5, #4]
    bd2e:	edc5 7a00 	vstr	s15, [r5]
    bd32:	e7a5      	b.n	bc80 <__ieee754_rem_pio2f+0x60>
    bd34:	f7ff fe64 	bl	ba00 <fabsf>
    bd38:	ed9f 7a4d 	vldr	s14, [pc, #308]	; be70 <__ieee754_rem_pio2f+0x250>
    bd3c:	ed9f 6a44 	vldr	s12, [pc, #272]	; be50 <__ieee754_rem_pio2f+0x230>
    bd40:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    bd44:	eee0 7a07 	vfma.f32	s15, s0, s14
    bd48:	ed9f 7a44 	vldr	s14, [pc, #272]	; be5c <__ieee754_rem_pio2f+0x23c>
    bd4c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    bd50:	ee17 0a90 	vmov	r0, s15
    bd54:	eef8 6ae7 	vcvt.f32.s32	s13, s15
    bd58:	281f      	cmp	r0, #31
    bd5a:	eea6 0ac6 	vfms.f32	s0, s13, s12
    bd5e:	ee66 7a87 	vmul.f32	s15, s13, s14
    bd62:	eeb1 6a66 	vneg.f32	s12, s13
    bd66:	dc1e      	bgt.n	bda6 <__ieee754_rem_pio2f+0x186>
    bd68:	4a42      	ldr	r2, [pc, #264]	; (be74 <__ieee754_rem_pio2f+0x254>)
    bd6a:	1e41      	subs	r1, r0, #1
    bd6c:	f024 03ff 	bic.w	r3, r4, #255	; 0xff
    bd70:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    bd74:	4293      	cmp	r3, r2
    bd76:	d016      	beq.n	bda6 <__ieee754_rem_pio2f+0x186>
    bd78:	ee30 7a67 	vsub.f32	s14, s0, s15
    bd7c:	ed85 7a00 	vstr	s14, [r5]
    bd80:	ee30 0a47 	vsub.f32	s0, s0, s14
    bd84:	2e00      	cmp	r6, #0
    bd86:	ee30 0a67 	vsub.f32	s0, s0, s15
    bd8a:	ed85 0a01 	vstr	s0, [r5, #4]
    bd8e:	f6bf af77 	bge.w	bc80 <__ieee754_rem_pio2f+0x60>
    bd92:	eeb1 7a47 	vneg.f32	s14, s14
    bd96:	eeb1 0a40 	vneg.f32	s0, s0
    bd9a:	ed85 7a00 	vstr	s14, [r5]
    bd9e:	ed85 0a01 	vstr	s0, [r5, #4]
    bda2:	4240      	negs	r0, r0
    bda4:	e76c      	b.n	bc80 <__ieee754_rem_pio2f+0x60>
    bda6:	ee30 7a67 	vsub.f32	s14, s0, s15
    bdaa:	15e2      	asrs	r2, r4, #23
    bdac:	ee17 3a10 	vmov	r3, s14
    bdb0:	f3c3 53c7 	ubfx	r3, r3, #23, #8
    bdb4:	ebc3 53d4 	rsb	r3, r3, r4, lsr #23
    bdb8:	2b08      	cmp	r3, #8
    bdba:	dddf      	ble.n	bd7c <__ieee754_rem_pio2f+0x15c>
    bdbc:	ed9f 7a26 	vldr	s14, [pc, #152]	; be58 <__ieee754_rem_pio2f+0x238>
    bdc0:	ed9f 5a27 	vldr	s10, [pc, #156]	; be60 <__ieee754_rem_pio2f+0x240>
    bdc4:	eef0 5a40 	vmov.f32	s11, s0
    bdc8:	eee6 5a07 	vfma.f32	s11, s12, s14
    bdcc:	ee70 7a65 	vsub.f32	s15, s0, s11
    bdd0:	eee6 7a07 	vfma.f32	s15, s12, s14
    bdd4:	eed6 7a85 	vfnms.f32	s15, s13, s10
    bdd8:	ee35 7ae7 	vsub.f32	s14, s11, s15
    bddc:	ee17 3a10 	vmov	r3, s14
    bde0:	f3c3 53c7 	ubfx	r3, r3, #23, #8
    bde4:	1ad2      	subs	r2, r2, r3
    bde6:	2a19      	cmp	r2, #25
    bde8:	dc06      	bgt.n	bdf8 <__ieee754_rem_pio2f+0x1d8>
    bdea:	eeb0 0a65 	vmov.f32	s0, s11
    bdee:	ed85 7a00 	vstr	s14, [r5]
    bdf2:	e7c5      	b.n	bd80 <__ieee754_rem_pio2f+0x160>
    bdf4:	2303      	movs	r3, #3
    bdf6:	e776      	b.n	bce6 <__ieee754_rem_pio2f+0xc6>
    bdf8:	ed9f 7a1f 	vldr	s14, [pc, #124]	; be78 <__ieee754_rem_pio2f+0x258>
    bdfc:	ed9f 5a1f 	vldr	s10, [pc, #124]	; be7c <__ieee754_rem_pio2f+0x25c>
    be00:	eeb0 0a65 	vmov.f32	s0, s11
    be04:	eea6 0a07 	vfma.f32	s0, s12, s14
    be08:	ee75 7ac0 	vsub.f32	s15, s11, s0
    be0c:	eee6 7a07 	vfma.f32	s15, s12, s14
    be10:	eed6 7a85 	vfnms.f32	s15, s13, s10
    be14:	e7b0      	b.n	bd78 <__ieee754_rem_pio2f+0x158>
    be16:	4294      	cmp	r4, r2
    be18:	ee70 7a27 	vadd.f32	s15, s0, s15
    be1c:	bf09      	itett	eq
    be1e:	eddf 6a0e 	vldreq	s13, [pc, #56]	; be58 <__ieee754_rem_pio2f+0x238>
    be22:	ed9f 7a0e 	vldrne	s14, [pc, #56]	; be5c <__ieee754_rem_pio2f+0x23c>
    be26:	ed9f 7a0e 	vldreq	s14, [pc, #56]	; be60 <__ieee754_rem_pio2f+0x240>
    be2a:	ee77 7aa6 	vaddeq.f32	s15, s15, s13
    be2e:	f04f 30ff 	mov.w	r0, #4294967295
    be32:	ee77 6a87 	vadd.f32	s13, s15, s14
    be36:	ee77 7ae6 	vsub.f32	s15, s15, s13
    be3a:	edc5 6a00 	vstr	s13, [r5]
    be3e:	ee77 7a87 	vadd.f32	s15, s15, s14
    be42:	edc5 7a01 	vstr	s15, [r5, #4]
    be46:	e71b      	b.n	bc80 <__ieee754_rem_pio2f+0x60>
    be48:	3f490fd8 	.word	0x3f490fd8
    be4c:	4016cbe3 	.word	0x4016cbe3
    be50:	3fc90f80 	.word	0x3fc90f80
    be54:	3fc90fd0 	.word	0x3fc90fd0
    be58:	37354400 	.word	0x37354400
    be5c:	37354443 	.word	0x37354443
    be60:	2e85a308 	.word	0x2e85a308
    be64:	43490f80 	.word	0x43490f80
    be68:	43800000 	.word	0x43800000
    be6c:	00010844 	.word	0x00010844
    be70:	3f22f984 	.word	0x3f22f984
    be74:	000107c4 	.word	0x000107c4
    be78:	2e85a300 	.word	0x2e85a300
    be7c:	248d3132 	.word	0x248d3132

0000be80 <__ieee754_sqrtf>:
    be80:	eeb1 0ac0 	vsqrt.f32	s0, s0
    be84:	4770      	bx	lr
    be86:	bf00      	nop

0000be88 <__ieee754_pow>:
    be88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    be8c:	ec55 4b11 	vmov	r4, r5, d1
    be90:	ed2d 8b0c 	vpush	{d8-d13}
    be94:	f025 4a00 	bic.w	sl, r5, #2147483648	; 0x80000000
    be98:	ea5a 0004 	orrs.w	r0, sl, r4
    be9c:	ec57 6b10 	vmov	r6, r7, d0
    bea0:	b087      	sub	sp, #28
    bea2:	d114      	bne.n	bece <__ieee754_pow+0x46>
    bea4:	19b3      	adds	r3, r6, r6
    bea6:	497c      	ldr	r1, [pc, #496]	; (c098 <__ieee754_pow+0x210>)
    bea8:	f487 2200 	eor.w	r2, r7, #524288	; 0x80000
    beac:	4152      	adcs	r2, r2
    beae:	4298      	cmp	r0, r3
    beb0:	4191      	sbcs	r1, r2
    beb2:	d223      	bcs.n	befc <__ieee754_pow+0x74>
    beb4:	4622      	mov	r2, r4
    beb6:	462b      	mov	r3, r5
    beb8:	4630      	mov	r0, r6
    beba:	4639      	mov	r1, r7
    bebc:	f001 fbec 	bl	d698 <__adddf3>
    bec0:	ec41 0b10 	vmov	d0, r0, r1
    bec4:	b007      	add	sp, #28
    bec6:	ecbd 8b0c 	vpop	{d8-d13}
    beca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bece:	4973      	ldr	r1, [pc, #460]	; (c09c <__ieee754_pow+0x214>)
    bed0:	f027 4900 	bic.w	r9, r7, #2147483648	; 0x80000000
    bed4:	4589      	cmp	r9, r1
    bed6:	ee10 2a10 	vmov	r2, s0
    beda:	46b8      	mov	r8, r7
    bedc:	dd15      	ble.n	bf0a <__ieee754_pow+0x82>
    bede:	f108 4840 	add.w	r8, r8, #3221225472	; 0xc0000000
    bee2:	f508 1880 	add.w	r8, r8, #1048576	; 0x100000
    bee6:	ea58 0802 	orrs.w	r8, r8, r2
    beea:	d1e3      	bne.n	beb4 <__ieee754_pow+0x2c>
    beec:	1923      	adds	r3, r4, r4
    beee:	496a      	ldr	r1, [pc, #424]	; (c098 <__ieee754_pow+0x210>)
    bef0:	f485 2200 	eor.w	r2, r5, #524288	; 0x80000
    bef4:	4152      	adcs	r2, r2
    bef6:	4598      	cmp	r8, r3
    bef8:	4191      	sbcs	r1, r2
    befa:	d3db      	bcc.n	beb4 <__ieee754_pow+0x2c>
    befc:	ed9f 0b64 	vldr	d0, [pc, #400]	; c090 <__ieee754_pow+0x208>
    bf00:	b007      	add	sp, #28
    bf02:	ecbd 8b0c 	vpop	{d8-d13}
    bf06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bf0a:	ee11 3a10 	vmov	r3, s2
    bf0e:	46ab      	mov	fp, r5
    bf10:	d042      	beq.n	bf98 <__ieee754_pow+0x110>
    bf12:	4962      	ldr	r1, [pc, #392]	; (c09c <__ieee754_pow+0x214>)
    bf14:	458a      	cmp	sl, r1
    bf16:	dce2      	bgt.n	bede <__ieee754_pow+0x56>
    bf18:	f000 8094 	beq.w	c044 <__ieee754_pow+0x1bc>
    bf1c:	f1b8 0f00 	cmp.w	r8, #0
    bf20:	db73      	blt.n	c00a <__ieee754_pow+0x182>
    bf22:	2100      	movs	r1, #0
    bf24:	9100      	str	r1, [sp, #0]
    bf26:	b97b      	cbnz	r3, bf48 <__ieee754_pow+0xc0>
    bf28:	4b5c      	ldr	r3, [pc, #368]	; (c09c <__ieee754_pow+0x214>)
    bf2a:	459a      	cmp	sl, r3
    bf2c:	f000 808e 	beq.w	c04c <__ieee754_pow+0x1c4>
    bf30:	4b5b      	ldr	r3, [pc, #364]	; (c0a0 <__ieee754_pow+0x218>)
    bf32:	459a      	cmp	sl, r3
    bf34:	f000 80a2 	beq.w	c07c <__ieee754_pow+0x1f4>
    bf38:	f1bb 4f80 	cmp.w	fp, #1073741824	; 0x40000000
    bf3c:	f000 84c0 	beq.w	c8c0 <__ieee754_pow+0xa38>
    bf40:	4b58      	ldr	r3, [pc, #352]	; (c0a4 <__ieee754_pow+0x21c>)
    bf42:	459b      	cmp	fp, r3
    bf44:	f000 83d5 	beq.w	c6f2 <__ieee754_pow+0x86a>
    bf48:	ec47 6b10 	vmov	d0, r6, r7
    bf4c:	9202      	str	r2, [sp, #8]
    bf4e:	f001 fa4d 	bl	d3ec <fabs>
    bf52:	9a02      	ldr	r2, [sp, #8]
    bf54:	b362      	cbz	r2, bfb0 <__ieee754_pow+0x128>
    bf56:	9a00      	ldr	r2, [sp, #0]
    bf58:	ea4f 73d8 	mov.w	r3, r8, lsr #31
    bf5c:	3b01      	subs	r3, #1
    bf5e:	9304      	str	r3, [sp, #16]
    bf60:	4313      	orrs	r3, r2
    bf62:	f000 8092 	beq.w	c08a <__ieee754_pow+0x202>
    bf66:	4b50      	ldr	r3, [pc, #320]	; (c0a8 <__ieee754_pow+0x220>)
    bf68:	459a      	cmp	sl, r3
    bf6a:	f340 80a3 	ble.w	c0b4 <__ieee754_pow+0x22c>
    bf6e:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
    bf72:	459a      	cmp	sl, r3
    bf74:	4b4d      	ldr	r3, [pc, #308]	; (c0ac <__ieee754_pow+0x224>)
    bf76:	f340 843d 	ble.w	c7f4 <__ieee754_pow+0x96c>
    bf7a:	4599      	cmp	r9, r3
    bf7c:	f340 84b2 	ble.w	c8e4 <__ieee754_pow+0xa5c>
    bf80:	f1bb 0f00 	cmp.w	fp, #0
    bf84:	f340 84b2 	ble.w	c8ec <__ieee754_pow+0xa64>
    bf88:	2000      	movs	r0, #0
    bf8a:	b007      	add	sp, #28
    bf8c:	ecbd 8b0c 	vpop	{d8-d13}
    bf90:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bf94:	f001 ba20 	b.w	d3d8 <__math_oflow>
    bf98:	2e00      	cmp	r6, #0
    bf9a:	d18b      	bne.n	beb4 <__ieee754_pow+0x2c>
    bf9c:	e7b9      	b.n	bf12 <__ieee754_pow+0x8a>
    bf9e:	ec47 6b10 	vmov	d0, r6, r7
    bfa2:	9200      	str	r2, [sp, #0]
    bfa4:	f001 fa22 	bl	d3ec <fabs>
    bfa8:	9a00      	ldr	r2, [sp, #0]
    bfaa:	2a00      	cmp	r2, #0
    bfac:	d16d      	bne.n	c08a <__ieee754_pow+0x202>
    bfae:	9200      	str	r2, [sp, #0]
    bfb0:	f1b9 0f00 	cmp.w	r9, #0
    bfb4:	d004      	beq.n	bfc0 <__ieee754_pow+0x138>
    bfb6:	4b3a      	ldr	r3, [pc, #232]	; (c0a0 <__ieee754_pow+0x218>)
    bfb8:	f028 4240 	bic.w	r2, r8, #3221225472	; 0xc0000000
    bfbc:	429a      	cmp	r2, r3
    bfbe:	d1ca      	bne.n	bf56 <__ieee754_pow+0xce>
    bfc0:	f1bb 0f00 	cmp.w	fp, #0
    bfc4:	da07      	bge.n	bfd6 <__ieee754_pow+0x14e>
    bfc6:	ec53 2b10 	vmov	r2, r3, d0
    bfca:	4935      	ldr	r1, [pc, #212]	; (c0a0 <__ieee754_pow+0x218>)
    bfcc:	2000      	movs	r0, #0
    bfce:	f001 fe43 	bl	dc58 <__aeabi_ddiv>
    bfd2:	ec41 0b10 	vmov	d0, r0, r1
    bfd6:	f1b8 0f00 	cmp.w	r8, #0
    bfda:	f6bf af73 	bge.w	bec4 <__ieee754_pow+0x3c>
    bfde:	9b00      	ldr	r3, [sp, #0]
    bfe0:	f109 4940 	add.w	r9, r9, #3221225472	; 0xc0000000
    bfe4:	f509 1980 	add.w	r9, r9, #1048576	; 0x100000
    bfe8:	ea59 0903 	orrs.w	r9, r9, r3
    bfec:	f040 848e 	bne.w	c90c <__ieee754_pow+0xa84>
    bff0:	ec53 2b10 	vmov	r2, r3, d0
    bff4:	4610      	mov	r0, r2
    bff6:	4619      	mov	r1, r3
    bff8:	f001 fb4c 	bl	d694 <__aeabi_dsub>
    bffc:	4602      	mov	r2, r0
    bffe:	460b      	mov	r3, r1
    c000:	f001 fe2a 	bl	dc58 <__aeabi_ddiv>
    c004:	ec41 0b10 	vmov	d0, r0, r1
    c008:	e75c      	b.n	bec4 <__ieee754_pow+0x3c>
    c00a:	4929      	ldr	r1, [pc, #164]	; (c0b0 <__ieee754_pow+0x228>)
    c00c:	458a      	cmp	sl, r1
    c00e:	dc2f      	bgt.n	c070 <__ieee754_pow+0x1e8>
    c010:	f1a1 7154 	sub.w	r1, r1, #55574528	; 0x3500000
    c014:	458a      	cmp	sl, r1
    c016:	dd0f      	ble.n	c038 <__ieee754_pow+0x1b0>
    c018:	ea4f 512a 	mov.w	r1, sl, asr #20
    c01c:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
    c020:	2914      	cmp	r1, #20
    c022:	f340 8465 	ble.w	c8f0 <__ieee754_pow+0xa68>
    c026:	f1c1 0134 	rsb	r1, r1, #52	; 0x34
    c02a:	fa23 f001 	lsr.w	r0, r3, r1
    c02e:	fa00 f101 	lsl.w	r1, r0, r1
    c032:	4299      	cmp	r1, r3
    c034:	f000 84a3 	beq.w	c97e <__ieee754_pow+0xaf6>
    c038:	2100      	movs	r1, #0
    c03a:	9100      	str	r1, [sp, #0]
    c03c:	2b00      	cmp	r3, #0
    c03e:	f43f af77 	beq.w	bf30 <__ieee754_pow+0xa8>
    c042:	e781      	b.n	bf48 <__ieee754_pow+0xc0>
    c044:	2b00      	cmp	r3, #0
    c046:	f43f af69 	beq.w	bf1c <__ieee754_pow+0x94>
    c04a:	e748      	b.n	bede <__ieee754_pow+0x56>
    c04c:	f109 4340 	add.w	r3, r9, #3221225472	; 0xc0000000
    c050:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
    c054:	4313      	orrs	r3, r2
    c056:	f43f af51 	beq.w	befc <__ieee754_pow+0x74>
    c05a:	4b14      	ldr	r3, [pc, #80]	; (c0ac <__ieee754_pow+0x224>)
    c05c:	4599      	cmp	r9, r3
    c05e:	f340 8382 	ble.w	c766 <__ieee754_pow+0x8de>
    c062:	f1bb 0f00 	cmp.w	fp, #0
    c066:	f2c0 845f 	blt.w	c928 <__ieee754_pow+0xaa0>
    c06a:	ec45 4b10 	vmov	d0, r4, r5
    c06e:	e729      	b.n	bec4 <__ieee754_pow+0x3c>
    c070:	2102      	movs	r1, #2
    c072:	9100      	str	r1, [sp, #0]
    c074:	2b00      	cmp	r3, #0
    c076:	f43f af57 	beq.w	bf28 <__ieee754_pow+0xa0>
    c07a:	e765      	b.n	bf48 <__ieee754_pow+0xc0>
    c07c:	f1bb 0f00 	cmp.w	fp, #0
    c080:	f2c0 8414 	blt.w	c8ac <__ieee754_pow+0xa24>
    c084:	ec47 6b10 	vmov	d0, r6, r7
    c088:	e71c      	b.n	bec4 <__ieee754_pow+0x3c>
    c08a:	4632      	mov	r2, r6
    c08c:	463b      	mov	r3, r7
    c08e:	e7b1      	b.n	bff4 <__ieee754_pow+0x16c>
    c090:	00000000 	.word	0x00000000
    c094:	3ff00000 	.word	0x3ff00000
    c098:	fff00000 	.word	0xfff00000
    c09c:	7ff00000 	.word	0x7ff00000
    c0a0:	3ff00000 	.word	0x3ff00000
    c0a4:	3fe00000 	.word	0x3fe00000
    c0a8:	41e00000 	.word	0x41e00000
    c0ac:	3fefffff 	.word	0x3fefffff
    c0b0:	433fffff 	.word	0x433fffff
    c0b4:	4be4      	ldr	r3, [pc, #912]	; (c448 <__ieee754_pow+0x5c0>)
    c0b6:	ea08 0303 	and.w	r3, r8, r3
    c0ba:	2200      	movs	r2, #0
    c0bc:	b953      	cbnz	r3, c0d4 <__ieee754_pow+0x24c>
    c0be:	ec51 0b10 	vmov	r0, r1, d0
    c0c2:	4be2      	ldr	r3, [pc, #904]	; (c44c <__ieee754_pow+0x5c4>)
    c0c4:	f001 fc9e 	bl	da04 <__aeabi_dmul>
    c0c8:	ec41 0b10 	vmov	d0, r0, r1
    c0cc:	ee10 9a90 	vmov	r9, s1
    c0d0:	f06f 0234 	mvn.w	r2, #52	; 0x34
    c0d4:	ea4f 5329 	mov.w	r3, r9, asr #20
    c0d8:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
    c0dc:	189a      	adds	r2, r3, r2
    c0de:	4bdc      	ldr	r3, [pc, #880]	; (c450 <__ieee754_pow+0x5c8>)
    c0e0:	9205      	str	r2, [sp, #20]
    c0e2:	f3c9 0913 	ubfx	r9, r9, #0, #20
    c0e6:	f049 567f 	orr.w	r6, r9, #1069547520	; 0x3fc00000
    c0ea:	4599      	cmp	r9, r3
    c0ec:	f446 1640 	orr.w	r6, r6, #3145728	; 0x300000
    c0f0:	dd07      	ble.n	c102 <__ieee754_pow+0x27a>
    c0f2:	4bd8      	ldr	r3, [pc, #864]	; (c454 <__ieee754_pow+0x5cc>)
    c0f4:	4599      	cmp	r9, r3
    c0f6:	f340 841b 	ble.w	c930 <__ieee754_pow+0xaa8>
    c0fa:	3201      	adds	r2, #1
    c0fc:	9205      	str	r2, [sp, #20]
    c0fe:	f5a6 1680 	sub.w	r6, r6, #1048576	; 0x100000
    c102:	ed9f 6bb9 	vldr	d6, [pc, #740]	; c3e8 <__ieee754_pow+0x560>
    c106:	ed9f 7bba 	vldr	d7, [pc, #744]	; c3f0 <__ieee754_pow+0x568>
    c10a:	ec51 0b16 	vmov	r0, r1, d6
    c10e:	eeb0 ca47 	vmov.f32	s24, s14
    c112:	eef0 ca67 	vmov.f32	s25, s15
    c116:	2700      	movs	r7, #0
    c118:	eeb0 da47 	vmov.f32	s26, s14
    c11c:	eef0 da67 	vmov.f32	s27, s15
    c120:	ec53 2b10 	vmov	r2, r3, d0
    c124:	4633      	mov	r3, r6
    c126:	ec43 2b19 	vmov	d9, r2, r3
    c12a:	ec41 0b1a 	vmov	d10, r0, r1
    c12e:	4602      	mov	r2, r0
    c130:	460b      	mov	r3, r1
    c132:	ec51 0b19 	vmov	r0, r1, d9
    c136:	f001 faad 	bl	d694 <__aeabi_dsub>
    c13a:	ec53 2b1a 	vmov	r2, r3, d10
    c13e:	4680      	mov	r8, r0
    c140:	4689      	mov	r9, r1
    c142:	ec51 0b19 	vmov	r0, r1, d9
    c146:	f001 faa7 	bl	d698 <__adddf3>
    c14a:	4602      	mov	r2, r0
    c14c:	460b      	mov	r3, r1
    c14e:	2000      	movs	r0, #0
    c150:	49c1      	ldr	r1, [pc, #772]	; (c458 <__ieee754_pow+0x5d0>)
    c152:	f001 fd81 	bl	dc58 <__aeabi_ddiv>
    c156:	ec41 0b1b 	vmov	d11, r0, r1
    c15a:	4640      	mov	r0, r8
    c15c:	ec53 2b1b 	vmov	r2, r3, d11
    c160:	4649      	mov	r1, r9
    c162:	f001 fc4f 	bl	da04 <__aeabi_dmul>
    c166:	ec41 0b18 	vmov	d8, r0, r1
    c16a:	460a      	mov	r2, r1
    c16c:	4601      	mov	r1, r0
    c16e:	e9cd 1202 	strd	r1, r2, [sp, #8]
    c172:	2100      	movs	r1, #0
    c174:	9102      	str	r1, [sp, #8]
    c176:	1076      	asrs	r6, r6, #1
    c178:	e9dd ab02 	ldrd	sl, fp, [sp, #8]
    c17c:	f046 5600 	orr.w	r6, r6, #536870912	; 0x20000000
    c180:	f506 2300 	add.w	r3, r6, #524288	; 0x80000
    c184:	2000      	movs	r0, #0
    c186:	19d9      	adds	r1, r3, r7
    c188:	4606      	mov	r6, r0
    c18a:	460f      	mov	r7, r1
    c18c:	4602      	mov	r2, r0
    c18e:	460b      	mov	r3, r1
    c190:	4650      	mov	r0, sl
    c192:	4659      	mov	r1, fp
    c194:	f001 fc36 	bl	da04 <__aeabi_dmul>
    c198:	4602      	mov	r2, r0
    c19a:	460b      	mov	r3, r1
    c19c:	4640      	mov	r0, r8
    c19e:	4649      	mov	r1, r9
    c1a0:	f001 fa78 	bl	d694 <__aeabi_dsub>
    c1a4:	ec53 2b1a 	vmov	r2, r3, d10
    c1a8:	4680      	mov	r8, r0
    c1aa:	4689      	mov	r9, r1
    c1ac:	4630      	mov	r0, r6
    c1ae:	4639      	mov	r1, r7
    c1b0:	f001 fa70 	bl	d694 <__aeabi_dsub>
    c1b4:	4602      	mov	r2, r0
    c1b6:	460b      	mov	r3, r1
    c1b8:	ec51 0b19 	vmov	r0, r1, d9
    c1bc:	f001 fa6a 	bl	d694 <__aeabi_dsub>
    c1c0:	4652      	mov	r2, sl
    c1c2:	465b      	mov	r3, fp
    c1c4:	f001 fc1e 	bl	da04 <__aeabi_dmul>
    c1c8:	4602      	mov	r2, r0
    c1ca:	460b      	mov	r3, r1
    c1cc:	4640      	mov	r0, r8
    c1ce:	4649      	mov	r1, r9
    c1d0:	f001 fa60 	bl	d694 <__aeabi_dsub>
    c1d4:	ec53 2b1b 	vmov	r2, r3, d11
    c1d8:	f001 fc14 	bl	da04 <__aeabi_dmul>
    c1dc:	ec53 2b18 	vmov	r2, r3, d8
    c1e0:	ec41 0b1b 	vmov	d11, r0, r1
    c1e4:	ec51 0b18 	vmov	r0, r1, d8
    c1e8:	f001 fc0c 	bl	da04 <__aeabi_dmul>
    c1ec:	a382      	add	r3, pc, #520	; (adr r3, c3f8 <__ieee754_pow+0x570>)
    c1ee:	e9d3 2300 	ldrd	r2, r3, [r3]
    c1f2:	4606      	mov	r6, r0
    c1f4:	460f      	mov	r7, r1
    c1f6:	f001 fc05 	bl	da04 <__aeabi_dmul>
    c1fa:	a381      	add	r3, pc, #516	; (adr r3, c400 <__ieee754_pow+0x578>)
    c1fc:	e9d3 2300 	ldrd	r2, r3, [r3]
    c200:	f001 fa4a 	bl	d698 <__adddf3>
    c204:	4632      	mov	r2, r6
    c206:	463b      	mov	r3, r7
    c208:	f001 fbfc 	bl	da04 <__aeabi_dmul>
    c20c:	a37e      	add	r3, pc, #504	; (adr r3, c408 <__ieee754_pow+0x580>)
    c20e:	e9d3 2300 	ldrd	r2, r3, [r3]
    c212:	f001 fa41 	bl	d698 <__adddf3>
    c216:	4632      	mov	r2, r6
    c218:	463b      	mov	r3, r7
    c21a:	f001 fbf3 	bl	da04 <__aeabi_dmul>
    c21e:	a37c      	add	r3, pc, #496	; (adr r3, c410 <__ieee754_pow+0x588>)
    c220:	e9d3 2300 	ldrd	r2, r3, [r3]
    c224:	f001 fa38 	bl	d698 <__adddf3>
    c228:	4632      	mov	r2, r6
    c22a:	463b      	mov	r3, r7
    c22c:	f001 fbea 	bl	da04 <__aeabi_dmul>
    c230:	a379      	add	r3, pc, #484	; (adr r3, c418 <__ieee754_pow+0x590>)
    c232:	e9d3 2300 	ldrd	r2, r3, [r3]
    c236:	f001 fa2f 	bl	d698 <__adddf3>
    c23a:	4632      	mov	r2, r6
    c23c:	463b      	mov	r3, r7
    c23e:	f001 fbe1 	bl	da04 <__aeabi_dmul>
    c242:	a377      	add	r3, pc, #476	; (adr r3, c420 <__ieee754_pow+0x598>)
    c244:	e9d3 2300 	ldrd	r2, r3, [r3]
    c248:	f001 fa26 	bl	d698 <__adddf3>
    c24c:	4632      	mov	r2, r6
    c24e:	4680      	mov	r8, r0
    c250:	4689      	mov	r9, r1
    c252:	463b      	mov	r3, r7
    c254:	4630      	mov	r0, r6
    c256:	4639      	mov	r1, r7
    c258:	f001 fbd4 	bl	da04 <__aeabi_dmul>
    c25c:	4602      	mov	r2, r0
    c25e:	460b      	mov	r3, r1
    c260:	4640      	mov	r0, r8
    c262:	4649      	mov	r1, r9
    c264:	f001 fbce 	bl	da04 <__aeabi_dmul>
    c268:	4652      	mov	r2, sl
    c26a:	4606      	mov	r6, r0
    c26c:	460f      	mov	r7, r1
    c26e:	465b      	mov	r3, fp
    c270:	ec51 0b18 	vmov	r0, r1, d8
    c274:	f001 fa10 	bl	d698 <__adddf3>
    c278:	ec53 2b1b 	vmov	r2, r3, d11
    c27c:	f001 fbc2 	bl	da04 <__aeabi_dmul>
    c280:	4632      	mov	r2, r6
    c282:	463b      	mov	r3, r7
    c284:	f001 fa08 	bl	d698 <__adddf3>
    c288:	4652      	mov	r2, sl
    c28a:	ec41 0b1a 	vmov	d10, r0, r1
    c28e:	465b      	mov	r3, fp
    c290:	4650      	mov	r0, sl
    c292:	4659      	mov	r1, fp
    c294:	f001 fbb6 	bl	da04 <__aeabi_dmul>
    c298:	4b70      	ldr	r3, [pc, #448]	; (c45c <__ieee754_pow+0x5d4>)
    c29a:	2200      	movs	r2, #0
    c29c:	4680      	mov	r8, r0
    c29e:	4689      	mov	r9, r1
    c2a0:	f001 f9fa 	bl	d698 <__adddf3>
    c2a4:	ec53 2b1a 	vmov	r2, r3, d10
    c2a8:	f001 f9f6 	bl	d698 <__adddf3>
    c2ac:	4650      	mov	r0, sl
    c2ae:	460f      	mov	r7, r1
    c2b0:	4659      	mov	r1, fp
    c2b2:	e9dd ab02 	ldrd	sl, fp, [sp, #8]
    c2b6:	463b      	mov	r3, r7
    c2b8:	4652      	mov	r2, sl
    c2ba:	f001 fba3 	bl	da04 <__aeabi_dmul>
    c2be:	4b67      	ldr	r3, [pc, #412]	; (c45c <__ieee754_pow+0x5d4>)
    c2c0:	ec41 0b19 	vmov	d9, r0, r1
    c2c4:	2200      	movs	r2, #0
    c2c6:	4650      	mov	r0, sl
    c2c8:	4639      	mov	r1, r7
    c2ca:	f001 f9e3 	bl	d694 <__aeabi_dsub>
    c2ce:	4642      	mov	r2, r8
    c2d0:	464b      	mov	r3, r9
    c2d2:	f001 f9df 	bl	d694 <__aeabi_dsub>
    c2d6:	4602      	mov	r2, r0
    c2d8:	460b      	mov	r3, r1
    c2da:	ec51 0b1a 	vmov	r0, r1, d10
    c2de:	f001 f9d9 	bl	d694 <__aeabi_dsub>
    c2e2:	ec53 2b18 	vmov	r2, r3, d8
    c2e6:	f001 fb8d 	bl	da04 <__aeabi_dmul>
    c2ea:	4652      	mov	r2, sl
    c2ec:	463b      	mov	r3, r7
    c2ee:	4606      	mov	r6, r0
    c2f0:	460f      	mov	r7, r1
    c2f2:	ec51 0b1b 	vmov	r0, r1, d11
    c2f6:	f001 fb85 	bl	da04 <__aeabi_dmul>
    c2fa:	4602      	mov	r2, r0
    c2fc:	460b      	mov	r3, r1
    c2fe:	4630      	mov	r0, r6
    c300:	4639      	mov	r1, r7
    c302:	f001 f9c9 	bl	d698 <__adddf3>
    c306:	4680      	mov	r8, r0
    c308:	4689      	mov	r9, r1
    c30a:	4642      	mov	r2, r8
    c30c:	464b      	mov	r3, r9
    c30e:	ec51 0b19 	vmov	r0, r1, d9
    c312:	f001 f9c1 	bl	d698 <__adddf3>
    c316:	a344      	add	r3, pc, #272	; (adr r3, c428 <__ieee754_pow+0x5a0>)
    c318:	e9d3 2300 	ldrd	r2, r3, [r3]
    c31c:	4650      	mov	r0, sl
    c31e:	460f      	mov	r7, r1
    c320:	f001 fb70 	bl	da04 <__aeabi_dmul>
    c324:	ec53 2b19 	vmov	r2, r3, d9
    c328:	ec41 0b19 	vmov	d9, r0, r1
    c32c:	4650      	mov	r0, sl
    c32e:	4639      	mov	r1, r7
    c330:	f001 f9b0 	bl	d694 <__aeabi_dsub>
    c334:	4602      	mov	r2, r0
    c336:	460b      	mov	r3, r1
    c338:	4640      	mov	r0, r8
    c33a:	4649      	mov	r1, r9
    c33c:	f001 f9aa 	bl	d694 <__aeabi_dsub>
    c340:	a33b      	add	r3, pc, #236	; (adr r3, c430 <__ieee754_pow+0x5a8>)
    c342:	e9d3 2300 	ldrd	r2, r3, [r3]
    c346:	f001 fb5d 	bl	da04 <__aeabi_dmul>
    c34a:	4602      	mov	r2, r0
    c34c:	460b      	mov	r3, r1
    c34e:	4616      	mov	r6, r2
    c350:	4650      	mov	r0, sl
    c352:	4639      	mov	r1, r7
    c354:	461f      	mov	r7, r3
    c356:	a338      	add	r3, pc, #224	; (adr r3, c438 <__ieee754_pow+0x5b0>)
    c358:	e9d3 2300 	ldrd	r2, r3, [r3]
    c35c:	f001 fb52 	bl	da04 <__aeabi_dmul>
    c360:	4602      	mov	r2, r0
    c362:	460b      	mov	r3, r1
    c364:	4630      	mov	r0, r6
    c366:	4639      	mov	r1, r7
    c368:	f001 f996 	bl	d698 <__adddf3>
    c36c:	ec53 2b1d 	vmov	r2, r3, d13
    c370:	f001 f992 	bl	d698 <__adddf3>
    c374:	4680      	mov	r8, r0
    c376:	9805      	ldr	r0, [sp, #20]
    c378:	4689      	mov	r9, r1
    c37a:	f001 fad9 	bl	d930 <__aeabi_i2d>
    c37e:	4642      	mov	r2, r8
    c380:	4682      	mov	sl, r0
    c382:	468b      	mov	fp, r1
    c384:	464b      	mov	r3, r9
    c386:	ec51 0b19 	vmov	r0, r1, d9
    c38a:	f001 f985 	bl	d698 <__adddf3>
    c38e:	ec53 2b1c 	vmov	r2, r3, d12
    c392:	f001 f981 	bl	d698 <__adddf3>
    c396:	4652      	mov	r2, sl
    c398:	465b      	mov	r3, fp
    c39a:	f001 f97d 	bl	d698 <__adddf3>
    c39e:	4652      	mov	r2, sl
    c3a0:	465b      	mov	r3, fp
    c3a2:	2000      	movs	r0, #0
    c3a4:	4606      	mov	r6, r0
    c3a6:	460f      	mov	r7, r1
    c3a8:	f001 f974 	bl	d694 <__aeabi_dsub>
    c3ac:	ec53 2b1c 	vmov	r2, r3, d12
    c3b0:	f001 f970 	bl	d694 <__aeabi_dsub>
    c3b4:	ec53 2b19 	vmov	r2, r3, d9
    c3b8:	f001 f96c 	bl	d694 <__aeabi_dsub>
    c3bc:	4602      	mov	r2, r0
    c3be:	460b      	mov	r3, r1
    c3c0:	4640      	mov	r0, r8
    c3c2:	4649      	mov	r1, r9
    c3c4:	f001 f966 	bl	d694 <__aeabi_dsub>
    c3c8:	9b00      	ldr	r3, [sp, #0]
    c3ca:	9a04      	ldr	r2, [sp, #16]
    c3cc:	3b01      	subs	r3, #1
    c3ce:	4313      	orrs	r3, r2
    c3d0:	4682      	mov	sl, r0
    c3d2:	468b      	mov	fp, r1
    c3d4:	f040 81c0 	bne.w	c758 <__ieee754_pow+0x8d0>
    c3d8:	ed9f 7b19 	vldr	d7, [pc, #100]	; c440 <__ieee754_pow+0x5b8>
    c3dc:	eeb0 8a47 	vmov.f32	s16, s14
    c3e0:	eef0 8a67 	vmov.f32	s17, s15
    c3e4:	e03c      	b.n	c460 <__ieee754_pow+0x5d8>
    c3e6:	bf00      	nop
    c3e8:	00000000 	.word	0x00000000
    c3ec:	3ff00000 	.word	0x3ff00000
	...
    c3f8:	4a454eef 	.word	0x4a454eef
    c3fc:	3fca7e28 	.word	0x3fca7e28
    c400:	93c9db65 	.word	0x93c9db65
    c404:	3fcd864a 	.word	0x3fcd864a
    c408:	a91d4101 	.word	0xa91d4101
    c40c:	3fd17460 	.word	0x3fd17460
    c410:	518f264d 	.word	0x518f264d
    c414:	3fd55555 	.word	0x3fd55555
    c418:	db6fabff 	.word	0xdb6fabff
    c41c:	3fdb6db6 	.word	0x3fdb6db6
    c420:	33333303 	.word	0x33333303
    c424:	3fe33333 	.word	0x3fe33333
    c428:	e0000000 	.word	0xe0000000
    c42c:	3feec709 	.word	0x3feec709
    c430:	dc3a03fd 	.word	0xdc3a03fd
    c434:	3feec709 	.word	0x3feec709
    c438:	145b01f5 	.word	0x145b01f5
    c43c:	be3e2fe0 	.word	0xbe3e2fe0
    c440:	00000000 	.word	0x00000000
    c444:	bff00000 	.word	0xbff00000
    c448:	7ff00000 	.word	0x7ff00000
    c44c:	43400000 	.word	0x43400000
    c450:	0003988e 	.word	0x0003988e
    c454:	000bb679 	.word	0x000bb679
    c458:	3ff00000 	.word	0x3ff00000
    c45c:	40080000 	.word	0x40080000
    c460:	2300      	movs	r3, #0
    c462:	e9cd 4500 	strd	r4, r5, [sp]
    c466:	9300      	str	r3, [sp, #0]
    c468:	e9dd 8900 	ldrd	r8, r9, [sp]
    c46c:	4620      	mov	r0, r4
    c46e:	4642      	mov	r2, r8
    c470:	464b      	mov	r3, r9
    c472:	4629      	mov	r1, r5
    c474:	f001 f90e 	bl	d694 <__aeabi_dsub>
    c478:	4632      	mov	r2, r6
    c47a:	463b      	mov	r3, r7
    c47c:	f001 fac2 	bl	da04 <__aeabi_dmul>
    c480:	4622      	mov	r2, r4
    c482:	462b      	mov	r3, r5
    c484:	4604      	mov	r4, r0
    c486:	460d      	mov	r5, r1
    c488:	4650      	mov	r0, sl
    c48a:	4659      	mov	r1, fp
    c48c:	f001 faba 	bl	da04 <__aeabi_dmul>
    c490:	4602      	mov	r2, r0
    c492:	460b      	mov	r3, r1
    c494:	4620      	mov	r0, r4
    c496:	4629      	mov	r1, r5
    c498:	f001 f8fe 	bl	d698 <__adddf3>
    c49c:	4642      	mov	r2, r8
    c49e:	4604      	mov	r4, r0
    c4a0:	460d      	mov	r5, r1
    c4a2:	464b      	mov	r3, r9
    c4a4:	4630      	mov	r0, r6
    c4a6:	4639      	mov	r1, r7
    c4a8:	f001 faac 	bl	da04 <__aeabi_dmul>
    c4ac:	4626      	mov	r6, r4
    c4ae:	462f      	mov	r7, r5
    c4b0:	4604      	mov	r4, r0
    c4b2:	460d      	mov	r5, r1
    c4b4:	462b      	mov	r3, r5
    c4b6:	4630      	mov	r0, r6
    c4b8:	4639      	mov	r1, r7
    c4ba:	4622      	mov	r2, r4
    c4bc:	f001 f8ec 	bl	d698 <__adddf3>
    c4c0:	4bc7      	ldr	r3, [pc, #796]	; (c7e0 <__ieee754_pow+0x958>)
    c4c2:	4299      	cmp	r1, r3
    c4c4:	4680      	mov	r8, r0
    c4c6:	4689      	mov	r9, r1
    c4c8:	468a      	mov	sl, r1
    c4ca:	f340 811f 	ble.w	c70c <__ieee754_pow+0x884>
    c4ce:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
    c4d2:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
    c4d6:	4303      	orrs	r3, r0
    c4d8:	f040 823e 	bne.w	c958 <__ieee754_pow+0xad0>
    c4dc:	a3aa      	add	r3, pc, #680	; (adr r3, c788 <__ieee754_pow+0x900>)
    c4de:	e9d3 2300 	ldrd	r2, r3, [r3]
    c4e2:	4630      	mov	r0, r6
    c4e4:	4639      	mov	r1, r7
    c4e6:	f001 f8d7 	bl	d698 <__adddf3>
    c4ea:	4602      	mov	r2, r0
    c4ec:	460b      	mov	r3, r1
    c4ee:	4640      	mov	r0, r8
    c4f0:	4649      	mov	r1, r9
    c4f2:	4690      	mov	r8, r2
    c4f4:	4699      	mov	r9, r3
    c4f6:	4622      	mov	r2, r4
    c4f8:	462b      	mov	r3, r5
    c4fa:	f001 f8cb 	bl	d694 <__aeabi_dsub>
    c4fe:	4602      	mov	r2, r0
    c500:	460b      	mov	r3, r1
    c502:	4640      	mov	r0, r8
    c504:	4649      	mov	r1, r9
    c506:	f001 fd0d 	bl	df24 <__aeabi_dcmpgt>
    c50a:	2800      	cmp	r0, #0
    c50c:	f040 8224 	bne.w	c958 <__ieee754_pow+0xad0>
    c510:	f3ca 530a 	ubfx	r3, sl, #20, #11
    c514:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    c518:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
    c51c:	fa42 f303 	asr.w	r3, r2, r3
    c520:	4453      	add	r3, sl
    c522:	49b0      	ldr	r1, [pc, #704]	; (c7e4 <__ieee754_pow+0x95c>)
    c524:	f3c3 520a 	ubfx	r2, r3, #20, #11
    c528:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
    c52c:	fa41 fc02 	asr.w	ip, r1, r2
    c530:	f3c3 0113 	ubfx	r1, r3, #0, #20
    c534:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c538:	f1c2 0214 	rsb	r2, r2, #20
    c53c:	fa41 f202 	asr.w	r2, r1, r2
    c540:	2000      	movs	r0, #0
    c542:	ea0c 0103 	and.w	r1, ip, r3
    c546:	f1ba 0f00 	cmp.w	sl, #0
    c54a:	9200      	str	r2, [sp, #0]
    c54c:	460b      	mov	r3, r1
    c54e:	4602      	mov	r2, r0
    c550:	da02      	bge.n	c558 <__ieee754_pow+0x6d0>
    c552:	9900      	ldr	r1, [sp, #0]
    c554:	4249      	negs	r1, r1
    c556:	9100      	str	r1, [sp, #0]
    c558:	4620      	mov	r0, r4
    c55a:	4629      	mov	r1, r5
    c55c:	f001 f89a 	bl	d694 <__aeabi_dsub>
    c560:	9b00      	ldr	r3, [sp, #0]
    c562:	051b      	lsls	r3, r3, #20
    c564:	9302      	str	r3, [sp, #8]
    c566:	4602      	mov	r2, r0
    c568:	460b      	mov	r3, r1
    c56a:	4604      	mov	r4, r0
    c56c:	460d      	mov	r5, r1
    c56e:	4630      	mov	r0, r6
    c570:	4639      	mov	r1, r7
    c572:	f001 f891 	bl	d698 <__adddf3>
    c576:	4689      	mov	r9, r1
    c578:	f04f 0800 	mov.w	r8, #0
    c57c:	a384      	add	r3, pc, #528	; (adr r3, c790 <__ieee754_pow+0x908>)
    c57e:	e9d3 2300 	ldrd	r2, r3, [r3]
    c582:	4640      	mov	r0, r8
    c584:	4649      	mov	r1, r9
    c586:	f001 fa3d 	bl	da04 <__aeabi_dmul>
    c58a:	4622      	mov	r2, r4
    c58c:	462b      	mov	r3, r5
    c58e:	4682      	mov	sl, r0
    c590:	468b      	mov	fp, r1
    c592:	4640      	mov	r0, r8
    c594:	4649      	mov	r1, r9
    c596:	f001 f87d 	bl	d694 <__aeabi_dsub>
    c59a:	4602      	mov	r2, r0
    c59c:	460b      	mov	r3, r1
    c59e:	4630      	mov	r0, r6
    c5a0:	4639      	mov	r1, r7
    c5a2:	f001 f877 	bl	d694 <__aeabi_dsub>
    c5a6:	a37c      	add	r3, pc, #496	; (adr r3, c798 <__ieee754_pow+0x910>)
    c5a8:	e9d3 2300 	ldrd	r2, r3, [r3]
    c5ac:	f001 fa2a 	bl	da04 <__aeabi_dmul>
    c5b0:	a37b      	add	r3, pc, #492	; (adr r3, c7a0 <__ieee754_pow+0x918>)
    c5b2:	e9d3 2300 	ldrd	r2, r3, [r3]
    c5b6:	4604      	mov	r4, r0
    c5b8:	460d      	mov	r5, r1
    c5ba:	4640      	mov	r0, r8
    c5bc:	4649      	mov	r1, r9
    c5be:	f001 fa21 	bl	da04 <__aeabi_dmul>
    c5c2:	4602      	mov	r2, r0
    c5c4:	460b      	mov	r3, r1
    c5c6:	4620      	mov	r0, r4
    c5c8:	4629      	mov	r1, r5
    c5ca:	f001 f865 	bl	d698 <__adddf3>
    c5ce:	4606      	mov	r6, r0
    c5d0:	460f      	mov	r7, r1
    c5d2:	4632      	mov	r2, r6
    c5d4:	463b      	mov	r3, r7
    c5d6:	4650      	mov	r0, sl
    c5d8:	4659      	mov	r1, fp
    c5da:	f001 f85d 	bl	d698 <__adddf3>
    c5de:	4652      	mov	r2, sl
    c5e0:	465b      	mov	r3, fp
    c5e2:	4604      	mov	r4, r0
    c5e4:	460d      	mov	r5, r1
    c5e6:	f001 f855 	bl	d694 <__aeabi_dsub>
    c5ea:	4602      	mov	r2, r0
    c5ec:	460b      	mov	r3, r1
    c5ee:	4630      	mov	r0, r6
    c5f0:	4639      	mov	r1, r7
    c5f2:	f001 f84f 	bl	d694 <__aeabi_dsub>
    c5f6:	4622      	mov	r2, r4
    c5f8:	4680      	mov	r8, r0
    c5fa:	4689      	mov	r9, r1
    c5fc:	462b      	mov	r3, r5
    c5fe:	4620      	mov	r0, r4
    c600:	4629      	mov	r1, r5
    c602:	f001 f9ff 	bl	da04 <__aeabi_dmul>
    c606:	a368      	add	r3, pc, #416	; (adr r3, c7a8 <__ieee754_pow+0x920>)
    c608:	e9d3 2300 	ldrd	r2, r3, [r3]
    c60c:	4606      	mov	r6, r0
    c60e:	460f      	mov	r7, r1
    c610:	f001 f9f8 	bl	da04 <__aeabi_dmul>
    c614:	a366      	add	r3, pc, #408	; (adr r3, c7b0 <__ieee754_pow+0x928>)
    c616:	e9d3 2300 	ldrd	r2, r3, [r3]
    c61a:	f001 f83b 	bl	d694 <__aeabi_dsub>
    c61e:	4632      	mov	r2, r6
    c620:	463b      	mov	r3, r7
    c622:	f001 f9ef 	bl	da04 <__aeabi_dmul>
    c626:	a364      	add	r3, pc, #400	; (adr r3, c7b8 <__ieee754_pow+0x930>)
    c628:	e9d3 2300 	ldrd	r2, r3, [r3]
    c62c:	f001 f834 	bl	d698 <__adddf3>
    c630:	4632      	mov	r2, r6
    c632:	463b      	mov	r3, r7
    c634:	f001 f9e6 	bl	da04 <__aeabi_dmul>
    c638:	a361      	add	r3, pc, #388	; (adr r3, c7c0 <__ieee754_pow+0x938>)
    c63a:	e9d3 2300 	ldrd	r2, r3, [r3]
    c63e:	f001 f829 	bl	d694 <__aeabi_dsub>
    c642:	4632      	mov	r2, r6
    c644:	463b      	mov	r3, r7
    c646:	f001 f9dd 	bl	da04 <__aeabi_dmul>
    c64a:	a35f      	add	r3, pc, #380	; (adr r3, c7c8 <__ieee754_pow+0x940>)
    c64c:	e9d3 2300 	ldrd	r2, r3, [r3]
    c650:	f001 f822 	bl	d698 <__adddf3>
    c654:	4632      	mov	r2, r6
    c656:	463b      	mov	r3, r7
    c658:	f001 f9d4 	bl	da04 <__aeabi_dmul>
    c65c:	4602      	mov	r2, r0
    c65e:	460b      	mov	r3, r1
    c660:	4620      	mov	r0, r4
    c662:	4629      	mov	r1, r5
    c664:	f001 f816 	bl	d694 <__aeabi_dsub>
    c668:	4606      	mov	r6, r0
    c66a:	460f      	mov	r7, r1
    c66c:	4632      	mov	r2, r6
    c66e:	463b      	mov	r3, r7
    c670:	4620      	mov	r0, r4
    c672:	4629      	mov	r1, r5
    c674:	f001 f9c6 	bl	da04 <__aeabi_dmul>
    c678:	4602      	mov	r2, r0
    c67a:	460b      	mov	r3, r1
    c67c:	4630      	mov	r0, r6
    c67e:	4639      	mov	r1, r7
    c680:	4616      	mov	r6, r2
    c682:	461f      	mov	r7, r3
    c684:	2200      	movs	r2, #0
    c686:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    c68a:	f001 f803 	bl	d694 <__aeabi_dsub>
    c68e:	4602      	mov	r2, r0
    c690:	460b      	mov	r3, r1
    c692:	4630      	mov	r0, r6
    c694:	4639      	mov	r1, r7
    c696:	f001 fadf 	bl	dc58 <__aeabi_ddiv>
    c69a:	4642      	mov	r2, r8
    c69c:	4606      	mov	r6, r0
    c69e:	460f      	mov	r7, r1
    c6a0:	464b      	mov	r3, r9
    c6a2:	4620      	mov	r0, r4
    c6a4:	4629      	mov	r1, r5
    c6a6:	f001 f9ad 	bl	da04 <__aeabi_dmul>
    c6aa:	4642      	mov	r2, r8
    c6ac:	464b      	mov	r3, r9
    c6ae:	f000 fff3 	bl	d698 <__adddf3>
    c6b2:	4602      	mov	r2, r0
    c6b4:	460b      	mov	r3, r1
    c6b6:	4630      	mov	r0, r6
    c6b8:	4639      	mov	r1, r7
    c6ba:	f000 ffeb 	bl	d694 <__aeabi_dsub>
    c6be:	4622      	mov	r2, r4
    c6c0:	462b      	mov	r3, r5
    c6c2:	f000 ffe7 	bl	d694 <__aeabi_dsub>
    c6c6:	4602      	mov	r2, r0
    c6c8:	460b      	mov	r3, r1
    c6ca:	2000      	movs	r0, #0
    c6cc:	4946      	ldr	r1, [pc, #280]	; (c7e8 <__ieee754_pow+0x960>)
    c6ce:	f000 ffe1 	bl	d694 <__aeabi_dsub>
    c6d2:	9a02      	ldr	r2, [sp, #8]
    c6d4:	460b      	mov	r3, r1
    c6d6:	4413      	add	r3, r2
    c6d8:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    c6dc:	f2c0 8147 	blt.w	c96e <__ieee754_pow+0xae6>
    c6e0:	4619      	mov	r1, r3
    c6e2:	ec53 2b18 	vmov	r2, r3, d8
    c6e6:	f001 f98d 	bl	da04 <__aeabi_dmul>
    c6ea:	ec41 0b10 	vmov	d0, r0, r1
    c6ee:	f7ff bbe9 	b.w	bec4 <__ieee754_pow+0x3c>
    c6f2:	f1b8 0f00 	cmp.w	r8, #0
    c6f6:	f6ff ac27 	blt.w	bf48 <__ieee754_pow+0xc0>
    c6fa:	ec47 6b10 	vmov	d0, r6, r7
    c6fe:	b007      	add	sp, #28
    c700:	ecbd 8b0c 	vpop	{d8-d13}
    c704:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c708:	f000 b974 	b.w	c9f4 <__ieee754_sqrt>
    c70c:	f8df c0e0 	ldr.w	ip, [pc, #224]	; c7f0 <__ieee754_pow+0x968>
    c710:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
    c714:	4563      	cmp	r3, ip
    c716:	f340 80dd 	ble.w	c8d4 <__ieee754_pow+0xa4c>
    c71a:	4b34      	ldr	r3, [pc, #208]	; (c7ec <__ieee754_pow+0x964>)
    c71c:	440b      	add	r3, r1
    c71e:	4303      	orrs	r3, r0
    c720:	d10a      	bne.n	c738 <__ieee754_pow+0x8b0>
    c722:	4622      	mov	r2, r4
    c724:	462b      	mov	r3, r5
    c726:	f000 ffb5 	bl	d694 <__aeabi_dsub>
    c72a:	4632      	mov	r2, r6
    c72c:	463b      	mov	r3, r7
    c72e:	f001 fbef 	bl	df10 <__aeabi_dcmpge>
    c732:	2800      	cmp	r0, #0
    c734:	f43f aeec 	beq.w	c510 <__ieee754_pow+0x688>
    c738:	ec51 0b18 	vmov	r0, r1, d8
    c73c:	2200      	movs	r2, #0
    c73e:	2300      	movs	r3, #0
    c740:	f001 fbd2 	bl	dee8 <__aeabi_dcmplt>
    c744:	3800      	subs	r0, #0
    c746:	bf18      	it	ne
    c748:	2001      	movne	r0, #1
    c74a:	b007      	add	sp, #28
    c74c:	ecbd 8b0c 	vpop	{d8-d13}
    c750:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c754:	f000 be36 	b.w	d3c4 <__math_uflow>
    c758:	ed9f 7b1d 	vldr	d7, [pc, #116]	; c7d0 <__ieee754_pow+0x948>
    c75c:	eeb0 8a47 	vmov.f32	s16, s14
    c760:	eef0 8a67 	vmov.f32	s17, s15
    c764:	e67c      	b.n	c460 <__ieee754_pow+0x5d8>
    c766:	f1bb 0f00 	cmp.w	fp, #0
    c76a:	ed9f 0b1b 	vldr	d0, [pc, #108]	; c7d8 <__ieee754_pow+0x950>
    c76e:	f6bf aba9 	bge.w	bec4 <__ieee754_pow+0x3c>
    c772:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
    c776:	ee00 4a10 	vmov	s0, r4
    c77a:	ee00 3a90 	vmov	s1, r3
    c77e:	f7ff bba1 	b.w	bec4 <__ieee754_pow+0x3c>
    c782:	bf00      	nop
    c784:	f3af 8000 	nop.w
    c788:	652b82fe 	.word	0x652b82fe
    c78c:	3c971547 	.word	0x3c971547
    c790:	00000000 	.word	0x00000000
    c794:	3fe62e43 	.word	0x3fe62e43
    c798:	fefa39ef 	.word	0xfefa39ef
    c79c:	3fe62e42 	.word	0x3fe62e42
    c7a0:	0ca86c39 	.word	0x0ca86c39
    c7a4:	be205c61 	.word	0xbe205c61
    c7a8:	72bea4d0 	.word	0x72bea4d0
    c7ac:	3e663769 	.word	0x3e663769
    c7b0:	c5d26bf1 	.word	0xc5d26bf1
    c7b4:	3ebbbd41 	.word	0x3ebbbd41
    c7b8:	af25de2c 	.word	0xaf25de2c
    c7bc:	3f11566a 	.word	0x3f11566a
    c7c0:	16bebd93 	.word	0x16bebd93
    c7c4:	3f66c16c 	.word	0x3f66c16c
    c7c8:	5555553e 	.word	0x5555553e
    c7cc:	3fc55555 	.word	0x3fc55555
    c7d0:	00000000 	.word	0x00000000
    c7d4:	3ff00000 	.word	0x3ff00000
	...
    c7e0:	408fffff 	.word	0x408fffff
    c7e4:	fff00000 	.word	0xfff00000
    c7e8:	3ff00000 	.word	0x3ff00000
    c7ec:	3f6f3400 	.word	0x3f6f3400
    c7f0:	4090cbff 	.word	0x4090cbff
    c7f4:	4599      	cmp	r9, r3
    c7f6:	db75      	blt.n	c8e4 <__ieee754_pow+0xa5c>
    c7f8:	4b7b      	ldr	r3, [pc, #492]	; (c9e8 <__ieee754_pow+0xb60>)
    c7fa:	4599      	cmp	r9, r3
    c7fc:	f73f abc0 	bgt.w	bf80 <__ieee754_pow+0xf8>
    c800:	ec51 0b10 	vmov	r0, r1, d0
    c804:	4b78      	ldr	r3, [pc, #480]	; (c9e8 <__ieee754_pow+0xb60>)
    c806:	2200      	movs	r2, #0
    c808:	f000 ff44 	bl	d694 <__aeabi_dsub>
    c80c:	a366      	add	r3, pc, #408	; (adr r3, c9a8 <__ieee754_pow+0xb20>)
    c80e:	e9d3 2300 	ldrd	r2, r3, [r3]
    c812:	4606      	mov	r6, r0
    c814:	460f      	mov	r7, r1
    c816:	f001 f8f5 	bl	da04 <__aeabi_dmul>
    c81a:	a365      	add	r3, pc, #404	; (adr r3, c9b0 <__ieee754_pow+0xb28>)
    c81c:	e9d3 2300 	ldrd	r2, r3, [r3]
    c820:	4682      	mov	sl, r0
    c822:	468b      	mov	fp, r1
    c824:	4630      	mov	r0, r6
    c826:	4639      	mov	r1, r7
    c828:	f001 f8ec 	bl	da04 <__aeabi_dmul>
    c82c:	4b6f      	ldr	r3, [pc, #444]	; (c9ec <__ieee754_pow+0xb64>)
    c82e:	ec41 0b18 	vmov	d8, r0, r1
    c832:	2200      	movs	r2, #0
    c834:	4630      	mov	r0, r6
    c836:	4639      	mov	r1, r7
    c838:	f001 f8e4 	bl	da04 <__aeabi_dmul>
    c83c:	4602      	mov	r2, r0
    c83e:	460b      	mov	r3, r1
    c840:	a15d      	add	r1, pc, #372	; (adr r1, c9b8 <__ieee754_pow+0xb30>)
    c842:	e9d1 0100 	ldrd	r0, r1, [r1]
    c846:	f000 ff25 	bl	d694 <__aeabi_dsub>
    c84a:	4632      	mov	r2, r6
    c84c:	463b      	mov	r3, r7
    c84e:	f001 f8d9 	bl	da04 <__aeabi_dmul>
    c852:	4602      	mov	r2, r0
    c854:	460b      	mov	r3, r1
    c856:	2000      	movs	r0, #0
    c858:	4965      	ldr	r1, [pc, #404]	; (c9f0 <__ieee754_pow+0xb68>)
    c85a:	f000 ff1b 	bl	d694 <__aeabi_dsub>
    c85e:	4632      	mov	r2, r6
    c860:	4680      	mov	r8, r0
    c862:	4689      	mov	r9, r1
    c864:	463b      	mov	r3, r7
    c866:	4630      	mov	r0, r6
    c868:	4639      	mov	r1, r7
    c86a:	f001 f8cb 	bl	da04 <__aeabi_dmul>
    c86e:	4602      	mov	r2, r0
    c870:	460b      	mov	r3, r1
    c872:	4640      	mov	r0, r8
    c874:	4649      	mov	r1, r9
    c876:	f001 f8c5 	bl	da04 <__aeabi_dmul>
    c87a:	a351      	add	r3, pc, #324	; (adr r3, c9c0 <__ieee754_pow+0xb38>)
    c87c:	e9d3 2300 	ldrd	r2, r3, [r3]
    c880:	f001 f8c0 	bl	da04 <__aeabi_dmul>
    c884:	4602      	mov	r2, r0
    c886:	460b      	mov	r3, r1
    c888:	ec51 0b18 	vmov	r0, r1, d8
    c88c:	f000 ff02 	bl	d694 <__aeabi_dsub>
    c890:	4680      	mov	r8, r0
    c892:	4689      	mov	r9, r1
    c894:	4642      	mov	r2, r8
    c896:	464b      	mov	r3, r9
    c898:	4650      	mov	r0, sl
    c89a:	4659      	mov	r1, fp
    c89c:	f000 fefc 	bl	d698 <__adddf3>
    c8a0:	2000      	movs	r0, #0
    c8a2:	4652      	mov	r2, sl
    c8a4:	465b      	mov	r3, fp
    c8a6:	4606      	mov	r6, r0
    c8a8:	460f      	mov	r7, r1
    c8aa:	e585      	b.n	c3b8 <__ieee754_pow+0x530>
    c8ac:	494e      	ldr	r1, [pc, #312]	; (c9e8 <__ieee754_pow+0xb60>)
    c8ae:	2000      	movs	r0, #0
    c8b0:	4632      	mov	r2, r6
    c8b2:	463b      	mov	r3, r7
    c8b4:	f001 f9d0 	bl	dc58 <__aeabi_ddiv>
    c8b8:	ec41 0b10 	vmov	d0, r0, r1
    c8bc:	f7ff bb02 	b.w	bec4 <__ieee754_pow+0x3c>
    c8c0:	4632      	mov	r2, r6
    c8c2:	463b      	mov	r3, r7
    c8c4:	4630      	mov	r0, r6
    c8c6:	4639      	mov	r1, r7
    c8c8:	f001 f89c 	bl	da04 <__aeabi_dmul>
    c8cc:	ec41 0b10 	vmov	d0, r0, r1
    c8d0:	f7ff baf8 	b.w	bec4 <__ieee754_pow+0x3c>
    c8d4:	4a46      	ldr	r2, [pc, #280]	; (c9f0 <__ieee754_pow+0xb68>)
    c8d6:	4293      	cmp	r3, r2
    c8d8:	dc62      	bgt.n	c9a0 <__ieee754_pow+0xb18>
    c8da:	e9dd 1200 	ldrd	r1, r2, [sp]
    c8de:	9102      	str	r1, [sp, #8]
    c8e0:	9100      	str	r1, [sp, #0]
    c8e2:	e649      	b.n	c578 <__ieee754_pow+0x6f0>
    c8e4:	f1bb 0f00 	cmp.w	fp, #0
    c8e8:	f6ff ab4e 	blt.w	bf88 <__ieee754_pow+0x100>
    c8ec:	2000      	movs	r0, #0
    c8ee:	e72c      	b.n	c74a <__ieee754_pow+0x8c2>
    c8f0:	2b00      	cmp	r3, #0
    c8f2:	f47f ab54 	bne.w	bf9e <__ieee754_pow+0x116>
    c8f6:	f1c1 0114 	rsb	r1, r1, #20
    c8fa:	fa4a f001 	asr.w	r0, sl, r1
    c8fe:	fa00 f101 	lsl.w	r1, r0, r1
    c902:	4551      	cmp	r1, sl
    c904:	d045      	beq.n	c992 <__ieee754_pow+0xb0a>
    c906:	9300      	str	r3, [sp, #0]
    c908:	f7ff bb12 	b.w	bf30 <__ieee754_pow+0xa8>
    c90c:	9b00      	ldr	r3, [sp, #0]
    c90e:	2b01      	cmp	r3, #1
    c910:	f47f aad8 	bne.w	bec4 <__ieee754_pow+0x3c>
    c914:	ee10 1a90 	vmov	r1, s1
    c918:	ee10 2a10 	vmov	r2, s0
    c91c:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
    c920:	ec43 2b10 	vmov	d0, r2, r3
    c924:	f7ff bace 	b.w	bec4 <__ieee754_pow+0x3c>
    c928:	ed9f 0b27 	vldr	d0, [pc, #156]	; c9c8 <__ieee754_pow+0xb40>
    c92c:	f7ff baca 	b.w	bec4 <__ieee754_pow+0x3c>
    c930:	ed9f 7b27 	vldr	d7, [pc, #156]	; c9d0 <__ieee754_pow+0xb48>
    c934:	eeb0 ca47 	vmov.f32	s24, s14
    c938:	eef0 ca67 	vmov.f32	s25, s15
    c93c:	ed9f 7b26 	vldr	d7, [pc, #152]	; c9d8 <__ieee754_pow+0xb50>
    c940:	eeb0 da47 	vmov.f32	s26, s14
    c944:	eef0 da67 	vmov.f32	s27, s15
    c948:	ed9f 7b25 	vldr	d7, [pc, #148]	; c9e0 <__ieee754_pow+0xb58>
    c94c:	f44f 2780 	mov.w	r7, #262144	; 0x40000
    c950:	ec51 0b17 	vmov	r0, r1, d7
    c954:	f7ff bbe4 	b.w	c120 <__ieee754_pow+0x298>
    c958:	ec51 0b18 	vmov	r0, r1, d8
    c95c:	2200      	movs	r2, #0
    c95e:	2300      	movs	r3, #0
    c960:	f001 fac2 	bl	dee8 <__aeabi_dcmplt>
    c964:	3800      	subs	r0, #0
    c966:	bf18      	it	ne
    c968:	2001      	movne	r0, #1
    c96a:	f7ff bb0e 	b.w	bf8a <__ieee754_pow+0x102>
    c96e:	ec41 0b10 	vmov	d0, r0, r1
    c972:	9800      	ldr	r0, [sp, #0]
    c974:	f000 fe08 	bl	d588 <scalbn>
    c978:	ec51 0b10 	vmov	r0, r1, d0
    c97c:	e6b1      	b.n	c6e2 <__ieee754_pow+0x85a>
    c97e:	f000 0001 	and.w	r0, r0, #1
    c982:	f1c0 0102 	rsb	r1, r0, #2
    c986:	9100      	str	r1, [sp, #0]
    c988:	2b00      	cmp	r3, #0
    c98a:	f43f aad1 	beq.w	bf30 <__ieee754_pow+0xa8>
    c98e:	f7ff badb 	b.w	bf48 <__ieee754_pow+0xc0>
    c992:	f000 0001 	and.w	r0, r0, #1
    c996:	f1c0 0302 	rsb	r3, r0, #2
    c99a:	9300      	str	r3, [sp, #0]
    c99c:	f7ff bac8 	b.w	bf30 <__ieee754_pow+0xa8>
    c9a0:	151b      	asrs	r3, r3, #20
    c9a2:	e5b7      	b.n	c514 <__ieee754_pow+0x68c>
    c9a4:	f3af 8000 	nop.w
    c9a8:	60000000 	.word	0x60000000
    c9ac:	3ff71547 	.word	0x3ff71547
    c9b0:	f85ddf44 	.word	0xf85ddf44
    c9b4:	3e54ae0b 	.word	0x3e54ae0b
    c9b8:	55555555 	.word	0x55555555
    c9bc:	3fd55555 	.word	0x3fd55555
    c9c0:	652b82fe 	.word	0x652b82fe
    c9c4:	3ff71547 	.word	0x3ff71547
	...
    c9d0:	40000000 	.word	0x40000000
    c9d4:	3fe2b803 	.word	0x3fe2b803
    c9d8:	43cfd006 	.word	0x43cfd006
    c9dc:	3e4cfdeb 	.word	0x3e4cfdeb
    c9e0:	00000000 	.word	0x00000000
    c9e4:	3ff80000 	.word	0x3ff80000
    c9e8:	3ff00000 	.word	0x3ff00000
    c9ec:	3fd00000 	.word	0x3fd00000
    c9f0:	3fe00000 	.word	0x3fe00000

0000c9f4 <__ieee754_sqrt>:
    c9f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c9f8:	4a62      	ldr	r2, [pc, #392]	; (cb84 <__ieee754_sqrt+0x190>)
    c9fa:	ec55 4b10 	vmov	r4, r5, d0
    c9fe:	43aa      	bics	r2, r5
    ca00:	f000 809c 	beq.w	cb3c <__ieee754_sqrt+0x148>
    ca04:	2d00      	cmp	r5, #0
    ca06:	ee10 ca10 	vmov	ip, s0
    ca0a:	462b      	mov	r3, r5
    ca0c:	dd55      	ble.n	caba <__ieee754_sqrt+0xc6>
    ca0e:	1529      	asrs	r1, r5, #20
    ca10:	d063      	beq.n	cada <__ieee754_sqrt+0xe6>
    ca12:	f3c3 0213 	ubfx	r2, r3, #0, #20
    ca16:	f2a1 37ff 	subw	r7, r1, #1023	; 0x3ff
    ca1a:	07c9      	lsls	r1, r1, #31
    ca1c:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    ca20:	d405      	bmi.n	ca2e <__ieee754_sqrt+0x3a>
    ca22:	ea4f 73dc 	mov.w	r3, ip, lsr #31
    ca26:	eb03 0242 	add.w	r2, r3, r2, lsl #1
    ca2a:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    ca2e:	ea4f 73dc 	mov.w	r3, ip, lsr #31
    ca32:	2600      	movs	r6, #0
    ca34:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    ca38:	107f      	asrs	r7, r7, #1
    ca3a:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    ca3e:	f04f 0e16 	mov.w	lr, #22
    ca42:	4634      	mov	r4, r6
    ca44:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    ca48:	18a1      	adds	r1, r4, r2
    ca4a:	4299      	cmp	r1, r3
    ca4c:	ea4f 70dc 	mov.w	r0, ip, lsr #31
    ca50:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    ca54:	dc02      	bgt.n	ca5c <__ieee754_sqrt+0x68>
    ca56:	188c      	adds	r4, r1, r2
    ca58:	1a5b      	subs	r3, r3, r1
    ca5a:	4416      	add	r6, r2
    ca5c:	f1be 0e01 	subs.w	lr, lr, #1
    ca60:	eb00 0343 	add.w	r3, r0, r3, lsl #1
    ca64:	ea4f 0252 	mov.w	r2, r2, lsr #1
    ca68:	d1ee      	bne.n	ca48 <__ieee754_sqrt+0x54>
    ca6a:	4675      	mov	r5, lr
    ca6c:	2020      	movs	r0, #32
    ca6e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    ca72:	e009      	b.n	ca88 <__ieee754_sqrt+0x94>
    ca74:	d042      	beq.n	cafc <__ieee754_sqrt+0x108>
    ca76:	005b      	lsls	r3, r3, #1
    ca78:	3801      	subs	r0, #1
    ca7a:	eb03 73dc 	add.w	r3, r3, ip, lsr #31
    ca7e:	ea4f 0252 	mov.w	r2, r2, lsr #1
    ca82:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    ca86:	d042      	beq.n	cb0e <__ieee754_sqrt+0x11a>
    ca88:	42a3      	cmp	r3, r4
    ca8a:	eb02 010e 	add.w	r1, r2, lr
    ca8e:	ddf1      	ble.n	ca74 <__ieee754_sqrt+0x80>
    ca90:	2900      	cmp	r1, #0
    ca92:	eb01 0e02 	add.w	lr, r1, r2
    ca96:	db0a      	blt.n	caae <__ieee754_sqrt+0xba>
    ca98:	46a0      	mov	r8, r4
    ca9a:	1b1b      	subs	r3, r3, r4
    ca9c:	4561      	cmp	r1, ip
    ca9e:	bf88      	it	hi
    caa0:	f103 33ff 	addhi.w	r3, r3, #4294967295
    caa4:	ebac 0c01 	sub.w	ip, ip, r1
    caa8:	4415      	add	r5, r2
    caaa:	4644      	mov	r4, r8
    caac:	e7e3      	b.n	ca76 <__ieee754_sqrt+0x82>
    caae:	f1be 0f00 	cmp.w	lr, #0
    cab2:	dbf1      	blt.n	ca98 <__ieee754_sqrt+0xa4>
    cab4:	f104 0801 	add.w	r8, r4, #1
    cab8:	e7ef      	b.n	ca9a <__ieee754_sqrt+0xa6>
    caba:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
    cabe:	4322      	orrs	r2, r4
    cac0:	d03a      	beq.n	cb38 <__ieee754_sqrt+0x144>
    cac2:	2d00      	cmp	r5, #0
    cac4:	d14a      	bne.n	cb5c <__ieee754_sqrt+0x168>
    cac6:	4629      	mov	r1, r5
    cac8:	ea4f 23dc 	mov.w	r3, ip, lsr #11
    cacc:	3915      	subs	r1, #21
    cace:	ea4f 5c4c 	mov.w	ip, ip, lsl #21
    cad2:	2b00      	cmp	r3, #0
    cad4:	d0f8      	beq.n	cac8 <__ieee754_sqrt+0xd4>
    cad6:	02dd      	lsls	r5, r3, #11
    cad8:	d44f      	bmi.n	cb7a <__ieee754_sqrt+0x186>
    cada:	2200      	movs	r2, #0
    cadc:	005b      	lsls	r3, r3, #1
    cade:	02dc      	lsls	r4, r3, #11
    cae0:	4610      	mov	r0, r2
    cae2:	f102 0201 	add.w	r2, r2, #1
    cae6:	d5f9      	bpl.n	cadc <__ieee754_sqrt+0xe8>
    cae8:	4664      	mov	r4, ip
    caea:	fa0c fc02 	lsl.w	ip, ip, r2
    caee:	f1c2 0220 	rsb	r2, r2, #32
    caf2:	fa24 f202 	lsr.w	r2, r4, r2
    caf6:	1a09      	subs	r1, r1, r0
    caf8:	4313      	orrs	r3, r2
    cafa:	e78a      	b.n	ca12 <__ieee754_sqrt+0x1e>
    cafc:	4561      	cmp	r1, ip
    cafe:	d8ba      	bhi.n	ca76 <__ieee754_sqrt+0x82>
    cb00:	2900      	cmp	r1, #0
    cb02:	eb01 0e02 	add.w	lr, r1, r2
    cb06:	dbd2      	blt.n	caae <__ieee754_sqrt+0xba>
    cb08:	4698      	mov	r8, r3
    cb0a:	2300      	movs	r3, #0
    cb0c:	e7ca      	b.n	caa4 <__ieee754_sqrt+0xb0>
    cb0e:	ea53 030c 	orrs.w	r3, r3, ip
    cb12:	d002      	beq.n	cb1a <__ieee754_sqrt+0x126>
    cb14:	1c6a      	adds	r2, r5, #1
    cb16:	d02e      	beq.n	cb76 <__ieee754_sqrt+0x182>
    cb18:	3501      	adds	r5, #1
    cb1a:	0868      	lsrs	r0, r5, #1
    cb1c:	1071      	asrs	r1, r6, #1
    cb1e:	07f3      	lsls	r3, r6, #31
    cb20:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
    cb24:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
    cb28:	bf48      	it	mi
    cb2a:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
    cb2e:	eb01 5307 	add.w	r3, r1, r7, lsl #20
    cb32:	4602      	mov	r2, r0
    cb34:	ec43 2b10 	vmov	d0, r2, r3
    cb38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    cb3c:	ee10 2a10 	vmov	r2, s0
    cb40:	ee10 0a10 	vmov	r0, s0
    cb44:	462b      	mov	r3, r5
    cb46:	4629      	mov	r1, r5
    cb48:	f000 ff5c 	bl	da04 <__aeabi_dmul>
    cb4c:	4622      	mov	r2, r4
    cb4e:	462b      	mov	r3, r5
    cb50:	f000 fda2 	bl	d698 <__adddf3>
    cb54:	ec41 0b10 	vmov	d0, r0, r1
    cb58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    cb5c:	ee10 2a10 	vmov	r2, s0
    cb60:	4620      	mov	r0, r4
    cb62:	4629      	mov	r1, r5
    cb64:	f000 fd96 	bl	d694 <__aeabi_dsub>
    cb68:	4602      	mov	r2, r0
    cb6a:	460b      	mov	r3, r1
    cb6c:	f001 f874 	bl	dc58 <__aeabi_ddiv>
    cb70:	ec41 0b10 	vmov	d0, r0, r1
    cb74:	e7e0      	b.n	cb38 <__ieee754_sqrt+0x144>
    cb76:	3601      	adds	r6, #1
    cb78:	e7d0      	b.n	cb1c <__ieee754_sqrt+0x128>
    cb7a:	4664      	mov	r4, ip
    cb7c:	2220      	movs	r2, #32
    cb7e:	f04f 30ff 	mov.w	r0, #4294967295
    cb82:	e7b6      	b.n	caf2 <__ieee754_sqrt+0xfe>
    cb84:	7ff00000 	.word	0x7ff00000

0000cb88 <__kernel_cosf>:
    cb88:	ee10 3a10 	vmov	r3, s0
    cb8c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    cb90:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
    cb94:	da2c      	bge.n	cbf0 <__kernel_cosf+0x68>
    cb96:	eefd 7ac0 	vcvt.s32.f32	s15, s0
    cb9a:	ee17 3a90 	vmov	r3, s15
    cb9e:	2b00      	cmp	r3, #0
    cba0:	d060      	beq.n	cc64 <__kernel_cosf+0xdc>
    cba2:	ee20 7a00 	vmul.f32	s14, s0, s0
    cba6:	eddf 7a31 	vldr	s15, [pc, #196]	; cc6c <__kernel_cosf+0xe4>
    cbaa:	ed9f 5a31 	vldr	s10, [pc, #196]	; cc70 <__kernel_cosf+0xe8>
    cbae:	eddf 5a31 	vldr	s11, [pc, #196]	; cc74 <__kernel_cosf+0xec>
    cbb2:	ed9f 6a31 	vldr	s12, [pc, #196]	; cc78 <__kernel_cosf+0xf0>
    cbb6:	eddf 6a31 	vldr	s13, [pc, #196]	; cc7c <__kernel_cosf+0xf4>
    cbba:	eea7 5a27 	vfma.f32	s10, s14, s15
    cbbe:	eddf 7a30 	vldr	s15, [pc, #192]	; cc80 <__kernel_cosf+0xf8>
    cbc2:	eee7 5a05 	vfma.f32	s11, s14, s10
    cbc6:	eea7 6a25 	vfma.f32	s12, s14, s11
    cbca:	eee7 7a06 	vfma.f32	s15, s14, s12
    cbce:	eee7 6a27 	vfma.f32	s13, s14, s15
    cbd2:	ee67 6a26 	vmul.f32	s13, s14, s13
    cbd6:	ee60 0ac0 	vnmul.f32	s1, s1, s0
    cbda:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    cbde:	eee7 0a26 	vfma.f32	s1, s14, s13
    cbe2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    cbe6:	eed7 0a27 	vfnms.f32	s1, s14, s15
    cbea:	ee30 0a60 	vsub.f32	s0, s0, s1
    cbee:	4770      	bx	lr
    cbf0:	ee20 7a00 	vmul.f32	s14, s0, s0
    cbf4:	eddf 7a1d 	vldr	s15, [pc, #116]	; cc6c <__kernel_cosf+0xe4>
    cbf8:	ed9f 5a1d 	vldr	s10, [pc, #116]	; cc70 <__kernel_cosf+0xe8>
    cbfc:	eddf 5a1d 	vldr	s11, [pc, #116]	; cc74 <__kernel_cosf+0xec>
    cc00:	ed9f 6a1d 	vldr	s12, [pc, #116]	; cc78 <__kernel_cosf+0xf0>
    cc04:	eddf 6a1d 	vldr	s13, [pc, #116]	; cc7c <__kernel_cosf+0xf4>
    cc08:	4a1e      	ldr	r2, [pc, #120]	; (cc84 <__kernel_cosf+0xfc>)
    cc0a:	eea7 5a27 	vfma.f32	s10, s14, s15
    cc0e:	4293      	cmp	r3, r2
    cc10:	eddf 7a1b 	vldr	s15, [pc, #108]	; cc80 <__kernel_cosf+0xf8>
    cc14:	eee5 5a07 	vfma.f32	s11, s10, s14
    cc18:	eea5 6a87 	vfma.f32	s12, s11, s14
    cc1c:	eee6 7a07 	vfma.f32	s15, s12, s14
    cc20:	eee7 6a87 	vfma.f32	s13, s15, s14
    cc24:	ee66 6a87 	vmul.f32	s13, s13, s14
    cc28:	ddd5      	ble.n	cbd6 <__kernel_cosf+0x4e>
    cc2a:	4a17      	ldr	r2, [pc, #92]	; (cc88 <__kernel_cosf+0x100>)
    cc2c:	4293      	cmp	r3, r2
    cc2e:	dc14      	bgt.n	cc5a <__kernel_cosf+0xd2>
    cc30:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
    cc34:	ee07 3a90 	vmov	s15, r3
    cc38:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    cc3c:	ee36 6a67 	vsub.f32	s12, s12, s15
    cc40:	ee60 0ac0 	vnmul.f32	s1, s1, s0
    cc44:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
    cc48:	eed7 7a25 	vfnms.f32	s15, s14, s11
    cc4c:	eee7 0a26 	vfma.f32	s1, s14, s13
    cc50:	ee77 7ae0 	vsub.f32	s15, s15, s1
    cc54:	ee36 0a67 	vsub.f32	s0, s12, s15
    cc58:	4770      	bx	lr
    cc5a:	eeb6 6a07 	vmov.f32	s12, #103	; 0x3f380000  0.7187500
    cc5e:	eef5 7a02 	vmov.f32	s15, #82	; 0x3e900000  0.2812500
    cc62:	e7ed      	b.n	cc40 <__kernel_cosf+0xb8>
    cc64:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    cc68:	4770      	bx	lr
    cc6a:	bf00      	nop
    cc6c:	ad47d74e 	.word	0xad47d74e
    cc70:	310f74f6 	.word	0x310f74f6
    cc74:	b493f27c 	.word	0xb493f27c
    cc78:	37d00d01 	.word	0x37d00d01
    cc7c:	3d2aaaab 	.word	0x3d2aaaab
    cc80:	bab60b61 	.word	0xbab60b61
    cc84:	3e999999 	.word	0x3e999999
    cc88:	3f480000 	.word	0x3f480000

0000cc8c <__kernel_rem_pio2f>:
    cc8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cc90:	ed2d 8b04 	vpush	{d8-d9}
    cc94:	b0db      	sub	sp, #364	; 0x16c
    cc96:	461c      	mov	r4, r3
    cc98:	9303      	str	r3, [sp, #12]
    cc9a:	9106      	str	r1, [sp, #24]
    cc9c:	4ba2      	ldr	r3, [pc, #648]	; (cf28 <__kernel_rem_pio2f+0x29c>)
    cc9e:	9968      	ldr	r1, [sp, #416]	; 0x1a0
    cca0:	9208      	str	r2, [sp, #32]
    cca2:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
    cca6:	1d11      	adds	r1, r2, #4
    cca8:	4682      	mov	sl, r0
    ccaa:	f104 38ff 	add.w	r8, r4, #4294967295
    ccae:	f2c0 829e 	blt.w	d1ee <__kernel_rem_pio2f+0x562>
    ccb2:	1ed3      	subs	r3, r2, #3
    ccb4:	bf48      	it	mi
    ccb6:	1d13      	addmi	r3, r2, #4
    ccb8:	10db      	asrs	r3, r3, #3
    ccba:	9302      	str	r3, [sp, #8]
    ccbc:	3301      	adds	r3, #1
    ccbe:	00db      	lsls	r3, r3, #3
    ccc0:	9307      	str	r3, [sp, #28]
    ccc2:	e9dd 2307 	ldrd	r2, r3, [sp, #28]
    ccc6:	1a9b      	subs	r3, r3, r2
    ccc8:	9305      	str	r3, [sp, #20]
    ccca:	9b02      	ldr	r3, [sp, #8]
    cccc:	eb15 0108 	adds.w	r1, r5, r8
    ccd0:	eba3 0308 	sub.w	r3, r3, r8
    ccd4:	d416      	bmi.n	cd04 <__kernel_rem_pio2f+0x78>
    ccd6:	3101      	adds	r1, #1
    ccd8:	ed9f 7a94 	vldr	s14, [pc, #592]	; cf2c <__kernel_rem_pio2f+0x2a0>
    ccdc:	9869      	ldr	r0, [sp, #420]	; 0x1a4
    ccde:	4419      	add	r1, r3
    cce0:	aa1e      	add	r2, sp, #120	; 0x78
    cce2:	2b00      	cmp	r3, #0
    cce4:	bfa4      	itt	ge
    cce6:	f850 4023 	ldrge.w	r4, [r0, r3, lsl #2]
    ccea:	ee07 4a90 	vmovge	s15, r4
    ccee:	f103 0301 	add.w	r3, r3, #1
    ccf2:	bfac      	ite	ge
    ccf4:	eef8 7ae7 	vcvtge.f32.s32	s15, s15
    ccf8:	eef0 7a47 	vmovlt.f32	s15, s14
    ccfc:	428b      	cmp	r3, r1
    ccfe:	ece2 7a01 	vstmia	r2!, {s15}
    cd02:	d1ee      	bne.n	cce2 <__kernel_rem_pio2f+0x56>
    cd04:	2d00      	cmp	r5, #0
    cd06:	f2c0 82e1 	blt.w	d2cc <__kernel_rem_pio2f+0x640>
    cd0a:	9b03      	ldr	r3, [sp, #12]
    cd0c:	aa1e      	add	r2, sp, #120	; 0x78
    cd0e:	eb02 0483 	add.w	r4, r2, r3, lsl #2
    cd12:	ae46      	add	r6, sp, #280	; 0x118
    cd14:	ea4f 0c83 	mov.w	ip, r3, lsl #2
    cd18:	4640      	mov	r0, r8
    cd1a:	18ef      	adds	r7, r5, r3
    cd1c:	eb0a 0183 	add.w	r1, sl, r3, lsl #2
    cd20:	f1b8 0f00 	cmp.w	r8, #0
    cd24:	eddf 7a81 	vldr	s15, [pc, #516]	; cf2c <__kernel_rem_pio2f+0x2a0>
    cd28:	db09      	blt.n	cd3e <__kernel_rem_pio2f+0xb2>
    cd2a:	4622      	mov	r2, r4
    cd2c:	4653      	mov	r3, sl
    cd2e:	ecf3 6a01 	vldmia	r3!, {s13}
    cd32:	ed32 7a01 	vldmdb	r2!, {s14}
    cd36:	428b      	cmp	r3, r1
    cd38:	eee6 7a87 	vfma.f32	s15, s13, s14
    cd3c:	d1f7      	bne.n	cd2e <__kernel_rem_pio2f+0xa2>
    cd3e:	3001      	adds	r0, #1
    cd40:	42b8      	cmp	r0, r7
    cd42:	ece6 7a01 	vstmia	r6!, {s15}
    cd46:	f104 0404 	add.w	r4, r4, #4
    cd4a:	d1e9      	bne.n	cd20 <__kernel_rem_pio2f+0x94>
    cd4c:	ab09      	add	r3, sp, #36	; 0x24
    cd4e:	af0a      	add	r7, sp, #40	; 0x28
    cd50:	eb03 0985 	add.w	r9, r3, r5, lsl #2
    cd54:	eb07 0385 	add.w	r3, r7, r5, lsl #2
    cd58:	3b08      	subs	r3, #8
    cd5a:	ed9f 9a76 	vldr	s18, [pc, #472]	; cf34 <__kernel_rem_pio2f+0x2a8>
    cd5e:	eddf 8a74 	vldr	s17, [pc, #464]	; cf30 <__kernel_rem_pio2f+0x2a4>
    cd62:	9805      	ldr	r0, [sp, #20]
    cd64:	9304      	str	r3, [sp, #16]
    cd66:	eb0a 040c 	add.w	r4, sl, ip
    cd6a:	ae46      	add	r6, sp, #280	; 0x118
    cd6c:	9500      	str	r5, [sp, #0]
    cd6e:	ab5a      	add	r3, sp, #360	; 0x168
    cd70:	eb03 0385 	add.w	r3, r3, r5, lsl #2
    cd74:	2d00      	cmp	r5, #0
    cd76:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
    cd7a:	ea4f 0b85 	mov.w	fp, r5, lsl #2
    cd7e:	dd16      	ble.n	cdae <__kernel_rem_pio2f+0x122>
    cd80:	eb06 0385 	add.w	r3, r6, r5, lsl #2
    cd84:	463a      	mov	r2, r7
    cd86:	ee60 7a09 	vmul.f32	s15, s0, s18
    cd8a:	eeb0 7a40 	vmov.f32	s14, s0
    cd8e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    cd92:	ed73 6a01 	vldmdb	r3!, {s13}
    cd96:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    cd9a:	42b3      	cmp	r3, r6
    cd9c:	eea7 7ae8 	vfms.f32	s14, s15, s17
    cda0:	ee37 0aa6 	vadd.f32	s0, s15, s13
    cda4:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    cda8:	eca2 7a01 	vstmia	r2!, {s14}
    cdac:	d1eb      	bne.n	cd86 <__kernel_rem_pio2f+0xfa>
    cdae:	9001      	str	r0, [sp, #4]
    cdb0:	f000 fb7a 	bl	d4a8 <scalbnf>
    cdb4:	eeb0 8a40 	vmov.f32	s16, s0
    cdb8:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
    cdbc:	ee28 0a00 	vmul.f32	s0, s16, s0
    cdc0:	f000 fb1e 	bl	d400 <floorf>
    cdc4:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    cdc8:	eea0 8a67 	vfms.f32	s16, s0, s15
    cdcc:	9801      	ldr	r0, [sp, #4]
    cdce:	2800      	cmp	r0, #0
    cdd0:	eefd 9ac8 	vcvt.s32.f32	s19, s16
    cdd4:	eef8 7ae9 	vcvt.f32.s32	s15, s19
    cdd8:	ee38 8a67 	vsub.f32	s16, s16, s15
    cddc:	dd79      	ble.n	ced2 <__kernel_rem_pio2f+0x246>
    cdde:	f105 3eff 	add.w	lr, r5, #4294967295
    cde2:	f1c0 0308 	rsb	r3, r0, #8
    cde6:	f857 202e 	ldr.w	r2, [r7, lr, lsl #2]
    cdea:	fa42 fc03 	asr.w	ip, r2, r3
    cdee:	fa0c f303 	lsl.w	r3, ip, r3
    cdf2:	1ad3      	subs	r3, r2, r3
    cdf4:	f1c0 0107 	rsb	r1, r0, #7
    cdf8:	ee19 2a90 	vmov	r2, s19
    cdfc:	f847 302e 	str.w	r3, [r7, lr, lsl #2]
    ce00:	410b      	asrs	r3, r1
    ce02:	4462      	add	r2, ip
    ce04:	2b00      	cmp	r3, #0
    ce06:	ee09 2a90 	vmov	s19, r2
    ce0a:	dc6a      	bgt.n	cee2 <__kernel_rem_pio2f+0x256>
    ce0c:	eeb5 8a40 	vcmp.f32	s16, #0.0
    ce10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ce14:	f040 80c1 	bne.w	cf9a <__kernel_rem_pio2f+0x30e>
    ce18:	9a00      	ldr	r2, [sp, #0]
    ce1a:	f105 3bff 	add.w	fp, r5, #4294967295
    ce1e:	455a      	cmp	r2, fp
    ce20:	dc11      	bgt.n	ce46 <__kernel_rem_pio2f+0x1ba>
    ce22:	f105 4280 	add.w	r2, r5, #1073741824	; 0x40000000
    ce26:	3a01      	subs	r2, #1
    ce28:	ea4f 0c82 	mov.w	ip, r2, lsl #2
    ce2c:	2100      	movs	r1, #0
    ce2e:	eb07 0282 	add.w	r2, r7, r2, lsl #2
    ce32:	469e      	mov	lr, r3
    ce34:	f852 3904 	ldr.w	r3, [r2], #-4
    ce38:	454a      	cmp	r2, r9
    ce3a:	ea41 0103 	orr.w	r1, r1, r3
    ce3e:	d1f9      	bne.n	ce34 <__kernel_rem_pio2f+0x1a8>
    ce40:	2900      	cmp	r1, #0
    ce42:	f040 80f1 	bne.w	d028 <__kernel_rem_pio2f+0x39c>
    ce46:	9b00      	ldr	r3, [sp, #0]
    ce48:	3b01      	subs	r3, #1
    ce4a:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
    ce4e:	2b00      	cmp	r3, #0
    ce50:	f040 80e6 	bne.w	d020 <__kernel_rem_pio2f+0x394>
    ce54:	9b04      	ldr	r3, [sp, #16]
    ce56:	f04f 0c01 	mov.w	ip, #1
    ce5a:	f853 2904 	ldr.w	r2, [r3], #-4
    ce5e:	f10c 0c01 	add.w	ip, ip, #1
    ce62:	2a00      	cmp	r2, #0
    ce64:	d0f9      	beq.n	ce5a <__kernel_rem_pio2f+0x1ce>
    ce66:	1c6b      	adds	r3, r5, #1
    ce68:	44ac      	add	ip, r5
    ce6a:	469e      	mov	lr, r3
    ce6c:	9902      	ldr	r1, [sp, #8]
    ce6e:	9a03      	ldr	r2, [sp, #12]
    ce70:	eb01 0b03 	add.w	fp, r1, r3
    ce74:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
    ce78:	9969      	ldr	r1, [sp, #420]	; 0x1a4
    ce7a:	442a      	add	r2, r5
    ce7c:	f10b 3bff 	add.w	fp, fp, #4294967295
    ce80:	eb06 0583 	add.w	r5, r6, r3, lsl #2
    ce84:	ab1e      	add	r3, sp, #120	; 0x78
    ce86:	eb01 0b8b 	add.w	fp, r1, fp, lsl #2
    ce8a:	eb03 0182 	add.w	r1, r3, r2, lsl #2
    ce8e:	eddb 7a01 	vldr	s15, [fp, #4]
    ce92:	ed9f 7a26 	vldr	s14, [pc, #152]	; cf2c <__kernel_rem_pio2f+0x2a0>
    ce96:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    ce9a:	f1b8 0f00 	cmp.w	r8, #0
    ce9e:	f10b 0b04 	add.w	fp, fp, #4
    cea2:	edc1 7a00 	vstr	s15, [r1]
    cea6:	460a      	mov	r2, r1
    cea8:	f101 0104 	add.w	r1, r1, #4
    ceac:	db09      	blt.n	cec2 <__kernel_rem_pio2f+0x236>
    ceae:	4653      	mov	r3, sl
    ceb0:	e001      	b.n	ceb6 <__kernel_rem_pio2f+0x22a>
    ceb2:	ed72 7a01 	vldmdb	r2!, {s15}
    ceb6:	ecf3 6a01 	vldmia	r3!, {s13}
    ceba:	42a3      	cmp	r3, r4
    cebc:	eea6 7aa7 	vfma.f32	s14, s13, s15
    cec0:	d1f7      	bne.n	ceb2 <__kernel_rem_pio2f+0x226>
    cec2:	f10e 0e01 	add.w	lr, lr, #1
    cec6:	45e6      	cmp	lr, ip
    cec8:	eca5 7a01 	vstmia	r5!, {s14}
    cecc:	dddf      	ble.n	ce8e <__kernel_rem_pio2f+0x202>
    cece:	4665      	mov	r5, ip
    ced0:	e74d      	b.n	cd6e <__kernel_rem_pio2f+0xe2>
    ced2:	f040 809b 	bne.w	d00c <__kernel_rem_pio2f+0x380>
    ced6:	1e6b      	subs	r3, r5, #1
    ced8:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
    cedc:	11db      	asrs	r3, r3, #7
    cede:	2b00      	cmp	r3, #0
    cee0:	dd94      	ble.n	ce0c <__kernel_rem_pio2f+0x180>
    cee2:	ee19 2a90 	vmov	r2, s19
    cee6:	2d00      	cmp	r5, #0
    cee8:	f102 0201 	add.w	r2, r2, #1
    ceec:	ee09 2a90 	vmov	s19, r2
    cef0:	f340 8193 	ble.w	d21a <__kernel_rem_pio2f+0x58e>
    cef4:	6839      	ldr	r1, [r7, #0]
    cef6:	2900      	cmp	r1, #0
    cef8:	d17e      	bne.n	cff8 <__kernel_rem_pio2f+0x36c>
    cefa:	2d01      	cmp	r5, #1
    cefc:	d026      	beq.n	cf4c <__kernel_rem_pio2f+0x2c0>
    cefe:	463a      	mov	r2, r7
    cf00:	f04f 0c01 	mov.w	ip, #1
    cf04:	f852 1f04 	ldr.w	r1, [r2, #4]!
    cf08:	2900      	cmp	r1, #0
    cf0a:	d079      	beq.n	d000 <__kernel_rem_pio2f+0x374>
    cf0c:	f10c 0201 	add.w	r2, ip, #1
    cf10:	f5c1 7180 	rsb	r1, r1, #256	; 0x100
    cf14:	4295      	cmp	r5, r2
    cf16:	f847 102c 	str.w	r1, [r7, ip, lsl #2]
    cf1a:	dd16      	ble.n	cf4a <__kernel_rem_pio2f+0x2be>
    cf1c:	f857 1022 	ldr.w	r1, [r7, r2, lsl #2]
    cf20:	44bb      	add	fp, r7
    cf22:	eb07 0282 	add.w	r2, r7, r2, lsl #2
    cf26:	e00a      	b.n	cf3e <__kernel_rem_pio2f+0x2b2>
    cf28:	00010b88 	.word	0x00010b88
    cf2c:	00000000 	.word	0x00000000
    cf30:	43800000 	.word	0x43800000
    cf34:	3b800000 	.word	0x3b800000
    cf38:	3fc90000 	.word	0x3fc90000
    cf3c:	6811      	ldr	r1, [r2, #0]
    cf3e:	f1c1 01ff 	rsb	r1, r1, #255	; 0xff
    cf42:	f842 1b04 	str.w	r1, [r2], #4
    cf46:	455a      	cmp	r2, fp
    cf48:	d1f8      	bne.n	cf3c <__kernel_rem_pio2f+0x2b0>
    cf4a:	2101      	movs	r1, #1
    cf4c:	2800      	cmp	r0, #0
    cf4e:	dd0c      	ble.n	cf6a <__kernel_rem_pio2f+0x2de>
    cf50:	2801      	cmp	r0, #1
    cf52:	f000 8143 	beq.w	d1dc <__kernel_rem_pio2f+0x550>
    cf56:	2802      	cmp	r0, #2
    cf58:	d107      	bne.n	cf6a <__kernel_rem_pio2f+0x2de>
    cf5a:	f105 3cff 	add.w	ip, r5, #4294967295
    cf5e:	f857 202c 	ldr.w	r2, [r7, ip, lsl #2]
    cf62:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    cf66:	f847 202c 	str.w	r2, [r7, ip, lsl #2]
    cf6a:	2b02      	cmp	r3, #2
    cf6c:	f47f af4e 	bne.w	ce0c <__kernel_rem_pio2f+0x180>
    cf70:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    cf74:	ee30 8a48 	vsub.f32	s16, s0, s16
    cf78:	2900      	cmp	r1, #0
    cf7a:	f43f af47 	beq.w	ce0c <__kernel_rem_pio2f+0x180>
    cf7e:	9309      	str	r3, [sp, #36]	; 0x24
    cf80:	9001      	str	r0, [sp, #4]
    cf82:	f000 fa91 	bl	d4a8 <scalbnf>
    cf86:	ee38 8a40 	vsub.f32	s16, s16, s0
    cf8a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cf8c:	9801      	ldr	r0, [sp, #4]
    cf8e:	eeb5 8a40 	vcmp.f32	s16, #0.0
    cf92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    cf96:	f43f af3f 	beq.w	ce18 <__kernel_rem_pio2f+0x18c>
    cf9a:	4698      	mov	r8, r3
    cf9c:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
    cfa0:	eeb0 0a48 	vmov.f32	s0, s16
    cfa4:	1a98      	subs	r0, r3, r2
    cfa6:	9501      	str	r5, [sp, #4]
    cfa8:	9d00      	ldr	r5, [sp, #0]
    cfaa:	f000 fa7d 	bl	d4a8 <scalbnf>
    cfae:	ed1f 7a20 	vldr	s14, [pc, #-128]	; cf30 <__kernel_rem_pio2f+0x2a4>
    cfb2:	9b01      	ldr	r3, [sp, #4]
    cfb4:	eeb4 0ac7 	vcmpe.f32	s0, s14
    cfb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    cfbc:	f2c0 8157 	blt.w	d26e <__kernel_rem_pio2f+0x5e2>
    cfc0:	ed5f 7a24 	vldr	s15, [pc, #-144]	; cf34 <__kernel_rem_pio2f+0x2a8>
    cfc4:	9a05      	ldr	r2, [sp, #20]
    cfc6:	ee60 7a27 	vmul.f32	s15, s0, s15
    cfca:	3208      	adds	r2, #8
    cfcc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    cfd0:	9205      	str	r2, [sp, #20]
    cfd2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    cfd6:	f103 0b01 	add.w	fp, r3, #1
    cfda:	eea7 0ac7 	vfms.f32	s0, s15, s14
    cfde:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    cfe2:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    cfe6:	ee10 2a10 	vmov	r2, s0
    cfea:	f847 2023 	str.w	r2, [r7, r3, lsl #2]
    cfee:	ee17 3a90 	vmov	r3, s15
    cff2:	f847 302b 	str.w	r3, [r7, fp, lsl #2]
    cff6:	e02b      	b.n	d050 <__kernel_rem_pio2f+0x3c4>
    cff8:	2201      	movs	r2, #1
    cffa:	f04f 0c00 	mov.w	ip, #0
    cffe:	e787      	b.n	cf10 <__kernel_rem_pio2f+0x284>
    d000:	f10c 0c01 	add.w	ip, ip, #1
    d004:	45ac      	cmp	ip, r5
    d006:	f47f af7d 	bne.w	cf04 <__kernel_rem_pio2f+0x278>
    d00a:	e79f      	b.n	cf4c <__kernel_rem_pio2f+0x2c0>
    d00c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    d010:	eeb4 8ae7 	vcmpe.f32	s16, s15
    d014:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d018:	f280 80ee 	bge.w	d1f8 <__kernel_rem_pio2f+0x56c>
    d01c:	2300      	movs	r3, #0
    d01e:	e6f5      	b.n	ce0c <__kernel_rem_pio2f+0x180>
    d020:	1c6b      	adds	r3, r5, #1
    d022:	469e      	mov	lr, r3
    d024:	469c      	mov	ip, r3
    d026:	e721      	b.n	ce6c <__kernel_rem_pio2f+0x1e0>
    d028:	9b05      	ldr	r3, [sp, #20]
    d02a:	9d00      	ldr	r5, [sp, #0]
    d02c:	f1a3 0208 	sub.w	r2, r3, #8
    d030:	f857 302b 	ldr.w	r3, [r7, fp, lsl #2]
    d034:	9205      	str	r2, [sp, #20]
    d036:	46f0      	mov	r8, lr
    d038:	b953      	cbnz	r3, d050 <__kernel_rem_pio2f+0x3c4>
    d03a:	f1ac 0304 	sub.w	r3, ip, #4
    d03e:	443b      	add	r3, r7
    d040:	f853 1904 	ldr.w	r1, [r3], #-4
    d044:	f10b 3bff 	add.w	fp, fp, #4294967295
    d048:	3a08      	subs	r2, #8
    d04a:	2900      	cmp	r1, #0
    d04c:	d0f8      	beq.n	d040 <__kernel_rem_pio2f+0x3b4>
    d04e:	9205      	str	r2, [sp, #20]
    d050:	9805      	ldr	r0, [sp, #20]
    d052:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    d056:	f000 fa27 	bl	d4a8 <scalbnf>
    d05a:	f1bb 0f00 	cmp.w	fp, #0
    d05e:	f2c0 812b 	blt.w	d2b8 <__kernel_rem_pio2f+0x62c>
    d062:	ea4f 0c8b 	mov.w	ip, fp, lsl #2
    d066:	ab46      	add	r3, sp, #280	; 0x118
    d068:	eb03 040c 	add.w	r4, r3, ip
    d06c:	f10c 0604 	add.w	r6, ip, #4
    d070:	ed1f 7a50 	vldr	s14, [pc, #-320]	; cf34 <__kernel_rem_pio2f+0x2a8>
    d074:	19bb      	adds	r3, r7, r6
    d076:	1d22      	adds	r2, r4, #4
    d078:	ed73 7a01 	vldmdb	r3!, {s15}
    d07c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    d080:	42bb      	cmp	r3, r7
    d082:	ee67 7a80 	vmul.f32	s15, s15, s0
    d086:	ee20 0a07 	vmul.f32	s0, s0, s14
    d08a:	ed62 7a01 	vstmdb	r2!, {s15}
    d08e:	d1f3      	bne.n	d078 <__kernel_rem_pio2f+0x3ec>
    d090:	2d00      	cmp	r5, #0
    d092:	ed1f 6a57 	vldr	s12, [pc, #-348]	; cf38 <__kernel_rem_pio2f+0x2ac>
    d096:	f04f 0000 	mov.w	r0, #0
    d09a:	db20      	blt.n	d0de <__kernel_rem_pio2f+0x452>
    d09c:	4992      	ldr	r1, [pc, #584]	; (d2e8 <__kernel_rem_pio2f+0x65c>)
    d09e:	eddf 7a93 	vldr	s15, [pc, #588]	; d2ec <__kernel_rem_pio2f+0x660>
    d0a2:	eeb0 7a46 	vmov.f32	s14, s12
    d0a6:	4622      	mov	r2, r4
    d0a8:	2300      	movs	r3, #0
    d0aa:	e003      	b.n	d0b4 <__kernel_rem_pio2f+0x428>
    d0ac:	4298      	cmp	r0, r3
    d0ae:	db08      	blt.n	d0c2 <__kernel_rem_pio2f+0x436>
    d0b0:	ecb1 7a01 	vldmia	r1!, {s14}
    d0b4:	ecf2 6a01 	vldmia	r2!, {s13}
    d0b8:	3301      	adds	r3, #1
    d0ba:	429d      	cmp	r5, r3
    d0bc:	eee6 7a87 	vfma.f32	s15, s13, s14
    d0c0:	daf4      	bge.n	d0ac <__kernel_rem_pio2f+0x420>
    d0c2:	ab5a      	add	r3, sp, #360	; 0x168
    d0c4:	eb03 0380 	add.w	r3, r3, r0, lsl #2
    d0c8:	4558      	cmp	r0, fp
    d0ca:	ed43 7a28 	vstr	s15, [r3, #-160]	; 0xffffff60
    d0ce:	f1a4 0404 	sub.w	r4, r4, #4
    d0d2:	f100 0301 	add.w	r3, r0, #1
    d0d6:	d005      	beq.n	d0e4 <__kernel_rem_pio2f+0x458>
    d0d8:	2d00      	cmp	r5, #0
    d0da:	4618      	mov	r0, r3
    d0dc:	dade      	bge.n	d09c <__kernel_rem_pio2f+0x410>
    d0de:	eddf 7a83 	vldr	s15, [pc, #524]	; d2ec <__kernel_rem_pio2f+0x660>
    d0e2:	e7ee      	b.n	d0c2 <__kernel_rem_pio2f+0x436>
    d0e4:	9a68      	ldr	r2, [sp, #416]	; 0x1a0
    d0e6:	2a02      	cmp	r2, #2
    d0e8:	dc1d      	bgt.n	d126 <__kernel_rem_pio2f+0x49a>
    d0ea:	2a00      	cmp	r2, #0
    d0ec:	f300 8097 	bgt.w	d21e <__kernel_rem_pio2f+0x592>
    d0f0:	d110      	bne.n	d114 <__kernel_rem_pio2f+0x488>
    d0f2:	ab32      	add	r3, sp, #200	; 0xc8
    d0f4:	eddf 7a7d 	vldr	s15, [pc, #500]	; d2ec <__kernel_rem_pio2f+0x660>
    d0f8:	441e      	add	r6, r3
    d0fa:	ed36 7a01 	vldmdb	r6!, {s14}
    d0fe:	42b3      	cmp	r3, r6
    d100:	ee77 7a87 	vadd.f32	s15, s15, s14
    d104:	d1f9      	bne.n	d0fa <__kernel_rem_pio2f+0x46e>
    d106:	4643      	mov	r3, r8
    d108:	b10b      	cbz	r3, d10e <__kernel_rem_pio2f+0x482>
    d10a:	eef1 7a67 	vneg.f32	s15, s15
    d10e:	9b06      	ldr	r3, [sp, #24]
    d110:	edc3 7a00 	vstr	s15, [r3]
    d114:	ee19 3a90 	vmov	r3, s19
    d118:	f003 0007 	and.w	r0, r3, #7
    d11c:	b05b      	add	sp, #364	; 0x16c
    d11e:	ecbd 8b04 	vpop	{d8-d9}
    d122:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d126:	9b68      	ldr	r3, [sp, #416]	; 0x1a0
    d128:	2b03      	cmp	r3, #3
    d12a:	d1f3      	bne.n	d114 <__kernel_rem_pio2f+0x488>
    d12c:	f1bb 0f00 	cmp.w	fp, #0
    d130:	f000 80d4 	beq.w	d2dc <__kernel_rem_pio2f+0x650>
    d134:	f50c 73b4 	add.w	r3, ip, #360	; 0x168
    d138:	446b      	add	r3, sp
    d13a:	aa32      	add	r2, sp, #200	; 0xc8
    d13c:	ed13 7a28 	vldr	s14, [r3, #-160]	; 0xffffff60
    d140:	eb02 038b 	add.w	r3, r2, fp, lsl #2
    d144:	ed73 7a01 	vldmdb	r3!, {s15}
    d148:	eef0 6a47 	vmov.f32	s13, s14
    d14c:	ee37 7a27 	vadd.f32	s14, s14, s15
    d150:	429a      	cmp	r2, r3
    d152:	ee77 7ac7 	vsub.f32	s15, s15, s14
    d156:	ed83 7a00 	vstr	s14, [r3]
    d15a:	ee77 7aa6 	vadd.f32	s15, s15, s13
    d15e:	edc3 7a01 	vstr	s15, [r3, #4]
    d162:	d1ef      	bne.n	d144 <__kernel_rem_pio2f+0x4b8>
    d164:	f1bb 0f01 	cmp.w	fp, #1
    d168:	f340 80b8 	ble.w	d2dc <__kernel_rem_pio2f+0x650>
    d16c:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
    d170:	f50c 73b4 	add.w	r3, ip, #360	; 0x168
    d174:	f10b 3bff 	add.w	fp, fp, #4294967295
    d178:	eb0d 0c03 	add.w	ip, sp, r3
    d17c:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
    d180:	f10b 0304 	add.w	r3, fp, #4
    d184:	ed1c 7a28 	vldr	s14, [ip, #-160]	; 0xffffff60
    d188:	4413      	add	r3, r2
    d18a:	a933      	add	r1, sp, #204	; 0xcc
    d18c:	ed73 7a01 	vldmdb	r3!, {s15}
    d190:	eef0 6a47 	vmov.f32	s13, s14
    d194:	ee37 7a27 	vadd.f32	s14, s14, s15
    d198:	4299      	cmp	r1, r3
    d19a:	ee77 7ac7 	vsub.f32	s15, s15, s14
    d19e:	ed83 7a00 	vstr	s14, [r3]
    d1a2:	ee77 7aa6 	vadd.f32	s15, s15, s13
    d1a6:	edc3 7a01 	vstr	s15, [r3, #4]
    d1aa:	d1ef      	bne.n	d18c <__kernel_rem_pio2f+0x500>
    d1ac:	f10b 0b08 	add.w	fp, fp, #8
    d1b0:	eddf 7a4e 	vldr	s15, [pc, #312]	; d2ec <__kernel_rem_pio2f+0x660>
    d1b4:	eb02 030b 	add.w	r3, r2, fp
    d1b8:	3208      	adds	r2, #8
    d1ba:	ed33 7a01 	vldmdb	r3!, {s14}
    d1be:	429a      	cmp	r2, r3
    d1c0:	ee77 7a87 	vadd.f32	s15, s15, s14
    d1c4:	d1f9      	bne.n	d1ba <__kernel_rem_pio2f+0x52e>
    d1c6:	4643      	mov	r3, r8
    d1c8:	2b00      	cmp	r3, #0
    d1ca:	d158      	bne.n	d27e <__kernel_rem_pio2f+0x5f2>
    d1cc:	9906      	ldr	r1, [sp, #24]
    d1ce:	9a32      	ldr	r2, [sp, #200]	; 0xc8
    d1d0:	9b33      	ldr	r3, [sp, #204]	; 0xcc
    d1d2:	600a      	str	r2, [r1, #0]
    d1d4:	604b      	str	r3, [r1, #4]
    d1d6:	edc1 7a02 	vstr	s15, [r1, #8]
    d1da:	e79b      	b.n	d114 <__kernel_rem_pio2f+0x488>
    d1dc:	f105 3cff 	add.w	ip, r5, #4294967295
    d1e0:	f857 202c 	ldr.w	r2, [r7, ip, lsl #2]
    d1e4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    d1e8:	f847 202c 	str.w	r2, [r7, ip, lsl #2]
    d1ec:	e6bd      	b.n	cf6a <__kernel_rem_pio2f+0x2de>
    d1ee:	2308      	movs	r3, #8
    d1f0:	9307      	str	r3, [sp, #28]
    d1f2:	2300      	movs	r3, #0
    d1f4:	9302      	str	r3, [sp, #8]
    d1f6:	e564      	b.n	ccc2 <__kernel_rem_pio2f+0x36>
    d1f8:	ee19 3a90 	vmov	r3, s19
    d1fc:	2d00      	cmp	r5, #0
    d1fe:	f103 0301 	add.w	r3, r3, #1
    d202:	ee09 3a90 	vmov	s19, r3
    d206:	bfc8      	it	gt
    d208:	2302      	movgt	r3, #2
    d20a:	f73f ae73 	bgt.w	cef4 <__kernel_rem_pio2f+0x268>
    d20e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d212:	ee37 8ac8 	vsub.f32	s16, s15, s16
    d216:	2302      	movs	r3, #2
    d218:	e5f8      	b.n	ce0c <__kernel_rem_pio2f+0x180>
    d21a:	2100      	movs	r1, #0
    d21c:	e696      	b.n	cf4c <__kernel_rem_pio2f+0x2c0>
    d21e:	aa32      	add	r2, sp, #200	; 0xc8
    d220:	eddf 7a32 	vldr	s15, [pc, #200]	; d2ec <__kernel_rem_pio2f+0x660>
    d224:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    d228:	ed33 7a01 	vldmdb	r3!, {s14}
    d22c:	429a      	cmp	r2, r3
    d22e:	ee77 7a87 	vadd.f32	s15, s15, s14
    d232:	d1f9      	bne.n	d228 <__kernel_rem_pio2f+0x59c>
    d234:	4643      	mov	r3, r8
    d236:	ed9d 7a32 	vldr	s14, [sp, #200]	; 0xc8
    d23a:	bb93      	cbnz	r3, d2a2 <__kernel_rem_pio2f+0x616>
    d23c:	9b06      	ldr	r3, [sp, #24]
    d23e:	f1bb 0f00 	cmp.w	fp, #0
    d242:	edc3 7a00 	vstr	s15, [r3]
    d246:	ee77 7a67 	vsub.f32	s15, s14, s15
    d24a:	dd0c      	ble.n	d266 <__kernel_rem_pio2f+0x5da>
    d24c:	aa33      	add	r2, sp, #204	; 0xcc
    d24e:	2301      	movs	r3, #1
    d250:	ecb2 7a01 	vldmia	r2!, {s14}
    d254:	3301      	adds	r3, #1
    d256:	459b      	cmp	fp, r3
    d258:	ee77 7a87 	vadd.f32	s15, s15, s14
    d25c:	daf8      	bge.n	d250 <__kernel_rem_pio2f+0x5c4>
    d25e:	4643      	mov	r3, r8
    d260:	b10b      	cbz	r3, d266 <__kernel_rem_pio2f+0x5da>
    d262:	eef1 7a67 	vneg.f32	s15, s15
    d266:	9b06      	ldr	r3, [sp, #24]
    d268:	edc3 7a01 	vstr	s15, [r3, #4]
    d26c:	e752      	b.n	d114 <__kernel_rem_pio2f+0x488>
    d26e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    d272:	469b      	mov	fp, r3
    d274:	ee10 2a10 	vmov	r2, s0
    d278:	f847 2023 	str.w	r2, [r7, r3, lsl #2]
    d27c:	e6e8      	b.n	d050 <__kernel_rem_pio2f+0x3c4>
    d27e:	eddd 6a32 	vldr	s13, [sp, #200]	; 0xc8
    d282:	ed9d 7a33 	vldr	s14, [sp, #204]	; 0xcc
    d286:	9b06      	ldr	r3, [sp, #24]
    d288:	eef1 6a66 	vneg.f32	s13, s13
    d28c:	eeb1 7a47 	vneg.f32	s14, s14
    d290:	eef1 7a67 	vneg.f32	s15, s15
    d294:	edc3 6a00 	vstr	s13, [r3]
    d298:	ed83 7a01 	vstr	s14, [r3, #4]
    d29c:	edc3 7a02 	vstr	s15, [r3, #8]
    d2a0:	e738      	b.n	d114 <__kernel_rem_pio2f+0x488>
    d2a2:	9b06      	ldr	r3, [sp, #24]
    d2a4:	eef1 6a67 	vneg.f32	s13, s15
    d2a8:	f1bb 0f00 	cmp.w	fp, #0
    d2ac:	ee77 7a67 	vsub.f32	s15, s14, s15
    d2b0:	edc3 6a00 	vstr	s13, [r3]
    d2b4:	dcca      	bgt.n	d24c <__kernel_rem_pio2f+0x5c0>
    d2b6:	e7d4      	b.n	d262 <__kernel_rem_pio2f+0x5d6>
    d2b8:	9b68      	ldr	r3, [sp, #416]	; 0x1a0
    d2ba:	2b02      	cmp	r3, #2
    d2bc:	dc0a      	bgt.n	d2d4 <__kernel_rem_pio2f+0x648>
    d2be:	2b00      	cmp	r3, #0
    d2c0:	dc0f      	bgt.n	d2e2 <__kernel_rem_pio2f+0x656>
    d2c2:	f47f af27 	bne.w	d114 <__kernel_rem_pio2f+0x488>
    d2c6:	eddf 7a09 	vldr	s15, [pc, #36]	; d2ec <__kernel_rem_pio2f+0x660>
    d2ca:	e71c      	b.n	d106 <__kernel_rem_pio2f+0x47a>
    d2cc:	9b03      	ldr	r3, [sp, #12]
    d2ce:	ea4f 0c83 	mov.w	ip, r3, lsl #2
    d2d2:	e53b      	b.n	cd4c <__kernel_rem_pio2f+0xc0>
    d2d4:	9b68      	ldr	r3, [sp, #416]	; 0x1a0
    d2d6:	2b03      	cmp	r3, #3
    d2d8:	f47f af1c 	bne.w	d114 <__kernel_rem_pio2f+0x488>
    d2dc:	eddf 7a03 	vldr	s15, [pc, #12]	; d2ec <__kernel_rem_pio2f+0x660>
    d2e0:	e771      	b.n	d1c6 <__kernel_rem_pio2f+0x53a>
    d2e2:	eddf 7a02 	vldr	s15, [pc, #8]	; d2ec <__kernel_rem_pio2f+0x660>
    d2e6:	e7a5      	b.n	d234 <__kernel_rem_pio2f+0x5a8>
    d2e8:	00010b60 	.word	0x00010b60
    d2ec:	00000000 	.word	0x00000000

0000d2f0 <__kernel_sinf>:
    d2f0:	ee10 3a10 	vmov	r3, s0
    d2f4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    d2f8:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
    d2fc:	da04      	bge.n	d308 <__kernel_sinf+0x18>
    d2fe:	eefd 7ac0 	vcvt.s32.f32	s15, s0
    d302:	ee17 3a90 	vmov	r3, s15
    d306:	b35b      	cbz	r3, d360 <__kernel_sinf+0x70>
    d308:	ee60 7a00 	vmul.f32	s15, s0, s0
    d30c:	ed9f 7a15 	vldr	s14, [pc, #84]	; d364 <__kernel_sinf+0x74>
    d310:	eddf 5a15 	vldr	s11, [pc, #84]	; d368 <__kernel_sinf+0x78>
    d314:	ed9f 6a15 	vldr	s12, [pc, #84]	; d36c <__kernel_sinf+0x7c>
    d318:	eddf 6a15 	vldr	s13, [pc, #84]	; d370 <__kernel_sinf+0x80>
    d31c:	eee7 5a87 	vfma.f32	s11, s15, s14
    d320:	ed9f 7a14 	vldr	s14, [pc, #80]	; d374 <__kernel_sinf+0x84>
    d324:	eea5 6aa7 	vfma.f32	s12, s11, s15
    d328:	ee20 5a27 	vmul.f32	s10, s0, s15
    d32c:	eee6 6a27 	vfma.f32	s13, s12, s15
    d330:	eea6 7aa7 	vfma.f32	s14, s13, s15
    d334:	b930      	cbnz	r0, d344 <__kernel_sinf+0x54>
    d336:	eddf 6a10 	vldr	s13, [pc, #64]	; d378 <__kernel_sinf+0x88>
    d33a:	eee7 6a87 	vfma.f32	s13, s15, s14
    d33e:	eea6 0a85 	vfma.f32	s0, s13, s10
    d342:	4770      	bx	lr
    d344:	ee27 7a45 	vnmul.f32	s14, s14, s10
    d348:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    d34c:	eea0 7aa6 	vfma.f32	s14, s1, s13
    d350:	eddf 6a0a 	vldr	s13, [pc, #40]	; d37c <__kernel_sinf+0x8c>
    d354:	eed7 0a27 	vfnms.f32	s1, s14, s15
    d358:	eee5 0a26 	vfma.f32	s1, s10, s13
    d35c:	ee30 0a60 	vsub.f32	s0, s0, s1
    d360:	4770      	bx	lr
    d362:	bf00      	nop
    d364:	2f2ec9d3 	.word	0x2f2ec9d3
    d368:	b2d72f34 	.word	0xb2d72f34
    d36c:	3638ef1b 	.word	0x3638ef1b
    d370:	b9500d01 	.word	0xb9500d01
    d374:	3c088889 	.word	0x3c088889
    d378:	be2aaaab 	.word	0xbe2aaaab
    d37c:	3e2aaaab 	.word	0x3e2aaaab

0000d380 <with_errno>:
    d380:	b5d0      	push	{r4, r6, r7, lr}
    d382:	4606      	mov	r6, r0
    d384:	460f      	mov	r7, r1
    d386:	4614      	mov	r4, r2
    d388:	f000 ffde 	bl	e348 <__errno>
    d38c:	4603      	mov	r3, r0
    d38e:	4639      	mov	r1, r7
    d390:	4630      	mov	r0, r6
    d392:	601c      	str	r4, [r3, #0]
    d394:	bdd0      	pop	{r4, r6, r7, pc}
    d396:	bf00      	nop

0000d398 <xflow>:
    d398:	b530      	push	{r4, r5, lr}
    d39a:	4614      	mov	r4, r2
    d39c:	b083      	sub	sp, #12
    d39e:	461d      	mov	r5, r3
    d3a0:	b108      	cbz	r0, d3a6 <xflow+0xe>
    d3a2:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
    d3a6:	e9cd 2300 	strd	r2, r3, [sp]
    d3aa:	e9dd 2300 	ldrd	r2, r3, [sp]
    d3ae:	4620      	mov	r0, r4
    d3b0:	4629      	mov	r1, r5
    d3b2:	f000 fb27 	bl	da04 <__aeabi_dmul>
    d3b6:	2222      	movs	r2, #34	; 0x22
    d3b8:	b003      	add	sp, #12
    d3ba:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    d3be:	f7ff bfdf 	b.w	d380 <with_errno>
    d3c2:	bf00      	nop

0000d3c4 <__math_uflow>:
    d3c4:	b508      	push	{r3, lr}
    d3c6:	2200      	movs	r2, #0
    d3c8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    d3cc:	f7ff ffe4 	bl	d398 <xflow>
    d3d0:	ec41 0b10 	vmov	d0, r0, r1
    d3d4:	bd08      	pop	{r3, pc}
    d3d6:	bf00      	nop

0000d3d8 <__math_oflow>:
    d3d8:	b508      	push	{r3, lr}
    d3da:	2200      	movs	r2, #0
    d3dc:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
    d3e0:	f7ff ffda 	bl	d398 <xflow>
    d3e4:	ec41 0b10 	vmov	d0, r0, r1
    d3e8:	bd08      	pop	{r3, pc}
    d3ea:	bf00      	nop

0000d3ec <fabs>:
    d3ec:	ec51 0b10 	vmov	r0, r1, d0
    d3f0:	ee10 2a10 	vmov	r2, s0
    d3f4:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
    d3f8:	ec43 2b10 	vmov	d0, r2, r3
    d3fc:	4770      	bx	lr
    d3fe:	bf00      	nop

0000d400 <floorf>:
    d400:	ee10 2a10 	vmov	r2, s0
    d404:	f3c2 53c7 	ubfx	r3, r2, #23, #8
    d408:	3b7f      	subs	r3, #127	; 0x7f
    d40a:	2b16      	cmp	r3, #22
    d40c:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
    d410:	dc2a      	bgt.n	d468 <floorf+0x68>
    d412:	2b00      	cmp	r3, #0
    d414:	ee10 0a10 	vmov	r0, s0
    d418:	db18      	blt.n	d44c <floorf+0x4c>
    d41a:	491a      	ldr	r1, [pc, #104]	; (d484 <floorf+0x84>)
    d41c:	4119      	asrs	r1, r3
    d41e:	420a      	tst	r2, r1
    d420:	d021      	beq.n	d466 <floorf+0x66>
    d422:	eddf 7a19 	vldr	s15, [pc, #100]	; d488 <floorf+0x88>
    d426:	ee70 7a27 	vadd.f32	s15, s0, s15
    d42a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    d42e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d432:	dd18      	ble.n	d466 <floorf+0x66>
    d434:	2a00      	cmp	r2, #0
    d436:	da04      	bge.n	d442 <floorf+0x42>
    d438:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    d43c:	fa42 f303 	asr.w	r3, r2, r3
    d440:	4418      	add	r0, r3
    d442:	ea20 0301 	bic.w	r3, r0, r1
    d446:	ee00 3a10 	vmov	s0, r3
    d44a:	4770      	bx	lr
    d44c:	eddf 7a0e 	vldr	s15, [pc, #56]	; d488 <floorf+0x88>
    d450:	ee70 7a27 	vadd.f32	s15, s0, s15
    d454:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    d458:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d45c:	dd03      	ble.n	d466 <floorf+0x66>
    d45e:	2a00      	cmp	r2, #0
    d460:	db08      	blt.n	d474 <floorf+0x74>
    d462:	ed9f 0a0a 	vldr	s0, [pc, #40]	; d48c <floorf+0x8c>
    d466:	4770      	bx	lr
    d468:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
    d46c:	d3fb      	bcc.n	d466 <floorf+0x66>
    d46e:	ee30 0a00 	vadd.f32	s0, s0, s0
    d472:	4770      	bx	lr
    d474:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
    d478:	2900      	cmp	r1, #0
    d47a:	bf18      	it	ne
    d47c:	eeb0 0a67 	vmovne.f32	s0, s15
    d480:	4770      	bx	lr
    d482:	bf00      	nop
    d484:	007fffff 	.word	0x007fffff
    d488:	7149f2ca 	.word	0x7149f2ca
    d48c:	00000000 	.word	0x00000000

0000d490 <finite>:
    d490:	b082      	sub	sp, #8
    d492:	ed8d 0b00 	vstr	d0, [sp]
    d496:	9801      	ldr	r0, [sp, #4]
    d498:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
    d49c:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
    d4a0:	0fc0      	lsrs	r0, r0, #31
    d4a2:	b002      	add	sp, #8
    d4a4:	4770      	bx	lr
    d4a6:	bf00      	nop

0000d4a8 <scalbnf>:
    d4a8:	b082      	sub	sp, #8
    d4aa:	ed8d 0a01 	vstr	s0, [sp, #4]
    d4ae:	9b01      	ldr	r3, [sp, #4]
    d4b0:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
    d4b4:	d02a      	beq.n	d50c <scalbnf+0x64>
    d4b6:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
    d4ba:	d223      	bcs.n	d504 <scalbnf+0x5c>
    d4bc:	f013 4fff 	tst.w	r3, #2139095040	; 0x7f800000
    d4c0:	d128      	bne.n	d514 <scalbnf+0x6c>
    d4c2:	ed9d 7a01 	vldr	s14, [sp, #4]
    d4c6:	eddf 7a28 	vldr	s15, [pc, #160]	; d568 <scalbnf+0xc0>
    d4ca:	4b28      	ldr	r3, [pc, #160]	; (d56c <scalbnf+0xc4>)
    d4cc:	ee67 7a27 	vmul.f32	s15, s14, s15
    d4d0:	4298      	cmp	r0, r3
    d4d2:	edcd 7a01 	vstr	s15, [sp, #4]
    d4d6:	db3a      	blt.n	d54e <scalbnf+0xa6>
    d4d8:	9b01      	ldr	r3, [sp, #4]
    d4da:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    d4de:	3a19      	subs	r2, #25
    d4e0:	4410      	add	r0, r2
    d4e2:	28fe      	cmp	r0, #254	; 0xfe
    d4e4:	dd1a      	ble.n	d51c <scalbnf+0x74>
    d4e6:	eddf 7a22 	vldr	s15, [pc, #136]	; d570 <scalbnf+0xc8>
    d4ea:	eddf 6a22 	vldr	s13, [pc, #136]	; d574 <scalbnf+0xcc>
    d4ee:	9b01      	ldr	r3, [sp, #4]
    d4f0:	2b00      	cmp	r3, #0
    d4f2:	eeb0 7a67 	vmov.f32	s14, s15
    d4f6:	bfb8      	it	lt
    d4f8:	eef0 7a66 	vmovlt.f32	s15, s13
    d4fc:	ee27 0a87 	vmul.f32	s0, s15, s14
    d500:	b002      	add	sp, #8
    d502:	4770      	bx	lr
    d504:	ee30 0a00 	vadd.f32	s0, s0, s0
    d508:	b002      	add	sp, #8
    d50a:	4770      	bx	lr
    d50c:	ed9d 0a01 	vldr	s0, [sp, #4]
    d510:	b002      	add	sp, #8
    d512:	4770      	bx	lr
    d514:	0dd2      	lsrs	r2, r2, #23
    d516:	4410      	add	r0, r2
    d518:	28fe      	cmp	r0, #254	; 0xfe
    d51a:	dce4      	bgt.n	d4e6 <scalbnf+0x3e>
    d51c:	2800      	cmp	r0, #0
    d51e:	dc0e      	bgt.n	d53e <scalbnf+0x96>
    d520:	f110 0f16 	cmn.w	r0, #22
    d524:	db1a      	blt.n	d55c <scalbnf+0xb4>
    d526:	3019      	adds	r0, #25
    d528:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
    d52c:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
    d530:	ed9f 0a11 	vldr	s0, [pc, #68]	; d578 <scalbnf+0xd0>
    d534:	ee07 3a90 	vmov	s15, r3
    d538:	ee27 0a80 	vmul.f32	s0, s15, s0
    d53c:	e7e4      	b.n	d508 <scalbnf+0x60>
    d53e:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
    d542:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
    d546:	ee00 3a10 	vmov	s0, r3
    d54a:	b002      	add	sp, #8
    d54c:	4770      	bx	lr
    d54e:	eddf 7a0b 	vldr	s15, [pc, #44]	; d57c <scalbnf+0xd4>
    d552:	ed9d 7a01 	vldr	s14, [sp, #4]
    d556:	ee27 0a27 	vmul.f32	s0, s14, s15
    d55a:	e7d5      	b.n	d508 <scalbnf+0x60>
    d55c:	eddf 7a07 	vldr	s15, [pc, #28]	; d57c <scalbnf+0xd4>
    d560:	eddf 6a07 	vldr	s13, [pc, #28]	; d580 <scalbnf+0xd8>
    d564:	e7c3      	b.n	d4ee <scalbnf+0x46>
    d566:	bf00      	nop
    d568:	4c000000 	.word	0x4c000000
    d56c:	ffff3cb0 	.word	0xffff3cb0
    d570:	7149f2ca 	.word	0x7149f2ca
    d574:	f149f2ca 	.word	0xf149f2ca
    d578:	33000000 	.word	0x33000000
    d57c:	0da24260 	.word	0x0da24260
    d580:	8da24260 	.word	0x8da24260
    d584:	ffffffff 	.word	0xffffffff

0000d588 <scalbn>:
    d588:	b538      	push	{r3, r4, r5, lr}
    d58a:	ec53 2b10 	vmov	r2, r3, d0
    d58e:	f3c3 540a 	ubfx	r4, r3, #20, #11
    d592:	4605      	mov	r5, r0
    d594:	4619      	mov	r1, r3
    d596:	bb6c      	cbnz	r4, d5f4 <scalbn+0x6c>
    d598:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    d59c:	4311      	orrs	r1, r2
    d59e:	ee10 0a10 	vmov	r0, s0
    d5a2:	d026      	beq.n	d5f2 <scalbn+0x6a>
    d5a4:	4619      	mov	r1, r3
    d5a6:	2200      	movs	r2, #0
    d5a8:	4b35      	ldr	r3, [pc, #212]	; (d680 <scalbn+0xf8>)
    d5aa:	4c36      	ldr	r4, [pc, #216]	; (d684 <scalbn+0xfc>)
    d5ac:	f000 fa2a 	bl	da04 <__aeabi_dmul>
    d5b0:	42a5      	cmp	r5, r4
    d5b2:	4602      	mov	r2, r0
    d5b4:	460b      	mov	r3, r1
    d5b6:	db3d      	blt.n	d634 <scalbn+0xac>
    d5b8:	f3c1 540a 	ubfx	r4, r1, #20, #11
    d5bc:	3c36      	subs	r4, #54	; 0x36
    d5be:	1928      	adds	r0, r5, r4
    d5c0:	f240 74fe 	movw	r4, #2046	; 0x7fe
    d5c4:	42a0      	cmp	r0, r4
    d5c6:	dc20      	bgt.n	d60a <scalbn+0x82>
    d5c8:	2800      	cmp	r0, #0
    d5ca:	dc3b      	bgt.n	d644 <scalbn+0xbc>
    d5cc:	f110 0f35 	cmn.w	r0, #53	; 0x35
    d5d0:	db2b      	blt.n	d62a <scalbn+0xa2>
    d5d2:	f021 41ff 	bic.w	r1, r1, #2139095040	; 0x7f800000
    d5d6:	f100 0336 	add.w	r3, r0, #54	; 0x36
    d5da:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    d5de:	ea41 5503 	orr.w	r5, r1, r3, lsl #20
    d5e2:	4610      	mov	r0, r2
    d5e4:	4b28      	ldr	r3, [pc, #160]	; (d688 <scalbn+0x100>)
    d5e6:	4629      	mov	r1, r5
    d5e8:	2200      	movs	r2, #0
    d5ea:	f000 fa0b 	bl	da04 <__aeabi_dmul>
    d5ee:	ec41 0b10 	vmov	d0, r0, r1
    d5f2:	bd38      	pop	{r3, r4, r5, pc}
    d5f4:	f240 70ff 	movw	r0, #2047	; 0x7ff
    d5f8:	4284      	cmp	r4, r0
    d5fa:	d1e0      	bne.n	d5be <scalbn+0x36>
    d5fc:	ee10 0a10 	vmov	r0, s0
    d600:	f000 f84a 	bl	d698 <__adddf3>
    d604:	ec41 0b10 	vmov	d0, r0, r1
    d608:	bd38      	pop	{r3, r4, r5, pc}
    d60a:	2b00      	cmp	r3, #0
    d60c:	a114      	add	r1, pc, #80	; (adr r1, d660 <scalbn+0xd8>)
    d60e:	e9d1 0100 	ldrd	r0, r1, [r1]
    d612:	da02      	bge.n	d61a <scalbn+0x92>
    d614:	a114      	add	r1, pc, #80	; (adr r1, d668 <scalbn+0xe0>)
    d616:	e9d1 0100 	ldrd	r0, r1, [r1]
    d61a:	a311      	add	r3, pc, #68	; (adr r3, d660 <scalbn+0xd8>)
    d61c:	e9d3 2300 	ldrd	r2, r3, [r3]
    d620:	f000 f9f0 	bl	da04 <__aeabi_dmul>
    d624:	ec41 0b10 	vmov	d0, r0, r1
    d628:	bd38      	pop	{r3, r4, r5, pc}
    d62a:	2b00      	cmp	r3, #0
    d62c:	a110      	add	r1, pc, #64	; (adr r1, d670 <scalbn+0xe8>)
    d62e:	e9d1 0100 	ldrd	r0, r1, [r1]
    d632:	db10      	blt.n	d656 <scalbn+0xce>
    d634:	a30e      	add	r3, pc, #56	; (adr r3, d670 <scalbn+0xe8>)
    d636:	e9d3 2300 	ldrd	r2, r3, [r3]
    d63a:	f000 f9e3 	bl	da04 <__aeabi_dmul>
    d63e:	ec41 0b10 	vmov	d0, r0, r1
    d642:	bd38      	pop	{r3, r4, r5, pc}
    d644:	f021 41ff 	bic.w	r1, r1, #2139095040	; 0x7f800000
    d648:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    d64c:	ea41 5300 	orr.w	r3, r1, r0, lsl #20
    d650:	ec43 2b10 	vmov	d0, r2, r3
    d654:	bd38      	pop	{r3, r4, r5, pc}
    d656:	a108      	add	r1, pc, #32	; (adr r1, d678 <scalbn+0xf0>)
    d658:	e9d1 0100 	ldrd	r0, r1, [r1]
    d65c:	e7ea      	b.n	d634 <scalbn+0xac>
    d65e:	bf00      	nop
    d660:	8800759c 	.word	0x8800759c
    d664:	7e37e43c 	.word	0x7e37e43c
    d668:	8800759c 	.word	0x8800759c
    d66c:	fe37e43c 	.word	0xfe37e43c
    d670:	c2f8f359 	.word	0xc2f8f359
    d674:	01a56e1f 	.word	0x01a56e1f
    d678:	c2f8f359 	.word	0xc2f8f359
    d67c:	81a56e1f 	.word	0x81a56e1f
    d680:	43500000 	.word	0x43500000
    d684:	ffff3cb0 	.word	0xffff3cb0
    d688:	3c900000 	.word	0x3c900000

0000d68c <__aeabi_drsub>:
    d68c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    d690:	e002      	b.n	d698 <__adddf3>
    d692:	bf00      	nop

0000d694 <__aeabi_dsub>:
    d694:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000d698 <__adddf3>:
    d698:	b530      	push	{r4, r5, lr}
    d69a:	ea4f 0441 	mov.w	r4, r1, lsl #1
    d69e:	ea4f 0543 	mov.w	r5, r3, lsl #1
    d6a2:	ea94 0f05 	teq	r4, r5
    d6a6:	bf08      	it	eq
    d6a8:	ea90 0f02 	teqeq	r0, r2
    d6ac:	bf1f      	itttt	ne
    d6ae:	ea54 0c00 	orrsne.w	ip, r4, r0
    d6b2:	ea55 0c02 	orrsne.w	ip, r5, r2
    d6b6:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    d6ba:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    d6be:	f000 80e2 	beq.w	d886 <__adddf3+0x1ee>
    d6c2:	ea4f 5454 	mov.w	r4, r4, lsr #21
    d6c6:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    d6ca:	bfb8      	it	lt
    d6cc:	426d      	neglt	r5, r5
    d6ce:	dd0c      	ble.n	d6ea <__adddf3+0x52>
    d6d0:	442c      	add	r4, r5
    d6d2:	ea80 0202 	eor.w	r2, r0, r2
    d6d6:	ea81 0303 	eor.w	r3, r1, r3
    d6da:	ea82 0000 	eor.w	r0, r2, r0
    d6de:	ea83 0101 	eor.w	r1, r3, r1
    d6e2:	ea80 0202 	eor.w	r2, r0, r2
    d6e6:	ea81 0303 	eor.w	r3, r1, r3
    d6ea:	2d36      	cmp	r5, #54	; 0x36
    d6ec:	bf88      	it	hi
    d6ee:	bd30      	pophi	{r4, r5, pc}
    d6f0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    d6f4:	ea4f 3101 	mov.w	r1, r1, lsl #12
    d6f8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    d6fc:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    d700:	d002      	beq.n	d708 <__adddf3+0x70>
    d702:	4240      	negs	r0, r0
    d704:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    d708:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    d70c:	ea4f 3303 	mov.w	r3, r3, lsl #12
    d710:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    d714:	d002      	beq.n	d71c <__adddf3+0x84>
    d716:	4252      	negs	r2, r2
    d718:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    d71c:	ea94 0f05 	teq	r4, r5
    d720:	f000 80a7 	beq.w	d872 <__adddf3+0x1da>
    d724:	f1a4 0401 	sub.w	r4, r4, #1
    d728:	f1d5 0e20 	rsbs	lr, r5, #32
    d72c:	db0d      	blt.n	d74a <__adddf3+0xb2>
    d72e:	fa02 fc0e 	lsl.w	ip, r2, lr
    d732:	fa22 f205 	lsr.w	r2, r2, r5
    d736:	1880      	adds	r0, r0, r2
    d738:	f141 0100 	adc.w	r1, r1, #0
    d73c:	fa03 f20e 	lsl.w	r2, r3, lr
    d740:	1880      	adds	r0, r0, r2
    d742:	fa43 f305 	asr.w	r3, r3, r5
    d746:	4159      	adcs	r1, r3
    d748:	e00e      	b.n	d768 <__adddf3+0xd0>
    d74a:	f1a5 0520 	sub.w	r5, r5, #32
    d74e:	f10e 0e20 	add.w	lr, lr, #32
    d752:	2a01      	cmp	r2, #1
    d754:	fa03 fc0e 	lsl.w	ip, r3, lr
    d758:	bf28      	it	cs
    d75a:	f04c 0c02 	orrcs.w	ip, ip, #2
    d75e:	fa43 f305 	asr.w	r3, r3, r5
    d762:	18c0      	adds	r0, r0, r3
    d764:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    d768:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    d76c:	d507      	bpl.n	d77e <__adddf3+0xe6>
    d76e:	f04f 0e00 	mov.w	lr, #0
    d772:	f1dc 0c00 	rsbs	ip, ip, #0
    d776:	eb7e 0000 	sbcs.w	r0, lr, r0
    d77a:	eb6e 0101 	sbc.w	r1, lr, r1
    d77e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    d782:	d31b      	bcc.n	d7bc <__adddf3+0x124>
    d784:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    d788:	d30c      	bcc.n	d7a4 <__adddf3+0x10c>
    d78a:	0849      	lsrs	r1, r1, #1
    d78c:	ea5f 0030 	movs.w	r0, r0, rrx
    d790:	ea4f 0c3c 	mov.w	ip, ip, rrx
    d794:	f104 0401 	add.w	r4, r4, #1
    d798:	ea4f 5244 	mov.w	r2, r4, lsl #21
    d79c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    d7a0:	f080 809a 	bcs.w	d8d8 <__adddf3+0x240>
    d7a4:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    d7a8:	bf08      	it	eq
    d7aa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    d7ae:	f150 0000 	adcs.w	r0, r0, #0
    d7b2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    d7b6:	ea41 0105 	orr.w	r1, r1, r5
    d7ba:	bd30      	pop	{r4, r5, pc}
    d7bc:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    d7c0:	4140      	adcs	r0, r0
    d7c2:	eb41 0101 	adc.w	r1, r1, r1
    d7c6:	3c01      	subs	r4, #1
    d7c8:	bf28      	it	cs
    d7ca:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
    d7ce:	d2e9      	bcs.n	d7a4 <__adddf3+0x10c>
    d7d0:	f091 0f00 	teq	r1, #0
    d7d4:	bf04      	itt	eq
    d7d6:	4601      	moveq	r1, r0
    d7d8:	2000      	moveq	r0, #0
    d7da:	fab1 f381 	clz	r3, r1
    d7de:	bf08      	it	eq
    d7e0:	3320      	addeq	r3, #32
    d7e2:	f1a3 030b 	sub.w	r3, r3, #11
    d7e6:	f1b3 0220 	subs.w	r2, r3, #32
    d7ea:	da0c      	bge.n	d806 <__adddf3+0x16e>
    d7ec:	320c      	adds	r2, #12
    d7ee:	dd08      	ble.n	d802 <__adddf3+0x16a>
    d7f0:	f102 0c14 	add.w	ip, r2, #20
    d7f4:	f1c2 020c 	rsb	r2, r2, #12
    d7f8:	fa01 f00c 	lsl.w	r0, r1, ip
    d7fc:	fa21 f102 	lsr.w	r1, r1, r2
    d800:	e00c      	b.n	d81c <__adddf3+0x184>
    d802:	f102 0214 	add.w	r2, r2, #20
    d806:	bfd8      	it	le
    d808:	f1c2 0c20 	rsble	ip, r2, #32
    d80c:	fa01 f102 	lsl.w	r1, r1, r2
    d810:	fa20 fc0c 	lsr.w	ip, r0, ip
    d814:	bfdc      	itt	le
    d816:	ea41 010c 	orrle.w	r1, r1, ip
    d81a:	4090      	lslle	r0, r2
    d81c:	1ae4      	subs	r4, r4, r3
    d81e:	bfa2      	ittt	ge
    d820:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    d824:	4329      	orrge	r1, r5
    d826:	bd30      	popge	{r4, r5, pc}
    d828:	ea6f 0404 	mvn.w	r4, r4
    d82c:	3c1f      	subs	r4, #31
    d82e:	da1c      	bge.n	d86a <__adddf3+0x1d2>
    d830:	340c      	adds	r4, #12
    d832:	dc0e      	bgt.n	d852 <__adddf3+0x1ba>
    d834:	f104 0414 	add.w	r4, r4, #20
    d838:	f1c4 0220 	rsb	r2, r4, #32
    d83c:	fa20 f004 	lsr.w	r0, r0, r4
    d840:	fa01 f302 	lsl.w	r3, r1, r2
    d844:	ea40 0003 	orr.w	r0, r0, r3
    d848:	fa21 f304 	lsr.w	r3, r1, r4
    d84c:	ea45 0103 	orr.w	r1, r5, r3
    d850:	bd30      	pop	{r4, r5, pc}
    d852:	f1c4 040c 	rsb	r4, r4, #12
    d856:	f1c4 0220 	rsb	r2, r4, #32
    d85a:	fa20 f002 	lsr.w	r0, r0, r2
    d85e:	fa01 f304 	lsl.w	r3, r1, r4
    d862:	ea40 0003 	orr.w	r0, r0, r3
    d866:	4629      	mov	r1, r5
    d868:	bd30      	pop	{r4, r5, pc}
    d86a:	fa21 f004 	lsr.w	r0, r1, r4
    d86e:	4629      	mov	r1, r5
    d870:	bd30      	pop	{r4, r5, pc}
    d872:	f094 0f00 	teq	r4, #0
    d876:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    d87a:	bf06      	itte	eq
    d87c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    d880:	3401      	addeq	r4, #1
    d882:	3d01      	subne	r5, #1
    d884:	e74e      	b.n	d724 <__adddf3+0x8c>
    d886:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    d88a:	bf18      	it	ne
    d88c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    d890:	d029      	beq.n	d8e6 <__adddf3+0x24e>
    d892:	ea94 0f05 	teq	r4, r5
    d896:	bf08      	it	eq
    d898:	ea90 0f02 	teqeq	r0, r2
    d89c:	d005      	beq.n	d8aa <__adddf3+0x212>
    d89e:	ea54 0c00 	orrs.w	ip, r4, r0
    d8a2:	bf04      	itt	eq
    d8a4:	4619      	moveq	r1, r3
    d8a6:	4610      	moveq	r0, r2
    d8a8:	bd30      	pop	{r4, r5, pc}
    d8aa:	ea91 0f03 	teq	r1, r3
    d8ae:	bf1e      	ittt	ne
    d8b0:	2100      	movne	r1, #0
    d8b2:	2000      	movne	r0, #0
    d8b4:	bd30      	popne	{r4, r5, pc}
    d8b6:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    d8ba:	d105      	bne.n	d8c8 <__adddf3+0x230>
    d8bc:	0040      	lsls	r0, r0, #1
    d8be:	4149      	adcs	r1, r1
    d8c0:	bf28      	it	cs
    d8c2:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    d8c6:	bd30      	pop	{r4, r5, pc}
    d8c8:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    d8cc:	bf3c      	itt	cc
    d8ce:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    d8d2:	bd30      	popcc	{r4, r5, pc}
    d8d4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    d8d8:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    d8dc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    d8e0:	f04f 0000 	mov.w	r0, #0
    d8e4:	bd30      	pop	{r4, r5, pc}
    d8e6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    d8ea:	bf1a      	itte	ne
    d8ec:	4619      	movne	r1, r3
    d8ee:	4610      	movne	r0, r2
    d8f0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    d8f4:	bf1c      	itt	ne
    d8f6:	460b      	movne	r3, r1
    d8f8:	4602      	movne	r2, r0
    d8fa:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    d8fe:	bf06      	itte	eq
    d900:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    d904:	ea91 0f03 	teqeq	r1, r3
    d908:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    d90c:	bd30      	pop	{r4, r5, pc}
    d90e:	bf00      	nop

0000d910 <__aeabi_ui2d>:
    d910:	f090 0f00 	teq	r0, #0
    d914:	bf04      	itt	eq
    d916:	2100      	moveq	r1, #0
    d918:	4770      	bxeq	lr
    d91a:	b530      	push	{r4, r5, lr}
    d91c:	f44f 6480 	mov.w	r4, #1024	; 0x400
    d920:	f104 0432 	add.w	r4, r4, #50	; 0x32
    d924:	f04f 0500 	mov.w	r5, #0
    d928:	f04f 0100 	mov.w	r1, #0
    d92c:	e750      	b.n	d7d0 <__adddf3+0x138>
    d92e:	bf00      	nop

0000d930 <__aeabi_i2d>:
    d930:	f090 0f00 	teq	r0, #0
    d934:	bf04      	itt	eq
    d936:	2100      	moveq	r1, #0
    d938:	4770      	bxeq	lr
    d93a:	b530      	push	{r4, r5, lr}
    d93c:	f44f 6480 	mov.w	r4, #1024	; 0x400
    d940:	f104 0432 	add.w	r4, r4, #50	; 0x32
    d944:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    d948:	bf48      	it	mi
    d94a:	4240      	negmi	r0, r0
    d94c:	f04f 0100 	mov.w	r1, #0
    d950:	e73e      	b.n	d7d0 <__adddf3+0x138>
    d952:	bf00      	nop

0000d954 <__aeabi_f2d>:
    d954:	0042      	lsls	r2, r0, #1
    d956:	ea4f 01e2 	mov.w	r1, r2, asr #3
    d95a:	ea4f 0131 	mov.w	r1, r1, rrx
    d95e:	ea4f 7002 	mov.w	r0, r2, lsl #28
    d962:	bf1f      	itttt	ne
    d964:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    d968:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    d96c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    d970:	4770      	bxne	lr
    d972:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    d976:	bf08      	it	eq
    d978:	4770      	bxeq	lr
    d97a:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
    d97e:	bf04      	itt	eq
    d980:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
    d984:	4770      	bxeq	lr
    d986:	b530      	push	{r4, r5, lr}
    d988:	f44f 7460 	mov.w	r4, #896	; 0x380
    d98c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    d990:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    d994:	e71c      	b.n	d7d0 <__adddf3+0x138>
    d996:	bf00      	nop

0000d998 <__aeabi_ul2d>:
    d998:	ea50 0201 	orrs.w	r2, r0, r1
    d99c:	bf08      	it	eq
    d99e:	4770      	bxeq	lr
    d9a0:	b530      	push	{r4, r5, lr}
    d9a2:	f04f 0500 	mov.w	r5, #0
    d9a6:	e00a      	b.n	d9be <__aeabi_l2d+0x16>

0000d9a8 <__aeabi_l2d>:
    d9a8:	ea50 0201 	orrs.w	r2, r0, r1
    d9ac:	bf08      	it	eq
    d9ae:	4770      	bxeq	lr
    d9b0:	b530      	push	{r4, r5, lr}
    d9b2:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    d9b6:	d502      	bpl.n	d9be <__aeabi_l2d+0x16>
    d9b8:	4240      	negs	r0, r0
    d9ba:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    d9be:	f44f 6480 	mov.w	r4, #1024	; 0x400
    d9c2:	f104 0432 	add.w	r4, r4, #50	; 0x32
    d9c6:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    d9ca:	f43f aed8 	beq.w	d77e <__adddf3+0xe6>
    d9ce:	f04f 0203 	mov.w	r2, #3
    d9d2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    d9d6:	bf18      	it	ne
    d9d8:	3203      	addne	r2, #3
    d9da:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    d9de:	bf18      	it	ne
    d9e0:	3203      	addne	r2, #3
    d9e2:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    d9e6:	f1c2 0320 	rsb	r3, r2, #32
    d9ea:	fa00 fc03 	lsl.w	ip, r0, r3
    d9ee:	fa20 f002 	lsr.w	r0, r0, r2
    d9f2:	fa01 fe03 	lsl.w	lr, r1, r3
    d9f6:	ea40 000e 	orr.w	r0, r0, lr
    d9fa:	fa21 f102 	lsr.w	r1, r1, r2
    d9fe:	4414      	add	r4, r2
    da00:	e6bd      	b.n	d77e <__adddf3+0xe6>
    da02:	bf00      	nop

0000da04 <__aeabi_dmul>:
    da04:	b570      	push	{r4, r5, r6, lr}
    da06:	f04f 0cff 	mov.w	ip, #255	; 0xff
    da0a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    da0e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    da12:	bf1d      	ittte	ne
    da14:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    da18:	ea94 0f0c 	teqne	r4, ip
    da1c:	ea95 0f0c 	teqne	r5, ip
    da20:	f000 f8de 	bleq	dbe0 <__aeabi_dmul+0x1dc>
    da24:	442c      	add	r4, r5
    da26:	ea81 0603 	eor.w	r6, r1, r3
    da2a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    da2e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    da32:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    da36:	bf18      	it	ne
    da38:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    da3c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    da40:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    da44:	d038      	beq.n	dab8 <__aeabi_dmul+0xb4>
    da46:	fba0 ce02 	umull	ip, lr, r0, r2
    da4a:	f04f 0500 	mov.w	r5, #0
    da4e:	fbe1 e502 	umlal	lr, r5, r1, r2
    da52:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    da56:	fbe0 e503 	umlal	lr, r5, r0, r3
    da5a:	f04f 0600 	mov.w	r6, #0
    da5e:	fbe1 5603 	umlal	r5, r6, r1, r3
    da62:	f09c 0f00 	teq	ip, #0
    da66:	bf18      	it	ne
    da68:	f04e 0e01 	orrne.w	lr, lr, #1
    da6c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    da70:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    da74:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    da78:	d204      	bcs.n	da84 <__aeabi_dmul+0x80>
    da7a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    da7e:	416d      	adcs	r5, r5
    da80:	eb46 0606 	adc.w	r6, r6, r6
    da84:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    da88:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    da8c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    da90:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    da94:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    da98:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    da9c:	bf88      	it	hi
    da9e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    daa2:	d81e      	bhi.n	dae2 <__aeabi_dmul+0xde>
    daa4:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    daa8:	bf08      	it	eq
    daaa:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    daae:	f150 0000 	adcs.w	r0, r0, #0
    dab2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    dab6:	bd70      	pop	{r4, r5, r6, pc}
    dab8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    dabc:	ea46 0101 	orr.w	r1, r6, r1
    dac0:	ea40 0002 	orr.w	r0, r0, r2
    dac4:	ea81 0103 	eor.w	r1, r1, r3
    dac8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    dacc:	bfc2      	ittt	gt
    dace:	ebd4 050c 	rsbsgt	r5, r4, ip
    dad2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    dad6:	bd70      	popgt	{r4, r5, r6, pc}
    dad8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    dadc:	f04f 0e00 	mov.w	lr, #0
    dae0:	3c01      	subs	r4, #1
    dae2:	f300 80ab 	bgt.w	dc3c <__aeabi_dmul+0x238>
    dae6:	f114 0f36 	cmn.w	r4, #54	; 0x36
    daea:	bfde      	ittt	le
    daec:	2000      	movle	r0, #0
    daee:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    daf2:	bd70      	pople	{r4, r5, r6, pc}
    daf4:	f1c4 0400 	rsb	r4, r4, #0
    daf8:	3c20      	subs	r4, #32
    dafa:	da35      	bge.n	db68 <__aeabi_dmul+0x164>
    dafc:	340c      	adds	r4, #12
    dafe:	dc1b      	bgt.n	db38 <__aeabi_dmul+0x134>
    db00:	f104 0414 	add.w	r4, r4, #20
    db04:	f1c4 0520 	rsb	r5, r4, #32
    db08:	fa00 f305 	lsl.w	r3, r0, r5
    db0c:	fa20 f004 	lsr.w	r0, r0, r4
    db10:	fa01 f205 	lsl.w	r2, r1, r5
    db14:	ea40 0002 	orr.w	r0, r0, r2
    db18:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    db1c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    db20:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    db24:	fa21 f604 	lsr.w	r6, r1, r4
    db28:	eb42 0106 	adc.w	r1, r2, r6
    db2c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    db30:	bf08      	it	eq
    db32:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    db36:	bd70      	pop	{r4, r5, r6, pc}
    db38:	f1c4 040c 	rsb	r4, r4, #12
    db3c:	f1c4 0520 	rsb	r5, r4, #32
    db40:	fa00 f304 	lsl.w	r3, r0, r4
    db44:	fa20 f005 	lsr.w	r0, r0, r5
    db48:	fa01 f204 	lsl.w	r2, r1, r4
    db4c:	ea40 0002 	orr.w	r0, r0, r2
    db50:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    db54:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    db58:	f141 0100 	adc.w	r1, r1, #0
    db5c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    db60:	bf08      	it	eq
    db62:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    db66:	bd70      	pop	{r4, r5, r6, pc}
    db68:	f1c4 0520 	rsb	r5, r4, #32
    db6c:	fa00 f205 	lsl.w	r2, r0, r5
    db70:	ea4e 0e02 	orr.w	lr, lr, r2
    db74:	fa20 f304 	lsr.w	r3, r0, r4
    db78:	fa01 f205 	lsl.w	r2, r1, r5
    db7c:	ea43 0302 	orr.w	r3, r3, r2
    db80:	fa21 f004 	lsr.w	r0, r1, r4
    db84:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    db88:	fa21 f204 	lsr.w	r2, r1, r4
    db8c:	ea20 0002 	bic.w	r0, r0, r2
    db90:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    db94:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    db98:	bf08      	it	eq
    db9a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    db9e:	bd70      	pop	{r4, r5, r6, pc}
    dba0:	f094 0f00 	teq	r4, #0
    dba4:	d10f      	bne.n	dbc6 <__aeabi_dmul+0x1c2>
    dba6:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    dbaa:	0040      	lsls	r0, r0, #1
    dbac:	eb41 0101 	adc.w	r1, r1, r1
    dbb0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    dbb4:	bf08      	it	eq
    dbb6:	3c01      	subeq	r4, #1
    dbb8:	d0f7      	beq.n	dbaa <__aeabi_dmul+0x1a6>
    dbba:	ea41 0106 	orr.w	r1, r1, r6
    dbbe:	f095 0f00 	teq	r5, #0
    dbc2:	bf18      	it	ne
    dbc4:	4770      	bxne	lr
    dbc6:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    dbca:	0052      	lsls	r2, r2, #1
    dbcc:	eb43 0303 	adc.w	r3, r3, r3
    dbd0:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    dbd4:	bf08      	it	eq
    dbd6:	3d01      	subeq	r5, #1
    dbd8:	d0f7      	beq.n	dbca <__aeabi_dmul+0x1c6>
    dbda:	ea43 0306 	orr.w	r3, r3, r6
    dbde:	4770      	bx	lr
    dbe0:	ea94 0f0c 	teq	r4, ip
    dbe4:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    dbe8:	bf18      	it	ne
    dbea:	ea95 0f0c 	teqne	r5, ip
    dbee:	d00c      	beq.n	dc0a <__aeabi_dmul+0x206>
    dbf0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    dbf4:	bf18      	it	ne
    dbf6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    dbfa:	d1d1      	bne.n	dba0 <__aeabi_dmul+0x19c>
    dbfc:	ea81 0103 	eor.w	r1, r1, r3
    dc00:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    dc04:	f04f 0000 	mov.w	r0, #0
    dc08:	bd70      	pop	{r4, r5, r6, pc}
    dc0a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    dc0e:	bf06      	itte	eq
    dc10:	4610      	moveq	r0, r2
    dc12:	4619      	moveq	r1, r3
    dc14:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    dc18:	d019      	beq.n	dc4e <__aeabi_dmul+0x24a>
    dc1a:	ea94 0f0c 	teq	r4, ip
    dc1e:	d102      	bne.n	dc26 <__aeabi_dmul+0x222>
    dc20:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    dc24:	d113      	bne.n	dc4e <__aeabi_dmul+0x24a>
    dc26:	ea95 0f0c 	teq	r5, ip
    dc2a:	d105      	bne.n	dc38 <__aeabi_dmul+0x234>
    dc2c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    dc30:	bf1c      	itt	ne
    dc32:	4610      	movne	r0, r2
    dc34:	4619      	movne	r1, r3
    dc36:	d10a      	bne.n	dc4e <__aeabi_dmul+0x24a>
    dc38:	ea81 0103 	eor.w	r1, r1, r3
    dc3c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    dc40:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    dc44:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    dc48:	f04f 0000 	mov.w	r0, #0
    dc4c:	bd70      	pop	{r4, r5, r6, pc}
    dc4e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    dc52:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    dc56:	bd70      	pop	{r4, r5, r6, pc}

0000dc58 <__aeabi_ddiv>:
    dc58:	b570      	push	{r4, r5, r6, lr}
    dc5a:	f04f 0cff 	mov.w	ip, #255	; 0xff
    dc5e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    dc62:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    dc66:	bf1d      	ittte	ne
    dc68:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    dc6c:	ea94 0f0c 	teqne	r4, ip
    dc70:	ea95 0f0c 	teqne	r5, ip
    dc74:	f000 f8a7 	bleq	ddc6 <__aeabi_ddiv+0x16e>
    dc78:	eba4 0405 	sub.w	r4, r4, r5
    dc7c:	ea81 0e03 	eor.w	lr, r1, r3
    dc80:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    dc84:	ea4f 3101 	mov.w	r1, r1, lsl #12
    dc88:	f000 8088 	beq.w	dd9c <__aeabi_ddiv+0x144>
    dc8c:	ea4f 3303 	mov.w	r3, r3, lsl #12
    dc90:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    dc94:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    dc98:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    dc9c:	ea4f 2202 	mov.w	r2, r2, lsl #8
    dca0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    dca4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    dca8:	ea4f 2600 	mov.w	r6, r0, lsl #8
    dcac:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    dcb0:	429d      	cmp	r5, r3
    dcb2:	bf08      	it	eq
    dcb4:	4296      	cmpeq	r6, r2
    dcb6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    dcba:	f504 7440 	add.w	r4, r4, #768	; 0x300
    dcbe:	d202      	bcs.n	dcc6 <__aeabi_ddiv+0x6e>
    dcc0:	085b      	lsrs	r3, r3, #1
    dcc2:	ea4f 0232 	mov.w	r2, r2, rrx
    dcc6:	1ab6      	subs	r6, r6, r2
    dcc8:	eb65 0503 	sbc.w	r5, r5, r3
    dccc:	085b      	lsrs	r3, r3, #1
    dcce:	ea4f 0232 	mov.w	r2, r2, rrx
    dcd2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    dcd6:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    dcda:	ebb6 0e02 	subs.w	lr, r6, r2
    dcde:	eb75 0e03 	sbcs.w	lr, r5, r3
    dce2:	bf22      	ittt	cs
    dce4:	1ab6      	subcs	r6, r6, r2
    dce6:	4675      	movcs	r5, lr
    dce8:	ea40 000c 	orrcs.w	r0, r0, ip
    dcec:	085b      	lsrs	r3, r3, #1
    dcee:	ea4f 0232 	mov.w	r2, r2, rrx
    dcf2:	ebb6 0e02 	subs.w	lr, r6, r2
    dcf6:	eb75 0e03 	sbcs.w	lr, r5, r3
    dcfa:	bf22      	ittt	cs
    dcfc:	1ab6      	subcs	r6, r6, r2
    dcfe:	4675      	movcs	r5, lr
    dd00:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    dd04:	085b      	lsrs	r3, r3, #1
    dd06:	ea4f 0232 	mov.w	r2, r2, rrx
    dd0a:	ebb6 0e02 	subs.w	lr, r6, r2
    dd0e:	eb75 0e03 	sbcs.w	lr, r5, r3
    dd12:	bf22      	ittt	cs
    dd14:	1ab6      	subcs	r6, r6, r2
    dd16:	4675      	movcs	r5, lr
    dd18:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    dd1c:	085b      	lsrs	r3, r3, #1
    dd1e:	ea4f 0232 	mov.w	r2, r2, rrx
    dd22:	ebb6 0e02 	subs.w	lr, r6, r2
    dd26:	eb75 0e03 	sbcs.w	lr, r5, r3
    dd2a:	bf22      	ittt	cs
    dd2c:	1ab6      	subcs	r6, r6, r2
    dd2e:	4675      	movcs	r5, lr
    dd30:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    dd34:	ea55 0e06 	orrs.w	lr, r5, r6
    dd38:	d018      	beq.n	dd6c <__aeabi_ddiv+0x114>
    dd3a:	ea4f 1505 	mov.w	r5, r5, lsl #4
    dd3e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    dd42:	ea4f 1606 	mov.w	r6, r6, lsl #4
    dd46:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    dd4a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    dd4e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    dd52:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    dd56:	d1c0      	bne.n	dcda <__aeabi_ddiv+0x82>
    dd58:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    dd5c:	d10b      	bne.n	dd76 <__aeabi_ddiv+0x11e>
    dd5e:	ea41 0100 	orr.w	r1, r1, r0
    dd62:	f04f 0000 	mov.w	r0, #0
    dd66:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    dd6a:	e7b6      	b.n	dcda <__aeabi_ddiv+0x82>
    dd6c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    dd70:	bf04      	itt	eq
    dd72:	4301      	orreq	r1, r0
    dd74:	2000      	moveq	r0, #0
    dd76:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    dd7a:	bf88      	it	hi
    dd7c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    dd80:	f63f aeaf 	bhi.w	dae2 <__aeabi_dmul+0xde>
    dd84:	ebb5 0c03 	subs.w	ip, r5, r3
    dd88:	bf04      	itt	eq
    dd8a:	ebb6 0c02 	subseq.w	ip, r6, r2
    dd8e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    dd92:	f150 0000 	adcs.w	r0, r0, #0
    dd96:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    dd9a:	bd70      	pop	{r4, r5, r6, pc}
    dd9c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    dda0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    dda4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    dda8:	bfc2      	ittt	gt
    ddaa:	ebd4 050c 	rsbsgt	r5, r4, ip
    ddae:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    ddb2:	bd70      	popgt	{r4, r5, r6, pc}
    ddb4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    ddb8:	f04f 0e00 	mov.w	lr, #0
    ddbc:	3c01      	subs	r4, #1
    ddbe:	e690      	b.n	dae2 <__aeabi_dmul+0xde>
    ddc0:	ea45 0e06 	orr.w	lr, r5, r6
    ddc4:	e68d      	b.n	dae2 <__aeabi_dmul+0xde>
    ddc6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    ddca:	ea94 0f0c 	teq	r4, ip
    ddce:	bf08      	it	eq
    ddd0:	ea95 0f0c 	teqeq	r5, ip
    ddd4:	f43f af3b 	beq.w	dc4e <__aeabi_dmul+0x24a>
    ddd8:	ea94 0f0c 	teq	r4, ip
    dddc:	d10a      	bne.n	ddf4 <__aeabi_ddiv+0x19c>
    ddde:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    dde2:	f47f af34 	bne.w	dc4e <__aeabi_dmul+0x24a>
    dde6:	ea95 0f0c 	teq	r5, ip
    ddea:	f47f af25 	bne.w	dc38 <__aeabi_dmul+0x234>
    ddee:	4610      	mov	r0, r2
    ddf0:	4619      	mov	r1, r3
    ddf2:	e72c      	b.n	dc4e <__aeabi_dmul+0x24a>
    ddf4:	ea95 0f0c 	teq	r5, ip
    ddf8:	d106      	bne.n	de08 <__aeabi_ddiv+0x1b0>
    ddfa:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    ddfe:	f43f aefd 	beq.w	dbfc <__aeabi_dmul+0x1f8>
    de02:	4610      	mov	r0, r2
    de04:	4619      	mov	r1, r3
    de06:	e722      	b.n	dc4e <__aeabi_dmul+0x24a>
    de08:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    de0c:	bf18      	it	ne
    de0e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    de12:	f47f aec5 	bne.w	dba0 <__aeabi_dmul+0x19c>
    de16:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    de1a:	f47f af0d 	bne.w	dc38 <__aeabi_dmul+0x234>
    de1e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    de22:	f47f aeeb 	bne.w	dbfc <__aeabi_dmul+0x1f8>
    de26:	e712      	b.n	dc4e <__aeabi_dmul+0x24a>

0000de28 <__gedf2>:
    de28:	f04f 3cff 	mov.w	ip, #4294967295
    de2c:	e006      	b.n	de3c <__cmpdf2+0x4>
    de2e:	bf00      	nop

0000de30 <__ledf2>:
    de30:	f04f 0c01 	mov.w	ip, #1
    de34:	e002      	b.n	de3c <__cmpdf2+0x4>
    de36:	bf00      	nop

0000de38 <__cmpdf2>:
    de38:	f04f 0c01 	mov.w	ip, #1
    de3c:	f84d cd04 	str.w	ip, [sp, #-4]!
    de40:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    de44:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    de48:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    de4c:	bf18      	it	ne
    de4e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    de52:	d01b      	beq.n	de8c <__cmpdf2+0x54>
    de54:	b001      	add	sp, #4
    de56:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    de5a:	bf0c      	ite	eq
    de5c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    de60:	ea91 0f03 	teqne	r1, r3
    de64:	bf02      	ittt	eq
    de66:	ea90 0f02 	teqeq	r0, r2
    de6a:	2000      	moveq	r0, #0
    de6c:	4770      	bxeq	lr
    de6e:	f110 0f00 	cmn.w	r0, #0
    de72:	ea91 0f03 	teq	r1, r3
    de76:	bf58      	it	pl
    de78:	4299      	cmppl	r1, r3
    de7a:	bf08      	it	eq
    de7c:	4290      	cmpeq	r0, r2
    de7e:	bf2c      	ite	cs
    de80:	17d8      	asrcs	r0, r3, #31
    de82:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    de86:	f040 0001 	orr.w	r0, r0, #1
    de8a:	4770      	bx	lr
    de8c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    de90:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    de94:	d102      	bne.n	de9c <__cmpdf2+0x64>
    de96:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    de9a:	d107      	bne.n	deac <__cmpdf2+0x74>
    de9c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    dea0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    dea4:	d1d6      	bne.n	de54 <__cmpdf2+0x1c>
    dea6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    deaa:	d0d3      	beq.n	de54 <__cmpdf2+0x1c>
    deac:	f85d 0b04 	ldr.w	r0, [sp], #4
    deb0:	4770      	bx	lr
    deb2:	bf00      	nop

0000deb4 <__aeabi_cdrcmple>:
    deb4:	4684      	mov	ip, r0
    deb6:	4610      	mov	r0, r2
    deb8:	4662      	mov	r2, ip
    deba:	468c      	mov	ip, r1
    debc:	4619      	mov	r1, r3
    debe:	4663      	mov	r3, ip
    dec0:	e000      	b.n	dec4 <__aeabi_cdcmpeq>
    dec2:	bf00      	nop

0000dec4 <__aeabi_cdcmpeq>:
    dec4:	b501      	push	{r0, lr}
    dec6:	f7ff ffb7 	bl	de38 <__cmpdf2>
    deca:	2800      	cmp	r0, #0
    decc:	bf48      	it	mi
    dece:	f110 0f00 	cmnmi.w	r0, #0
    ded2:	bd01      	pop	{r0, pc}

0000ded4 <__aeabi_dcmpeq>:
    ded4:	f84d ed08 	str.w	lr, [sp, #-8]!
    ded8:	f7ff fff4 	bl	dec4 <__aeabi_cdcmpeq>
    dedc:	bf0c      	ite	eq
    dede:	2001      	moveq	r0, #1
    dee0:	2000      	movne	r0, #0
    dee2:	f85d fb08 	ldr.w	pc, [sp], #8
    dee6:	bf00      	nop

0000dee8 <__aeabi_dcmplt>:
    dee8:	f84d ed08 	str.w	lr, [sp, #-8]!
    deec:	f7ff ffea 	bl	dec4 <__aeabi_cdcmpeq>
    def0:	bf34      	ite	cc
    def2:	2001      	movcc	r0, #1
    def4:	2000      	movcs	r0, #0
    def6:	f85d fb08 	ldr.w	pc, [sp], #8
    defa:	bf00      	nop

0000defc <__aeabi_dcmple>:
    defc:	f84d ed08 	str.w	lr, [sp, #-8]!
    df00:	f7ff ffe0 	bl	dec4 <__aeabi_cdcmpeq>
    df04:	bf94      	ite	ls
    df06:	2001      	movls	r0, #1
    df08:	2000      	movhi	r0, #0
    df0a:	f85d fb08 	ldr.w	pc, [sp], #8
    df0e:	bf00      	nop

0000df10 <__aeabi_dcmpge>:
    df10:	f84d ed08 	str.w	lr, [sp, #-8]!
    df14:	f7ff ffce 	bl	deb4 <__aeabi_cdrcmple>
    df18:	bf94      	ite	ls
    df1a:	2001      	movls	r0, #1
    df1c:	2000      	movhi	r0, #0
    df1e:	f85d fb08 	ldr.w	pc, [sp], #8
    df22:	bf00      	nop

0000df24 <__aeabi_dcmpgt>:
    df24:	f84d ed08 	str.w	lr, [sp, #-8]!
    df28:	f7ff ffc4 	bl	deb4 <__aeabi_cdrcmple>
    df2c:	bf34      	ite	cc
    df2e:	2001      	movcc	r0, #1
    df30:	2000      	movcs	r0, #0
    df32:	f85d fb08 	ldr.w	pc, [sp], #8
    df36:	bf00      	nop

0000df38 <__aeabi_dcmpun>:
    df38:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    df3c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    df40:	d102      	bne.n	df48 <__aeabi_dcmpun+0x10>
    df42:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    df46:	d10a      	bne.n	df5e <__aeabi_dcmpun+0x26>
    df48:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    df4c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    df50:	d102      	bne.n	df58 <__aeabi_dcmpun+0x20>
    df52:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    df56:	d102      	bne.n	df5e <__aeabi_dcmpun+0x26>
    df58:	f04f 0000 	mov.w	r0, #0
    df5c:	4770      	bx	lr
    df5e:	f04f 0001 	mov.w	r0, #1
    df62:	4770      	bx	lr

0000df64 <__aeabi_d2uiz>:
    df64:	004a      	lsls	r2, r1, #1
    df66:	d211      	bcs.n	df8c <__aeabi_d2uiz+0x28>
    df68:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    df6c:	d211      	bcs.n	df92 <__aeabi_d2uiz+0x2e>
    df6e:	d50d      	bpl.n	df8c <__aeabi_d2uiz+0x28>
    df70:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    df74:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    df78:	d40e      	bmi.n	df98 <__aeabi_d2uiz+0x34>
    df7a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    df7e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    df82:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    df86:	fa23 f002 	lsr.w	r0, r3, r2
    df8a:	4770      	bx	lr
    df8c:	f04f 0000 	mov.w	r0, #0
    df90:	4770      	bx	lr
    df92:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    df96:	d102      	bne.n	df9e <__aeabi_d2uiz+0x3a>
    df98:	f04f 30ff 	mov.w	r0, #4294967295
    df9c:	4770      	bx	lr
    df9e:	f04f 0000 	mov.w	r0, #0
    dfa2:	4770      	bx	lr

0000dfa4 <__aeabi_d2f>:
    dfa4:	ea4f 0241 	mov.w	r2, r1, lsl #1
    dfa8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    dfac:	bf24      	itt	cs
    dfae:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    dfb2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    dfb6:	d90d      	bls.n	dfd4 <__aeabi_d2f+0x30>
    dfb8:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    dfbc:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    dfc0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    dfc4:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    dfc8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    dfcc:	bf08      	it	eq
    dfce:	f020 0001 	biceq.w	r0, r0, #1
    dfd2:	4770      	bx	lr
    dfd4:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    dfd8:	d121      	bne.n	e01e <__aeabi_d2f+0x7a>
    dfda:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    dfde:	bfbc      	itt	lt
    dfe0:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    dfe4:	4770      	bxlt	lr
    dfe6:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    dfea:	ea4f 5252 	mov.w	r2, r2, lsr #21
    dfee:	f1c2 0218 	rsb	r2, r2, #24
    dff2:	f1c2 0c20 	rsb	ip, r2, #32
    dff6:	fa10 f30c 	lsls.w	r3, r0, ip
    dffa:	fa20 f002 	lsr.w	r0, r0, r2
    dffe:	bf18      	it	ne
    e000:	f040 0001 	orrne.w	r0, r0, #1
    e004:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    e008:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    e00c:	fa03 fc0c 	lsl.w	ip, r3, ip
    e010:	ea40 000c 	orr.w	r0, r0, ip
    e014:	fa23 f302 	lsr.w	r3, r3, r2
    e018:	ea4f 0343 	mov.w	r3, r3, lsl #1
    e01c:	e7cc      	b.n	dfb8 <__aeabi_d2f+0x14>
    e01e:	ea7f 5362 	mvns.w	r3, r2, asr #21
    e022:	d107      	bne.n	e034 <__aeabi_d2f+0x90>
    e024:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    e028:	bf1e      	ittt	ne
    e02a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    e02e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    e032:	4770      	bxne	lr
    e034:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    e038:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    e03c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    e040:	4770      	bx	lr
    e042:	bf00      	nop

0000e044 <__aeabi_uldivmod>:
    e044:	b953      	cbnz	r3, e05c <__aeabi_uldivmod+0x18>
    e046:	b94a      	cbnz	r2, e05c <__aeabi_uldivmod+0x18>
    e048:	2900      	cmp	r1, #0
    e04a:	bf08      	it	eq
    e04c:	2800      	cmpeq	r0, #0
    e04e:	bf1c      	itt	ne
    e050:	f04f 31ff 	movne.w	r1, #4294967295
    e054:	f04f 30ff 	movne.w	r0, #4294967295
    e058:	f000 b970 	b.w	e33c <__aeabi_idiv0>
    e05c:	f1ad 0c08 	sub.w	ip, sp, #8
    e060:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    e064:	f000 f806 	bl	e074 <__udivmoddi4>
    e068:	f8dd e004 	ldr.w	lr, [sp, #4]
    e06c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    e070:	b004      	add	sp, #16
    e072:	4770      	bx	lr

0000e074 <__udivmoddi4>:
    e074:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e078:	9e08      	ldr	r6, [sp, #32]
    e07a:	460d      	mov	r5, r1
    e07c:	4604      	mov	r4, r0
    e07e:	460f      	mov	r7, r1
    e080:	2b00      	cmp	r3, #0
    e082:	d14a      	bne.n	e11a <__udivmoddi4+0xa6>
    e084:	428a      	cmp	r2, r1
    e086:	4694      	mov	ip, r2
    e088:	d965      	bls.n	e156 <__udivmoddi4+0xe2>
    e08a:	fab2 f382 	clz	r3, r2
    e08e:	b143      	cbz	r3, e0a2 <__udivmoddi4+0x2e>
    e090:	fa02 fc03 	lsl.w	ip, r2, r3
    e094:	f1c3 0220 	rsb	r2, r3, #32
    e098:	409f      	lsls	r7, r3
    e09a:	fa20 f202 	lsr.w	r2, r0, r2
    e09e:	4317      	orrs	r7, r2
    e0a0:	409c      	lsls	r4, r3
    e0a2:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
    e0a6:	fa1f f58c 	uxth.w	r5, ip
    e0aa:	fbb7 f1fe 	udiv	r1, r7, lr
    e0ae:	0c22      	lsrs	r2, r4, #16
    e0b0:	fb0e 7711 	mls	r7, lr, r1, r7
    e0b4:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
    e0b8:	fb01 f005 	mul.w	r0, r1, r5
    e0bc:	4290      	cmp	r0, r2
    e0be:	d90a      	bls.n	e0d6 <__udivmoddi4+0x62>
    e0c0:	eb1c 0202 	adds.w	r2, ip, r2
    e0c4:	f101 37ff 	add.w	r7, r1, #4294967295
    e0c8:	f080 811c 	bcs.w	e304 <__udivmoddi4+0x290>
    e0cc:	4290      	cmp	r0, r2
    e0ce:	f240 8119 	bls.w	e304 <__udivmoddi4+0x290>
    e0d2:	3902      	subs	r1, #2
    e0d4:	4462      	add	r2, ip
    e0d6:	1a12      	subs	r2, r2, r0
    e0d8:	b2a4      	uxth	r4, r4
    e0da:	fbb2 f0fe 	udiv	r0, r2, lr
    e0de:	fb0e 2210 	mls	r2, lr, r0, r2
    e0e2:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
    e0e6:	fb00 f505 	mul.w	r5, r0, r5
    e0ea:	42a5      	cmp	r5, r4
    e0ec:	d90a      	bls.n	e104 <__udivmoddi4+0x90>
    e0ee:	eb1c 0404 	adds.w	r4, ip, r4
    e0f2:	f100 32ff 	add.w	r2, r0, #4294967295
    e0f6:	f080 8107 	bcs.w	e308 <__udivmoddi4+0x294>
    e0fa:	42a5      	cmp	r5, r4
    e0fc:	f240 8104 	bls.w	e308 <__udivmoddi4+0x294>
    e100:	4464      	add	r4, ip
    e102:	3802      	subs	r0, #2
    e104:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
    e108:	1b64      	subs	r4, r4, r5
    e10a:	2100      	movs	r1, #0
    e10c:	b11e      	cbz	r6, e116 <__udivmoddi4+0xa2>
    e10e:	40dc      	lsrs	r4, r3
    e110:	2300      	movs	r3, #0
    e112:	e9c6 4300 	strd	r4, r3, [r6]
    e116:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e11a:	428b      	cmp	r3, r1
    e11c:	d908      	bls.n	e130 <__udivmoddi4+0xbc>
    e11e:	2e00      	cmp	r6, #0
    e120:	f000 80ed 	beq.w	e2fe <__udivmoddi4+0x28a>
    e124:	2100      	movs	r1, #0
    e126:	e9c6 0500 	strd	r0, r5, [r6]
    e12a:	4608      	mov	r0, r1
    e12c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e130:	fab3 f183 	clz	r1, r3
    e134:	2900      	cmp	r1, #0
    e136:	d149      	bne.n	e1cc <__udivmoddi4+0x158>
    e138:	42ab      	cmp	r3, r5
    e13a:	d302      	bcc.n	e142 <__udivmoddi4+0xce>
    e13c:	4282      	cmp	r2, r0
    e13e:	f200 80f8 	bhi.w	e332 <__udivmoddi4+0x2be>
    e142:	1a84      	subs	r4, r0, r2
    e144:	eb65 0203 	sbc.w	r2, r5, r3
    e148:	2001      	movs	r0, #1
    e14a:	4617      	mov	r7, r2
    e14c:	2e00      	cmp	r6, #0
    e14e:	d0e2      	beq.n	e116 <__udivmoddi4+0xa2>
    e150:	e9c6 4700 	strd	r4, r7, [r6]
    e154:	e7df      	b.n	e116 <__udivmoddi4+0xa2>
    e156:	b902      	cbnz	r2, e15a <__udivmoddi4+0xe6>
    e158:	deff      	udf	#255	; 0xff
    e15a:	fab2 f382 	clz	r3, r2
    e15e:	2b00      	cmp	r3, #0
    e160:	f040 8090 	bne.w	e284 <__udivmoddi4+0x210>
    e164:	1a8a      	subs	r2, r1, r2
    e166:	ea4f 471c 	mov.w	r7, ip, lsr #16
    e16a:	fa1f fe8c 	uxth.w	lr, ip
    e16e:	2101      	movs	r1, #1
    e170:	fbb2 f5f7 	udiv	r5, r2, r7
    e174:	fb07 2015 	mls	r0, r7, r5, r2
    e178:	0c22      	lsrs	r2, r4, #16
    e17a:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
    e17e:	fb0e f005 	mul.w	r0, lr, r5
    e182:	4290      	cmp	r0, r2
    e184:	d908      	bls.n	e198 <__udivmoddi4+0x124>
    e186:	eb1c 0202 	adds.w	r2, ip, r2
    e18a:	f105 38ff 	add.w	r8, r5, #4294967295
    e18e:	d202      	bcs.n	e196 <__udivmoddi4+0x122>
    e190:	4290      	cmp	r0, r2
    e192:	f200 80cb 	bhi.w	e32c <__udivmoddi4+0x2b8>
    e196:	4645      	mov	r5, r8
    e198:	1a12      	subs	r2, r2, r0
    e19a:	b2a4      	uxth	r4, r4
    e19c:	fbb2 f0f7 	udiv	r0, r2, r7
    e1a0:	fb07 2210 	mls	r2, r7, r0, r2
    e1a4:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
    e1a8:	fb0e fe00 	mul.w	lr, lr, r0
    e1ac:	45a6      	cmp	lr, r4
    e1ae:	d908      	bls.n	e1c2 <__udivmoddi4+0x14e>
    e1b0:	eb1c 0404 	adds.w	r4, ip, r4
    e1b4:	f100 32ff 	add.w	r2, r0, #4294967295
    e1b8:	d202      	bcs.n	e1c0 <__udivmoddi4+0x14c>
    e1ba:	45a6      	cmp	lr, r4
    e1bc:	f200 80bb 	bhi.w	e336 <__udivmoddi4+0x2c2>
    e1c0:	4610      	mov	r0, r2
    e1c2:	eba4 040e 	sub.w	r4, r4, lr
    e1c6:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
    e1ca:	e79f      	b.n	e10c <__udivmoddi4+0x98>
    e1cc:	f1c1 0720 	rsb	r7, r1, #32
    e1d0:	408b      	lsls	r3, r1
    e1d2:	fa22 fc07 	lsr.w	ip, r2, r7
    e1d6:	ea4c 0c03 	orr.w	ip, ip, r3
    e1da:	fa05 f401 	lsl.w	r4, r5, r1
    e1de:	fa20 f307 	lsr.w	r3, r0, r7
    e1e2:	40fd      	lsrs	r5, r7
    e1e4:	ea4f 491c 	mov.w	r9, ip, lsr #16
    e1e8:	4323      	orrs	r3, r4
    e1ea:	fbb5 f8f9 	udiv	r8, r5, r9
    e1ee:	fa1f fe8c 	uxth.w	lr, ip
    e1f2:	fb09 5518 	mls	r5, r9, r8, r5
    e1f6:	0c1c      	lsrs	r4, r3, #16
    e1f8:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
    e1fc:	fb08 f50e 	mul.w	r5, r8, lr
    e200:	42a5      	cmp	r5, r4
    e202:	fa02 f201 	lsl.w	r2, r2, r1
    e206:	fa00 f001 	lsl.w	r0, r0, r1
    e20a:	d90b      	bls.n	e224 <__udivmoddi4+0x1b0>
    e20c:	eb1c 0404 	adds.w	r4, ip, r4
    e210:	f108 3aff 	add.w	sl, r8, #4294967295
    e214:	f080 8088 	bcs.w	e328 <__udivmoddi4+0x2b4>
    e218:	42a5      	cmp	r5, r4
    e21a:	f240 8085 	bls.w	e328 <__udivmoddi4+0x2b4>
    e21e:	f1a8 0802 	sub.w	r8, r8, #2
    e222:	4464      	add	r4, ip
    e224:	1b64      	subs	r4, r4, r5
    e226:	b29d      	uxth	r5, r3
    e228:	fbb4 f3f9 	udiv	r3, r4, r9
    e22c:	fb09 4413 	mls	r4, r9, r3, r4
    e230:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
    e234:	fb03 fe0e 	mul.w	lr, r3, lr
    e238:	45a6      	cmp	lr, r4
    e23a:	d908      	bls.n	e24e <__udivmoddi4+0x1da>
    e23c:	eb1c 0404 	adds.w	r4, ip, r4
    e240:	f103 35ff 	add.w	r5, r3, #4294967295
    e244:	d26c      	bcs.n	e320 <__udivmoddi4+0x2ac>
    e246:	45a6      	cmp	lr, r4
    e248:	d96a      	bls.n	e320 <__udivmoddi4+0x2ac>
    e24a:	3b02      	subs	r3, #2
    e24c:	4464      	add	r4, ip
    e24e:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
    e252:	fba3 9502 	umull	r9, r5, r3, r2
    e256:	eba4 040e 	sub.w	r4, r4, lr
    e25a:	42ac      	cmp	r4, r5
    e25c:	46c8      	mov	r8, r9
    e25e:	46ae      	mov	lr, r5
    e260:	d356      	bcc.n	e310 <__udivmoddi4+0x29c>
    e262:	d053      	beq.n	e30c <__udivmoddi4+0x298>
    e264:	b156      	cbz	r6, e27c <__udivmoddi4+0x208>
    e266:	ebb0 0208 	subs.w	r2, r0, r8
    e26a:	eb64 040e 	sbc.w	r4, r4, lr
    e26e:	fa04 f707 	lsl.w	r7, r4, r7
    e272:	40ca      	lsrs	r2, r1
    e274:	40cc      	lsrs	r4, r1
    e276:	4317      	orrs	r7, r2
    e278:	e9c6 7400 	strd	r7, r4, [r6]
    e27c:	4618      	mov	r0, r3
    e27e:	2100      	movs	r1, #0
    e280:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e284:	f1c3 0120 	rsb	r1, r3, #32
    e288:	fa02 fc03 	lsl.w	ip, r2, r3
    e28c:	fa20 f201 	lsr.w	r2, r0, r1
    e290:	fa25 f101 	lsr.w	r1, r5, r1
    e294:	409d      	lsls	r5, r3
    e296:	432a      	orrs	r2, r5
    e298:	ea4f 471c 	mov.w	r7, ip, lsr #16
    e29c:	fa1f fe8c 	uxth.w	lr, ip
    e2a0:	fbb1 f0f7 	udiv	r0, r1, r7
    e2a4:	fb07 1510 	mls	r5, r7, r0, r1
    e2a8:	0c11      	lsrs	r1, r2, #16
    e2aa:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
    e2ae:	fb00 f50e 	mul.w	r5, r0, lr
    e2b2:	428d      	cmp	r5, r1
    e2b4:	fa04 f403 	lsl.w	r4, r4, r3
    e2b8:	d908      	bls.n	e2cc <__udivmoddi4+0x258>
    e2ba:	eb1c 0101 	adds.w	r1, ip, r1
    e2be:	f100 38ff 	add.w	r8, r0, #4294967295
    e2c2:	d22f      	bcs.n	e324 <__udivmoddi4+0x2b0>
    e2c4:	428d      	cmp	r5, r1
    e2c6:	d92d      	bls.n	e324 <__udivmoddi4+0x2b0>
    e2c8:	3802      	subs	r0, #2
    e2ca:	4461      	add	r1, ip
    e2cc:	1b49      	subs	r1, r1, r5
    e2ce:	b292      	uxth	r2, r2
    e2d0:	fbb1 f5f7 	udiv	r5, r1, r7
    e2d4:	fb07 1115 	mls	r1, r7, r5, r1
    e2d8:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
    e2dc:	fb05 f10e 	mul.w	r1, r5, lr
    e2e0:	4291      	cmp	r1, r2
    e2e2:	d908      	bls.n	e2f6 <__udivmoddi4+0x282>
    e2e4:	eb1c 0202 	adds.w	r2, ip, r2
    e2e8:	f105 38ff 	add.w	r8, r5, #4294967295
    e2ec:	d216      	bcs.n	e31c <__udivmoddi4+0x2a8>
    e2ee:	4291      	cmp	r1, r2
    e2f0:	d914      	bls.n	e31c <__udivmoddi4+0x2a8>
    e2f2:	3d02      	subs	r5, #2
    e2f4:	4462      	add	r2, ip
    e2f6:	1a52      	subs	r2, r2, r1
    e2f8:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
    e2fc:	e738      	b.n	e170 <__udivmoddi4+0xfc>
    e2fe:	4631      	mov	r1, r6
    e300:	4630      	mov	r0, r6
    e302:	e708      	b.n	e116 <__udivmoddi4+0xa2>
    e304:	4639      	mov	r1, r7
    e306:	e6e6      	b.n	e0d6 <__udivmoddi4+0x62>
    e308:	4610      	mov	r0, r2
    e30a:	e6fb      	b.n	e104 <__udivmoddi4+0x90>
    e30c:	4548      	cmp	r0, r9
    e30e:	d2a9      	bcs.n	e264 <__udivmoddi4+0x1f0>
    e310:	ebb9 0802 	subs.w	r8, r9, r2
    e314:	eb65 0e0c 	sbc.w	lr, r5, ip
    e318:	3b01      	subs	r3, #1
    e31a:	e7a3      	b.n	e264 <__udivmoddi4+0x1f0>
    e31c:	4645      	mov	r5, r8
    e31e:	e7ea      	b.n	e2f6 <__udivmoddi4+0x282>
    e320:	462b      	mov	r3, r5
    e322:	e794      	b.n	e24e <__udivmoddi4+0x1da>
    e324:	4640      	mov	r0, r8
    e326:	e7d1      	b.n	e2cc <__udivmoddi4+0x258>
    e328:	46d0      	mov	r8, sl
    e32a:	e77b      	b.n	e224 <__udivmoddi4+0x1b0>
    e32c:	3d02      	subs	r5, #2
    e32e:	4462      	add	r2, ip
    e330:	e732      	b.n	e198 <__udivmoddi4+0x124>
    e332:	4608      	mov	r0, r1
    e334:	e70a      	b.n	e14c <__udivmoddi4+0xd8>
    e336:	4464      	add	r4, ip
    e338:	3802      	subs	r0, #2
    e33a:	e742      	b.n	e1c2 <__udivmoddi4+0x14e>

0000e33c <__aeabi_idiv0>:
    e33c:	4770      	bx	lr
    e33e:	bf00      	nop

0000e340 <atoi>:
    e340:	220a      	movs	r2, #10
    e342:	2100      	movs	r1, #0
    e344:	f000 ba0e 	b.w	e764 <strtol>

0000e348 <__errno>:
    e348:	4b01      	ldr	r3, [pc, #4]	; (e350 <__errno+0x8>)
    e34a:	6818      	ldr	r0, [r3, #0]
    e34c:	4770      	bx	lr
    e34e:	bf00      	nop
    e350:	1fff0850 	.word	0x1fff0850

0000e354 <__libc_init_array>:
    e354:	b570      	push	{r4, r5, r6, lr}
    e356:	4d0d      	ldr	r5, [pc, #52]	; (e38c <__libc_init_array+0x38>)
    e358:	4c0d      	ldr	r4, [pc, #52]	; (e390 <__libc_init_array+0x3c>)
    e35a:	1b64      	subs	r4, r4, r5
    e35c:	10a4      	asrs	r4, r4, #2
    e35e:	2600      	movs	r6, #0
    e360:	42a6      	cmp	r6, r4
    e362:	d109      	bne.n	e378 <__libc_init_array+0x24>
    e364:	4d0b      	ldr	r5, [pc, #44]	; (e394 <__libc_init_array+0x40>)
    e366:	4c0c      	ldr	r4, [pc, #48]	; (e398 <__libc_init_array+0x44>)
    e368:	f002 fcc6 	bl	10cf8 <_init>
    e36c:	1b64      	subs	r4, r4, r5
    e36e:	10a4      	asrs	r4, r4, #2
    e370:	2600      	movs	r6, #0
    e372:	42a6      	cmp	r6, r4
    e374:	d105      	bne.n	e382 <__libc_init_array+0x2e>
    e376:	bd70      	pop	{r4, r5, r6, pc}
    e378:	f855 3b04 	ldr.w	r3, [r5], #4
    e37c:	4798      	blx	r3
    e37e:	3601      	adds	r6, #1
    e380:	e7ee      	b.n	e360 <__libc_init_array+0xc>
    e382:	f855 3b04 	ldr.w	r3, [r5], #4
    e386:	4798      	blx	r3
    e388:	3601      	adds	r6, #1
    e38a:	e7f2      	b.n	e372 <__libc_init_array+0x1e>
    e38c:	00010d04 	.word	0x00010d04
    e390:	00010d04 	.word	0x00010d04
    e394:	00010d04 	.word	0x00010d04
    e398:	00010d0c 	.word	0x00010d0c

0000e39c <isspace>:
    e39c:	4b02      	ldr	r3, [pc, #8]	; (e3a8 <isspace+0xc>)
    e39e:	4418      	add	r0, r3
    e3a0:	7840      	ldrb	r0, [r0, #1]
    e3a2:	f000 0008 	and.w	r0, r0, #8
    e3a6:	4770      	bx	lr
    e3a8:	00010b94 	.word	0x00010b94

0000e3ac <free>:
    e3ac:	4b02      	ldr	r3, [pc, #8]	; (e3b8 <free+0xc>)
    e3ae:	4601      	mov	r1, r0
    e3b0:	6818      	ldr	r0, [r3, #0]
    e3b2:	f000 b819 	b.w	e3e8 <_free_r>
    e3b6:	bf00      	nop
    e3b8:	1fff0850 	.word	0x1fff0850

0000e3bc <memcpy>:
    e3bc:	440a      	add	r2, r1
    e3be:	4291      	cmp	r1, r2
    e3c0:	f100 33ff 	add.w	r3, r0, #4294967295
    e3c4:	d100      	bne.n	e3c8 <memcpy+0xc>
    e3c6:	4770      	bx	lr
    e3c8:	b510      	push	{r4, lr}
    e3ca:	f811 4b01 	ldrb.w	r4, [r1], #1
    e3ce:	f803 4f01 	strb.w	r4, [r3, #1]!
    e3d2:	4291      	cmp	r1, r2
    e3d4:	d1f9      	bne.n	e3ca <memcpy+0xe>
    e3d6:	bd10      	pop	{r4, pc}

0000e3d8 <memset>:
    e3d8:	4402      	add	r2, r0
    e3da:	4603      	mov	r3, r0
    e3dc:	4293      	cmp	r3, r2
    e3de:	d100      	bne.n	e3e2 <memset+0xa>
    e3e0:	4770      	bx	lr
    e3e2:	f803 1b01 	strb.w	r1, [r3], #1
    e3e6:	e7f9      	b.n	e3dc <memset+0x4>

0000e3e8 <_free_r>:
    e3e8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    e3ea:	2900      	cmp	r1, #0
    e3ec:	d044      	beq.n	e478 <_free_r+0x90>
    e3ee:	f851 3c04 	ldr.w	r3, [r1, #-4]
    e3f2:	9001      	str	r0, [sp, #4]
    e3f4:	2b00      	cmp	r3, #0
    e3f6:	f1a1 0404 	sub.w	r4, r1, #4
    e3fa:	bfb8      	it	lt
    e3fc:	18e4      	addlt	r4, r4, r3
    e3fe:	f000 f9c5 	bl	e78c <__malloc_lock>
    e402:	4a1e      	ldr	r2, [pc, #120]	; (e47c <_free_r+0x94>)
    e404:	9801      	ldr	r0, [sp, #4]
    e406:	6813      	ldr	r3, [r2, #0]
    e408:	b933      	cbnz	r3, e418 <_free_r+0x30>
    e40a:	6063      	str	r3, [r4, #4]
    e40c:	6014      	str	r4, [r2, #0]
    e40e:	b003      	add	sp, #12
    e410:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    e414:	f000 b9bb 	b.w	e78e <__malloc_unlock>
    e418:	42a3      	cmp	r3, r4
    e41a:	d908      	bls.n	e42e <_free_r+0x46>
    e41c:	6825      	ldr	r5, [r4, #0]
    e41e:	1961      	adds	r1, r4, r5
    e420:	428b      	cmp	r3, r1
    e422:	bf01      	itttt	eq
    e424:	6819      	ldreq	r1, [r3, #0]
    e426:	685b      	ldreq	r3, [r3, #4]
    e428:	1949      	addeq	r1, r1, r5
    e42a:	6021      	streq	r1, [r4, #0]
    e42c:	e7ed      	b.n	e40a <_free_r+0x22>
    e42e:	461a      	mov	r2, r3
    e430:	685b      	ldr	r3, [r3, #4]
    e432:	b10b      	cbz	r3, e438 <_free_r+0x50>
    e434:	42a3      	cmp	r3, r4
    e436:	d9fa      	bls.n	e42e <_free_r+0x46>
    e438:	6811      	ldr	r1, [r2, #0]
    e43a:	1855      	adds	r5, r2, r1
    e43c:	42a5      	cmp	r5, r4
    e43e:	d10b      	bne.n	e458 <_free_r+0x70>
    e440:	6824      	ldr	r4, [r4, #0]
    e442:	4421      	add	r1, r4
    e444:	1854      	adds	r4, r2, r1
    e446:	42a3      	cmp	r3, r4
    e448:	6011      	str	r1, [r2, #0]
    e44a:	d1e0      	bne.n	e40e <_free_r+0x26>
    e44c:	681c      	ldr	r4, [r3, #0]
    e44e:	685b      	ldr	r3, [r3, #4]
    e450:	6053      	str	r3, [r2, #4]
    e452:	440c      	add	r4, r1
    e454:	6014      	str	r4, [r2, #0]
    e456:	e7da      	b.n	e40e <_free_r+0x26>
    e458:	d902      	bls.n	e460 <_free_r+0x78>
    e45a:	230c      	movs	r3, #12
    e45c:	6003      	str	r3, [r0, #0]
    e45e:	e7d6      	b.n	e40e <_free_r+0x26>
    e460:	6825      	ldr	r5, [r4, #0]
    e462:	1961      	adds	r1, r4, r5
    e464:	428b      	cmp	r3, r1
    e466:	bf04      	itt	eq
    e468:	6819      	ldreq	r1, [r3, #0]
    e46a:	685b      	ldreq	r3, [r3, #4]
    e46c:	6063      	str	r3, [r4, #4]
    e46e:	bf04      	itt	eq
    e470:	1949      	addeq	r1, r1, r5
    e472:	6021      	streq	r1, [r4, #0]
    e474:	6054      	str	r4, [r2, #4]
    e476:	e7ca      	b.n	e40e <_free_r+0x26>
    e478:	b003      	add	sp, #12
    e47a:	bd30      	pop	{r4, r5, pc}
    e47c:	1fff14c4 	.word	0x1fff14c4

0000e480 <sbrk_aligned>:
    e480:	b570      	push	{r4, r5, r6, lr}
    e482:	4e0e      	ldr	r6, [pc, #56]	; (e4bc <sbrk_aligned+0x3c>)
    e484:	460c      	mov	r4, r1
    e486:	6831      	ldr	r1, [r6, #0]
    e488:	4605      	mov	r5, r0
    e48a:	b911      	cbnz	r1, e492 <sbrk_aligned+0x12>
    e48c:	f000 f894 	bl	e5b8 <_sbrk_r>
    e490:	6030      	str	r0, [r6, #0]
    e492:	4621      	mov	r1, r4
    e494:	4628      	mov	r0, r5
    e496:	f000 f88f 	bl	e5b8 <_sbrk_r>
    e49a:	1c43      	adds	r3, r0, #1
    e49c:	d00a      	beq.n	e4b4 <sbrk_aligned+0x34>
    e49e:	1cc4      	adds	r4, r0, #3
    e4a0:	f024 0403 	bic.w	r4, r4, #3
    e4a4:	42a0      	cmp	r0, r4
    e4a6:	d007      	beq.n	e4b8 <sbrk_aligned+0x38>
    e4a8:	1a21      	subs	r1, r4, r0
    e4aa:	4628      	mov	r0, r5
    e4ac:	f000 f884 	bl	e5b8 <_sbrk_r>
    e4b0:	3001      	adds	r0, #1
    e4b2:	d101      	bne.n	e4b8 <sbrk_aligned+0x38>
    e4b4:	f04f 34ff 	mov.w	r4, #4294967295
    e4b8:	4620      	mov	r0, r4
    e4ba:	bd70      	pop	{r4, r5, r6, pc}
    e4bc:	1fff14c8 	.word	0x1fff14c8

0000e4c0 <_malloc_r>:
    e4c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e4c4:	1ccd      	adds	r5, r1, #3
    e4c6:	f025 0503 	bic.w	r5, r5, #3
    e4ca:	3508      	adds	r5, #8
    e4cc:	2d0c      	cmp	r5, #12
    e4ce:	bf38      	it	cc
    e4d0:	250c      	movcc	r5, #12
    e4d2:	2d00      	cmp	r5, #0
    e4d4:	4607      	mov	r7, r0
    e4d6:	db01      	blt.n	e4dc <_malloc_r+0x1c>
    e4d8:	42a9      	cmp	r1, r5
    e4da:	d905      	bls.n	e4e8 <_malloc_r+0x28>
    e4dc:	230c      	movs	r3, #12
    e4de:	603b      	str	r3, [r7, #0]
    e4e0:	2600      	movs	r6, #0
    e4e2:	4630      	mov	r0, r6
    e4e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e4e8:	4e2e      	ldr	r6, [pc, #184]	; (e5a4 <_malloc_r+0xe4>)
    e4ea:	f000 f94f 	bl	e78c <__malloc_lock>
    e4ee:	6833      	ldr	r3, [r6, #0]
    e4f0:	461c      	mov	r4, r3
    e4f2:	bb34      	cbnz	r4, e542 <_malloc_r+0x82>
    e4f4:	4629      	mov	r1, r5
    e4f6:	4638      	mov	r0, r7
    e4f8:	f7ff ffc2 	bl	e480 <sbrk_aligned>
    e4fc:	1c43      	adds	r3, r0, #1
    e4fe:	4604      	mov	r4, r0
    e500:	d14d      	bne.n	e59e <_malloc_r+0xde>
    e502:	6834      	ldr	r4, [r6, #0]
    e504:	4626      	mov	r6, r4
    e506:	2e00      	cmp	r6, #0
    e508:	d140      	bne.n	e58c <_malloc_r+0xcc>
    e50a:	6823      	ldr	r3, [r4, #0]
    e50c:	4631      	mov	r1, r6
    e50e:	4638      	mov	r0, r7
    e510:	eb04 0803 	add.w	r8, r4, r3
    e514:	f000 f850 	bl	e5b8 <_sbrk_r>
    e518:	4580      	cmp	r8, r0
    e51a:	d13a      	bne.n	e592 <_malloc_r+0xd2>
    e51c:	6823      	ldr	r3, [r4, #0]
    e51e:	3503      	adds	r5, #3
    e520:	1aed      	subs	r5, r5, r3
    e522:	f025 0503 	bic.w	r5, r5, #3
    e526:	3508      	adds	r5, #8
    e528:	2d0c      	cmp	r5, #12
    e52a:	bf38      	it	cc
    e52c:	250c      	movcc	r5, #12
    e52e:	4629      	mov	r1, r5
    e530:	4638      	mov	r0, r7
    e532:	f7ff ffa5 	bl	e480 <sbrk_aligned>
    e536:	3001      	adds	r0, #1
    e538:	d02b      	beq.n	e592 <_malloc_r+0xd2>
    e53a:	6823      	ldr	r3, [r4, #0]
    e53c:	442b      	add	r3, r5
    e53e:	6023      	str	r3, [r4, #0]
    e540:	e00e      	b.n	e560 <_malloc_r+0xa0>
    e542:	6822      	ldr	r2, [r4, #0]
    e544:	1b52      	subs	r2, r2, r5
    e546:	d41e      	bmi.n	e586 <_malloc_r+0xc6>
    e548:	2a0b      	cmp	r2, #11
    e54a:	d916      	bls.n	e57a <_malloc_r+0xba>
    e54c:	1961      	adds	r1, r4, r5
    e54e:	42a3      	cmp	r3, r4
    e550:	6025      	str	r5, [r4, #0]
    e552:	bf18      	it	ne
    e554:	6059      	strne	r1, [r3, #4]
    e556:	6863      	ldr	r3, [r4, #4]
    e558:	bf08      	it	eq
    e55a:	6031      	streq	r1, [r6, #0]
    e55c:	5162      	str	r2, [r4, r5]
    e55e:	604b      	str	r3, [r1, #4]
    e560:	4638      	mov	r0, r7
    e562:	f104 060b 	add.w	r6, r4, #11
    e566:	f000 f912 	bl	e78e <__malloc_unlock>
    e56a:	f026 0607 	bic.w	r6, r6, #7
    e56e:	1d23      	adds	r3, r4, #4
    e570:	1af2      	subs	r2, r6, r3
    e572:	d0b6      	beq.n	e4e2 <_malloc_r+0x22>
    e574:	1b9b      	subs	r3, r3, r6
    e576:	50a3      	str	r3, [r4, r2]
    e578:	e7b3      	b.n	e4e2 <_malloc_r+0x22>
    e57a:	6862      	ldr	r2, [r4, #4]
    e57c:	42a3      	cmp	r3, r4
    e57e:	bf0c      	ite	eq
    e580:	6032      	streq	r2, [r6, #0]
    e582:	605a      	strne	r2, [r3, #4]
    e584:	e7ec      	b.n	e560 <_malloc_r+0xa0>
    e586:	4623      	mov	r3, r4
    e588:	6864      	ldr	r4, [r4, #4]
    e58a:	e7b2      	b.n	e4f2 <_malloc_r+0x32>
    e58c:	4634      	mov	r4, r6
    e58e:	6876      	ldr	r6, [r6, #4]
    e590:	e7b9      	b.n	e506 <_malloc_r+0x46>
    e592:	230c      	movs	r3, #12
    e594:	603b      	str	r3, [r7, #0]
    e596:	4638      	mov	r0, r7
    e598:	f000 f8f9 	bl	e78e <__malloc_unlock>
    e59c:	e7a1      	b.n	e4e2 <_malloc_r+0x22>
    e59e:	6025      	str	r5, [r4, #0]
    e5a0:	e7de      	b.n	e560 <_malloc_r+0xa0>
    e5a2:	bf00      	nop
    e5a4:	1fff14c4 	.word	0x1fff14c4

0000e5a8 <realloc>:
    e5a8:	4b02      	ldr	r3, [pc, #8]	; (e5b4 <realloc+0xc>)
    e5aa:	460a      	mov	r2, r1
    e5ac:	4601      	mov	r1, r0
    e5ae:	6818      	ldr	r0, [r3, #0]
    e5b0:	f000 b8ee 	b.w	e790 <_realloc_r>
    e5b4:	1fff0850 	.word	0x1fff0850

0000e5b8 <_sbrk_r>:
    e5b8:	b538      	push	{r3, r4, r5, lr}
    e5ba:	4d06      	ldr	r5, [pc, #24]	; (e5d4 <_sbrk_r+0x1c>)
    e5bc:	2300      	movs	r3, #0
    e5be:	4604      	mov	r4, r0
    e5c0:	4608      	mov	r0, r1
    e5c2:	602b      	str	r3, [r5, #0]
    e5c4:	f7f6 fa90 	bl	4ae8 <_sbrk>
    e5c8:	1c43      	adds	r3, r0, #1
    e5ca:	d102      	bne.n	e5d2 <_sbrk_r+0x1a>
    e5cc:	682b      	ldr	r3, [r5, #0]
    e5ce:	b103      	cbz	r3, e5d2 <_sbrk_r+0x1a>
    e5d0:	6023      	str	r3, [r4, #0]
    e5d2:	bd38      	pop	{r3, r4, r5, pc}
    e5d4:	1fff14cc 	.word	0x1fff14cc

0000e5d8 <strcmp>:
    e5d8:	f810 2b01 	ldrb.w	r2, [r0], #1
    e5dc:	f811 3b01 	ldrb.w	r3, [r1], #1
    e5e0:	2a01      	cmp	r2, #1
    e5e2:	bf28      	it	cs
    e5e4:	429a      	cmpcs	r2, r3
    e5e6:	d0f7      	beq.n	e5d8 <strcmp>
    e5e8:	1ad0      	subs	r0, r2, r3
    e5ea:	4770      	bx	lr

0000e5ec <strcpy>:
    e5ec:	4603      	mov	r3, r0
    e5ee:	f811 2b01 	ldrb.w	r2, [r1], #1
    e5f2:	f803 2b01 	strb.w	r2, [r3], #1
    e5f6:	2a00      	cmp	r2, #0
    e5f8:	d1f9      	bne.n	e5ee <strcpy+0x2>
    e5fa:	4770      	bx	lr

0000e5fc <strlen>:
    e5fc:	4603      	mov	r3, r0
    e5fe:	f813 2b01 	ldrb.w	r2, [r3], #1
    e602:	2a00      	cmp	r2, #0
    e604:	d1fb      	bne.n	e5fe <strlen+0x2>
    e606:	1a18      	subs	r0, r3, r0
    e608:	3801      	subs	r0, #1
    e60a:	4770      	bx	lr

0000e60c <strncpy>:
    e60c:	b510      	push	{r4, lr}
    e60e:	3901      	subs	r1, #1
    e610:	4603      	mov	r3, r0
    e612:	b132      	cbz	r2, e622 <strncpy+0x16>
    e614:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    e618:	f803 4b01 	strb.w	r4, [r3], #1
    e61c:	3a01      	subs	r2, #1
    e61e:	2c00      	cmp	r4, #0
    e620:	d1f7      	bne.n	e612 <strncpy+0x6>
    e622:	441a      	add	r2, r3
    e624:	2100      	movs	r1, #0
    e626:	4293      	cmp	r3, r2
    e628:	d100      	bne.n	e62c <strncpy+0x20>
    e62a:	bd10      	pop	{r4, pc}
    e62c:	f803 1b01 	strb.w	r1, [r3], #1
    e630:	e7f9      	b.n	e626 <strncpy+0x1a>

0000e632 <strstr>:
    e632:	780a      	ldrb	r2, [r1, #0]
    e634:	b570      	push	{r4, r5, r6, lr}
    e636:	b96a      	cbnz	r2, e654 <strstr+0x22>
    e638:	bd70      	pop	{r4, r5, r6, pc}
    e63a:	429a      	cmp	r2, r3
    e63c:	d109      	bne.n	e652 <strstr+0x20>
    e63e:	460c      	mov	r4, r1
    e640:	4605      	mov	r5, r0
    e642:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    e646:	2b00      	cmp	r3, #0
    e648:	d0f6      	beq.n	e638 <strstr+0x6>
    e64a:	f815 6f01 	ldrb.w	r6, [r5, #1]!
    e64e:	429e      	cmp	r6, r3
    e650:	d0f7      	beq.n	e642 <strstr+0x10>
    e652:	3001      	adds	r0, #1
    e654:	7803      	ldrb	r3, [r0, #0]
    e656:	2b00      	cmp	r3, #0
    e658:	d1ef      	bne.n	e63a <strstr+0x8>
    e65a:	4618      	mov	r0, r3
    e65c:	e7ec      	b.n	e638 <strstr+0x6>
    e65e:	Address 0x0000e65e is out of bounds.


0000e660 <_strtol_l.constprop.0>:
    e660:	2b01      	cmp	r3, #1
    e662:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e666:	d001      	beq.n	e66c <_strtol_l.constprop.0+0xc>
    e668:	2b24      	cmp	r3, #36	; 0x24
    e66a:	d906      	bls.n	e67a <_strtol_l.constprop.0+0x1a>
    e66c:	f7ff fe6c 	bl	e348 <__errno>
    e670:	2316      	movs	r3, #22
    e672:	6003      	str	r3, [r0, #0]
    e674:	2000      	movs	r0, #0
    e676:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e67a:	f8df c0e4 	ldr.w	ip, [pc, #228]	; e760 <_strtol_l.constprop.0+0x100>
    e67e:	460d      	mov	r5, r1
    e680:	462e      	mov	r6, r5
    e682:	f815 4b01 	ldrb.w	r4, [r5], #1
    e686:	f81c 7004 	ldrb.w	r7, [ip, r4]
    e68a:	f017 0708 	ands.w	r7, r7, #8
    e68e:	d1f7      	bne.n	e680 <_strtol_l.constprop.0+0x20>
    e690:	2c2d      	cmp	r4, #45	; 0x2d
    e692:	d132      	bne.n	e6fa <_strtol_l.constprop.0+0x9a>
    e694:	782c      	ldrb	r4, [r5, #0]
    e696:	2701      	movs	r7, #1
    e698:	1cb5      	adds	r5, r6, #2
    e69a:	2b00      	cmp	r3, #0
    e69c:	d05b      	beq.n	e756 <_strtol_l.constprop.0+0xf6>
    e69e:	2b10      	cmp	r3, #16
    e6a0:	d109      	bne.n	e6b6 <_strtol_l.constprop.0+0x56>
    e6a2:	2c30      	cmp	r4, #48	; 0x30
    e6a4:	d107      	bne.n	e6b6 <_strtol_l.constprop.0+0x56>
    e6a6:	782c      	ldrb	r4, [r5, #0]
    e6a8:	f004 04df 	and.w	r4, r4, #223	; 0xdf
    e6ac:	2c58      	cmp	r4, #88	; 0x58
    e6ae:	d14d      	bne.n	e74c <_strtol_l.constprop.0+0xec>
    e6b0:	786c      	ldrb	r4, [r5, #1]
    e6b2:	2310      	movs	r3, #16
    e6b4:	3502      	adds	r5, #2
    e6b6:	f107 4800 	add.w	r8, r7, #2147483648	; 0x80000000
    e6ba:	f108 38ff 	add.w	r8, r8, #4294967295
    e6be:	f04f 0e00 	mov.w	lr, #0
    e6c2:	fbb8 f9f3 	udiv	r9, r8, r3
    e6c6:	4676      	mov	r6, lr
    e6c8:	fb03 8a19 	mls	sl, r3, r9, r8
    e6cc:	f1a4 0c30 	sub.w	ip, r4, #48	; 0x30
    e6d0:	f1bc 0f09 	cmp.w	ip, #9
    e6d4:	d816      	bhi.n	e704 <_strtol_l.constprop.0+0xa4>
    e6d6:	4664      	mov	r4, ip
    e6d8:	42a3      	cmp	r3, r4
    e6da:	dd24      	ble.n	e726 <_strtol_l.constprop.0+0xc6>
    e6dc:	f1be 3fff 	cmp.w	lr, #4294967295
    e6e0:	d008      	beq.n	e6f4 <_strtol_l.constprop.0+0x94>
    e6e2:	45b1      	cmp	r9, r6
    e6e4:	d31c      	bcc.n	e720 <_strtol_l.constprop.0+0xc0>
    e6e6:	d101      	bne.n	e6ec <_strtol_l.constprop.0+0x8c>
    e6e8:	45a2      	cmp	sl, r4
    e6ea:	db19      	blt.n	e720 <_strtol_l.constprop.0+0xc0>
    e6ec:	fb06 4603 	mla	r6, r6, r3, r4
    e6f0:	f04f 0e01 	mov.w	lr, #1
    e6f4:	f815 4b01 	ldrb.w	r4, [r5], #1
    e6f8:	e7e8      	b.n	e6cc <_strtol_l.constprop.0+0x6c>
    e6fa:	2c2b      	cmp	r4, #43	; 0x2b
    e6fc:	bf04      	itt	eq
    e6fe:	782c      	ldrbeq	r4, [r5, #0]
    e700:	1cb5      	addeq	r5, r6, #2
    e702:	e7ca      	b.n	e69a <_strtol_l.constprop.0+0x3a>
    e704:	f1a4 0c41 	sub.w	ip, r4, #65	; 0x41
    e708:	f1bc 0f19 	cmp.w	ip, #25
    e70c:	d801      	bhi.n	e712 <_strtol_l.constprop.0+0xb2>
    e70e:	3c37      	subs	r4, #55	; 0x37
    e710:	e7e2      	b.n	e6d8 <_strtol_l.constprop.0+0x78>
    e712:	f1a4 0c61 	sub.w	ip, r4, #97	; 0x61
    e716:	f1bc 0f19 	cmp.w	ip, #25
    e71a:	d804      	bhi.n	e726 <_strtol_l.constprop.0+0xc6>
    e71c:	3c57      	subs	r4, #87	; 0x57
    e71e:	e7db      	b.n	e6d8 <_strtol_l.constprop.0+0x78>
    e720:	f04f 3eff 	mov.w	lr, #4294967295
    e724:	e7e6      	b.n	e6f4 <_strtol_l.constprop.0+0x94>
    e726:	f1be 3fff 	cmp.w	lr, #4294967295
    e72a:	d105      	bne.n	e738 <_strtol_l.constprop.0+0xd8>
    e72c:	2322      	movs	r3, #34	; 0x22
    e72e:	6003      	str	r3, [r0, #0]
    e730:	4646      	mov	r6, r8
    e732:	b942      	cbnz	r2, e746 <_strtol_l.constprop.0+0xe6>
    e734:	4630      	mov	r0, r6
    e736:	e79e      	b.n	e676 <_strtol_l.constprop.0+0x16>
    e738:	b107      	cbz	r7, e73c <_strtol_l.constprop.0+0xdc>
    e73a:	4276      	negs	r6, r6
    e73c:	2a00      	cmp	r2, #0
    e73e:	d0f9      	beq.n	e734 <_strtol_l.constprop.0+0xd4>
    e740:	f1be 0f00 	cmp.w	lr, #0
    e744:	d000      	beq.n	e748 <_strtol_l.constprop.0+0xe8>
    e746:	1e69      	subs	r1, r5, #1
    e748:	6011      	str	r1, [r2, #0]
    e74a:	e7f3      	b.n	e734 <_strtol_l.constprop.0+0xd4>
    e74c:	2430      	movs	r4, #48	; 0x30
    e74e:	2b00      	cmp	r3, #0
    e750:	d1b1      	bne.n	e6b6 <_strtol_l.constprop.0+0x56>
    e752:	2308      	movs	r3, #8
    e754:	e7af      	b.n	e6b6 <_strtol_l.constprop.0+0x56>
    e756:	2c30      	cmp	r4, #48	; 0x30
    e758:	d0a5      	beq.n	e6a6 <_strtol_l.constprop.0+0x46>
    e75a:	230a      	movs	r3, #10
    e75c:	e7ab      	b.n	e6b6 <_strtol_l.constprop.0+0x56>
    e75e:	bf00      	nop
    e760:	00010b95 	.word	0x00010b95

0000e764 <strtol>:
    e764:	4613      	mov	r3, r2
    e766:	460a      	mov	r2, r1
    e768:	4601      	mov	r1, r0
    e76a:	4802      	ldr	r0, [pc, #8]	; (e774 <strtol+0x10>)
    e76c:	6800      	ldr	r0, [r0, #0]
    e76e:	f7ff bf77 	b.w	e660 <_strtol_l.constprop.0>
    e772:	bf00      	nop
    e774:	1fff0850 	.word	0x1fff0850

0000e778 <tolower>:
    e778:	4b03      	ldr	r3, [pc, #12]	; (e788 <tolower+0x10>)
    e77a:	5c1b      	ldrb	r3, [r3, r0]
    e77c:	f003 0303 	and.w	r3, r3, #3
    e780:	2b01      	cmp	r3, #1
    e782:	bf08      	it	eq
    e784:	3020      	addeq	r0, #32
    e786:	4770      	bx	lr
    e788:	00010b95 	.word	0x00010b95

0000e78c <__malloc_lock>:
    e78c:	4770      	bx	lr

0000e78e <__malloc_unlock>:
    e78e:	4770      	bx	lr

0000e790 <_realloc_r>:
    e790:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e794:	4680      	mov	r8, r0
    e796:	4614      	mov	r4, r2
    e798:	460e      	mov	r6, r1
    e79a:	b921      	cbnz	r1, e7a6 <_realloc_r+0x16>
    e79c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    e7a0:	4611      	mov	r1, r2
    e7a2:	f7ff be8d 	b.w	e4c0 <_malloc_r>
    e7a6:	b92a      	cbnz	r2, e7b4 <_realloc_r+0x24>
    e7a8:	f7ff fe1e 	bl	e3e8 <_free_r>
    e7ac:	4625      	mov	r5, r4
    e7ae:	4628      	mov	r0, r5
    e7b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e7b4:	f000 f81b 	bl	e7ee <_malloc_usable_size_r>
    e7b8:	4284      	cmp	r4, r0
    e7ba:	4607      	mov	r7, r0
    e7bc:	d802      	bhi.n	e7c4 <_realloc_r+0x34>
    e7be:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
    e7c2:	d812      	bhi.n	e7ea <_realloc_r+0x5a>
    e7c4:	4621      	mov	r1, r4
    e7c6:	4640      	mov	r0, r8
    e7c8:	f7ff fe7a 	bl	e4c0 <_malloc_r>
    e7cc:	4605      	mov	r5, r0
    e7ce:	2800      	cmp	r0, #0
    e7d0:	d0ed      	beq.n	e7ae <_realloc_r+0x1e>
    e7d2:	42bc      	cmp	r4, r7
    e7d4:	4622      	mov	r2, r4
    e7d6:	4631      	mov	r1, r6
    e7d8:	bf28      	it	cs
    e7da:	463a      	movcs	r2, r7
    e7dc:	f7ff fdee 	bl	e3bc <memcpy>
    e7e0:	4631      	mov	r1, r6
    e7e2:	4640      	mov	r0, r8
    e7e4:	f7ff fe00 	bl	e3e8 <_free_r>
    e7e8:	e7e1      	b.n	e7ae <_realloc_r+0x1e>
    e7ea:	4635      	mov	r5, r6
    e7ec:	e7df      	b.n	e7ae <_realloc_r+0x1e>

0000e7ee <_malloc_usable_size_r>:
    e7ee:	f851 3c04 	ldr.w	r3, [r1, #-4]
    e7f2:	1f18      	subs	r0, r3, #4
    e7f4:	2b00      	cmp	r3, #0
    e7f6:	bfbc      	itt	lt
    e7f8:	580b      	ldrlt	r3, [r1, r0]
    e7fa:	18c0      	addlt	r0, r0, r3
    e7fc:	4770      	bx	lr
    e7fe:	Address 0x0000e7fe is out of bounds.


0000e800 <_ZL4logo>:
    e800:	0a0d 2023 2020 2020 2020 2020 2020 e220     ..#            .
    e810:	8896 96e2 e288 8896 96e2 e288 8896 95e2     ................
    e820:	2097 96e2 e288 8896 96e2 e288 8896 96e2     . ..............
    e830:	e288 8896 95e2 2097 96e2 e288 8896 95e2     ....... ........
    e840:	2097 2020 e220 8896 96e2 e288 8896 96e2     .    ...........
    e850:	e288 8896 96e2 e288 8896 95e2 e297 8896     ................
    e860:	96e2 e288 9795 96e2 e288 8896 96e2 e288     ................
    e870:	8896 96e2 e288 8896 96e2 e288 8896 95e2     ................
    e880:	0d97 230a 2020 2020 2020 2020 2020 e220     ...#           .
    e890:	8896 96e2 e288 9495 95e2 e290 9095 96e2     ................
    e8a0:	e288 8896 95e2 e297 8896 96e2 e288 9495     ................
    e8b0:	95e2 e290 9095 96e2 e288 8896 95e2 e297     ................
    e8c0:	8896 96e2 e288 9195 2020 2020 96e2 e288     ........    ....
    e8d0:	8896 95e2 e294 9095 95e2 e290 9095 95e2     ................
    e8e0:	e290 9d95 96e2 e288 8896 95e2 e291 9a95     ................
    e8f0:	95e2 e290 9095 96e2 e288 8896 95e2 e294     ................
    e900:	9095 95e2 e290 9d95 0a0d 2023 2020 2020     ..........#     
    e910:	2020 2020 2020 96e2 e288 8896 96e2 e288           ..........
    e920:	8896 96e2 e288 8896 96e2 e288 9195 96e2     ................
    e930:	e288 8896 96e2 e288 8896 96e2 e288 8896     ................
    e940:	95e2 e294 9d95 96e2 e288 8896 95e2 2091     ............... 
    e950:	2020 e220 8896 96e2 e288 8896 96e2 e288        .............
    e960:	8896 95e2 2097 e220 8896 96e2 e288 9195     .....  .........
    e970:	2020 e220 8896 96e2 e288 9195 2020 0d20        .........   .
    e980:	230a 2020 2020 2020 2020 2020 e220 8896     .#           ...
    e990:	96e2 e288 9495 95e2 e290 9095 96e2 e288     ................
    e9a0:	8896 95e2 e291 8896 96e2 e288 9495 95e2     ................
    e9b0:	e290 9095 96e2 e288 8896 95e2 e297 8896     ................
    e9c0:	96e2 e288 9195 2020 2020 96e2 e288 8896     ......    ......
    e9d0:	95e2 e294 9095 95e2 e290 9d95 2020 96e2     ............  ..
    e9e0:	e288 8896 95e2 2091 2020 96e2 e288 8896     .......   ......
    e9f0:	95e2 2091 2020 0a0d 2023 2020 2020 2020     ...   ..#       
    ea00:	2020 2020 96e2 e288 8896 95e2 2091 e220         .........  .
    ea10:	8896 96e2 e288 9195 96e2 e288 8896 96e2     ................
    ea20:	e288 8896 96e2 e288 8896 95e2 e294 9d95     ................
    ea30:	96e2 e288 8896 95e2 2091 2020 e220 8896     .........    ...
    ea40:	96e2 e288 8896 96e2 e288 8896 96e2 e288     ................
    ea50:	8896 95e2 e297 8896 96e2 e288 9195 2020     ..............  
    ea60:	e220 8896 96e2 e288 9195 2020 0d20 230a      .........   ..#
    ea70:	2020 2020 2020 2020 2020 e220 9a95 95e2                .....
    ea80:	e290 9d95 2020 95e2 e29a 9095 95e2 e29d     ....  ..........
    ea90:	9a95 95e2 e290 9095 95e2 e290 9095 95e2     ................
    eaa0:	e290 9d95 e220 9a95 95e2 e290 9d95 2020     .... .........  
    eab0:	2020 95e2 e29a 9095 95e2 e290 9095 95e2       ..............
    eac0:	e290 9095 95e2 e290 9d95 95e2 e29a 9095     ................
    ead0:	95e2 209d 2020 95e2 e29a 9095 95e2 209d     ...   ......... 
    eae0:	2020 0a0d 2023 2020 2020 2020 2020 2020       ..#           
    eaf0:	2020 2020 2020 2020 2020 2020 2020 2020                     
    eb00:	2020 2020 2020 2020 2020 2020 2020 2020                     
    eb10:	0a0d 2023 2020 2020 5f5f 5f5f 5f5f 5f5f     ..#     ________
    eb20:	5f5f 5f5f 5f20 5f5f 205f 5f5f 5f5f 5f5f     ____ ____ ______
    eb30:	5f5f 0a0d 2023 2020 2020 5f20 5f5f 202f     __..#      ___/ 
    eb40:	5f20 5f5f 2f5f 5f5f 202f 5f2f 5f2f 2020      ____/__/ /_/_  
    eb50:	5f5f 2f5f 2020 2020 2020 2020 2020 5f20     ___/           _
    eb60:	205f 2020 5f5f 5f5f 5f20 5f20 0d20 230a     _   ____ _ _ ..#
    eb70:	2020 2020 2020 5f5f 202f 5f20 2f5f 2020           __/  __/  
    eb80:	5f5f 202f 202f 5f5f 202f 202f 2020 2020     __/ / __/ /     
    eb90:	2020 2020 5f5f 5f20 2f5f 2020 205c 5f7c         __ __/  \ |_
    eba0:	205f 7c2f 7c20 7c20 0d20 230a 2020 2020     _ /| | | ..#    
    ebb0:	2020 2f5f 2020 5f2f 5f5f 2020 2f5f 2f20       _/  /___  _/ /
    ebc0:	2020 2f5f 2f20 2020 2020 2020 2020 2020       _/ /          
    ebd0:	205c 2056 202f 2928 7c20 7c20 205f 7c5c     \ V / () | |_ \|
    ebe0:	205f 5f20 0d7c 230a 2020 2020 2020 5f2f     _  _|..#      /_
    ebf0:	5f5f 5f5f 2f5f 2020 5f2f 202f 2020 5f2f     _____/  /_/   /_
    ec00:	202f 2020 2020 2020 2020 2020 5c20 2f5f     /            \_/
    ec10:	5c20 5f5f 5f28 5f29 5f5f 5f28 7c29 7c5f      \__(_)___(_)|_|
    ec20:	0d20 000a 6863 6e61 656e 206c 203c 7528      ...channel < (u
    ec30:	6e69 3374 5f32 2974 5346 5f4c 4546 5441     int32_t)FSL_FEAT
    ec40:	5255 5f45 4d44 4d41 5855 4d5f 444f 4c55     URE_DMAMUX_MODUL
    ec50:	5f45 4843 4e41 454e 004c 0000 6f76 6469     E_CHANNEL...void
    ec60:	4420 414d 554d 5f58 6e45 6261 656c 6843      DMAMUX_EnableCh
    ec70:	6e61 656e 286c 4d44 4d41 5855 545f 7079     annel(DMAMUX_Typ
    ec80:	2a65 202c 6975 746e 3233 745f 0029 0000     e*, uint32_t)...
    ec90:	3a43 555c 6573 7372 615c 7263 3065 3831     C:\Users\acre018
    eca0:	675c 7469 7568 5c62 6574 6e65 7973 3633     \github\teensy36
    ecb0:	625f 696f 656c 7072 616c 6574 645c 6972     _boilerplate\dri
    ecc0:	6576 7372 645c 7665 6369 7365 4d5c 364b     vers\devices\MK6
    ecd0:	4636 3831 645c 6972 6576 7372 662f 6c73     6F18\drivers/fsl
    ece0:	645f 616d 756d 2e78 0068 0000 6f76 6469     _dmamux.h...void
    ecf0:	4420 414d 554d 5f58 6553 5374 756f 6372      DMAMUX_SetSourc
    ed00:	2865 4d44 4d41 5855 545f 7079 2a65 202c     e(DMAMUX_Type*, 
    ed10:	6975 746e 3233 745f 202c 6975 746e 3233     uint32_t, uint32
    ed20:	745f 0029 6f76 6469 4520 4d44 5f41 6e45     _t).void EDMA_En
    ed30:	6261 656c 7341 6e79 5263 7165 6575 7473     ableAsyncRequest
    ed40:	4428 414d 545f 7079 2a65 202c 6975 746e     (DMA_Type*, uint
    ed50:	3233 745f 202c 6f62 6c6f 0029 3a43 555c     32_t, bool).C:\U
    ed60:	6573 7372 615c 7263 3065 3831 675c 7469     sers\acre018\git
    ed70:	7568 5c62 6574 6e65 7973 3633 625f 696f     hub\teensy36_boi
    ed80:	656c 7072 616c 6574 645c 6972 6576 7372     lerplate\drivers
    ed90:	645c 7665 6369 7365 4d5c 364b 4636 3831     \devices\MK66F18
    eda0:	645c 6972 6576 7372 662f 6c73 655f 6d64     \drivers/fsl_edm
    edb0:	2e61 0068 7528 6e69 3874 745f 6329 6168     a.h.(uint8_t)cha
    edc0:	6e6e 6c65 3c20 2820 6975 746e 5f38 2974     nnel < (uint8_t)
    edd0:	5346 5f4c 4546 5441 5255 5f45 4450 5f42     FSL_FEATURE_PDB_
    ede0:	4144 5f43 4e49 4554 5652 4c41 545f 4952     DAC_INTERVAL_TRI
    edf0:	4747 5245 435f 554f 544e 0000 6f76 6469     GGER_COUNT..void
    ee00:	5020 4244 535f 7465 4144 5443 6972 6767      PDB_SetDACTrigg
    ee10:	7265 6e49 6574 7672 6c61 6156 756c 2865     erIntervalValue(
    ee20:	4450 5f42 7954 6570 2c2a 7020 6264 645f     PDB_Type*, pdb_d
    ee30:	6361 745f 6972 6767 7265 635f 6168 6e6e     ac_trigger_chann
    ee40:	6c65 745f 202c 6975 746e 3233 745f 0029     el_t, uint32_t).
    ee50:	3a43 555c 6573 7372 615c 7263 3065 3831     C:\Users\acre018
    ee60:	675c 7469 7568 5c62 6574 6e65 7973 3633     \github\teensy36
    ee70:	625f 696f 656c 7072 616c 6574 645c 6972     _boilerplate\dri
    ee80:	6576 7372 645c 7665 6369 7365 4d5c 364b     vers\devices\MK6
    ee90:	4636 3831 645c 6972 6576 7372 662f 6c73     6F18\drivers/fsl
    eea0:	705f 6264 682e 0000 5245 4f52 0052 0000     _pdb.h..ERROR...
    eeb0:	4945 0054 6554 7473 6f20 7475 7570 2074     EIT.Test output 
    eec0:	6977 6874 6620 7869 6465 7020 6e69 0073     with fixed pins.
    eed0:	6554 7473 6920 706e 7475 2073 4528 5449     Test inputs (EIT
    eee0:	0029 0000 6554 7473 6520 656c 7463 6f72     )...Test electro
    eef0:	6564 6920 706e 7475 2073 7228 7761 0029     de inputs (raw).
    ef00:	6554 7473 6f20 7475 7570 2074 6f74 6920     Test output to i
    ef10:	706e 7475 6d20 7461 6972 2078 4528 5449     nput matrix (EIT
    ef20:	0029 0000 4945 2054 7228 7761 0029 0000     )...EIT (raw)...
    ef30:	6f4c 2077 6572 6f73 756c 6974 6e6f 2820     Low resolution (
    ef40:	3631 5020 696f 746e 0029 0000 6948 6867     16 Point)...High
    ef50:	7220 7365 6c6f 7475 6f69 206e 3328 2030      resolution (30 
    ef60:	6f50 6e69 2974 0000 0a0d 7320 6d5f 6165     Point).... s_mea
    ef70:	206e 203a 0000 0000 202c 5f69 656d 6e61     n : ...., i_mean
    ef80:	3a20 0020 202c 5f71 656d 6e61 3a20 0020      : ., q_mean : .
    ef90:	202c 616d 6e67 7469 6475 2065 203a 0000     , magnitude : ..
    efa0:	202c 6870 7361 2065 203a 0000 0a0d 0000     , phase : ......
    efb0:	0a0d 616d 6e67 7469 6475 7365 203a 0000     ..magnitudes: ..
    efc0:	202c 0000 0a0d 0a0d 6946 6578 2064 754f     , ......Fixed Ou
    efd0:	7074 7475 4420 6972 6576 3120 322c 202c     tput Drive 1,2, 
    efe0:	6553 736e 2065 2c33 2034 203a 0a0d 0000     Sense 3,4 : ....
    eff0:	0a0d 754f 7074 7475 7620 2073 6e49 7570     ..Output vs Inpu
    f000:	2074 614d 7274 7869 0000 0000 0a0d 6944     t Matrix......Di
    f010:	7473 203a 0000 0000 0a0d 2b4f 4f2c 2c2d     st: ......O+,O-,
    f020:	0009 0000 092c 0000 0a0d 6c45 6365 7274     ....,.....Electr
    f030:	646f 2065 6e49 7570 7374 5220 7761 5620     ode Inputs Raw V
    f040:	6c61 6575 0073 0000 0a0d 6e49 7570 7374     alues.....Inputs
    f050:	0000 0000 0a0d 4945 2054 6152 2077 6164     ......EIT Raw da
    f060:	6174 0020 0a0d 2b4f 4f2c 2c2d 4909 2c2b     ta ...O+,O-,.I+,
    f070:	2d49 092c 6153 706d 656c 0073 6153 706d     I-,.Samples.Samp
    f080:	696c 676e 3a20 0d20 000a 0000 7309 6d61     ling : ......sam
    f090:	6c70 7365 203a 0000 6d09 6e69 203a 0000     ples: ...min: ..
    f0a0:	6d09 7861 203a 0000 6d09 6165 3a6e 0020     .max: ...mean: .
    f0b0:	7309 6769 616d 203a 0000 0000 5b20 0000     .sigma: .... [..
    f0c0:	0a0d 2023 0000 0000 4120 4942 4520 5449     ..# .... ABI EIT
    f0d0:	2820 7620 2e30 2e33 2034 0029 4420 4245      ( v0.3.4 ). DEB
    f0e0:	4755 4220 4955 444c 0020 0000 203a 0000     UG BUILD ...: ..
    f0f0:	7274 6575 0000 0000 6166 736c 0065 0000     true....false...
    f100:	0031 0000 6f50 7373 6269 656c 7620 6c61     1...Possible val
    f110:	6575 2073 203a 0000 6c61 2c6c 0020 0000     ues : ..all, ...
    f120:	6164 4d63 646f 2c65 0020 0000 6564 616c     dacMode, ...dela
    f130:	2c79 0020 6964 7473 202c 0000 6c65 6365     y, .dist, ..elec
    f140:	7274 646f 7365 202c 0000 0000 6e69 7570     trodes, ....inpu
    f150:	4774 6961 526e 7365 7369 6f74 3172 202c     tGainResistor1, 
    f160:	0000 0000 6e69 7570 4774 6961 526e 7365     ....inputGainRes
    f170:	7369 6f74 3272 202c 0000 0000 6f6d 6564     istor2, ....mode
    f180:	202c 0000 756f 7074 7475 6147 6e69 6552     , ..outputGainRe
    f190:	6973 7473 726f 202c 0000 0000 6173 706d     sistor, ....samp
    f1a0:	656c 7943 6c63 7365 202c 0000 6173 706d     leCycles, ..samp
    f1b0:	656c 5073 7265 7943 6c63 2c65 0020 0000     lesPerCycle, ...
    f1c0:	6173 706d 656c 7552 6262 7369 2c68 0020     sampleRubbish, .
    f1d0:	616d 5470 4c6f 6e69 7365 202c 0000 0000     mapToLines, ....
    f1e0:	7355 6761 2065 203a 6567 2074 6176 756c     Usage : get valu
    f1f0:	4e65 6d61 0d65 000a 7355 6761 2065 203a     eName...Usage : 
    f200:	6573 2074 6176 756c 4e65 6d61 2065 6176     set valueName va
    f210:	756c 0d65 000a 0000 6e20 746f 7620 6c61     lue..... not val
    f220:	6469 0d21 000a 0000 6f50 7373 6269 656c     id!.....Possible
    f230:	6320 6d6f 616d 646e 2073 203a 0000 0000      commands : ....
    f240:	7473 706f 202c 7473 7261 2c74 7320 7465     stop, start, set
    f250:	202c 6567 2c74 6820 6c65 0070 6f43 6d6d     , get, help.Comm
    f260:	6e61 2064 0027 0000 2027 6f6e 2074 6176     and '...' not va
    f270:	696c 2164 0a0d 0000 6c61 006c 6f6d 6564     lid!....all.mode
    f280:	0000 0000 6164 4d63 646f 0065 6564 616c     ....dacMode.dela
    f290:	0079 0000 6d20 0073 6964 7473 0000 0000     y... ms.dist....
    f2a0:	6c65 6365 7274 646f 7365 0000 6e69 7570     electrodes..inpu
    f2b0:	4774 6961 526e 7365 7369 6f74 3172 0000     tGainResistor1..
    f2c0:	6f20 6d68 0073 0000 6e69 7570 4774 6961      ohms...inputGai
    f2d0:	526e 7365 7369 6f74 3272 0000 756f 7074     nResistor2..outp
    f2e0:	7475 6147 6e69 6552 6973 7473 726f 0000     utGainResistor..
    f2f0:	6173 706d 656c 7943 6c63 7365 0000 0000     sampleCycles....
    f300:	6173 706d 656c 5073 7265 7943 6c63 0065     samplesPerCycle.
    f310:	6173 706d 656c 7552 6262 7369 0068 0000     sampleRubbish...
    f320:	616d 5470 4c6f 6e69 7365 0000 6461 4663     mapToLines..adcF
    f330:	6572 7571 6e65 7963 0000 0000 4820 007a     requency.... Hz.
    f340:	7572 006e 6173 706d 656c 0073 6173 706d     run.samples.samp
    f350:	656c 5573 6573 7566 006c 0000 6174 6772     lesUseful...targ
    f360:	7465 7246 7165 6575 636e 0079 6174 6772     etFrequency.targ
    f370:	7465 6550 6972 646f 0000 0000 ce20 73bc     etPeriod.... ..s
    f380:	0000 0000 6164 5063 696f 746e 0073 0000     ....dacPoints...
    f390:	6470 4362 6379 656c 654c 676e 6874 0000     pdbCycleLength..
    f3a0:	6164 5463 6972 6767 7265 6e49 6574 7672     dacTriggerInterv
    f3b0:	6c61 0000 6470 4d62 646f 0000 6567 0074     al..pdbMod..get.
    f3c0:	6164 6d63 646f 0065 6e69 7570 6774 6961     dacmode.inputgai
    f3d0:	726e 7365 7369 6f74 3172 0000 6e69 7570     nresistor1..inpu
    f3e0:	6774 6961 726e 7365 7369 6f74 3272 0000     tgainresistor2..
    f3f0:	756f 7074 7475 6167 6e69 6572 6973 7473     outputgainresist
    f400:	726f 0000 6173 706d 656c 7963 6c63 7365     or..samplecycles
    f410:	0000 0000 6173 706d 656c 7073 7265 7963     ....samplespercy
    f420:	6c63 0065 6173 706d 656c 7572 6262 7369     cle.samplerubbis
    f430:	0068 0000 6461 6663 6572 7571 6e65 7963     h...adcfrequency
    f440:	0000 0000 6173 706d 656c 7573 6573 7566     ....samplesusefu
    f450:	006c 0000 6174 6772 7465 7266 7165 6575     l...targetfreque
    f460:	636e 0079 6174 6772 7465 6570 6972 646f     ncy.targetperiod
    f470:	0000 0000 6470 6362 6379 656c 656c 676e     ....pdbcycleleng
    f480:	6874 0000 6164 7463 6972 6767 7265 6e69     th..dactriggerin
    f490:	6574 7672 6c61 0000 6470 6d62 646f 0000     terval..pdbmod..
    f4a0:	6573 0074 0020 0000 0000 0000 6568 706c     set. .......help
    f4b0:	0000 0000 003f 0000 7473 7261 0074 0000     ....?...start...
    f4c0:	7473 706f ff00 ffff                         stop....

0000f4c8 <_ZL9mcgConfig>:
    f4c8:	0007 0000 0004 0000 0140 001d               ........@...

0000f4d4 <_ZL9simConfig>:
    f4d4:	0000 0000 0000 0106                         ........

0000f4dc <_ZL9oscConfig>:
    f4dc:	2400 00f4 040a 0080                         .$......

0000f4e4 <_ZL10LED_Config>:
    f4e4:	0101 ffff                                   ....

0000f4e8 <_ZL9TP_Config>:
    f4e8:	0101 ffff                                   ....

0000f4ec <_ZL13ADCFLG_Config>:
    f4ec:	0101 ffff                                   ....

0000f4f0 <_ZL17g_dacValuesLowRes>:
    f4f0:	0ae9 0acc 0a7b 0a03 0974 08e6 086d 081c     ....{...t...m...
    f500:	0800 081c 086d 08e6 0974 0a03 0a7b 0acc     ....m...t...{...

0000f510 <_ZL18g_dacValuesHighRes>:
    f510:	0ae9 0ae0 0ac8 0aa1 0a6d 0a2e 09e7 099b     ........m.......
    f520:	094d 0901 08ba 087b 0847 0820 0808 0800     M.....{.G. .....

0000f530 <_ZL16ADC_sense_config>:
    f530:	0004 0000 0001 0000 616e 006e 6e69 0066     ........nan.inf.
    f540:	766f 0066                                   ovf.

0000f544 <_ZTV16usb_serial_class>:
	...
    f54c:	6099 0000 60b7 0000 60d5 0000 06b3 0000     .`...`...`......
    f55c:	606d 0000 6083 0000 069d 0000 06c7 0000     m`...`..........

0000f56c <usb_descriptor_list>:
    f56c:	0100 0000 07a4 1fff 0012 0000 0200 0000     ................
    f57c:	07b8 1fff 0043 0000 0300 0000 07fc 1fff     ....C...........
    f58c:	0000 0000 0301 0409 0800 1fff 0000 0000     ................
    f59c:	0302 0409 0818 1fff 0000 0000 0303 0409     ................
    f5ac:	0830 1fff 0000 0000 0000 0000 0000 0000     0...............
    f5bc:	0000 0000                                   ....

0000f5c0 <usb_endpoint_config_table>:
    f5c0:	1500 1519 6e69 7473 6e61 6563 3c20 4120     ....instance < A
    f5d0:	5252 5941 535f 5a49 2845 5f73 7067 6f69     RRAY_SIZE(s_gpio
    f5e0:	6142 6573 2973 0000 3a43 555c 6573 7372     Bases)..C:\Users
    f5f0:	615c 7263 3065 3831 675c 7469 7568 5c62     \acre018\github\
    f600:	6574 6e65 7973 3633 625f 696f 656c 7072     teensy36_boilerp
    f610:	616c 6574 645c 6972 6576 7372 645c 7665     late\drivers\dev
    f620:	6369 7365 4d5c 364b 4636 3831 645c 6972     ices\MK66F18\dri
    f630:	6576 7372 665c 6c73 675f 6970 2e6f 0063     vers\fsl_gpio.c.
    f640:	554e 4c4c 2120 203d 6f63 666e 6769 ff00     NULL != config..

0000f650 <__func__.0>:
    f650:	5047 4f49 505f 6e69 6e49 7469 ff00 ffff     GPIO_PinInit....
    f660:	5530 2120 203d 5f67 7478 6c61 4630 6572     0U != g_xtal0Fre
    f670:	0071 0000 3a43 555c 6573 7372 615c 7263     q...C:\Users\acr
    f680:	3065 3831 675c 7469 7568 5c62 6574 6e65     e018\github\teen
    f690:	7973 3633 625f 696f 656c 7072 616c 6574     sy36_boilerplate
    f6a0:	645c 6972 6576 7372 645c 7665 6369 7365     \drivers\devices
    f6b0:	4d5c 364b 4636 3831 645c 6972 6576 7372     \MK66F18\drivers
    f6c0:	665c 6c73 635f 6f6c 6b63 632e 0000 0000     \fsl_clock.c....
    f6d0:	5530 2120 203d 5f67 7478 6c61 3233 7246     0U != g_xtal32Fr
    f6e0:	7165 0000 5f67 7478 6c61 4630 6572 0071     eq..g_xtal0Freq.
    f6f0:	5f67 7478 6c61 3233 7246 7165 0000 0000     g_xtal32Freq....
    f700:	436b 4f4c 4b43 555f 6273 7253 5563 6273     kCLOCK_UsbSrcUsb
    f710:	6650 2064 3d21 7320 6372 0000 434d 2d47     Pfd != src..MCG-
    f720:	433e 2031 2026 434d 5f47 3143 495f 4352     >C1 & MCG_C1_IRC
    f730:	4b4c 4e45 4d5f 5341 004b 0000 4d28 4743     LKEN_MASK...(MCG
    f740:	3e2d 3243 2620 4d20 4743 435f 5f32 5249     ->C2 & MCG_C2_IR
    f750:	5343 4d5f 5341 294b 3d20 203d 5530 0000     CS_MASK) == 0U..
    f760:	534f 3043 3e2d 5243 2620 4f20 4353 435f     OSC0->CR & OSC_C
    f770:	5f52 5245 4c43 454b 5f4e 414d 4b53 0000     R_ERCLKEN_MASK..
    f780:	6628 6172 2063 3d3c 3320 5535 2029 2626     (frac <= 35U) &&
    f790:	2820 7266 6361 3e20 203d 3831 2955 0000      (frac >= 18U)..
    f7a0:	636d 7067 6c6c 6330 6b6c 0000 6f63 666e     mcgpll0clk..conf
    f7b0:	6769 0000 6166 736c 0065 ffff               ig..false...

0000f7bc <mcgModeMatrix>:
    f7bc:	0100 0301 0404 0404 0100 0302 0404 0404     ................
    f7cc:	0101 0102 0101 0101 0100 0301 0404 0404     ................
    f7dc:	0100 0301 0504 0606 0404 0404 0504 0606     ................
    f7ec:	0404 0404 0504 0706 0606 0606 0606 0606     ................

0000f7fc <__func__.13>:
    f7fc:	4c43 434f 5f4b 6547 4d74 6763 7845 4374     CLOCK_GetMcgExtC
    f80c:	6b6c 7246 7165 ff00                         lkFreq..

0000f814 <__func__.12>:
    f814:	4c43 434f 5f4b 6547 4f74 6373 4530 4372     CLOCK_GetOsc0ErC
    f824:	6b6c 6e55 6964 4676 6572 0071               lkUndivFreq.

0000f830 <__func__.11>:
    f830:	4c43 434f 5f4b 6547 4f74 6373 4530 4372     CLOCK_GetOsc0ErC
    f840:	6b6c 6944 4676 6572 0071 ffff               lkDivFreq...

0000f84c <__func__.10>:
    f84c:	4c43 434f 5f4b 6547 4574 3372 6b32 6c43     CLOCK_GetEr32kCl
    f85c:	466b 6572 0071 ffff                         kFreq...

0000f864 <__func__.9>:
    f864:	4c43 434f 5f4b 6e45 6261 656c 7355 6662     CLOCK_EnableUsbf
    f874:	3073 6c43 636f 006b                         s0Clock.

0000f87c <fllFactorTable.6>:
    f87c:	0280 02dc 0500 05b8 0780 0895 0a00 0b71     ..............q.

0000f88c <__func__.5>:
    f88c:	4c43 434f 5f4b 6547 5074 6c6c 4630 6572     CLOCK_GetPll0Fre
    f89c:	0071 ffff                                   q...

0000f8a0 <__func__.4>:
    f8a0:	4c43 434f 5f4b 6e45 6261 656c 6c50 306c     CLOCK_EnablePll0
    f8b0:	ff00 ffff                                   ....

0000f8b4 <__func__.2>:
    f8b4:	4c43 434f 5f4b 6553 5074 6562 6f4d 6564     CLOCK_SetPbeMode
    f8c4:	ff00 ffff                                   ....

0000f8c8 <__func__.0>:
    f8c8:	4c43 434f 5f4b 6553 4d74 6763 6f43 666e     CLOCK_SetMcgConf
    f8d8:	6769 ff00                                   ig..

0000f8dc <s_adc16Bases>:
    f8dc:	b000 4003 b000 400b                         ...@...@

0000f8e4 <s_adc16Clocks>:
    f8e4:	001b 103c 001b 1030 6e69 7473 6e61 6563     ..<...0.instance
    f8f4:	3c20 4120 5252 5941 535f 5a49 2845 5f73      < ARRAY_SIZE(s_
    f904:	6461 3163 4236 7361 7365 0029 3a43 555c     adc16Bases).C:\U
    f914:	6573 7372 615c 7263 3065 3831 675c 7469     sers\acre018\git
    f924:	7568 5c62 6574 6e65 7973 3633 625f 696f     hub\teensy36_boi
    f934:	656c 7072 616c 6574 645c 6972 6576 7372     lerplate\drivers
    f944:	645c 7665 6369 7365 4d5c 364b 4636 3831     \devices\MK66F18
    f954:	645c 6972 6576 7372 665c 6c73 615f 6364     \drivers\fsl_adc
    f964:	3631 632e 0000 0000 554e 4c4c 2120 203d     16.c....NULL != 
    f974:	6f63 666e 6769 0000 6166 736c 0065 0000     config..false...
    f984:	6863 6e61 656e 476c 6f72 7075 3c20 4120     channelGroup < A
    f994:	4344 535f 3143 435f 554f 544e ff00 ffff     DC_SC1_COUNT....

0000f9a4 <__func__.5>:
    f9a4:	4441 3143 5f36 6547 4974 736e 6174 636e     ADC16_GetInstanc
    f9b4:	0065 ffff                                   e...

0000f9b8 <__func__.4>:
    f9b8:	4441 3143 5f36 6e49 7469 ff00               ADC16_Init..

0000f9c4 <__func__.1>:
    f9c4:	4441 3143 5f36 6553 4374 6168 6e6e 6c65     ADC16_SetChannel
    f9d4:	6f43 666e 6769 ff00                         Config..

0000f9dc <__func__.0>:
    f9dc:	4441 3143 5f36 6547 4374 6168 6e6e 6c65     ADC16_GetChannel
    f9ec:	7453 7461 7375 6c46 6761 0073 6e69 7473     StatusFlags.inst
    f9fc:	6e61 6563 3c20 4120 5252 5941 535f 5a49     ance < ARRAY_SIZ
    fa0c:	2845 5f73 6d64 6d61 7875 6142 6573 2973     E(s_dmamuxBases)
    fa1c:	0000 0000 3a43 555c 6573 7372 615c 7263     ....C:\Users\acr
    fa2c:	3065 3831 675c 7469 7568 5c62 6574 6e65     e018\github\teen
    fa3c:	7973 3633 625f 696f 656c 7072 616c 6574     sy36_boilerplate
    fa4c:	645c 6972 6576 7372 645c 7665 6369 7365     \drivers\devices
    fa5c:	4d5c 364b 4636 3831 645c 6972 6576 7372     \MK66F18\drivers
    fa6c:	665c 6c73 645f 616d 756d 2e78 0063 ffff     \fsl_dmamux.c...

0000fa7c <__func__.0>:
    fa7c:	4d44 4d41 5855 475f 7465 6e49 7473 6e61     DMAMUX_GetInstan
    fa8c:	6563 ff00                                   ce..

0000fa90 <s_edmaIRQNumber>:
    fa90:	0100 0302 0504 0706 0908 0b0a 0d0c 0f0e     ................
    faa0:	0100 0302 0504 0706 0908 0b0a 0d0c 0f0e     ................
    fab0:	6e69 7473 6e61 6563 3c20 4120 5252 5941     instance < ARRAY
    fac0:	535f 5a49 2845 5f73 6465 616d 6142 6573     _SIZE(s_edmaBase
    fad0:	2973 0000 3a43 555c 6573 7372 615c 7263     s)..C:\Users\acr
    fae0:	3065 3831 675c 7469 7568 5c62 6574 6e65     e018\github\teen
    faf0:	7973 3633 625f 696f 656c 7072 616c 6574     sy36_boilerplate
    fb00:	645c 6972 6576 7372 645c 7665 6369 7365     \drivers\devices
    fb10:	4d5c 364b 4636 3831 645c 6972 6576 7372     \MK66F18\drivers
    fb20:	665c 6c73 655f 6d64 2e61 0063 6863 6e61     \fsl_edma.c.chan
    fb30:	656e 206c 203c 7528 6e69 3374 5f32 2974     nel < (uint32_t)
    fb40:	5346 5f4c 4546 5441 5255 5f45 4445 414d     FSL_FEATURE_EDMA
    fb50:	4d5f 444f 4c55 5f45 4843 4e41 454e 004c     _MODULE_CHANNEL.
    fb60:	6374 2064 3d21 4e20 4c55 004c 2828 6975     tcd != NULL.((ui
    fb70:	746e 3233 745f 7429 6463 2620 3020 3178     nt32_t)tcd & 0x1
    fb80:	5546 2029 3d3d 3020 0055 0000 6f63 666e     FU) == 0U...conf
    fb90:	6769 2120 203d 554e 4c4c 0000 2828 6975     ig != NULL..((ui
    fba0:	746e 3233 745f 6e29 7865 5474 6463 2620     nt32_t)nextTcd &
    fbb0:	3020 3178 5546 2029 3d3d 3020 0055 0000      0x1FU) == 0U...
    fbc0:	696c 6b6e 6465 6843 6e61 656e 206c 203c     linkedChannel < 
    fbd0:	7528 6e69 3374 5f32 2974 5346 5f4c 4546     (uint32_t)FSL_FE
    fbe0:	5441 5255 5f45 4445 414d 4d5f 444f 4c55     ATURE_EDMA_MODUL
    fbf0:	5f45 4843 4e41 454e 004c 0000 6328 6e6f     E_CHANNEL...(con
    fc00:	6966 2d67 733e 6372 6441 7264 2520 2820     fig->srcAddr % (
    fc10:	5531 204c 3c3c 2820 6975 746e 3233 745f     1UL << (uint32_t
    fc20:	6329 6e6f 6966 2d67 733e 6372 7254 6e61     )config->srcTran
    fc30:	6673 7265 6953 657a 2929 3d20 203d 5530     sferSize)) == 0U
    fc40:	0000 0000 6328 6e6f 6966 2d67 643e 7365     ....(config->des
    fc50:	4174 6464 2072 2025 3128 4c55 3c20 203c     tAddr % (1UL << 
    fc60:	7528 6e69 3374 5f32 2974 6f63 666e 6769     (uint32_t)config
    fc70:	3e2d 6564 7473 7254 6e61 6673 7265 6953     ->destTransferSi
    fc80:	657a 2929 3d20 203d 5530 0000 7473 7261     ze)) == 0U..star
    fc90:	4974 736e 6174 636e 4e65 6d75 3c20 203d     tInstanceNum <= 
    fca0:	6e69 7473 6e61 6563 0000 0000 6168 646e     instance....hand
    fcb0:	656c 2120 203d 554e 4c4c 0000 2828 6975     le != NULL..((ui
    fcc0:	746e 3233 745f 7429 6463 6f50 6c6f 2620     nt32_t)tcdPool &
    fcd0:	3020 3178 5546 2029 3d3d 3020 0055 0000      0x1FU) == 0U...
    fce0:	6166 736c 0065 0000 7273 4163 6464 2072     false...srcAddr 
    fcf0:	3d21 4e20 4c55 004c 6564 7473 6441 7264     != NULL.destAddr
    fd00:	2120 203d 554e 4c4c 0000 0000 7328 6372      != NULL....(src
    fd10:	6957 7464 2068 3d21 3020 2955 2620 2026     Width != 0U) && 
    fd20:	7328 6372 6957 7464 2068 3d3c 3320 5532     (srcWidth <= 32U
    fd30:	2029 2626 2820 7328 6372 6957 7464 2068     ) && ((srcWidth 
    fd40:	2026 7328 6372 6957 7464 2068 202d 5531     & (srcWidth - 1U
    fd50:	2929 3d20 203d 5530 0029 0000 6428 7365     )) == 0U)...(des
    fd60:	5774 6469 6874 2120 203d 5530 2029 2626     tWidth != 0U) &&
    fd70:	2820 6564 7473 6957 7464 2068 3d3c 3320      (destWidth <= 3
    fd80:	5532 2029 2626 2820 6428 7365 5774 6469     2U) && ((destWid
    fd90:	6874 2620 2820 6564 7473 6957 7464 2068     th & (destWidth 
    fda0:	202d 5531 2929 3d20 203d 5530 0029 0000     - 1U)) == 0U)...
    fdb0:	7428 6172 736e 6566 4272 7479 7365 2520     (transferBytes %
    fdc0:	6220 7479 7365 6145 6863 6552 7571 7365      bytesEachReques
    fdd0:	2974 3d20 203d 5530 0000 0000 2828 7528     t) == 0U....(((u
    fde0:	6e69 3374 5f32 2974 7528 6e69 3374 5f32     int32_t)(uint32_
    fdf0:	2074 292a 7273 4163 6464 2972 2520 7320     t *)srcAddr) % s
    fe00:	6372 6957 7464 2968 3d20 203d 5530 0000     rcWidth) == 0U..
    fe10:	2828 7528 6e69 3374 5f32 2974 7528 6e69     (((uint32_t)(uin
    fe20:	3374 5f32 2074 292a 6564 7473 6441 7264     t32_t *)destAddr
    fe30:	2029 2025 6564 7473 6957 7464 2968 3d20     ) % destWidth) =
    fe40:	203d 5530 ff00 ffff                         = 0U....

0000fe48 <__func__.36>:
    fe48:	4445 414d 475f 7465 6e49 7473 6e61 6563     EDMA_GetInstance
    fe58:	ff00 ffff                                   ....

0000fe5c <__func__.34>:
    fe5c:	4445 414d 495f 696e 0074 ffff               EDMA_Init...

0000fe68 <__func__.33>:
    fe68:	4445 414d 475f 7465 6544 6166 6c75 4374     EDMA_GetDefaultC
    fe78:	6e6f 6966 0067 ffff                         onfig...

0000fe80 <__func__.31>:
    fe80:	4445 414d 535f 7465 7254 6e61 6673 7265     EDMA_SetTransfer
    fe90:	6f43 666e 6769 ff00                         Config..

0000fe98 <__func__.24>:
    fe98:	4445 414d 455f 616e 6c62 4365 6168 6e6e     EDMA_EnableChann
    fea8:	6c65 6e49 6574 7272 7075 7374 ff00 ffff     elInterrupts....

0000feb8 <__func__.21>:
    feb8:	4445 414d 545f 6463 6553 5474 6172 736e     EDMA_TcdSetTrans
    fec8:	6566 4372 6e6f 6966 0067 ffff               ferConfig...

0000fed4 <__func__.13>:
    fed4:	4445 414d 475f 7465 6843 6e61 656e 536c     EDMA_GetChannelS
    fee4:	6174 7574 4673 616c 7367 ff00               tatusFlags..

0000fef0 <__func__.12>:
    fef0:	4445 414d 435f 656c 7261 6843 6e61 656e     EDMA_ClearChanne
    ff00:	536c 6174 7574 4673 616c 7367 ff00 ffff     lStatusFlags....

0000ff10 <__func__.10>:
    ff10:	4445 414d 475f 7465 6e49 7473 6e61 6563     EDMA_GetInstance
    ff20:	664f 7366 7465 ff00                         Offset..

0000ff28 <__func__.9>:
    ff28:	4445 414d 435f 6572 7461 4865 6e61 6c64     EDMA_CreateHandl
    ff38:	0065 ffff                                   e...

0000ff3c <__func__.7>:
    ff3c:	4445 414d 535f 7465 6143 6c6c 6162 6b63     EDMA_SetCallback
    ff4c:	ff00 ffff                                   ....

0000ff50 <__func__.6>:
    ff50:	4445 414d 545f 6172 736e 6566 5772 6469     EDMA_TransferWid
    ff60:	6874 614d 7070 6e69 0067 ffff               thMapping...

0000ff6c <__func__.5>:
    ff6c:	4445 414d 505f 6572 6170 6572 7254 6e61     EDMA_PrepareTran
    ff7c:	6673 7265 6f43 666e 6769 ff00               sferConfig..

0000ff88 <__func__.4>:
    ff88:	4445 414d 505f 6572 6170 6572 7254 6e61     EDMA_PrepareTran
    ff98:	6673 7265 ff00 ffff                         sfer....

0000ffa0 <__func__.2>:
    ffa0:	4445 414d 535f 6174 7472 7254 6e61 6673     EDMA_StartTransf
    ffb0:	7265 ff00                                   er..

0000ffb4 <__func__.0>:
    ffb4:	4445 414d 485f 6e61 6c64 4965 5152 ff00     EDMA_HandleIRQ..
    ffc4:	6e69 7473 6e61 6563 3c20 4120 5252 5941     instance < ARRAY
    ffd4:	535f 5a49 2845 5f73 6470 4262 7361 7365     _SIZE(s_pdbBases
    ffe4:	0029 0000 3a43 555c 6573 7372 615c 7263     )...C:\Users\acr
    fff4:	3065 3831 675c 7469 7568 5c62 6574 6e65     e018\github\teen
   10004:	7973 3633 625f 696f 656c 7072 616c 6574     sy36_boilerplate
   10014:	645c 6972 6576 7372 645c 7665 6369 7365     \drivers\devices
   10024:	4d5c 364b 4636 3831 645c 6972 6576 7372     \MK66F18\drivers
   10034:	665c 6c73 705f 6264 632e 0000 554e 4c4c     \fsl_pdb.c..NULL
   10044:	2120 203d 6f63 666e 6769 0000 7528 6e69      != config..(uin
   10054:	3874 745f 6329 6168 6e6e 6c65 3c20 2820     t8_t)channel < (
   10064:	6975 746e 5f38 2974 5346 5f4c 4546 5441     uint8_t)FSL_FEAT
   10074:	5255 5f45 4450 5f42 4144 5f43 4e49 4554     URE_PDB_DAC_INTE
   10084:	5652 4c41 545f 4952 4747 5245 435f 554f     RVAL_TRIGGER_COU
   10094:	544e ff00                                   NT..

00010098 <__func__.3>:
   10098:	4450 5f42 6547 4974 736e 6174 636e 0065     PDB_GetInstance.

000100a8 <__func__.2>:
   100a8:	4450 5f42 6e49 7469 ff00 ffff               PDB_Init....

000100b4 <__func__.0>:
   100b4:	4450 5f42 6553 4474 4341 7254 6769 6567     PDB_SetDACTrigge
   100c4:	4372 6e6f 6966 0067                         rConfig.

000100cc <s_dacBases>:
   100cc:	c000 400c d000 400c                         ...@...@

000100d4 <s_dacClocks>:
   100d4:	000c 102c 000d 102c 6e69 7473 6e61 6563     ..,...,.instance
   100e4:	3c20 4120 5252 5941 535f 5a49 2845 5f73      < ARRAY_SIZE(s_
   100f4:	6164 4263 7361 7365 0029 0000 3a43 555c     dacBases)...C:\U
   10104:	6573 7372 615c 7263 3065 3831 675c 7469     sers\acre018\git
   10114:	7568 5c62 6574 6e65 7973 3633 625f 696f     hub\teensy36_boi
   10124:	656c 7072 616c 6574 645c 6972 6576 7372     lerplate\drivers
   10134:	645c 7665 6369 7365 4d5c 364b 4636 3831     \devices\MK66F18
   10144:	645c 6972 6576 7372 665c 6c73 645f 6361     \drivers\fsl_dac
   10154:	632e 0000 554e 4c4c 2120 203d 6f63 666e     .c..NULL != conf
   10164:	6769 0000 6e69 6564 2078 203c 4144 5f43     ig..index < DAC_
   10174:	4144 4c54 435f 554f 544e ff00               DATL_COUNT..

00010180 <__func__.6>:
   10180:	4144 5f43 6547 4974 736e 6174 636e 0065     DAC_GetInstance.

00010190 <__func__.5>:
   10190:	4144 5f43 6e49 7469 ff00 ffff               DAC_Init....

0001019c <__func__.4>:
   1019c:	4144 5f43 6547 4474 6665 7561 746c 6f43     DAC_GetDefaultCo
   101ac:	666e 6769 ff00 ffff                         nfig....

000101b4 <__func__.3>:
   101b4:	4144 5f43 6553 4274 6675 6566 4372 6e6f     DAC_SetBufferCon
   101c4:	6966 0067                                   fig.

000101c8 <__func__.2>:
   101c8:	4144 5f43 6547 4474 6665 7561 746c 7542     DAC_GetDefaultBu
   101d8:	6666 7265 6f43 666e 6769 ff00               fferConfig..

000101e4 <__func__.1>:
   101e4:	4144 5f43 6553 4274 6675 6566 5672 6c61     DAC_SetBufferVal
   101f4:	6575 ff00                                   ue..

000101f8 <__func__.0>:
   101f8:	4144 5f43 6553 4274 6675 6566 5272 6165     DAC_SetBufferRea
   10208:	5064 696f 746e 7265 ff00 ffff 6f63 666e     dPointer....conf
   10218:	6769 0000 6f76 6469 5020 524f 5f54 6553     ig..void PORT_Se
   10228:	5074 6e69 6f43 666e 6769 5028 524f 5f54     tPinConfig(PORT_
   10238:	7954 6570 2c2a 7520 6e69 3374 5f32 2c74     Type*, uint32_t,
   10248:	6320 6e6f 7473 7020 726f 5f74 6970 5f6e      const port_pin_
   10258:	6f63 666e 6769 745f 292a 0000 3a43 555c     config_t*)..C:\U
   10268:	6573 7372 615c 7263 3065 3831 675c 7469     sers\acre018\git
   10278:	7568 5c62 6574 6e65 7973 3633 625f 696f     hub\teensy36_boi
   10288:	656c 7072 616c 6574 645c 6972 6576 7372     lerplate\drivers
   10298:	645c 7665 6369 7365 4d5c 364b 4636 3831     \devices\MK66F18
   102a8:	645c 6972 6576 7372 662f 6c73 705f 726f     \drivers/fsl_por
   102b8:	2e74 0068 0101 ffff                         t.h.....

000102c0 <_ZL20FrequencyRegisterLUT>:
   102c0:	4000 8000                                   .@..

000102c4 <_ZL16PhaseRegisterLUT>:
   102c4:	c000 e000                                   ....

000102c8 <_ZL12WriteModeLUT>:
   102c8:	0000 1000 2000 ffff                         ..... ..

000102d0 <_ZL13OutputModeLUT>:
   102d0:	0200 2820                                   .. (

000102d4 <_ZL12SleepModeLUT>:
   102d4:	4000 c080 2028 616d 2078 3d3e 7620 6c61     .@..( max >= val
   102e4:	6575 2029 2626 2820 6d20 6e69 3c20 203d     ue) && ( min <= 
   102f4:	6176 756c 2965 0000 2054 6f62 6e75 2864     value)..T bound(
   10304:	2c54 5420 202c 2954 5b20 6977 6874 5420     T, T, T) [with T
   10314:	3d20 6420 756f 6c62 5d65 0000 3a43 555c      = double]..C:\U
   10324:	6573 7372 615c 7263 3065 3831 675c 7469     sers\acre018\git
   10334:	7568 5c62 6574 6e65 7973 3633 625f 696f     hub\teensy36_boi
   10344:	656c 7072 616c 6574 645c 6972 6576 7372     lerplate\drivers
   10354:	655c 7478 7265 616e 5c6c 4441 3839 3333     \external\AD9833
   10364:	415c 3944 3338 2e33 7063 0070 2054 6f62     \AD9833.cpp.T bo
   10374:	6e75 2864 2c54 5420 202c 2954 5b20 6977     und(T, T, T) [wi
   10384:	6874 5420 3d20 6620 6f6c 7461 005d 0000     th T = float]...
   10394:	2054 6f62 6e75 2864 2c54 5420 202c 2954     T bound(T, T, T)
   103a4:	5b20 6977 6874 5420 3d20 4120 3944 3338      [with T = AD983
   103b4:	3a33 463a 6572 7571 6e65 7963 6552 6967     3::FrequencyRegi
   103c4:	7473 7265 3a73 543a 7079 5d65 0000 0000     sters::Type]....
   103d4:	2054 6f62 6e75 2864 2c54 5420 202c 2954     T bound(T, T, T)
   103e4:	5b20 6977 6874 5420 3d20 4120 3944 3338      [with T = AD983
   103f4:	3a33 503a 6168 6573 6552 6967 7473 7265     3::PhaseRegister
   10404:	3a73 543a 7079 5d65 0000 0000 2054 6f62     s::Type]....T bo
   10414:	6e75 2864 2c54 5420 202c 2954 5b20 6977     und(T, T, T) [wi
   10424:	6874 5420 3d20 4120 3944 3338 3a33 573a     th T = AD9833::W
   10434:	6972 6574 6f4d 6564 3a73 543a 7079 5d65     riteModes::Type]
   10444:	0000 0000 2054 6f62 6e75 2864 2c54 5420     ....T bound(T, T
   10454:	202c 2954 5b20 6977 6874 5420 3d20 4120     , T) [with T = A
   10464:	3944 3338 3a33 533a 656c 7065 6f4d 6564     D9833::SleepMode
   10474:	3a73 543a 7079 5d65 0000 0000 2054 6f62     s::Type]....T bo
   10484:	6e75 2864 2c54 5420 202c 2954 5b20 6977     und(T, T, T) [wi
   10494:	6874 5420 3d20 4120 3944 3338 3a33 4f3a     th T = AD9833::O
   104a4:	7475 7570 4d74 646f 7365 3a3a 7954 6570     utputModes::Type
   104b4:	005d ffff                                   ]...

000104b8 <s_baudratePrescaler>:
   104b8:	0002 0000 0003 0000 0005 0000 0007 0000     ................

000104c8 <s_baudrateScaler>:
   104c8:	0002 0000 0004 0000 0006 0000 0008 0000     ................
   104d8:	0010 0000 0020 0000 0040 0000 0080 0000     .... ...@.......
   104e8:	0100 0000 0200 0000 0400 0000 0800 0000     ................
   104f8:	1000 0000 2000 0000 4000 0000 8000 0000     ..... ...@......

00010508 <s_delayPrescaler>:
   10508:	0001 0000 0003 0000 0005 0000 0007 0000     ................

00010518 <s_delayScaler>:
   10518:	0002 0000 0004 0000 0008 0000 0010 0000     ................
   10528:	0020 0000 0040 0000 0080 0000 0100 0000      ...@...........
   10538:	0200 0000 0400 0000 0800 0000 1000 0000     ................
   10548:	2000 0000 4000 0000 8000 0000 0000 0001     . ...@..........

00010558 <s_dspiBases>:
   10558:	c000 4002 d000 4002 c000 400a               ...@...@...@

00010564 <s_dspiClock>:
   10564:	000c 103c 000d 103c 000c 1030 6e69 7473     ..<...<...0.inst
   10574:	6e61 6563 3c20 4120 5252 5941 535f 5a49     ance < ARRAY_SIZ
   10584:	2845 5f73 7364 6970 6142 6573 2973 0000     E(s_dspiBases)..
   10594:	3a43 555c 6573 7372 615c 7263 3065 3831     C:\Users\acre018
   105a4:	675c 7469 7568 5c62 6574 6e65 7973 3633     \github\teensy36
   105b4:	625f 696f 656c 7072 616c 6574 645c 6972     _boilerplate\dri
   105c4:	6576 7372 645c 7665 6369 7365 4d5c 364b     vers\devices\MK6
   105d4:	4636 3831 645c 6972 6576 7372 665c 6c73     6F18\drivers\fsl
   105e4:	645f 7073 2e69 0063 554e 4c4c 2120 203d     _dspi.c.NULL != 
   105f4:	616d 7473 7265 6f43 666e 6769 0000 0000     masterConfig....
   10604:	6166 736c 0065 0000 554e 4c4c 2120 203d     false...NULL != 
   10614:	6c73 7661 4365 6e6f 6966 0067 554e 4c4c     slaveConfig.NULL
   10624:	2120 203d 6f63 6d6d 6e61 0064 554e 4c4c      != command.NULL
   10634:	2120 203d 6168 646e 656c 0000 554e 4c4c      != handle..NULL
   10644:	2120 203d 7274 6e61 6673 7265 0000 0000      != transfer....
   10654:	554e 4c4c 2120 203d 6678 7265 0000 0000     NULL != xfer....
   10664:	554e 4c4c 2120 203d 5f67 7364 6970 6148     NULL != g_dspiHa
   10674:	646e 656c 305b 005d 554e 4c4c 2120 203d     ndle[0].NULL != 
   10684:	5f67 7364 6970 6148 646e 656c 315b 005d     g_dspiHandle[1].
   10694:	554e 4c4c 2120 203d 5f67 7364 6970 6148     NULL != g_dspiHa
   106a4:	646e 656c 325b 005d                         ndle[2].

000106ac <__func__.28>:
   106ac:	5344 4950 475f 7465 6e49 7473 6e61 6563     DSPI_GetInstance
   106bc:	ff00 ffff                                   ....

000106c0 <__func__.27>:
   106c0:	5344 4950 4d5f 7361 6574 4972 696e 0074     DSPI_MasterInit.

000106d0 <__func__.23>:
   106d0:	5344 4950 4d5f 7361 6574 5372 7465 6544     DSPI_MasterSetDe
   106e0:	616c 5379 6163 656c 0072 ffff               layScaler...

000106ec <__func__.21>:
   106ec:	5344 4950 4d5f 7361 6574 5772 6972 6574     DSPI_MasterWrite
   106fc:	6144 6174 6c42 636f 696b 676e ff00 ffff     DataBlocking....
   1070c:	5530 2120 203d 6564 616c 5479 6d69 5f65     0U != delayTime_
   1071c:	7375 0000 3a43 555c 6573 7372 615c 7263     us..C:\Users\acr
   1072c:	3065 3831 675c 7469 7568 5c62 6574 6e65     e018\github\teen
   1073c:	7973 3633 625f 696f 656c 7072 616c 6574     sy36_boilerplate
   1074c:	645c 6972 6576 7372 645c 7665 6369 7365     \drivers\devices
   1075c:	4d5c 364b 4636 3831 645c 6972 6576 7372     \MK66F18\drivers
   1076c:	665c 6c73 635f 6d6f 6f6d 2e6e 0063 0000     \fsl_common.c...
   1077c:	6f63 6e75 2074 3d3c 5520 4e49 3354 5f32     count <= UINT32_
   1078c:	414d 0058                                   MAX.

00010790 <__func__.0>:
   10790:	4453 5f4b 6544 616c 4179 4c74 6165 7473     SDK_DelayAtLeast
   107a0:	7355 ff00                                   Us..

000107a4 <atanhi>:
   107a4:	6338 3eed 0fda 3f49 985e 3f7b 0fda 3fc9     8c.>..I?^.{?...?

000107b4 <atanlo>:
   107b4:	3769 31ac 2168 3322 0fb4 3314 2168 33a2     i7.1h!"3...3h!.3

000107c4 <npio2_hw>:
   107c4:	0f00 3fc9 0f00 4049 cb00 4096 0f00 40c9     ...?..I@...@...@
   107d4:	5300 40fb cb00 4116 ed00 412f 0f00 4149     .S.@...A../A..IA
   107e4:	3100 4162 5300 417b 3a00 418a cb00 4196     .1bA.S{A.:.A...A
   107f4:	5c00 41a3 ed00 41af 7e00 41bc 0f00 41c9     .\.A...A.~.A...A
   10804:	a000 41d5 3100 41e2 c200 41ee 5300 41fb     ...A.1.A...A.S.A
   10814:	f200 4203 3a00 420a 8300 4210 cb00 4216     ...B.:.B...B...B
   10824:	1400 421d 5c00 4223 a500 4229 ed00 422f     ...B.\#B..)B../B
   10834:	3600 4236 7e00 423c c700 4242 0f00 4249     .66B.~<B..BB..IB

00010844 <two_over_pi>:
   10844:	00a2 0000 00f9 0000 0083 0000 006e 0000     ............n...
   10854:	004e 0000 0044 0000 0015 0000 0029 0000     N...D.......)...
   10864:	00fc 0000 0027 0000 0057 0000 00d1 0000     ....'...W.......
   10874:	00f5 0000 0034 0000 00dd 0000 00c0 0000     ....4...........
   10884:	00db 0000 0062 0000 0095 0000 0099 0000     ....b...........
   10894:	003c 0000 0043 0000 0090 0000 0041 0000     <...C.......A...
   108a4:	00fe 0000 0051 0000 0063 0000 00ab 0000     ....Q...c.......
   108b4:	00de 0000 00bb 0000 00c5 0000 0061 0000     ............a...
   108c4:	00b7 0000 0024 0000 006e 0000 003a 0000     ....$...n...:...
   108d4:	0042 0000 004d 0000 00d2 0000 00e0 0000     B...M...........
   108e4:	0006 0000 0049 0000 002e 0000 00ea 0000     ....I...........
   108f4:	0009 0000 00d1 0000 0092 0000 001c 0000     ................
   10904:	00fe 0000 001d 0000 00eb 0000 001c 0000     ................
   10914:	00b1 0000 0029 0000 00a7 0000 003e 0000     ....).......>...
   10924:	00e8 0000 0082 0000 0035 0000 00f5 0000     ........5.......
   10934:	002e 0000 00bb 0000 0044 0000 0084 0000     ........D.......
   10944:	00e9 0000 009c 0000 0070 0000 0026 0000     ........p...&...
   10954:	00b4 0000 005f 0000 007e 0000 0041 0000     ...._...~...A...
   10964:	0039 0000 0091 0000 00d6 0000 0039 0000     9...........9...
   10974:	0083 0000 0053 0000 0039 0000 00f4 0000     ....S...9.......
   10984:	009c 0000 0084 0000 005f 0000 008b 0000     ........_.......
   10994:	00bd 0000 00f9 0000 0028 0000 003b 0000     ........(...;...
   109a4:	001f 0000 00f8 0000 0097 0000 00ff 0000     ................
   109b4:	00de 0000 0005 0000 0098 0000 000f 0000     ................
   109c4:	00ef 0000 002f 0000 0011 0000 008b 0000     ..../...........
   109d4:	005a 0000 000a 0000 006d 0000 001f 0000     Z.......m.......
   109e4:	006d 0000 0036 0000 007e 0000 00cf 0000     m...6...~.......
   109f4:	0027 0000 00cb 0000 0009 0000 00b7 0000     '...............
   10a04:	004f 0000 0046 0000 003f 0000 0066 0000     O...F...?...f...
   10a14:	009e 0000 005f 0000 00ea 0000 002d 0000     ...._.......-...
   10a24:	0075 0000 0027 0000 00ba 0000 00c7 0000     u...'...........
   10a34:	00eb 0000 00e5 0000 00f1 0000 007b 0000     ............{...
   10a44:	003d 0000 0007 0000 0039 0000 00f7 0000     =.......9.......
   10a54:	008a 0000 0052 0000 0092 0000 00ea 0000     ....R...........
   10a64:	006b 0000 00fb 0000 005f 0000 00b1 0000     k......._.......
   10a74:	001f 0000 008d 0000 005d 0000 0008 0000     ........].......
   10a84:	0056 0000 0003 0000 0030 0000 0046 0000     V.......0...F...
   10a94:	00fc 0000 007b 0000 006b 0000 00ab 0000     ....{...k.......
   10aa4:	00f0 0000 00cf 0000 00bc 0000 0020 0000     ............ ...
   10ab4:	009a 0000 00f4 0000 0036 0000 001d 0000     ........6.......
   10ac4:	00a9 0000 00e3 0000 0091 0000 0061 0000     ............a...
   10ad4:	005e 0000 00e6 0000 001b 0000 0008 0000     ^...............
   10ae4:	0065 0000 0099 0000 0085 0000 005f 0000     e..........._...
   10af4:	0014 0000 00a0 0000 0068 0000 0040 0000     ........h...@...
   10b04:	008d 0000 00ff 0000 00d8 0000 0080 0000     ................
   10b14:	004d 0000 0073 0000 0027 0000 0031 0000     M...s...'...1...
   10b24:	0006 0000 0006 0000 0015 0000 0056 0000     ............V...
   10b34:	00ca 0000 0073 0000 00a8 0000 00c9 0000     ....s...........
   10b44:	0060 0000 00e2 0000 007b 0000 00c0 0000     `.......{.......
   10b54:	008c 0000 006b 0000                         ....k...

00010b5c <PIo2>:
   10b5c:	0000 3fc9 0000 39f0 0000 37da 0000 33a2     ...?...9...7...3
   10b6c:	0000 2e84 0000 2b50 0000 27c2 0000 22d0     ......P+...'..."
   10b7c:	0000 1fc4 0000 1bc6 0000 1744               ..........D.

00010b88 <init_jk>:
   10b88:	0004 0000 0007 0000 0009 0000               ............

00010b94 <_ctype_>:
   10b94:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
   10ba4:	2020 2020 2020 2020 2020 2020 2020 2020                     
   10bb4:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
   10bc4:	0410 0404 0404 0404 0404 1004 1010 1010     ................
   10bd4:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
   10be4:	0101 0101 0101 0101 0101 0101 1010 1010     ................
   10bf4:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
   10c04:	0202 0202 0202 0202 0202 0202 1010 1010     ................
   10c14:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...
   10c94:	ff00 ffff                                   ....

00010c98 <__sf_fake_stderr>:
	...

00010cb8 <__sf_fake_stdin>:
	...

00010cd8 <__sf_fake_stdout>:
	...

00010cf8 <_init>:
   10cf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10cfa:	bf00      	nop
   10cfc:	bcf8      	pop	{r3, r4, r5, r6, r7}
   10cfe:	bc08      	pop	{r3}
   10d00:	469e      	mov	lr, r3
   10d02:	4770      	bx	lr

00010d04 <__frame_dummy_init_array_entry>:
   10d04:	0435 0000 486d 0000                         5...mH..

Disassembly of section .fini:

00010d0c <_fini>:
   10d0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10d0e:	bf00      	nop
